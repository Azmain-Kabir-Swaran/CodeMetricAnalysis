{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "innerGetFileStatus",
  "functionId": "innerGetFileStatus___f-Path(modifiers-final)__needEmptyDirectoryFlag-boolean(modifiers-final)__probes-Set__StatusProbeEnum__(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 2794,
  "functionEndLine": 2891,
  "numCommitsSeen": 362,
  "timeTaken": 15833,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "ea25f4de236611d388e14a710ebe5d6872c421b6",
    "74e5018d871bdf712b3ad0706150a37cb8efee5c",
    "9221704f857e33a5f9e00c19d3705e46e94f427b",
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "4317d332321778269a583e2223d433107fab82eb",
    "34747c373f40a33d36a2e21ecb33fa791ccd939f",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "b5db2383832881034d57d836a8135a07a2bd1cf4",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
    "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5",
    "ef450df443f1dea1c52082cf281f25db7141972f",
    "621b43e254afaff708cd6fc4698b29628f6abc33",
    "3372e940303149d6258e0b72c54d72f080f0daa2",
    "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "7fe521b1dd49f81ae325f78cf531cfff15be6641",
    "709ff99cff4124823bde631e272af7be9a22f83b",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "ea25f4de236611d388e14a710ebe5d6872c421b6": "Ybodychange",
    "74e5018d871bdf712b3ad0706150a37cb8efee5c": "Ybodychange",
    "9221704f857e33a5f9e00c19d3705e46e94f427b": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ybodychange",
    "4317d332321778269a583e2223d433107fab82eb": "Ybodychange",
    "34747c373f40a33d36a2e21ecb33fa791ccd939f": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ybodychange",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ybodychange",
    "b5db2383832881034d57d836a8135a07a2bd1cf4": "Ybodychange",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": "Ybodychange",
    "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5": "Ybodychange",
    "ef450df443f1dea1c52082cf281f25db7141972f": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "3372e940303149d6258e0b72c54d72f080f0daa2": "Ybodychange",
    "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c": "Ymultichange(Ybodychange,Yparametermetachange)",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "7fe521b1dd49f81ae325f78cf531cfff15be6641": "Ybodychange",
    "709ff99cff4124823bde631e272af7be9a22f83b": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "07/01/20 3:17 AM",
      "commitNameOld": "2bbf73f1df96ebe7e6fcf64a724ae846230a8487",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,98 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       final boolean needEmptyDirectoryFlag,\n       final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     boolean allowAuthoritative \u003d allowAuthoritative(path);\n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n           needEmptyDirectoryFlag, allowAuthoritative);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n \n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative \u0026\u0026\n           probes.contains(StatusProbeEnum.Head)) {\n         // a file has been found in a non-auth path and the caller has not said\n         // they only care about directories\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n-                instrumentation, ttlTimeProvider);\n+                ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider,\n                   allowAuthoritative);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n-          instrumentation, ttlTimeProvider);\n+          ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, probes, tombstones),\n-          instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      final boolean needEmptyDirectoryFlag,\n      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    boolean allowAuthoritative \u003d allowAuthoritative(path);\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag, allowAuthoritative);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative \u0026\u0026\n          probes.contains(StatusProbeEnum.Head)) {\n        // a file has been found in a non-auth path and the caller has not said\n        // they only care about directories\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider,\n                  allowAuthoritative);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, probes, tombstones),\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ea25f4de236611d388e14a710ebe5d6872c421b6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16709. S3Guard: Make authoritative mode exclusive for metadata - don\u0027t check for expiry for authoritative paths (#1721). Contributed by Gabor Bota.\n\n",
      "commitDate": "26/11/19 7:36 AM",
      "commitName": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "12/11/19 10:17 AM",
      "commitNameOld": "990063d2af0a37e9474949f33128805e34c3f016",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 13.89,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       final boolean needEmptyDirectoryFlag,\n       final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n+    boolean allowAuthoritative \u003d allowAuthoritative(path);\n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n-          needEmptyDirectoryFlag);\n+          needEmptyDirectoryFlag, allowAuthoritative);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n-      // TODO After HADOOP-16085 the modification detection can be done with\n-      //  etags or object version instead of modTime\n-      boolean allowAuthoritative \u003d allowAuthoritative(path);\n+\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative \u0026\u0026\n           probes.contains(StatusProbeEnum.Head)) {\n         // a file has been found in a non-auth path and the caller has not said\n         // they only care about directories\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n-              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n+              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider,\n+                  allowAuthoritative);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, probes, tombstones),\n           instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      final boolean needEmptyDirectoryFlag,\n      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    boolean allowAuthoritative \u003d allowAuthoritative(path);\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag, allowAuthoritative);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative \u0026\u0026\n          probes.contains(StatusProbeEnum.Head)) {\n        // a file has been found in a non-auth path and the caller has not said\n        // they only care about directories\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider,\n                  allowAuthoritative);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, probes, tombstones),\n          instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "74e5018d871bdf712b3ad0706150a37cb8efee5c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16635. S3A \"directories only\" scan still does a HEAD.\n\nContributed by Steve Loughran.\n\nChange-Id: I5e41d7f721364c392e1f4344db83dfa8c5aa06ce\n",
      "commitDate": "14/10/19 9:05 AM",
      "commitName": "74e5018d871bdf712b3ad0706150a37cb8efee5c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "04/10/19 10:54 AM",
      "commitNameOld": "6574f27fa348542411bff888b184cd7ce34e5d9e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 9.92,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       final boolean needEmptyDirectoryFlag,\n       final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n           needEmptyDirectoryFlag);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n       boolean allowAuthoritative \u003d allowAuthoritative(path);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative \u0026\u0026\n           probes.contains(StatusProbeEnum.Head)) {\n         // a file has been found in a non-auth path and the caller has not said\n         // they only care about directories\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n-          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n+          s3GetFileStatus(path, key, probes, tombstones),\n           instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      final boolean needEmptyDirectoryFlag,\n      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d allowAuthoritative(path);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative \u0026\u0026\n          probes.contains(StatusProbeEnum.Head)) {\n        // a file has been found in a non-auth path and the caller has not said\n        // they only care about directories\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, probes, tombstones),\n          instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "9221704f857e33a5f9e00c19d3705e46e94f427b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
      "commitDate": "11/09/19 8:46 AM",
      "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
          "commitDate": "11/09/19 8:46 AM",
          "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/09/19 6:25 AM",
          "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 6.1,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,99 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n-      boolean needEmptyDirectoryFlag) throws IOException {\n-    entryPoint(INVOCATION_GET_FILE_STATUS);\n-    checkNotClosed();\n+      final boolean needEmptyDirectoryFlag,\n+      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n           needEmptyDirectoryFlag);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n-        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n-      boolean allowAuthoritative \u003d allowAuthoritative(f);\n+      boolean allowAuthoritative \u003d allowAuthoritative(path);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n-          !allowAuthoritative) {\n+          !allowAuthoritative \u0026\u0026\n+          probes.contains(StatusProbeEnum.Head)) {\n+        // a file has been found in a non-auth path and the caller has not said\n+        // they only care about directories\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n-          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n-        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n-          s3GetFileStatus(path, key, tombstones), instrumentation,\n+          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n+          instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      final boolean needEmptyDirectoryFlag,\n      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d allowAuthoritative(path);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative \u0026\u0026\n          probes.contains(StatusProbeEnum.Head)) {\n        // a file has been found in a non-auth path and the caller has not said\n        // they only care about directories\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n          instrumentation,\n          ttlTimeProvider);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path(modifiers-final), needEmptyDirectoryFlag-boolean]",
            "newValue": "[f-Path(modifiers-final), needEmptyDirectoryFlag-boolean(modifiers-final), probes-Set\u003cStatusProbeEnum\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
          "commitDate": "11/09/19 8:46 AM",
          "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/09/19 6:25 AM",
          "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 6.1,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,99 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n-      boolean needEmptyDirectoryFlag) throws IOException {\n-    entryPoint(INVOCATION_GET_FILE_STATUS);\n-    checkNotClosed();\n+      final boolean needEmptyDirectoryFlag,\n+      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n           needEmptyDirectoryFlag);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n-        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n-      boolean allowAuthoritative \u003d allowAuthoritative(f);\n+      boolean allowAuthoritative \u003d allowAuthoritative(path);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n-          !allowAuthoritative) {\n+          !allowAuthoritative \u0026\u0026\n+          probes.contains(StatusProbeEnum.Head)) {\n+        // a file has been found in a non-auth path and the caller has not said\n+        // they only care about directories\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n-          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n-        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n-          s3GetFileStatus(path, key, tombstones), instrumentation,\n+          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n+          instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      final boolean needEmptyDirectoryFlag,\n      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d allowAuthoritative(path);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative \u0026\u0026\n          probes.contains(StatusProbeEnum.Head)) {\n        // a file has been found in a non-auth path and the caller has not said\n        // they only care about directories\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n          instrumentation,\n          ttlTimeProvider);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
          "commitDate": "11/09/19 8:46 AM",
          "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/09/19 6:25 AM",
          "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 6.1,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,99 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n-      boolean needEmptyDirectoryFlag) throws IOException {\n-    entryPoint(INVOCATION_GET_FILE_STATUS);\n-    checkNotClosed();\n+      final boolean needEmptyDirectoryFlag,\n+      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n           needEmptyDirectoryFlag);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n-        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n-      boolean allowAuthoritative \u003d allowAuthoritative(f);\n+      boolean allowAuthoritative \u003d allowAuthoritative(path);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n-          !allowAuthoritative) {\n+          !allowAuthoritative \u0026\u0026\n+          probes.contains(StatusProbeEnum.Head)) {\n+        // a file has been found in a non-auth path and the caller has not said\n+        // they only care about directories\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n-          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n-        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n-          s3GetFileStatus(path, key, tombstones), instrumentation,\n+          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n+          instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      final boolean needEmptyDirectoryFlag,\n      final Set\u003cStatusProbeEnum\u003e probes) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + path + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d allowAuthoritative(path);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative \u0026\u0026\n          probes.contains(StatusProbeEnum.Head)) {\n        // a file has been found in a non-auth path and the caller has not said\n        // they only care about directories\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, probes, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, StatusProbeEnum.ALL, tombstones),\n          instrumentation,\n          ttlTimeProvider);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path(modifiers-final), needEmptyDirectoryFlag-boolean]",
            "newValue": "[f-Path(modifiers-final), needEmptyDirectoryFlag-boolean(modifiers-final), probes-Set\u003cStatusProbeEnum\u003e(modifiers-final)]"
          }
        }
      ]
    },
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "23/07/19 6:52 AM",
      "commitNameOld": "4317d332321778269a583e2223d433107fab82eb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 43.98,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,96 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     checkNotClosed();\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n           needEmptyDirectoryFlag);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n-      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n-          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n+      boolean allowAuthoritative \u003d allowAuthoritative(f);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative) {\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    checkNotClosed();\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d allowAuthoritative(f);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "4317d332321778269a583e2223d433107fab82eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16380. S3Guard to determine empty directory status for all non-root directories.\n\nContributed by Steve Loughran and Gabor Bota.\n\nThis\n* Asks S3Guard to determine the empty directory status.\n* Has S3A\u0027s root directory rm(\"/\") command to always return false (as abfs does)\n* Documents that object stores MAY do this\n* Overloads ContractTestUtils.assertDeleted to let assertions declare that the source directory does not need to exist. This stops inconsistencies in directory listings failing a root test.\n\nIt avoids a recent regression (HADOOP-16279) where if there was a tombstone above the first element found in a directory listing, the directory would be considered empty, when in fact there were child entries. That could downgrade an rm(path, recursive) to a no-op, while also confusing rename(src, dest), as dest could be mistaken for an empty directory and so permit the copy above it, rather than reject it \"destination path exists and is not empty\".\n\nChange-Id: I136a3d1a5a48a67e6155d790a40ff558d0d2c108\n",
      "commitDate": "23/07/19 6:52 AM",
      "commitName": "4317d332321778269a583e2223d433107fab82eb",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/07/19 7:24 AM",
      "commitNameOld": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 5.98,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,97 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     checkNotClosed();\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n-      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n+      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n+          needEmptyDirectoryFlag);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n       boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n           allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative) {\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    checkNotClosed();\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider,\n          needEmptyDirectoryFlag);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "34747c373f40a33d36a2e21ecb33fa791ccd939f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16396. Allow authoritative mode on a subdirectory. (#1043)\n\n",
      "commitDate": "03/07/19 11:04 AM",
      "commitName": "34747c373f40a33d36a2e21ecb33fa791ccd939f",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "20/06/19 1:56 AM",
      "commitNameOld": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 13.38,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     checkNotClosed();\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n             Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n             ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n+      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n+          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative) {\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                 + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                 path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    checkNotClosed();\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,94 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n+    checkNotClosed();\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d null;\n     if (hasMetadataStore()) {\n       pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n     }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n+        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n+            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n+            ZoneOffset.UTC);\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n-            \"deleted by S3Guard\");\n+            \"deleted by S3Guard at \" + deletedAt);\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative) {\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n-            LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n-                path);\n+            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n+                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n+                path, s3ModTime, msModTime);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n           instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation,\n           ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    checkNotClosed();\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        OffsetDateTime deletedAt \u003d OffsetDateTime.ofInstant(\n            Instant.ofEpochMilli(pm.getFileStatus().getModificationTime()),\n            ZoneOffset.UTC);\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard at \" + deletedAt);\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated;\"\n                + \" s3modtime\u003d{}; msModTime\u003d{} updating metastore\",\n                path, s3ModTime, msModTime);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "19/05/19 2:29 PM",
      "commitNameOld": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,89 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n-    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n+    PathMetadata pm \u003d null;\n+    if (hasMetadataStore()) {\n+      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n+    }\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard\");\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative) {\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n                 path);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n-                instrumentation);\n+                instrumentation, ttlTimeProvider);\n           }\n         }\n       }\n \n       S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n             null, null);\n       }\n       // entry was found, save in S3Guard\n-      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n+      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n+          instrumentation, ttlTimeProvider);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n-          s3GetFileStatus(path, key, tombstones), instrumentation);\n+          s3GetFileStatus(path, key, tombstones), instrumentation,\n+          ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d null;\n    if (hasMetadataStore()) {\n      pm \u003d S3Guard.getWithTtl(metadataStore, path, ttlTimeProvider);\n    }\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n                path);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation, ttlTimeProvider);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus,\n          instrumentation, ttlTimeProvider);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation,\n          ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "30/04/19 3:53 AM",
      "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 19.44,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard\");\n       }\n \n       // if ms is not authoritative, check S3 if there\u0027s any recent\n       // modification - compare the modTime to check if metadata is up to date\n       // Skip going to s3 if the file checked is a directory. Because if the\n       // dest is also a directory, there\u0027s no difference.\n       // TODO After HADOOP-16085 the modification detection can be done with\n       //  etags or object version instead of modTime\n       if (!pm.getFileStatus().isDirectory() \u0026\u0026\n           !allowAuthoritative) {\n         LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n         final long msModTime \u003d pm.getFileStatus().getModificationTime();\n \n         S3AFileStatus s3AFileStatus;\n         try {\n           s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n         } catch (FileNotFoundException fne) {\n           s3AFileStatus \u003d null;\n         }\n         if (s3AFileStatus \u003d\u003d null) {\n           LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n               + \"it has been deleted.\", path);\n         } else {\n           final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n \n           if(s3ModTime \u003e msModTime) {\n             LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n                 path);\n             return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                 instrumentation);\n           }\n         }\n       }\n \n-      FileStatus msStatus \u003d pm.getFileStatus();\n+      S3AFileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n-          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n+          return msStatus;\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n-        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n+        return msStatus;\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n-        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n+        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n+            null, null);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n                path);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation);\n          }\n        }\n      }\n\n      S3AFileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return msStatus;\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return msStatus;\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE,\n            null, null);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "b5db2383832881034d57d836a8135a07a2bd1cf4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15999. S3Guard: Better support for out-of-band operations.\n\nAuthor:    Gabor Bota\n",
      "commitDate": "28/03/19 8:59 AM",
      "commitName": "b5db2383832881034d57d836a8135a07a2bd1cf4",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "22/03/19 4:42 AM",
      "commitNameOld": "ae2eb2dd4261e5fef964384efd168d9867eb94af",
      "commitAuthorOld": "Lokesh Jain",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,83 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard\");\n       }\n \n+      // if ms is not authoritative, check S3 if there\u0027s any recent\n+      // modification - compare the modTime to check if metadata is up to date\n+      // Skip going to s3 if the file checked is a directory. Because if the\n+      // dest is also a directory, there\u0027s no difference.\n+      // TODO After HADOOP-16085 the modification detection can be done with\n+      //  etags or object version instead of modTime\n+      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n+          !allowAuthoritative) {\n+        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n+        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n+\n+        S3AFileStatus s3AFileStatus;\n+        try {\n+          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+        } catch (FileNotFoundException fne) {\n+          s3AFileStatus \u003d null;\n+        }\n+        if (s3AFileStatus \u003d\u003d null) {\n+          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n+              + \"it has been deleted.\", path);\n+        } else {\n+          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n+\n+          if(s3ModTime \u003e msModTime) {\n+            LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n+                path);\n+            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n+                instrumentation);\n+          }\n+        }\n+      }\n+\n       FileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n           DirListingMetadata children \u003d\n               S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      // if ms is not authoritative, check S3 if there\u0027s any recent\n      // modification - compare the modTime to check if metadata is up to date\n      // Skip going to s3 if the file checked is a directory. Because if the\n      // dest is also a directory, there\u0027s no difference.\n      // TODO After HADOOP-16085 the modification detection can be done with\n      //  etags or object version instead of modTime\n      if (!pm.getFileStatus().isDirectory() \u0026\u0026\n          !allowAuthoritative) {\n        LOG.debug(\"Metadata for {} found in the non-auth metastore.\", path);\n        final long msModTime \u003d pm.getFileStatus().getModificationTime();\n\n        S3AFileStatus s3AFileStatus;\n        try {\n          s3AFileStatus \u003d s3GetFileStatus(path, key, tombstones);\n        } catch (FileNotFoundException fne) {\n          s3AFileStatus \u003d null;\n        }\n        if (s3AFileStatus \u003d\u003d null) {\n          LOG.warn(\"Failed to find file {}. Either it is not yet visible, or \"\n              + \"it has been deleted.\", path);\n        } else {\n          final long s3ModTime \u003d s3AFileStatus.getModificationTime();\n\n          if(s3ModTime \u003e msModTime) {\n            LOG.debug(\"S3Guard metadata for {} is outdated, updating it\",\n                path);\n            return S3Guard.putAndReturn(metadataStore, s3AFileStatus,\n                instrumentation);\n          }\n        }\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
      "commitDate": "02/10/18 9:22 PM",
      "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "12/09/18 9:04 PM",
      "commitNameOld": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,51 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n     Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard\");\n       }\n \n       FileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n-          DirListingMetadata children \u003d metadataStore.listChildren(path);\n+          DirListingMetadata children \u003d\n+              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d\n              S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15223. Replace Collections.EMPTY* with empty* when available\n\nSigned-off-by: Akira Ajisaka \u003caajisaka@apache.org\u003e\n",
      "commitDate": "18/02/18 5:19 AM",
      "commitName": "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5",
      "commitAuthor": "fang zhenyi",
      "commitDateOld": "16/02/18 8:37 AM",
      "commitNameOld": "7ac88244c54ce483729af3d2736d9f4731e230ca",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.86,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n     entryPoint(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n-    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n+    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard\");\n       }\n \n       FileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n           DirListingMetadata children \u003d metadataStore.listChildren(path);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.emptySet();\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d metadataStore.listChildren(path);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ef450df443f1dea1c52082cf281f25db7141972f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15113. NPE in S3A getFileStatus: null instrumentation on using closed instance.\nContributed by Steve Loughran.\n",
      "commitDate": "21/12/17 6:15 AM",
      "commitName": "ef450df443f1dea1c52082cf281f25db7141972f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   S3AFileStatus innerGetFileStatus(final Path f,\n       boolean needEmptyDirectoryFlag) throws IOException {\n-    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n+    entryPoint(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n     // Check MetadataStore, if any.\n     PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n     Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n     if (pm !\u003d null) {\n       if (pm.isDeleted()) {\n         throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n             \"deleted by S3Guard\");\n       }\n \n       FileStatus msStatus \u003d pm.getFileStatus();\n       if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n         if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n           // We have a definitive true / false from MetadataStore, we are done.\n           return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n           DirListingMetadata children \u003d metadataStore.listChildren(path);\n           if (children !\u003d null) {\n             tombstones \u003d children.listTombstones();\n           }\n           LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n       } else {\n         // Either this is not a directory, or we don\u0027t care if it is empty\n         return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n       // If the metadata store has no children for it and it\u0027s not listed in\n       // S3 yet, we\u0027ll assume the empty directory is true;\n       S3AFileStatus s3FileStatus;\n       try {\n         s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n       } catch (FileNotFoundException e) {\n         return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n       // entry was found, save in S3Guard\n       return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n     } else {\n       // there was no entry in S3Guard\n       // retrieve the data and update the metadata store in the process.\n       return S3Guard.putAndReturn(metadataStore,\n           s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    entryPoint(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d metadataStore.listChildren(path);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,98 +1,50 @@\n-  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n+  S3AFileStatus innerGetFileStatus(final Path f,\n+      boolean needEmptyDirectoryFlag) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n-    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n-    if (!key.isEmpty()) {\n-      try {\n-        ObjectMetadata meta \u003d getObjectMetadata(key);\n+    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n-        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n-          LOG.debug(\"Found exact file: fake directory\");\n-          return new S3AFileStatus(true, path, username);\n+    // Check MetadataStore, if any.\n+    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n+    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n+    if (pm !\u003d null) {\n+      if (pm.isDeleted()) {\n+        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+            \"deleted by S3Guard\");\n+      }\n+\n+      FileStatus msStatus \u003d pm.getFileStatus();\n+      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n+        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n+          // We have a definitive true / false from MetadataStore, we are done.\n+          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n-          LOG.debug(\"Found exact file: normal file\");\n-          return new S3AFileStatus(meta.getContentLength(),\n-              dateToLong(meta.getLastModified()),\n-              path,\n-              getDefaultBlockSize(path),\n-              username);\n+          DirListingMetadata children \u003d metadataStore.listChildren(path);\n+          if (children !\u003d null) {\n+            tombstones \u003d children.listTombstones();\n+          }\n+          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n-      } catch (AmazonServiceException e) {\n-        if (e.getStatusCode() !\u003d 404) {\n-          throw translateException(\"getFileStatus\", path, e);\n-        }\n-      } catch (AmazonClientException e) {\n-        throw translateException(\"getFileStatus\", path, e);\n+      } else {\n+        // Either this is not a directory, or we don\u0027t care if it is empty\n+        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n-      // Necessary?\n-      if (!key.endsWith(\"/\")) {\n-        String newKey \u003d key + \"/\";\n-        try {\n-          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n-\n-          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n-            LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, path, username);\n-          } else {\n-            LOG.warn(\"Found file (with /): real file? should not happen: {}\",\n-                key);\n-\n-            return new S3AFileStatus(meta.getContentLength(),\n-                dateToLong(meta.getLastModified()),\n-                path,\n-                getDefaultBlockSize(path),\n-                username);\n-          }\n-        } catch (AmazonServiceException e) {\n-          if (e.getStatusCode() !\u003d 404) {\n-            throw translateException(\"getFileStatus\", newKey, e);\n-          }\n-        } catch (AmazonClientException e) {\n-          throw translateException(\"getFileStatus\", newKey, e);\n-        }\n+      // If the metadata store has no children for it and it\u0027s not listed in\n+      // S3 yet, we\u0027ll assume the empty directory is true;\n+      S3AFileStatus s3FileStatus;\n+      try {\n+        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+      } catch (FileNotFoundException e) {\n+        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n+      // entry was found, save in S3Guard\n+      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n+    } else {\n+      // there was no entry in S3Guard\n+      // retrieve the data and update the metadata store in the process.\n+      return S3Guard.putAndReturn(metadataStore,\n+          s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n-\n-    try {\n-      key \u003d maybeAddTrailingSlash(key);\n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(key);\n-      request.setDelimiter(\"/\");\n-      request.setMaxKeys(1);\n-\n-      ObjectListing objects \u003d listObjects(request);\n-\n-      if (!objects.getCommonPrefixes().isEmpty()\n-          || !objects.getObjectSummaries().isEmpty()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found path as directory (with /): {}/{}\",\n-              objects.getCommonPrefixes().size() ,\n-              objects.getObjectSummaries().size());\n-\n-          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n-          }\n-          for (String prefix : objects.getCommonPrefixes()) {\n-            LOG.debug(\"Prefix: {}\", prefix);\n-          }\n-        }\n-\n-        return new S3AFileStatus(false, path, username);\n-      } else if (key.isEmpty()) {\n-        LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, path, username);\n-      }\n-    } catch (AmazonServiceException e) {\n-      if (e.getStatusCode() !\u003d 404) {\n-        throw translateException(\"getFileStatus\", key, e);\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"getFileStatus\", key, e);\n-    }\n-\n-    LOG.debug(\"Not Found: {}\", path);\n-    throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d metadataStore.listChildren(path);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "getFileStatus",
            "newValue": "innerGetFileStatus"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,98 +1,50 @@\n-  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n+  S3AFileStatus innerGetFileStatus(final Path f,\n+      boolean needEmptyDirectoryFlag) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n-    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n-    if (!key.isEmpty()) {\n-      try {\n-        ObjectMetadata meta \u003d getObjectMetadata(key);\n+    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n-        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n-          LOG.debug(\"Found exact file: fake directory\");\n-          return new S3AFileStatus(true, path, username);\n+    // Check MetadataStore, if any.\n+    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n+    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n+    if (pm !\u003d null) {\n+      if (pm.isDeleted()) {\n+        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+            \"deleted by S3Guard\");\n+      }\n+\n+      FileStatus msStatus \u003d pm.getFileStatus();\n+      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n+        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n+          // We have a definitive true / false from MetadataStore, we are done.\n+          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n-          LOG.debug(\"Found exact file: normal file\");\n-          return new S3AFileStatus(meta.getContentLength(),\n-              dateToLong(meta.getLastModified()),\n-              path,\n-              getDefaultBlockSize(path),\n-              username);\n+          DirListingMetadata children \u003d metadataStore.listChildren(path);\n+          if (children !\u003d null) {\n+            tombstones \u003d children.listTombstones();\n+          }\n+          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n-      } catch (AmazonServiceException e) {\n-        if (e.getStatusCode() !\u003d 404) {\n-          throw translateException(\"getFileStatus\", path, e);\n-        }\n-      } catch (AmazonClientException e) {\n-        throw translateException(\"getFileStatus\", path, e);\n+      } else {\n+        // Either this is not a directory, or we don\u0027t care if it is empty\n+        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n-      // Necessary?\n-      if (!key.endsWith(\"/\")) {\n-        String newKey \u003d key + \"/\";\n-        try {\n-          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n-\n-          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n-            LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, path, username);\n-          } else {\n-            LOG.warn(\"Found file (with /): real file? should not happen: {}\",\n-                key);\n-\n-            return new S3AFileStatus(meta.getContentLength(),\n-                dateToLong(meta.getLastModified()),\n-                path,\n-                getDefaultBlockSize(path),\n-                username);\n-          }\n-        } catch (AmazonServiceException e) {\n-          if (e.getStatusCode() !\u003d 404) {\n-            throw translateException(\"getFileStatus\", newKey, e);\n-          }\n-        } catch (AmazonClientException e) {\n-          throw translateException(\"getFileStatus\", newKey, e);\n-        }\n+      // If the metadata store has no children for it and it\u0027s not listed in\n+      // S3 yet, we\u0027ll assume the empty directory is true;\n+      S3AFileStatus s3FileStatus;\n+      try {\n+        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+      } catch (FileNotFoundException e) {\n+        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n+      // entry was found, save in S3Guard\n+      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n+    } else {\n+      // there was no entry in S3Guard\n+      // retrieve the data and update the metadata store in the process.\n+      return S3Guard.putAndReturn(metadataStore,\n+          s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n-\n-    try {\n-      key \u003d maybeAddTrailingSlash(key);\n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(key);\n-      request.setDelimiter(\"/\");\n-      request.setMaxKeys(1);\n-\n-      ObjectListing objects \u003d listObjects(request);\n-\n-      if (!objects.getCommonPrefixes().isEmpty()\n-          || !objects.getObjectSummaries().isEmpty()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found path as directory (with /): {}/{}\",\n-              objects.getCommonPrefixes().size() ,\n-              objects.getObjectSummaries().size());\n-\n-          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n-          }\n-          for (String prefix : objects.getCommonPrefixes()) {\n-            LOG.debug(\"Prefix: {}\", prefix);\n-          }\n-        }\n-\n-        return new S3AFileStatus(false, path, username);\n-      } else if (key.isEmpty()) {\n-        LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, path, username);\n-      }\n-    } catch (AmazonServiceException e) {\n-      if (e.getStatusCode() !\u003d 404) {\n-        throw translateException(\"getFileStatus\", key, e);\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"getFileStatus\", key, e);\n-    }\n-\n-    LOG.debug(\"Not Found: {}\", path);\n-    throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d metadataStore.listChildren(path);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path(modifiers-final)]",
            "newValue": "[f-Path(modifiers-final), needEmptyDirectoryFlag-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,98 +1,50 @@\n-  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n+  S3AFileStatus innerGetFileStatus(final Path f,\n+      boolean needEmptyDirectoryFlag) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n-    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n-    if (!key.isEmpty()) {\n-      try {\n-        ObjectMetadata meta \u003d getObjectMetadata(key);\n+    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n-        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n-          LOG.debug(\"Found exact file: fake directory\");\n-          return new S3AFileStatus(true, path, username);\n+    // Check MetadataStore, if any.\n+    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n+    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n+    if (pm !\u003d null) {\n+      if (pm.isDeleted()) {\n+        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+            \"deleted by S3Guard\");\n+      }\n+\n+      FileStatus msStatus \u003d pm.getFileStatus();\n+      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n+        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n+          // We have a definitive true / false from MetadataStore, we are done.\n+          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n-          LOG.debug(\"Found exact file: normal file\");\n-          return new S3AFileStatus(meta.getContentLength(),\n-              dateToLong(meta.getLastModified()),\n-              path,\n-              getDefaultBlockSize(path),\n-              username);\n+          DirListingMetadata children \u003d metadataStore.listChildren(path);\n+          if (children !\u003d null) {\n+            tombstones \u003d children.listTombstones();\n+          }\n+          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n-      } catch (AmazonServiceException e) {\n-        if (e.getStatusCode() !\u003d 404) {\n-          throw translateException(\"getFileStatus\", path, e);\n-        }\n-      } catch (AmazonClientException e) {\n-        throw translateException(\"getFileStatus\", path, e);\n+      } else {\n+        // Either this is not a directory, or we don\u0027t care if it is empty\n+        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n-      // Necessary?\n-      if (!key.endsWith(\"/\")) {\n-        String newKey \u003d key + \"/\";\n-        try {\n-          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n-\n-          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n-            LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, path, username);\n-          } else {\n-            LOG.warn(\"Found file (with /): real file? should not happen: {}\",\n-                key);\n-\n-            return new S3AFileStatus(meta.getContentLength(),\n-                dateToLong(meta.getLastModified()),\n-                path,\n-                getDefaultBlockSize(path),\n-                username);\n-          }\n-        } catch (AmazonServiceException e) {\n-          if (e.getStatusCode() !\u003d 404) {\n-            throw translateException(\"getFileStatus\", newKey, e);\n-          }\n-        } catch (AmazonClientException e) {\n-          throw translateException(\"getFileStatus\", newKey, e);\n-        }\n+      // If the metadata store has no children for it and it\u0027s not listed in\n+      // S3 yet, we\u0027ll assume the empty directory is true;\n+      S3AFileStatus s3FileStatus;\n+      try {\n+        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+      } catch (FileNotFoundException e) {\n+        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n+      // entry was found, save in S3Guard\n+      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n+    } else {\n+      // there was no entry in S3Guard\n+      // retrieve the data and update the metadata store in the process.\n+      return S3Guard.putAndReturn(metadataStore,\n+          s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n-\n-    try {\n-      key \u003d maybeAddTrailingSlash(key);\n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(key);\n-      request.setDelimiter(\"/\");\n-      request.setMaxKeys(1);\n-\n-      ObjectListing objects \u003d listObjects(request);\n-\n-      if (!objects.getCommonPrefixes().isEmpty()\n-          || !objects.getObjectSummaries().isEmpty()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found path as directory (with /): {}/{}\",\n-              objects.getCommonPrefixes().size() ,\n-              objects.getObjectSummaries().size());\n-\n-          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n-          }\n-          for (String prefix : objects.getCommonPrefixes()) {\n-            LOG.debug(\"Prefix: {}\", prefix);\n-          }\n-        }\n-\n-        return new S3AFileStatus(false, path, username);\n-      } else if (key.isEmpty()) {\n-        LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, path, username);\n-      }\n-    } catch (AmazonServiceException e) {\n-      if (e.getStatusCode() !\u003d 404) {\n-        throw translateException(\"getFileStatus\", key, e);\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"getFileStatus\", key, e);\n-    }\n-\n-    LOG.debug(\"Not Found: {}\", path);\n-    throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d metadataStore.listChildren(path);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,98 +1,50 @@\n-  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n+  S3AFileStatus innerGetFileStatus(final Path f,\n+      boolean needEmptyDirectoryFlag) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n-    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n-    if (!key.isEmpty()) {\n-      try {\n-        ObjectMetadata meta \u003d getObjectMetadata(key);\n+    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n \n-        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n-          LOG.debug(\"Found exact file: fake directory\");\n-          return new S3AFileStatus(true, path, username);\n+    // Check MetadataStore, if any.\n+    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n+    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n+    if (pm !\u003d null) {\n+      if (pm.isDeleted()) {\n+        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n+            \"deleted by S3Guard\");\n+      }\n+\n+      FileStatus msStatus \u003d pm.getFileStatus();\n+      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n+        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n+          // We have a definitive true / false from MetadataStore, we are done.\n+          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n         } else {\n-          LOG.debug(\"Found exact file: normal file\");\n-          return new S3AFileStatus(meta.getContentLength(),\n-              dateToLong(meta.getLastModified()),\n-              path,\n-              getDefaultBlockSize(path),\n-              username);\n+          DirListingMetadata children \u003d metadataStore.listChildren(path);\n+          if (children !\u003d null) {\n+            tombstones \u003d children.listTombstones();\n+          }\n+          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n         }\n-      } catch (AmazonServiceException e) {\n-        if (e.getStatusCode() !\u003d 404) {\n-          throw translateException(\"getFileStatus\", path, e);\n-        }\n-      } catch (AmazonClientException e) {\n-        throw translateException(\"getFileStatus\", path, e);\n+      } else {\n+        // Either this is not a directory, or we don\u0027t care if it is empty\n+        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n       }\n \n-      // Necessary?\n-      if (!key.endsWith(\"/\")) {\n-        String newKey \u003d key + \"/\";\n-        try {\n-          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n-\n-          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n-            LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, path, username);\n-          } else {\n-            LOG.warn(\"Found file (with /): real file? should not happen: {}\",\n-                key);\n-\n-            return new S3AFileStatus(meta.getContentLength(),\n-                dateToLong(meta.getLastModified()),\n-                path,\n-                getDefaultBlockSize(path),\n-                username);\n-          }\n-        } catch (AmazonServiceException e) {\n-          if (e.getStatusCode() !\u003d 404) {\n-            throw translateException(\"getFileStatus\", newKey, e);\n-          }\n-        } catch (AmazonClientException e) {\n-          throw translateException(\"getFileStatus\", newKey, e);\n-        }\n+      // If the metadata store has no children for it and it\u0027s not listed in\n+      // S3 yet, we\u0027ll assume the empty directory is true;\n+      S3AFileStatus s3FileStatus;\n+      try {\n+        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n+      } catch (FileNotFoundException e) {\n+        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n       }\n+      // entry was found, save in S3Guard\n+      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n+    } else {\n+      // there was no entry in S3Guard\n+      // retrieve the data and update the metadata store in the process.\n+      return S3Guard.putAndReturn(metadataStore,\n+          s3GetFileStatus(path, key, tombstones), instrumentation);\n     }\n-\n-    try {\n-      key \u003d maybeAddTrailingSlash(key);\n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(key);\n-      request.setDelimiter(\"/\");\n-      request.setMaxKeys(1);\n-\n-      ObjectListing objects \u003d listObjects(request);\n-\n-      if (!objects.getCommonPrefixes().isEmpty()\n-          || !objects.getObjectSummaries().isEmpty()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found path as directory (with /): {}/{}\",\n-              objects.getCommonPrefixes().size() ,\n-              objects.getObjectSummaries().size());\n-\n-          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n-          }\n-          for (String prefix : objects.getCommonPrefixes()) {\n-            LOG.debug(\"Prefix: {}\", prefix);\n-          }\n-        }\n-\n-        return new S3AFileStatus(false, path, username);\n-      } else if (key.isEmpty()) {\n-        LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, path, username);\n-      }\n-    } catch (AmazonServiceException e) {\n-      if (e.getStatusCode() !\u003d 404) {\n-        throw translateException(\"getFileStatus\", key, e);\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"getFileStatus\", key, e);\n-    }\n-\n-    LOG.debug(\"Not Found: {}\", path);\n-    throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  S3AFileStatus innerGetFileStatus(final Path f,\n      boolean needEmptyDirectoryFlag) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path, key);\n\n    // Check MetadataStore, if any.\n    PathMetadata pm \u003d metadataStore.get(path, needEmptyDirectoryFlag);\n    Set\u003cPath\u003e tombstones \u003d Collections.EMPTY_SET;\n    if (pm !\u003d null) {\n      if (pm.isDeleted()) {\n        throw new FileNotFoundException(\"Path \" + f + \" is recorded as \" +\n            \"deleted by S3Guard\");\n      }\n\n      FileStatus msStatus \u003d pm.getFileStatus();\n      if (needEmptyDirectoryFlag \u0026\u0026 msStatus.isDirectory()) {\n        if (pm.isEmptyDirectory() !\u003d Tristate.UNKNOWN) {\n          // We have a definitive true / false from MetadataStore, we are done.\n          return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n        } else {\n          DirListingMetadata children \u003d metadataStore.listChildren(path);\n          if (children !\u003d null) {\n            tombstones \u003d children.listTombstones();\n          }\n          LOG.debug(\"MetadataStore doesn\u0027t know if dir is empty, using S3.\");\n        }\n      } else {\n        // Either this is not a directory, or we don\u0027t care if it is empty\n        return S3AFileStatus.fromFileStatus(msStatus, pm.isEmptyDirectory());\n      }\n\n      // If the metadata store has no children for it and it\u0027s not listed in\n      // S3 yet, we\u0027ll assume the empty directory is true;\n      S3AFileStatus s3FileStatus;\n      try {\n        s3FileStatus \u003d s3GetFileStatus(path, key, tombstones);\n      } catch (FileNotFoundException e) {\n        return S3AFileStatus.fromFileStatus(msStatus, Tristate.TRUE);\n      }\n      // entry was found, save in S3Guard\n      return S3Guard.putAndReturn(metadataStore, s3FileStatus, instrumentation);\n    } else {\n      // there was no entry in S3Guard\n      // retrieve the data and update the metadata store in the process.\n      return S3Guard.putAndReturn(metadataStore,\n          s3GetFileStatus(path, key, tombstones), instrumentation);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "3372e940303149d6258e0b72c54d72f080f0daa2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12774. s3a should use UGI.getCurrentUser.getShortname() for username. Contributed by Steve Loughran.\n",
      "commitDate": "24/10/16 9:54 PM",
      "commitName": "3372e940303149d6258e0b72c54d72f080f0daa2",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/10/16 6:50 AM",
      "commitNameOld": "9ae270af02c243993f853513c731cb268430e492",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 4.63,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,98 @@\n   public S3AFileStatus getFileStatus(final Path f) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"Getting path status for {}  ({})\", path , key);\n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d getObjectMetadata(key);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           LOG.debug(\"Found exact file: fake directory\");\n-          return new S3AFileStatus(true, true,\n-              path);\n+          return new S3AFileStatus(true, path, username);\n         } else {\n           LOG.debug(\"Found exact file: normal file\");\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n               path,\n-              getDefaultBlockSize(path));\n+              getDefaultBlockSize(path),\n+              username);\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n           throw translateException(\"getFileStatus\", path, e);\n         }\n       } catch (AmazonClientException e) {\n         throw translateException(\"getFileStatus\", path, e);\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         String newKey \u003d key + \"/\";\n         try {\n           ObjectMetadata meta \u003d getObjectMetadata(newKey);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, true, path);\n+            return new S3AFileStatus(true, path, username);\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\",\n                 key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n                 path,\n-                getDefaultBlockSize(path));\n+                getDefaultBlockSize(path),\n+                username);\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             throw translateException(\"getFileStatus\", newKey, e);\n           }\n         } catch (AmazonClientException e) {\n           throw translateException(\"getFileStatus\", newKey, e);\n         }\n       }\n     }\n \n     try {\n       key \u003d maybeAddTrailingSlash(key);\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || !objects.getObjectSummaries().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): {}/{}\",\n               objects.getCommonPrefixes().size() ,\n               objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: {}\", prefix);\n           }\n         }\n \n-        return new S3AFileStatus(true, false, path);\n+        return new S3AFileStatus(false, path, username);\n       } else if (key.isEmpty()) {\n         LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, true, path);\n+        return new S3AFileStatus(true, path, username);\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         throw translateException(\"getFileStatus\", key, e);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"getFileStatus\", key, e);\n     }\n \n     LOG.debug(\"Not Found: {}\", path);\n     throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d getObjectMetadata(key);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          LOG.debug(\"Found exact file: fake directory\");\n          return new S3AFileStatus(true, path, username);\n        } else {\n          LOG.debug(\"Found exact file: normal file\");\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              path,\n              getDefaultBlockSize(path),\n              username);\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          throw translateException(\"getFileStatus\", path, e);\n        }\n      } catch (AmazonClientException e) {\n        throw translateException(\"getFileStatus\", path, e);\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        String newKey \u003d key + \"/\";\n        try {\n          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            LOG.debug(\"Found file (with /): fake directory\");\n            return new S3AFileStatus(true, path, username);\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\",\n                key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                path,\n                getDefaultBlockSize(path),\n                username);\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            throw translateException(\"getFileStatus\", newKey, e);\n          }\n        } catch (AmazonClientException e) {\n          throw translateException(\"getFileStatus\", newKey, e);\n        }\n      }\n    }\n\n    try {\n      key \u003d maybeAddTrailingSlash(key);\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || !objects.getObjectSummaries().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): {}/{}\",\n              objects.getCommonPrefixes().size() ,\n              objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: {}\", prefix);\n          }\n        }\n\n        return new S3AFileStatus(false, path, username);\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, path, username);\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        throw translateException(\"getFileStatus\", key, e);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"getFileStatus\", key, e);\n    }\n\n    LOG.debug(\"Not Found: {}\", path);\n    throw new FileNotFoundException(\"No such file or directory: \" + path);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-13208. S3A listFiles(recursive\u003dtrue) to do a bulk listObjects instead of walking the pseudo-tree of directories. Contributed by Steve Loughran.\n",
      "commitDate": "17/08/16 2:54 PM",
      "commitName": "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13208. S3A listFiles(recursive\u003dtrue) to do a bulk listObjects instead of walking the pseudo-tree of directories. Contributed by Steve Loughran.\n",
          "commitDate": "17/08/16 2:54 PM",
          "commitName": "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "25/07/16 7:50 AM",
          "commitNameOld": "86ae218893d018638e937c2528c8e84336254da7",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 23.29,
          "commitsBetweenForRepo": 177,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,96 @@\n-  public S3AFileStatus getFileStatus(Path f) throws IOException {\n-    String key \u003d pathToKey(f);\n+  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n-    LOG.debug(\"Getting path status for {}  ({})\", f , key);\n-\n+    final Path path \u003d qualify(f);\n+    String key \u003d pathToKey(path);\n+    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d getObjectMetadata(key);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           LOG.debug(\"Found exact file: fake directory\");\n           return new S3AFileStatus(true, true,\n-              f.makeQualified(uri, workingDir));\n+              path);\n         } else {\n           LOG.debug(\"Found exact file: normal file\");\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n-              f.makeQualified(uri, workingDir),\n-              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n+              path,\n+              getDefaultBlockSize(path));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n-          throw translateException(\"getFileStatus\", f, e);\n+          throw translateException(\"getFileStatus\", path, e);\n         }\n       } catch (AmazonClientException e) {\n-        throw translateException(\"getFileStatus\", f, e);\n+        throw translateException(\"getFileStatus\", path, e);\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         String newKey \u003d key + \"/\";\n         try {\n           ObjectMetadata meta \u003d getObjectMetadata(newKey);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+            return new S3AFileStatus(true, true, path);\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n-                f.makeQualified(uri, workingDir),\n-                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n+                path,\n+                getDefaultBlockSize(path));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             throw translateException(\"getFileStatus\", newKey, e);\n           }\n         } catch (AmazonClientException e) {\n           throw translateException(\"getFileStatus\", newKey, e);\n         }\n       }\n     }\n \n     try {\n-      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n-        key \u003d key + \"/\";\n-      }\n+      key \u003d maybeAddTrailingSlash(key);\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || !objects.getObjectSummaries().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): {}/{}\",\n               objects.getCommonPrefixes().size() ,\n               objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: {}\", prefix);\n           }\n         }\n \n-        return new S3AFileStatus(true, false,\n-            f.makeQualified(uri, workingDir));\n+        return new S3AFileStatus(true, false, path);\n       } else if (key.isEmpty()) {\n         LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+        return new S3AFileStatus(true, true, path);\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         throw translateException(\"getFileStatus\", key, e);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"getFileStatus\", key, e);\n     }\n \n-    LOG.debug(\"Not Found: {}\", f);\n-    throw new FileNotFoundException(\"No such file or directory: \" + f);\n+    LOG.debug(\"Not Found: {}\", path);\n+    throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d getObjectMetadata(key);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          LOG.debug(\"Found exact file: fake directory\");\n          return new S3AFileStatus(true, true,\n              path);\n        } else {\n          LOG.debug(\"Found exact file: normal file\");\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              path,\n              getDefaultBlockSize(path));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          throw translateException(\"getFileStatus\", path, e);\n        }\n      } catch (AmazonClientException e) {\n        throw translateException(\"getFileStatus\", path, e);\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        String newKey \u003d key + \"/\";\n        try {\n          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            LOG.debug(\"Found file (with /): fake directory\");\n            return new S3AFileStatus(true, true, path);\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                path,\n                getDefaultBlockSize(path));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            throw translateException(\"getFileStatus\", newKey, e);\n          }\n        } catch (AmazonClientException e) {\n          throw translateException(\"getFileStatus\", newKey, e);\n        }\n      }\n    }\n\n    try {\n      key \u003d maybeAddTrailingSlash(key);\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || !objects.getObjectSummaries().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): {}/{}\",\n              objects.getCommonPrefixes().size() ,\n              objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: {}\", prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false, path);\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, true, path);\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        throw translateException(\"getFileStatus\", key, e);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"getFileStatus\", key, e);\n    }\n\n    LOG.debug(\"Not Found: {}\", path);\n    throw new FileNotFoundException(\"No such file or directory: \" + path);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-13208. S3A listFiles(recursive\u003dtrue) to do a bulk listObjects instead of walking the pseudo-tree of directories. Contributed by Steve Loughran.\n",
          "commitDate": "17/08/16 2:54 PM",
          "commitName": "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "25/07/16 7:50 AM",
          "commitNameOld": "86ae218893d018638e937c2528c8e84336254da7",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 23.29,
          "commitsBetweenForRepo": 177,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,96 @@\n-  public S3AFileStatus getFileStatus(Path f) throws IOException {\n-    String key \u003d pathToKey(f);\n+  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n     incrementStatistic(INVOCATION_GET_FILE_STATUS);\n-    LOG.debug(\"Getting path status for {}  ({})\", f , key);\n-\n+    final Path path \u003d qualify(f);\n+    String key \u003d pathToKey(path);\n+    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d getObjectMetadata(key);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           LOG.debug(\"Found exact file: fake directory\");\n           return new S3AFileStatus(true, true,\n-              f.makeQualified(uri, workingDir));\n+              path);\n         } else {\n           LOG.debug(\"Found exact file: normal file\");\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n-              f.makeQualified(uri, workingDir),\n-              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n+              path,\n+              getDefaultBlockSize(path));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n-          throw translateException(\"getFileStatus\", f, e);\n+          throw translateException(\"getFileStatus\", path, e);\n         }\n       } catch (AmazonClientException e) {\n-        throw translateException(\"getFileStatus\", f, e);\n+        throw translateException(\"getFileStatus\", path, e);\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         String newKey \u003d key + \"/\";\n         try {\n           ObjectMetadata meta \u003d getObjectMetadata(newKey);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             LOG.debug(\"Found file (with /): fake directory\");\n-            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+            return new S3AFileStatus(true, true, path);\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n-                f.makeQualified(uri, workingDir),\n-                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n+                path,\n+                getDefaultBlockSize(path));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             throw translateException(\"getFileStatus\", newKey, e);\n           }\n         } catch (AmazonClientException e) {\n           throw translateException(\"getFileStatus\", newKey, e);\n         }\n       }\n     }\n \n     try {\n-      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n-        key \u003d key + \"/\";\n-      }\n+      key \u003d maybeAddTrailingSlash(key);\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || !objects.getObjectSummaries().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): {}/{}\",\n               objects.getCommonPrefixes().size() ,\n               objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: {}\", prefix);\n           }\n         }\n \n-        return new S3AFileStatus(true, false,\n-            f.makeQualified(uri, workingDir));\n+        return new S3AFileStatus(true, false, path);\n       } else if (key.isEmpty()) {\n         LOG.debug(\"Found root directory\");\n-        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+        return new S3AFileStatus(true, true, path);\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         throw translateException(\"getFileStatus\", key, e);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"getFileStatus\", key, e);\n     }\n \n-    LOG.debug(\"Not Found: {}\", f);\n-    throw new FileNotFoundException(\"No such file or directory: \" + f);\n+    LOG.debug(\"Not Found: {}\", path);\n+    throw new FileNotFoundException(\"No such file or directory: \" + path);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public S3AFileStatus getFileStatus(final Path f) throws IOException {\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"Getting path status for {}  ({})\", path , key);\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d getObjectMetadata(key);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          LOG.debug(\"Found exact file: fake directory\");\n          return new S3AFileStatus(true, true,\n              path);\n        } else {\n          LOG.debug(\"Found exact file: normal file\");\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              path,\n              getDefaultBlockSize(path));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          throw translateException(\"getFileStatus\", path, e);\n        }\n      } catch (AmazonClientException e) {\n        throw translateException(\"getFileStatus\", path, e);\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        String newKey \u003d key + \"/\";\n        try {\n          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            LOG.debug(\"Found file (with /): fake directory\");\n            return new S3AFileStatus(true, true, path);\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                path,\n                getDefaultBlockSize(path));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            throw translateException(\"getFileStatus\", newKey, e);\n          }\n        } catch (AmazonClientException e) {\n          throw translateException(\"getFileStatus\", newKey, e);\n        }\n      }\n    }\n\n    try {\n      key \u003d maybeAddTrailingSlash(key);\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || !objects.getObjectSummaries().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): {}/{}\",\n              objects.getCommonPrefixes().size() ,\n              objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: {}\", prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false, path);\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, true, path);\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        throw translateException(\"getFileStatus\", key, e);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"getFileStatus\", key, e);\n    }\n\n    LOG.debug(\"Not Found: {}\", path);\n    throw new FileNotFoundException(\"No such file or directory: \" + path);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path]",
            "newValue": "[f-Path(modifiers-final)]"
          }
        }
      ]
    },
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13171. Add StorageStatistics to S3A; instrument some more operations. Contributed by Steve Loughran.\n",
      "commitDate": "03/06/16 8:55 AM",
      "commitName": "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "01/06/16 2:49 PM",
      "commitNameOld": "16b1cc7af9bd63b65ef50e1056f275a7baf111a2",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,99 @@\n   public S3AFileStatus getFileStatus(Path f) throws IOException {\n     String key \u003d pathToKey(f);\n+    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n     LOG.debug(\"Getting path status for {}  ({})\", f , key);\n \n     if (!key.isEmpty()) {\n       try {\n-        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n-        statistics.incrementReadOps(1);\n+        ObjectMetadata meta \u003d getObjectMetadata(key);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           LOG.debug(\"Found exact file: fake directory\");\n           return new S3AFileStatus(true, true,\n               f.makeQualified(uri, workingDir));\n         } else {\n           LOG.debug(\"Found exact file: normal file\");\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n               f.makeQualified(uri, workingDir),\n               getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n           throw translateException(\"getFileStatus\", f, e);\n         }\n       } catch (AmazonClientException e) {\n         throw translateException(\"getFileStatus\", f, e);\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         String newKey \u003d key + \"/\";\n         try {\n-          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n-          statistics.incrementReadOps(1);\n+          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             LOG.debug(\"Found file (with /): fake directory\");\n             return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n                 f.makeQualified(uri, workingDir),\n                 getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             throw translateException(\"getFileStatus\", newKey, e);\n           }\n         } catch (AmazonClientException e) {\n           throw translateException(\"getFileStatus\", newKey, e);\n         }\n       }\n     }\n \n     try {\n       if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n-      ObjectListing objects \u003d s3.listObjects(request);\n-      statistics.incrementReadOps(1);\n+      ObjectListing objects \u003d listObjects(request);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || !objects.getObjectSummaries().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): {}/{}\",\n               objects.getCommonPrefixes().size() ,\n               objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: {}\", prefix);\n           }\n         }\n \n         return new S3AFileStatus(true, false,\n             f.makeQualified(uri, workingDir));\n       } else if (key.isEmpty()) {\n         LOG.debug(\"Found root directory\");\n         return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         throw translateException(\"getFileStatus\", key, e);\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"getFileStatus\", key, e);\n     }\n \n     LOG.debug(\"Not Found: {}\", f);\n     throw new FileNotFoundException(\"No such file or directory: \" + f);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n    incrementStatistic(INVOCATION_GET_FILE_STATUS);\n    LOG.debug(\"Getting path status for {}  ({})\", f , key);\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d getObjectMetadata(key);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          LOG.debug(\"Found exact file: fake directory\");\n          return new S3AFileStatus(true, true,\n              f.makeQualified(uri, workingDir));\n        } else {\n          LOG.debug(\"Found exact file: normal file\");\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir),\n              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          throw translateException(\"getFileStatus\", f, e);\n        }\n      } catch (AmazonClientException e) {\n        throw translateException(\"getFileStatus\", f, e);\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        String newKey \u003d key + \"/\";\n        try {\n          ObjectMetadata meta \u003d getObjectMetadata(newKey);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            LOG.debug(\"Found file (with /): fake directory\");\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir),\n                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            throw translateException(\"getFileStatus\", newKey, e);\n          }\n        } catch (AmazonClientException e) {\n          throw translateException(\"getFileStatus\", newKey, e);\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || !objects.getObjectSummaries().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): {}/{}\",\n              objects.getCommonPrefixes().size() ,\n              objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: {}\", prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false,\n            f.makeQualified(uri, workingDir));\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        throw translateException(\"getFileStatus\", key, e);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"getFileStatus\", key, e);\n    }\n\n    LOG.debug(\"Not Found: {}\", f);\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/05/16 5:52 AM",
      "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,101 @@\n   public S3AFileStatus getFileStatus(Path f) throws IOException {\n     String key \u003d pathToKey(f);\n     LOG.debug(\"Getting path status for {}  ({})\", f , key);\n \n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n         statistics.incrementReadOps(1);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           LOG.debug(\"Found exact file: fake directory\");\n           return new S3AFileStatus(true, true,\n               f.makeQualified(uri, workingDir));\n         } else {\n           LOG.debug(\"Found exact file: normal file\");\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n               f.makeQualified(uri, workingDir),\n               getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n-          printAmazonServiceException(f.toString(), e);\n-          throw e;\n+          throw translateException(\"getFileStatus\", f, e);\n         }\n       } catch (AmazonClientException e) {\n-        printAmazonClientException(f.toString(), e);\n-        throw e;\n+        throw translateException(\"getFileStatus\", f, e);\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         String newKey \u003d key + \"/\";\n         try {\n           ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n           statistics.incrementReadOps(1);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             LOG.debug(\"Found file (with /): fake directory\");\n             return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n                 f.makeQualified(uri, workingDir),\n                 getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n-            printAmazonServiceException(newKey, e);\n-            throw e;\n+            throw translateException(\"getFileStatus\", newKey, e);\n           }\n         } catch (AmazonClientException e) {\n-          printAmazonClientException(newKey, e);\n-          throw e;\n+          throw translateException(\"getFileStatus\", newKey, e);\n         }\n       }\n     }\n \n     try {\n       if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || !objects.getObjectSummaries().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): {}/{}\",\n               objects.getCommonPrefixes().size() ,\n               objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: {}\", prefix);\n           }\n         }\n \n         return new S3AFileStatus(true, false,\n             f.makeQualified(uri, workingDir));\n       } else if (key.isEmpty()) {\n         LOG.debug(\"Found root directory\");\n         return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n-        printAmazonServiceException(key, e);\n-        throw e;\n+        throw translateException(\"getFileStatus\", key, e);\n       }\n     } catch (AmazonClientException e) {\n-      printAmazonClientException(key, e);\n-      throw e;\n+      throw translateException(\"getFileStatus\", key, e);\n     }\n \n     LOG.debug(\"Not Found: {}\", f);\n     throw new FileNotFoundException(\"No such file or directory: \" + f);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n    LOG.debug(\"Getting path status for {}  ({})\", f , key);\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n        statistics.incrementReadOps(1);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          LOG.debug(\"Found exact file: fake directory\");\n          return new S3AFileStatus(true, true,\n              f.makeQualified(uri, workingDir));\n        } else {\n          LOG.debug(\"Found exact file: normal file\");\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir),\n              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          throw translateException(\"getFileStatus\", f, e);\n        }\n      } catch (AmazonClientException e) {\n        throw translateException(\"getFileStatus\", f, e);\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        String newKey \u003d key + \"/\";\n        try {\n          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n          statistics.incrementReadOps(1);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            LOG.debug(\"Found file (with /): fake directory\");\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir),\n                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            throw translateException(\"getFileStatus\", newKey, e);\n          }\n        } catch (AmazonClientException e) {\n          throw translateException(\"getFileStatus\", newKey, e);\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || !objects.getObjectSummaries().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): {}/{}\",\n              objects.getCommonPrefixes().size() ,\n              objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: {}\", prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false,\n            f.makeQualified(uri, workingDir));\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        throw translateException(\"getFileStatus\", key, e);\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"getFileStatus\", key, e);\n    }\n\n    LOG.debug(\"Not Found: {}\", f);\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,107 @@\n   public S3AFileStatus getFileStatus(Path f) throws IOException {\n     String key \u003d pathToKey(f);\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n-    }\n-\n+    LOG.debug(\"Getting path status for {}  ({})\", f , key);\n \n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n         statistics.incrementReadOps(1);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found exact file: fake directory\");\n-          }\n+          LOG.debug(\"Found exact file: fake directory\");\n           return new S3AFileStatus(true, true,\n               f.makeQualified(uri, workingDir));\n         } else {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found exact file: normal file\");\n-          }\n+          LOG.debug(\"Found exact file: normal file\");\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n               f.makeQualified(uri, workingDir),\n               getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n-          printAmazonServiceException(e);\n+          printAmazonServiceException(f.toString(), e);\n           throw e;\n         }\n       } catch (AmazonClientException e) {\n-        printAmazonClientException(e);\n+        printAmazonClientException(f.toString(), e);\n         throw e;\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n+        String newKey \u003d key + \"/\";\n         try {\n-          String newKey \u003d key + \"/\";\n           ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n           statistics.incrementReadOps(1);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Found file (with /): fake directory\");\n-            }\n+            LOG.debug(\"Found file (with /): fake directory\");\n             return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n                 f.makeQualified(uri, workingDir),\n                 getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n-            printAmazonServiceException(e);\n+            printAmazonServiceException(newKey, e);\n             throw e;\n           }\n         } catch (AmazonClientException e) {\n-          printAmazonClientException(e);\n+          printAmazonClientException(newKey, e);\n           throw e;\n         }\n       }\n     }\n \n     try {\n       if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n-          || objects.getObjectSummaries().size() \u003e 0) {\n+          || !objects.getObjectSummaries().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found path as directory (with /): \" +\n-              objects.getCommonPrefixes().size() + \"/\" +\n+          LOG.debug(\"Found path as directory (with /): {}/{}\",\n+              objects.getCommonPrefixes().size() ,\n               objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-            LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n+            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n-            LOG.debug(\"Prefix: \" + prefix);\n+            LOG.debug(\"Prefix: {}\", prefix);\n           }\n         }\n \n         return new S3AFileStatus(true, false,\n             f.makeQualified(uri, workingDir));\n       } else if (key.isEmpty()) {\n         LOG.debug(\"Found root directory\");\n         return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n-        printAmazonServiceException(e);\n+        printAmazonServiceException(key, e);\n         throw e;\n       }\n     } catch (AmazonClientException e) {\n-      printAmazonClientException(e);\n+      printAmazonClientException(key, e);\n       throw e;\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Not Found: \" + f);\n-    }\n+    LOG.debug(\"Not Found: {}\", f);\n     throw new FileNotFoundException(\"No such file or directory: \" + f);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n    LOG.debug(\"Getting path status for {}  ({})\", f , key);\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n        statistics.incrementReadOps(1);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          LOG.debug(\"Found exact file: fake directory\");\n          return new S3AFileStatus(true, true,\n              f.makeQualified(uri, workingDir));\n        } else {\n          LOG.debug(\"Found exact file: normal file\");\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir),\n              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          printAmazonServiceException(f.toString(), e);\n          throw e;\n        }\n      } catch (AmazonClientException e) {\n        printAmazonClientException(f.toString(), e);\n        throw e;\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        String newKey \u003d key + \"/\";\n        try {\n          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n          statistics.incrementReadOps(1);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            LOG.debug(\"Found file (with /): fake directory\");\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir),\n                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            printAmazonServiceException(newKey, e);\n            throw e;\n          }\n        } catch (AmazonClientException e) {\n          printAmazonClientException(newKey, e);\n          throw e;\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || !objects.getObjectSummaries().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): {}/{}\",\n              objects.getCommonPrefixes().size() ,\n              objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: {} {}\", summary.getKey(), summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: {}\", prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false,\n            f.makeQualified(uri, workingDir));\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        printAmazonServiceException(key, e);\n        throw e;\n      }\n    } catch (AmazonClientException e) {\n      printAmazonClientException(key, e);\n      throw e;\n    }\n\n    LOG.debug(\"Not Found: {}\", f);\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "7fe521b1dd49f81ae325f78cf531cfff15be6641": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11918. Listing an empty s3a root directory throws FileNotFound. Contributed by Lei (Eddy) Xu.\n",
      "commitDate": "25/09/15 10:33 PM",
      "commitName": "7fe521b1dd49f81ae325f78cf531cfff15be6641",
      "commitAuthor": "cnauroth",
      "commitDateOld": "04/08/15 6:51 PM",
      "commitNameOld": "d5403747b57b1e294e533ce17f197e7be8f5339c",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 52.15,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,118 @@\n   public S3AFileStatus getFileStatus(Path f) throws IOException {\n     String key \u003d pathToKey(f);\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n     }\n \n \n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n         statistics.incrementReadOps(1);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found exact file: fake directory\");\n           }\n           return new S3AFileStatus(true, true,\n               f.makeQualified(uri, workingDir));\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found exact file: normal file\");\n           }\n           return new S3AFileStatus(meta.getContentLength(),\n               dateToLong(meta.getLastModified()),\n               f.makeQualified(uri, workingDir),\n               getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n           printAmazonServiceException(e);\n           throw e;\n         }\n       } catch (AmazonClientException e) {\n         printAmazonClientException(e);\n         throw e;\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         try {\n           String newKey \u003d key + \"/\";\n           ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n           statistics.incrementReadOps(1);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Found file (with /): fake directory\");\n             }\n             return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(),\n                 dateToLong(meta.getLastModified()),\n                 f.makeQualified(uri, workingDir),\n                 getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             printAmazonServiceException(e);\n             throw e;\n           }\n         } catch (AmazonClientException e) {\n           printAmazonClientException(e);\n           throw e;\n         }\n       }\n     }\n \n     try {\n       if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || objects.getObjectSummaries().size() \u003e 0) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): \" + \n             objects.getCommonPrefixes().size() + \"/\" + \n             objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: \" + prefix);\n           }\n         }\n \n         return new S3AFileStatus(true, false,\n             f.makeQualified(uri, workingDir));\n+      } else if (key.isEmpty()) {\n+        LOG.debug(\"Found root directory\");\n+        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         printAmazonServiceException(e);\n         throw e;\n       }\n     } catch (AmazonClientException e) {\n       printAmazonClientException(e);\n       throw e;\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Not Found: \" + f);\n     }\n     throw new FileNotFoundException(\"No such file or directory: \" + f);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n    }\n\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n        statistics.incrementReadOps(1);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: fake directory\");\n          }\n          return new S3AFileStatus(true, true,\n              f.makeQualified(uri, workingDir));\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: normal file\");\n          }\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir),\n              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          printAmazonServiceException(e);\n          throw e;\n        }\n      } catch (AmazonClientException e) {\n        printAmazonClientException(e);\n        throw e;\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        try {\n          String newKey \u003d key + \"/\";\n          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n          statistics.incrementReadOps(1);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Found file (with /): fake directory\");\n            }\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir),\n                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            printAmazonServiceException(e);\n            throw e;\n          }\n        } catch (AmazonClientException e) {\n          printAmazonClientException(e);\n          throw e;\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || objects.getObjectSummaries().size() \u003e 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): \" + \n            objects.getCommonPrefixes().size() + \"/\" + \n            objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: \" + prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false,\n            f.makeQualified(uri, workingDir));\n      } else if (key.isEmpty()) {\n        LOG.debug(\"Found root directory\");\n        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        printAmazonServiceException(e);\n        throw e;\n      }\n    } catch (AmazonClientException e) {\n      printAmazonClientException(e);\n      throw e;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Not Found: \" + f);\n    }\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "709ff99cff4124823bde631e272af7be9a22f83b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11584 s3a file block size set to 0 in getFileStatus. (Brahma Reddy Battula via stevel)\n",
      "commitDate": "21/02/15 4:03 AM",
      "commitName": "709ff99cff4124823bde631e272af7be9a22f83b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/02/15 12:51 PM",
      "commitNameOld": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,115 @@\n   public S3AFileStatus getFileStatus(Path f) throws IOException {\n     String key \u003d pathToKey(f);\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n     }\n \n \n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n         statistics.incrementReadOps(1);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found exact file: fake directory\");\n           }\n-          return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+          return new S3AFileStatus(true, true,\n+              f.makeQualified(uri, workingDir));\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found exact file: normal file\");\n           }\n-          return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n-              f.makeQualified(uri, workingDir));\n+          return new S3AFileStatus(meta.getContentLength(),\n+              dateToLong(meta.getLastModified()),\n+              f.makeQualified(uri, workingDir),\n+              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n           printAmazonServiceException(e);\n           throw e;\n         }\n       } catch (AmazonClientException e) {\n         printAmazonClientException(e);\n         throw e;\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         try {\n           String newKey \u003d key + \"/\";\n           ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n           statistics.incrementReadOps(1);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Found file (with /): fake directory\");\n             }\n             return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n           } else {\n             LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n-            return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n-                f.makeQualified(uri, workingDir));\n+            return new S3AFileStatus(meta.getContentLength(),\n+                dateToLong(meta.getLastModified()),\n+                f.makeQualified(uri, workingDir),\n+                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             printAmazonServiceException(e);\n             throw e;\n           }\n         } catch (AmazonClientException e) {\n           printAmazonClientException(e);\n           throw e;\n         }\n       }\n     }\n \n     try {\n       if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       if (!objects.getCommonPrefixes().isEmpty()\n           || objects.getObjectSummaries().size() \u003e 0) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): \" + \n             objects.getCommonPrefixes().size() + \"/\" + \n             objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: \" + prefix);\n           }\n         }\n \n-        return new S3AFileStatus(true, false, f.makeQualified(uri, workingDir));\n+        return new S3AFileStatus(true, false,\n+            f.makeQualified(uri, workingDir));\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         printAmazonServiceException(e);\n         throw e;\n       }\n     } catch (AmazonClientException e) {\n       printAmazonClientException(e);\n       throw e;\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Not Found: \" + f);\n     }\n     throw new FileNotFoundException(\"No such file or directory: \" + f);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n    }\n\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n        statistics.incrementReadOps(1);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: fake directory\");\n          }\n          return new S3AFileStatus(true, true,\n              f.makeQualified(uri, workingDir));\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: normal file\");\n          }\n          return new S3AFileStatus(meta.getContentLength(),\n              dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir),\n              getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          printAmazonServiceException(e);\n          throw e;\n        }\n      } catch (AmazonClientException e) {\n        printAmazonClientException(e);\n        throw e;\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        try {\n          String newKey \u003d key + \"/\";\n          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n          statistics.incrementReadOps(1);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Found file (with /): fake directory\");\n            }\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(),\n                dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir),\n                getDefaultBlockSize(f.makeQualified(uri, workingDir)));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            printAmazonServiceException(e);\n            throw e;\n          }\n        } catch (AmazonClientException e) {\n          printAmazonClientException(e);\n          throw e;\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || objects.getObjectSummaries().size() \u003e 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): \" + \n            objects.getCommonPrefixes().size() + \"/\" + \n            objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: \" + prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false,\n            f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        printAmazonServiceException(e);\n        throw e;\n      }\n    } catch (AmazonClientException e) {\n      printAmazonClientException(e);\n      throw e;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Not Found: \" + f);\n    }\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 4:49 PM",
      "commitNameOld": "0ac760a58d96b36ab30e9d60679bbea6365ef120",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,109 @@\n   public S3AFileStatus getFileStatus(Path f) throws IOException {\n     String key \u003d pathToKey(f);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n+    }\n \n-    LOG.info(\"Getting path status for \" + f + \" (\" + key + \")\");\n \n     if (!key.isEmpty()) {\n       try {\n         ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n         statistics.incrementReadOps(1);\n \n         if (objectRepresentsDirectory(key, meta.getContentLength())) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found exact file: fake directory\");\n           }\n           return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found exact file: normal file\");\n           }\n           return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n               f.makeQualified(uri, workingDir));\n         }\n       } catch (AmazonServiceException e) {\n         if (e.getStatusCode() !\u003d 404) {\n           printAmazonServiceException(e);\n           throw e;\n         }\n       } catch (AmazonClientException e) {\n         printAmazonClientException(e);\n         throw e;\n       }\n \n       // Necessary?\n       if (!key.endsWith(\"/\")) {\n         try {\n           String newKey \u003d key + \"/\";\n           ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n           statistics.incrementReadOps(1);\n \n           if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Found file (with /): fake directory\");\n             }\n             return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n           } else {\n-            LOG.warn(\"Found file (with /): real file? should not happen: \" + key);\n+            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n \n             return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n                 f.makeQualified(uri, workingDir));\n           }\n         } catch (AmazonServiceException e) {\n           if (e.getStatusCode() !\u003d 404) {\n             printAmazonServiceException(e);\n             throw e;\n           }\n         } catch (AmazonClientException e) {\n           printAmazonClientException(e);\n           throw e;\n         }\n       }\n     }\n \n     try {\n       if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(1);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n-      if (objects.getCommonPrefixes().size() \u003e 0 || objects.getObjectSummaries().size() \u003e 0) {\n+      if (!objects.getCommonPrefixes().isEmpty()\n+          || objects.getObjectSummaries().size() \u003e 0) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as directory (with /): \" + \n             objects.getCommonPrefixes().size() + \"/\" + \n             objects.getObjectSummaries().size());\n \n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n           }\n           for (String prefix : objects.getCommonPrefixes()) {\n             LOG.debug(\"Prefix: \" + prefix);\n           }\n         }\n \n         return new S3AFileStatus(true, false, f.makeQualified(uri, workingDir));\n       }\n     } catch (AmazonServiceException e) {\n       if (e.getStatusCode() !\u003d 404) {\n         printAmazonServiceException(e);\n         throw e;\n       }\n     } catch (AmazonClientException e) {\n       printAmazonClientException(e);\n       throw e;\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Not Found: \" + f);\n     }\n     throw new FileNotFoundException(\"No such file or directory: \" + f);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Getting path status for \" + f + \" (\" + key + \")\");\n    }\n\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n        statistics.incrementReadOps(1);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: fake directory\");\n          }\n          return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: normal file\");\n          }\n          return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          printAmazonServiceException(e);\n          throw e;\n        }\n      } catch (AmazonClientException e) {\n        printAmazonClientException(e);\n        throw e;\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        try {\n          String newKey \u003d key + \"/\";\n          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n          statistics.incrementReadOps(1);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Found file (with /): fake directory\");\n            }\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: {}\", key);\n\n            return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            printAmazonServiceException(e);\n            throw e;\n          }\n        } catch (AmazonClientException e) {\n          printAmazonClientException(e);\n          throw e;\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      if (!objects.getCommonPrefixes().isEmpty()\n          || objects.getObjectSummaries().size() \u003e 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): \" + \n            objects.getCommonPrefixes().size() + \"/\" + \n            objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: \" + prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false, f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        printAmazonServiceException(e);\n        throw e;\n      }\n    } catch (AmazonClientException e) {\n      printAmazonClientException(e);\n      throw e;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Not Found: \" + f);\n    }\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,106 @@\n+  public S3AFileStatus getFileStatus(Path f) throws IOException {\n+    String key \u003d pathToKey(f);\n+\n+    LOG.info(\"Getting path status for \" + f + \" (\" + key + \")\");\n+\n+    if (!key.isEmpty()) {\n+      try {\n+        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n+        statistics.incrementReadOps(1);\n+\n+        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found exact file: fake directory\");\n+          }\n+          return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+        } else {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found exact file: normal file\");\n+          }\n+          return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n+              f.makeQualified(uri, workingDir));\n+        }\n+      } catch (AmazonServiceException e) {\n+        if (e.getStatusCode() !\u003d 404) {\n+          printAmazonServiceException(e);\n+          throw e;\n+        }\n+      } catch (AmazonClientException e) {\n+        printAmazonClientException(e);\n+        throw e;\n+      }\n+\n+      // Necessary?\n+      if (!key.endsWith(\"/\")) {\n+        try {\n+          String newKey \u003d key + \"/\";\n+          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n+          statistics.incrementReadOps(1);\n+\n+          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Found file (with /): fake directory\");\n+            }\n+            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n+          } else {\n+            LOG.warn(\"Found file (with /): real file? should not happen: \" + key);\n+\n+            return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n+                f.makeQualified(uri, workingDir));\n+          }\n+        } catch (AmazonServiceException e) {\n+          if (e.getStatusCode() !\u003d 404) {\n+            printAmazonServiceException(e);\n+            throw e;\n+          }\n+        } catch (AmazonClientException e) {\n+          printAmazonClientException(e);\n+          throw e;\n+        }\n+      }\n+    }\n+\n+    try {\n+      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n+        key \u003d key + \"/\";\n+      }\n+      ListObjectsRequest request \u003d new ListObjectsRequest();\n+      request.setBucketName(bucket);\n+      request.setPrefix(key);\n+      request.setDelimiter(\"/\");\n+      request.setMaxKeys(1);\n+\n+      ObjectListing objects \u003d s3.listObjects(request);\n+      statistics.incrementReadOps(1);\n+\n+      if (objects.getCommonPrefixes().size() \u003e 0 || objects.getObjectSummaries().size() \u003e 0) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Found path as directory (with /): \" + \n+            objects.getCommonPrefixes().size() + \"/\" + \n+            objects.getObjectSummaries().size());\n+\n+          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n+            LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n+          }\n+          for (String prefix : objects.getCommonPrefixes()) {\n+            LOG.debug(\"Prefix: \" + prefix);\n+          }\n+        }\n+\n+        return new S3AFileStatus(true, false, f.makeQualified(uri, workingDir));\n+      }\n+    } catch (AmazonServiceException e) {\n+      if (e.getStatusCode() !\u003d 404) {\n+        printAmazonServiceException(e);\n+        throw e;\n+      }\n+    } catch (AmazonClientException e) {\n+      printAmazonClientException(e);\n+      throw e;\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Not Found: \" + f);\n+    }\n+    throw new FileNotFoundException(\"No such file or directory: \" + f);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public S3AFileStatus getFileStatus(Path f) throws IOException {\n    String key \u003d pathToKey(f);\n\n    LOG.info(\"Getting path status for \" + f + \" (\" + key + \")\");\n\n    if (!key.isEmpty()) {\n      try {\n        ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, key);\n        statistics.incrementReadOps(1);\n\n        if (objectRepresentsDirectory(key, meta.getContentLength())) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: fake directory\");\n          }\n          return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found exact file: normal file\");\n          }\n          return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n              f.makeQualified(uri, workingDir));\n        }\n      } catch (AmazonServiceException e) {\n        if (e.getStatusCode() !\u003d 404) {\n          printAmazonServiceException(e);\n          throw e;\n        }\n      } catch (AmazonClientException e) {\n        printAmazonClientException(e);\n        throw e;\n      }\n\n      // Necessary?\n      if (!key.endsWith(\"/\")) {\n        try {\n          String newKey \u003d key + \"/\";\n          ObjectMetadata meta \u003d s3.getObjectMetadata(bucket, newKey);\n          statistics.incrementReadOps(1);\n\n          if (objectRepresentsDirectory(newKey, meta.getContentLength())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Found file (with /): fake directory\");\n            }\n            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));\n          } else {\n            LOG.warn(\"Found file (with /): real file? should not happen: \" + key);\n\n            return new S3AFileStatus(meta.getContentLength(), dateToLong(meta.getLastModified()),\n                f.makeQualified(uri, workingDir));\n          }\n        } catch (AmazonServiceException e) {\n          if (e.getStatusCode() !\u003d 404) {\n            printAmazonServiceException(e);\n            throw e;\n          }\n        } catch (AmazonClientException e) {\n          printAmazonClientException(e);\n          throw e;\n        }\n      }\n    }\n\n    try {\n      if (!key.isEmpty() \u0026\u0026 !key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(1);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      if (objects.getCommonPrefixes().size() \u003e 0 || objects.getObjectSummaries().size() \u003e 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as directory (with /): \" + \n            objects.getCommonPrefixes().size() + \"/\" + \n            objects.getObjectSummaries().size());\n\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            LOG.debug(\"Summary: \" + summary.getKey() + \" \" + summary.getSize());\n          }\n          for (String prefix : objects.getCommonPrefixes()) {\n            LOG.debug(\"Prefix: \" + prefix);\n          }\n        }\n\n        return new S3AFileStatus(true, false, f.makeQualified(uri, workingDir));\n      }\n    } catch (AmazonServiceException e) {\n      if (e.getStatusCode() !\u003d 404) {\n        printAmazonServiceException(e);\n        throw e;\n      }\n    } catch (AmazonClientException e) {\n      printAmazonClientException(e);\n      throw e;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Not Found: \" + f);\n    }\n    throw new FileNotFoundException(\"No such file or directory: \" + f);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}