{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "move",
  "functionId": "move___pathsToDelete-Collection__Path__(annotations-@Nullable)__pathsToCreate-Collection__PathMetadata__(annotations-@Nullable)__operationState-BulkOperationState(annotations-@Nullable__modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 1093,
  "functionEndLine": 1146,
  "numCommitsSeen": 126,
  "timeTaken": 7946,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "7b219778e05a50e33cca75d727e62783322b7f80",
    "c58e11bf521d746842ce16724211a2a0339d7b61",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "7b219778e05a50e33cca75d727e62783322b7f80": "Ybodychange",
    "c58e11bf521d746842ce16724211a2a0339d7b61": "Ymultichange(Yparameterchange,Ybodychange)",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ymultichange(Yparameterchange,Ybodychange)",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": "Ybodychange",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/11/19 7:36 AM",
      "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 44.82,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       // create all parent entries.\n       // this is synchronized on the move state so that across both serialized\n       // and parallelized renames, duplicate ancestor entries are not created.\n       synchronized (ancestorState) {\n         newItems.addAll(\n             completeAncestry(\n                 pathMetaToDDBPathMeta(pathsToCreate),\n                 ancestorState));\n       }\n     }\n     // sort all the new items topmost first.\n     newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n \n     // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n       List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta,\n             ttlTimeProvider.getNow());\n         tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n       // sort all the tombstones lowest first.\n-      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n+      tombstones.sort(TOPMOST_PM_LAST);\n       newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(ancestorState,\n         null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta,\n            ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(ancestorState,\n        null, pathMetadataToItem(newItems));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "7b219778e05a50e33cca75d727e62783322b7f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16433. S3Guard: Filter expired entries and tombstones when listing with MetadataStore.listChildren().\n\nContributed by Gabor Bota.\n\nThis pulls the tracking of the lastUpdated timestamp of metadata entries up from the DDB metastore into all s3guard stores, and then uses this to filter out expired tombstones from listings.\n\nChange-Id: I80f121236b49c75a024116f65a3ef29d3580b462\n",
      "commitDate": "24/07/19 10:11 AM",
      "commitName": "7b219778e05a50e33cca75d727e62783322b7f80",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "17/07/19 7:24 AM",
      "commitNameOld": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       // create all parent entries.\n       // this is synchronized on the move state so that across both serialized\n       // and parallelized renames, duplicate ancestor entries are not created.\n       synchronized (ancestorState) {\n         newItems.addAll(\n             completeAncestry(\n                 pathMetaToDDBPathMeta(pathsToCreate),\n                 ancestorState));\n       }\n     }\n     // sort all the new items topmost first.\n     newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n \n     // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n       List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n-        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n-        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n+        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta,\n+            ttlTimeProvider.getNow());\n         tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n       // sort all the tombstones lowest first.\n       tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n       newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(ancestorState,\n         null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta,\n            ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(ancestorState,\n        null, pathMetadataToItem(newItems));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "c58e11bf521d746842ce16724211a2a0339d7b61": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
      "commitDate": "17/07/19 7:24 AM",
      "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
          "commitDate": "17/07/19 7:24 AM",
          "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "12/07/19 5:02 AM",
          "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 5.1,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,54 @@\n-  public void move(\n-      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n-      final ITtlTimeProvider ttlTimeProvider,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       // create all parent entries.\n       // this is synchronized on the move state so that across both serialized\n       // and parallelized renames, duplicate ancestor entries are not created.\n       synchronized (ancestorState) {\n         newItems.addAll(\n             completeAncestry(\n                 pathMetaToDDBPathMeta(pathsToCreate),\n-                ancestorState,\n-                extractTimeProvider(ttlTimeProvider)));\n+                ancestorState));\n       }\n     }\n     // sort all the new items topmost first.\n     newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n \n     // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n       List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n         pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n         tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n       // sort all the tombstones lowest first.\n       tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n       newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(ancestorState,\n         null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(ancestorState,\n        null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), ttlTimeProvider-ITtlTimeProvider(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
          "commitDate": "17/07/19 7:24 AM",
          "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "12/07/19 5:02 AM",
          "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 5.1,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,54 @@\n-  public void move(\n-      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n-      final ITtlTimeProvider ttlTimeProvider,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       // create all parent entries.\n       // this is synchronized on the move state so that across both serialized\n       // and parallelized renames, duplicate ancestor entries are not created.\n       synchronized (ancestorState) {\n         newItems.addAll(\n             completeAncestry(\n                 pathMetaToDDBPathMeta(pathsToCreate),\n-                ancestorState,\n-                extractTimeProvider(ttlTimeProvider)));\n+                ancestorState));\n       }\n     }\n     // sort all the new items topmost first.\n     newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n \n     // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n       List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n         pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n         tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n       // sort all the tombstones lowest first.\n       tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n       newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(ancestorState,\n         null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(ancestorState,\n        null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "08/07/19 10:27 AM",
      "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,57 @@\n   public void move(\n       @Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n       final ITtlTimeProvider ttlTimeProvider,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       // create all parent entries.\n       // this is synchronized on the move state so that across both serialized\n       // and parallelized renames, duplicate ancestor entries are not created.\n       synchronized (ancestorState) {\n         newItems.addAll(\n             completeAncestry(\n                 pathMetaToDDBPathMeta(pathsToCreate),\n                 ancestorState,\n                 extractTimeProvider(ttlTimeProvider)));\n       }\n     }\n     // sort all the new items topmost first.\n     newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n \n     // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n       List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n         pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n         tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n       // sort all the tombstones lowest first.\n       tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n       newItems.addAll(tombstones);\n     }\n \n-    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n+    processBatchWriteRequest(ancestorState,\n+        null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      final ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState,\n                extractTimeProvider(ttlTimeProvider)));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(ancestorState,\n        null, pathMetadataToItem(newItems));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,56 @@\n-  public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n-      throws IOException {\n+  public void move(\n+      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n-    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n+    AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Rename);\n+    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n-      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n+      // create all parent entries.\n+      // this is synchronized on the move state so that across both serialized\n+      // and parallelized renames, duplicate ancestor entries are not created.\n+      synchronized (ancestorState) {\n+        newItems.addAll(\n+            completeAncestry(\n+                pathMetaToDDBPathMeta(pathsToCreate),\n+                ancestorState,\n+                extractTimeProvider(ttlTimeProvider)));\n+      }\n     }\n+    // sort all the new items topmost first.\n+    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+\n+    // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n+      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n         pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n-        newItems.add(new DDBPathMetadata(pmTombstone));\n+        tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n+      // sort all the tombstones lowest first.\n+      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n+      newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      final ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState,\n                extractTimeProvider(ttlTimeProvider)));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), ttlTimeProvider-ITtlTimeProvider(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,56 @@\n-  public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n-      throws IOException {\n+  public void move(\n+      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n-    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n+    AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Rename);\n+    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n-      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n+      // create all parent entries.\n+      // this is synchronized on the move state so that across both serialized\n+      // and parallelized renames, duplicate ancestor entries are not created.\n+      synchronized (ancestorState) {\n+        newItems.addAll(\n+            completeAncestry(\n+                pathMetaToDDBPathMeta(pathsToCreate),\n+                ancestorState,\n+                extractTimeProvider(ttlTimeProvider)));\n+      }\n     }\n+    // sort all the new items topmost first.\n+    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+\n+    // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n+      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n         pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n-        newItems.add(new DDBPathMetadata(pmTombstone));\n+        tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n+      // sort all the tombstones lowest first.\n+      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n+      newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      final ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState,\n                extractTimeProvider(ttlTimeProvider)));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,56 @@\n-  public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n-      throws IOException {\n+  public void move(\n+      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n-    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n+    AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Rename);\n+    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n-      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n+      // create all parent entries.\n+      // this is synchronized on the move state so that across both serialized\n+      // and parallelized renames, duplicate ancestor entries are not created.\n+      synchronized (ancestorState) {\n+        newItems.addAll(\n+            completeAncestry(\n+                pathMetaToDDBPathMeta(pathsToCreate),\n+                ancestorState,\n+                extractTimeProvider(ttlTimeProvider)));\n+      }\n     }\n+    // sort all the new items topmost first.\n+    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+\n+    // now process the deletions.\n     if (pathsToDelete !\u003d null) {\n+      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n       for (Path meta : pathsToDelete) {\n         Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n             + \" must not be null\");\n         final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n         pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n-        newItems.add(new DDBPathMetadata(pmTombstone));\n+        tombstones.add(new DDBPathMetadata(pmTombstone));\n       }\n+      // sort all the tombstones lowest first.\n+      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n+      newItems.addAll(tombstones);\n     }\n \n     processBatchWriteRequest(null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      final ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    List\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      // create all parent entries.\n      // this is synchronized on the move state so that across both serialized\n      // and parallelized renames, duplicate ancestor entries are not created.\n      synchronized (ancestorState) {\n        newItems.addAll(\n            completeAncestry(\n                pathMetaToDDBPathMeta(pathsToCreate),\n                ancestorState,\n                extractTimeProvider(ttlTimeProvider)));\n      }\n    }\n    // sort all the new items topmost first.\n    newItems.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n\n    // now process the deletions.\n    if (pathsToDelete !\u003d null) {\n      List\u003cDDBPathMetadata\u003e tombstones \u003d new ArrayList\u003c\u003e(pathsToDelete.size());\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        tombstones.add(new DDBPathMetadata(pmTombstone));\n      }\n      // sort all the tombstones lowest first.\n      tombstones.sort(PathOrderComparators.TOPMOST_PM_LAST);\n      newItems.addAll(tombstones);\n    }\n\n    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), ttlTimeProvider-ITtlTimeProvider(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        }
      ]
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "07/06/19 10:26 AM",
          "commitNameOld": "4e38dafde4dce8cd8c368783a291e830f06e1def",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,35 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n+      throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n     }\n     if (pathsToDelete !\u003d null) {\n       for (Path meta : pathsToDelete) {\n-        newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));\n+        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n+            + \" must not be null\");\n+        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n+        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n+        newItems.add(new DDBPathMetadata(pmTombstone));\n       }\n     }\n \n     processBatchWriteRequest(null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n    }\n    if (pathsToDelete !\u003d null) {\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        newItems.add(new DDBPathMetadata(pmTombstone));\n      }\n    }\n\n    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e, ttlTimeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "07/06/19 10:26 AM",
          "commitNameOld": "4e38dafde4dce8cd8c368783a291e830f06e1def",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,35 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n+      throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n     }\n     if (pathsToDelete !\u003d null) {\n       for (Path meta : pathsToDelete) {\n-        newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));\n+        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n+            + \" must not be null\");\n+        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n+        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n+        newItems.add(new DDBPathMetadata(pmTombstone));\n       }\n     }\n \n     processBatchWriteRequest(null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate, ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n    }\n    if (pathsToDelete !\u003d null) {\n      for (Path meta : pathsToDelete) {\n        Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider\"\n            + \" must not be null\");\n        final PathMetadata pmTombstone \u003d PathMetadata.tombstone(meta);\n        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n        newItems.add(new DDBPathMetadata(pmTombstone));\n      }\n    }\n\n    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15426 Make S3guard client resilient to DDB throttle events and network failures (Contributed by Steve Loughran)\n",
      "commitDate": "12/09/18 9:04 PM",
      "commitName": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/09/18 4:36 PM",
      "commitNameOld": "d32a8d5d582725eb724b78f27310ad1efd33ed2a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,30 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n       Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n     }\n     if (pathsToDelete !\u003d null) {\n       for (Path meta : pathsToDelete) {\n         newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));\n       }\n     }\n \n-    Invoker.once(\"move\", tableName,\n-        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(newItems)));\n+    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n    }\n    if (pathsToDelete !\u003d null) {\n      for (Path meta : pathsToDelete) {\n        newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));\n      }\n    }\n\n    processBatchWriteRequest(null, pathMetadataToItem(newItems));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "08/08/18 10:57 PM",
      "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 8.47,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n       Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n-    Collection\u003cPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n+    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n-      newItems.addAll(completeAncestry(pathsToCreate));\n+      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n     }\n     if (pathsToDelete !\u003d null) {\n       for (Path meta : pathsToDelete) {\n-        newItems.add(PathMetadata.tombstone(meta));\n+        newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));\n       }\n     }\n \n     Invoker.once(\"move\", tableName,\n         () -\u003e processBatchWriteRequest(null, pathMetadataToItem(newItems)));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    Collection\u003cDDBPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      newItems.addAll(completeAncestry(pathMetaToDDBPathMeta(pathsToCreate)));\n    }\n    if (pathsToDelete !\u003d null) {\n      for (Path meta : pathsToDelete) {\n        newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));\n      }\n    }\n\n    Invoker.once(\"move\", tableName,\n        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(newItems)));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,31 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n       Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n     if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n       return;\n     }\n \n     LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n         + \" paths to create\", tableName, region,\n         pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n         pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n     LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n         pathsToCreate);\n \n     // In DynamoDBMetadataStore implementation, we assume that if a path\n     // exists, all its ancestors will also exist in the table.\n     // Following code is to maintain this invariant by putting all ancestor\n     // directories of the paths to create.\n     // ancestor paths that are not explicitly added to paths to create\n     Collection\u003cPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n     if (pathsToCreate !\u003d null) {\n       newItems.addAll(completeAncestry(pathsToCreate));\n     }\n     if (pathsToDelete !\u003d null) {\n       for (Path meta : pathsToDelete) {\n         newItems.add(PathMetadata.tombstone(meta));\n       }\n     }\n \n-    try {\n-      processBatchWriteRequest(null, pathMetadataToItem(newItems));\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"move\", (String) null, e);\n-    }\n+    Invoker.once(\"move\", tableName,\n+        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(newItems)));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    Collection\u003cPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      newItems.addAll(completeAncestry(pathsToCreate));\n    }\n    if (pathsToDelete !\u003d null) {\n      for (Path meta : pathsToDelete) {\n        newItems.add(PathMetadata.tombstone(meta));\n      }\n    }\n\n    Invoker.once(\"move\", tableName,\n        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(newItems)));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,34 @@\n+  public void move(Collection\u003cPath\u003e pathsToDelete,\n+      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n+      return;\n+    }\n+\n+    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n+        + \" paths to create\", tableName, region,\n+        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n+        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n+    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n+        pathsToCreate);\n+\n+    // In DynamoDBMetadataStore implementation, we assume that if a path\n+    // exists, all its ancestors will also exist in the table.\n+    // Following code is to maintain this invariant by putting all ancestor\n+    // directories of the paths to create.\n+    // ancestor paths that are not explicitly added to paths to create\n+    Collection\u003cPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n+    if (pathsToCreate !\u003d null) {\n+      newItems.addAll(completeAncestry(pathsToCreate));\n+    }\n+    if (pathsToDelete !\u003d null) {\n+      for (Path meta : pathsToDelete) {\n+        newItems.add(PathMetadata.tombstone(meta));\n+      }\n+    }\n+\n+    try {\n+      processBatchWriteRequest(null, pathMetadataToItem(newItems));\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"move\", (String) null, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n    if (pathsToDelete \u003d\u003d null \u0026\u0026 pathsToCreate \u003d\u003d null) {\n      return;\n    }\n\n    LOG.debug(\"Moving paths of table {} in region {}: {} paths to delete and {}\"\n        + \" paths to create\", tableName, region,\n        pathsToDelete \u003d\u003d null ? 0 : pathsToDelete.size(),\n        pathsToCreate \u003d\u003d null ? 0 : pathsToCreate.size());\n    LOG.trace(\"move: pathsToDelete \u003d {}, pathsToCreate \u003d {}\", pathsToDelete,\n        pathsToCreate);\n\n    // In DynamoDBMetadataStore implementation, we assume that if a path\n    // exists, all its ancestors will also exist in the table.\n    // Following code is to maintain this invariant by putting all ancestor\n    // directories of the paths to create.\n    // ancestor paths that are not explicitly added to paths to create\n    Collection\u003cPathMetadata\u003e newItems \u003d new ArrayList\u003c\u003e();\n    if (pathsToCreate !\u003d null) {\n      newItems.addAll(completeAncestry(pathsToCreate));\n    }\n    if (pathsToDelete !\u003d null) {\n      for (Path meta : pathsToDelete) {\n        newItems.add(PathMetadata.tombstone(meta));\n      }\n    }\n\n    try {\n      processBatchWriteRequest(null, pathMetadataToItem(newItems));\n    } catch (AmazonClientException e) {\n      throw translateException(\"move\", (String) null, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}