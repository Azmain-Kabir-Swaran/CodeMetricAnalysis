{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "createInternal",
  "functionId": "createInternal___f-Path__permission-FsPermission__overwrite-boolean__parentFolderLease-SelfRenewingLease",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 1830,
  "functionEndLine": 1925,
  "numCommitsSeen": 66,
  "timeTaken": 1692,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "9288206cb3c1a39044a8e106436987185ef43ddf"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "9288206cb3c1a39044a8e106436987185ef43ddf": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n   protected FSDataOutputStream createInternal(Path f, FsPermission permission,\n                                     boolean overwrite,\n                                     SelfRenewingLease parentFolderLease)\n       throws FileAlreadyExistsException, IOException {\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n-      if (existingMetadata.isDir()) {\n+      if (existingMetadata.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n       else {\n         performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n-      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n+      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDirectory() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n-        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n+        mkdirs(parentFolder, metadata.getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus, key);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus, key), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n \n     // Increment the counter\n     instrumentation.fileCreated();\n \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected FSDataOutputStream createInternal(Path f, FsPermission permission,\n                                    boolean overwrite,\n                                    SelfRenewingLease parentFolderLease)\n      throws FileAlreadyExistsException, IOException {\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n      else {\n        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDirectory() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus, key);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus, key), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n\n    // Increment the counter\n    instrumentation.fileCreated();\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "9288206cb3c1a39044a8e106436987185ef43ddf": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14845. Azure wasb: getFileStatus not making any auth check.\nContributed by Sivaguru Sankaridurg\n",
      "commitDate": "05/10/17 7:05 AM",
      "commitName": "9288206cb3c1a39044a8e106436987185ef43ddf",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,96 @@\n+  protected FSDataOutputStream createInternal(Path f, FsPermission permission,\n+                                    boolean overwrite,\n+                                    SelfRenewingLease parentFolderLease)\n+      throws FileAlreadyExistsException, IOException {\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    String key \u003d pathToKey(absolutePath);\n+\n+    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n+    if (existingMetadata !\u003d null) {\n+      if (existingMetadata.isDir()) {\n+        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n+            + \"; already exists as a directory.\");\n+      }\n+      if (!overwrite) {\n+        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n+      }\n+      else {\n+        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n+      }\n+    }\n+\n+    Path parentFolder \u003d absolutePath.getParent();\n+    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n+      // Update the parent folder last modified time if the parent folder\n+      // already exists.\n+      String parentKey \u003d pathToKey(parentFolder);\n+      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n+        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+        if (parentFolderLease !\u003d null) {\n+          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n+        } else {\n+          updateParentFolderLastModifiedTime(key);\n+        }\n+      } else {\n+        // Make sure that the parent folder exists.\n+        // Create it using inherited permissions from the first existing directory going up the path\n+        Path firstExisting \u003d parentFolder.getParent();\n+        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n+        while(metadata \u003d\u003d null) {\n+          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n+          firstExisting \u003d firstExisting.getParent();\n+          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n+        }\n+        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n+      }\n+    }\n+\n+    // Mask the permission first (with the default permission mask as well).\n+    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n+    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n+\n+    OutputStream bufOutStream;\n+    if (store.isPageBlobKey(key)) {\n+      // Store page blobs directly in-place without renames.\n+      bufOutStream \u003d store.storefile(key, permissionStatus, key);\n+    } else {\n+      // This is a block blob, so open the output blob stream based on the\n+      // encoded key.\n+      //\n+      String keyEncoded \u003d encodeKey(key);\n+\n+\n+      // First create a blob at the real key, pointing back to the temporary file\n+      // This accomplishes a few things:\n+      // 1. Makes sure we can create a file there.\n+      // 2. Makes it visible to other concurrent threads/processes/nodes what\n+      // we\u0027re\n+      // doing.\n+      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n+      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n+\n+      // The key is encoded to point to a common container at the storage server.\n+      // This reduces the number of splits on the server side when load balancing.\n+      // Ingress to Azure storage can take advantage of earlier splits. We remove\n+      // the root path to the key and prefix a random GUID to the tail (or leaf\n+      // filename) of the key. Keys are thus broadly and randomly distributed over\n+      // a single container to ease load balancing on the storage server. When the\n+      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n+      // are not cleaned up and we leave it to Azure storage to garbage collect\n+      // these\n+      // blocks.\n+      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n+          keyEncoded, permissionStatus, key), key, keyEncoded);\n+    }\n+    // Construct the data output stream from the buffered output stream.\n+    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n+\n+\n+    // Increment the counter\n+    instrumentation.fileCreated();\n+\n+    // Return data output stream to caller.\n+    return fsOut;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected FSDataOutputStream createInternal(Path f, FsPermission permission,\n                                    boolean overwrite,\n                                    SelfRenewingLease parentFolderLease)\n      throws FileAlreadyExistsException, IOException {\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n      else {\n        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus, key);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus, key), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n\n    // Increment the counter\n    instrumentation.fileCreated();\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}