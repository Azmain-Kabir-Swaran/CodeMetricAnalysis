{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeRpcServer.java",
  "functionName": "getEventBatchList",
  "functionId": "getEventBatchList___syncTxid-long__txid-long__log-FSEditLog__readInProgress-boolean__maxEventsPerRPC-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
  "functionStartLine": 2398,
  "functionEndLine": 2465,
  "numCommitsSeen": 296,
  "timeTaken": 2279,
  "changeHistory": [
    "c75105f07b4cdbc2773435fc1125446233113c15"
  ],
  "changeHistoryShort": {
    "c75105f07b4cdbc2773435fc1125446233113c15": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c75105f07b4cdbc2773435fc1125446233113c15": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13040. Kerberized inotify client fails despite kinit properly. Contributed by Istvan Fajth, Wei-Chiu Chuang, Xiao Chen.\n",
      "commitDate": "02/03/18 4:46 PM",
      "commitName": "c75105f07b4cdbc2773435fc1125446233113c15",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,68 @@\n+  private EventBatchList getEventBatchList(long syncTxid, long txid,\n+      FSEditLog log, boolean readInProgress, int maxEventsPerRPC)\n+      throws IOException {\n+    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n+    int totalEvents \u003d 0;\n+    long maxSeenTxid \u003d -1;\n+    long firstSeenTxid \u003d -1;\n+\n+    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n+      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n+      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n+    }\n+\n+    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n+    try {\n+      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n+    } catch (IllegalStateException e) { // can happen if we have\n+      // transitioned out of active and haven\u0027t yet transitioned to standby\n+      // and are using QJM -- the edit log will be closed and this exception\n+      // will result\n+      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n+          \"is closed -- could not read edits\");\n+      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n+    }\n+\n+    boolean breakOuter \u003d false;\n+    for (EditLogInputStream elis : streams) {\n+      // our assumption in this code is the EditLogInputStreams are ordered by\n+      // starting txid\n+      try {\n+        FSEditLogOp op \u003d null;\n+        while ((op \u003d readOp(elis)) !\u003d null) {\n+          // break out of here in the unlikely event that syncTxid is so\n+          // out of date that its segment has already been deleted, so the first\n+          // txid we get is greater than syncTxid\n+          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n+            breakOuter \u003d true;\n+            break;\n+          }\n+\n+          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n+          if (eventBatch !\u003d null) {\n+            batches.add(eventBatch);\n+            totalEvents +\u003d eventBatch.getEvents().length;\n+          }\n+          if (op.getTransactionId() \u003e maxSeenTxid) {\n+            maxSeenTxid \u003d op.getTransactionId();\n+          }\n+          if (firstSeenTxid \u003d\u003d -1) {\n+            firstSeenTxid \u003d op.getTransactionId();\n+          }\n+          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n+              op.getTransactionId() \u003d\u003d syncTxid)) {\n+            // we\u0027re done\n+            breakOuter \u003d true;\n+            break;\n+          }\n+        }\n+      } finally {\n+        elis.close();\n+      }\n+      if (breakOuter) {\n+        break;\n+      }\n+    }\n+\n+    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private EventBatchList getEventBatchList(long syncTxid, long txid,\n      FSEditLog log, boolean readInProgress, int maxEventsPerRPC)\n      throws IOException {\n    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n    int totalEvents \u003d 0;\n    long maxSeenTxid \u003d -1;\n    long firstSeenTxid \u003d -1;\n\n    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n    try {\n      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n    } catch (IllegalStateException e) { // can happen if we have\n      // transitioned out of active and haven\u0027t yet transitioned to standby\n      // and are using QJM -- the edit log will be closed and this exception\n      // will result\n      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n          \"is closed -- could not read edits\");\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    boolean breakOuter \u003d false;\n    for (EditLogInputStream elis : streams) {\n      // our assumption in this code is the EditLogInputStreams are ordered by\n      // starting txid\n      try {\n        FSEditLogOp op \u003d null;\n        while ((op \u003d readOp(elis)) !\u003d null) {\n          // break out of here in the unlikely event that syncTxid is so\n          // out of date that its segment has already been deleted, so the first\n          // txid we get is greater than syncTxid\n          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n            breakOuter \u003d true;\n            break;\n          }\n\n          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n          if (eventBatch !\u003d null) {\n            batches.add(eventBatch);\n            totalEvents +\u003d eventBatch.getEvents().length;\n          }\n          if (op.getTransactionId() \u003e maxSeenTxid) {\n            maxSeenTxid \u003d op.getTransactionId();\n          }\n          if (firstSeenTxid \u003d\u003d -1) {\n            firstSeenTxid \u003d op.getTransactionId();\n          }\n          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n              op.getTransactionId() \u003d\u003d syncTxid)) {\n            // we\u0027re done\n            breakOuter \u003d true;\n            break;\n          }\n        }\n      } finally {\n        elis.close();\n      }\n      if (breakOuter) {\n        break;\n      }\n    }\n\n    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java"
    }
  }
}