{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NetworkTopology.java",
  "functionName": "chooseRandom",
  "functionId": "chooseRandom___parentNode-InnerNode(modifiers-final)__excludedScopeNode-Node(modifiers-final)__excludedNodes-Collection__Node__(modifiers-final)__totalInScopeNodes-int(modifiers-final)__availableNodes-int(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
  "functionStartLine": 558,
  "functionEndLine": 625,
  "numCommitsSeen": 49,
  "timeTaken": 1660,
  "changeHistory": [
    "aa9f0850e85203b2ce4f4a8dc8968e9186cdc67a",
    "57374c4737ab0fccf52dae3cea911fc6bd90e1b7"
  ],
  "changeHistoryShort": {
    "aa9f0850e85203b2ce4f4a8dc8968e9186cdc67a": "Ybodychange",
    "57374c4737ab0fccf52dae3cea911fc6bd90e1b7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "aa9f0850e85203b2ce4f4a8dc8968e9186cdc67a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16385. Namenode crashes with \u0027RedundancyMonitor thread received Runtime exception\u0027. Contributed by Ayush Saxena.\n",
      "commitDate": "02/07/19 1:22 PM",
      "commitName": "aa9f0850e85203b2ce4f4a8dc8968e9186cdc67a",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "13/05/19 11:46 AM",
      "commitNameOld": "389e640f0cc7d8528e9b4411457f04a528601c69",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 50.07,
      "commitsBetweenForRepo": 407,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n   private Node chooseRandom(final InnerNode parentNode,\n       final Node excludedScopeNode, final Collection\u003cNode\u003e excludedNodes,\n       final int totalInScopeNodes, final int availableNodes) {\n-    Preconditions.checkArgument(\n-        totalInScopeNodes \u003e\u003d availableNodes \u0026\u0026 availableNodes \u003e 0, String\n-            .format(\"%d should \u003e\u003d %d, and both should be positive.\",\n-                totalInScopeNodes, availableNodes));\n+    if (totalInScopeNodes \u003c availableNodes) {\n+      LOG.warn(\"Total Nodes in scope : {} are less than Available Nodes : {}\",\n+          totalInScopeNodes, availableNodes);\n+      return null;\n+    }\n     if (excludedNodes \u003d\u003d null || excludedNodes.isEmpty()) {\n       // if there are no excludedNodes, randomly choose a node\n       final int index \u003d r.nextInt(totalInScopeNodes);\n       return parentNode.getLeaf(index, excludedScopeNode);\n     }\n \n     // excludedNodes non empty.\n     // Choose the nth VALID node, where n is random. VALID meaning it can be\n     // returned, after considering exclude scope and exclude nodes.\n     // The probability of being chosen should be equal for all VALID nodes.\n     // Notably, we do NOT choose nth node, and find the next valid node\n     // if n is excluded - this will make the probability of the node immediately\n     // after an excluded node higher.\n     //\n     // Start point is always 0 and that\u0027s fine, because the nth valid node\n     // logic provides equal randomness.\n     //\n     // Consider this example, where 1,3,5 out of the 10 nodes are excluded:\n     // 1 2 3 4 5 6 7 8 9 10\n     // x   x   x\n     // We will randomly choose the nth valid node where n is [0,6].\n     // We do NOT choose a random number n and just use the closest valid node,\n     // for example both n\u003d3 and n\u003d4 will choose 4, making it a 2/10 probability,\n     // higher than the expected 1/7\n     // totalInScopeNodes\u003d10 and availableNodes\u003d7 in this example.\n     int nthValidToReturn \u003d r.nextInt(availableNodes);\n     LOG.debug(\"nthValidToReturn is {}\", nthValidToReturn);\n     Node ret \u003d\n         parentNode.getLeaf(r.nextInt(totalInScopeNodes), excludedScopeNode);\n     if (!excludedNodes.contains(ret)) {\n       // return if we\u0027re lucky enough to get a valid node at a random first pick\n       LOG.debug(\"Chosen node {} from first random\", ret);\n       return ret;\n     } else {\n       ret \u003d null;\n     }\n     Node lastValidNode \u003d null;\n     for (int i \u003d 0; i \u003c totalInScopeNodes; ++i) {\n       ret \u003d parentNode.getLeaf(i, excludedScopeNode);\n       if (!excludedNodes.contains(ret)) {\n         if (nthValidToReturn \u003d\u003d 0) {\n           break;\n         }\n         --nthValidToReturn;\n         lastValidNode \u003d ret;\n       } else {\n         LOG.debug(\"Node {} is excluded, continuing.\", ret);\n         ret \u003d null;\n       }\n     }\n     if (ret \u003d\u003d null \u0026\u0026 lastValidNode !\u003d null) {\n       LOG.error(\"BUG: Found lastValidNode {} but not nth valid node. \"\n               + \"parentNode\u003d{}, excludedScopeNode\u003d{}, excludedNodes\u003d{}, \"\n               + \"totalInScopeNodes\u003d{}, availableNodes\u003d{}, nthValidToReturn\u003d{}.\",\n           lastValidNode, parentNode, excludedScopeNode, excludedNodes,\n           totalInScopeNodes, availableNodes, nthValidToReturn);\n       ret \u003d lastValidNode;\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(final InnerNode parentNode,\n      final Node excludedScopeNode, final Collection\u003cNode\u003e excludedNodes,\n      final int totalInScopeNodes, final int availableNodes) {\n    if (totalInScopeNodes \u003c availableNodes) {\n      LOG.warn(\"Total Nodes in scope : {} are less than Available Nodes : {}\",\n          totalInScopeNodes, availableNodes);\n      return null;\n    }\n    if (excludedNodes \u003d\u003d null || excludedNodes.isEmpty()) {\n      // if there are no excludedNodes, randomly choose a node\n      final int index \u003d r.nextInt(totalInScopeNodes);\n      return parentNode.getLeaf(index, excludedScopeNode);\n    }\n\n    // excludedNodes non empty.\n    // Choose the nth VALID node, where n is random. VALID meaning it can be\n    // returned, after considering exclude scope and exclude nodes.\n    // The probability of being chosen should be equal for all VALID nodes.\n    // Notably, we do NOT choose nth node, and find the next valid node\n    // if n is excluded - this will make the probability of the node immediately\n    // after an excluded node higher.\n    //\n    // Start point is always 0 and that\u0027s fine, because the nth valid node\n    // logic provides equal randomness.\n    //\n    // Consider this example, where 1,3,5 out of the 10 nodes are excluded:\n    // 1 2 3 4 5 6 7 8 9 10\n    // x   x   x\n    // We will randomly choose the nth valid node where n is [0,6].\n    // We do NOT choose a random number n and just use the closest valid node,\n    // for example both n\u003d3 and n\u003d4 will choose 4, making it a 2/10 probability,\n    // higher than the expected 1/7\n    // totalInScopeNodes\u003d10 and availableNodes\u003d7 in this example.\n    int nthValidToReturn \u003d r.nextInt(availableNodes);\n    LOG.debug(\"nthValidToReturn is {}\", nthValidToReturn);\n    Node ret \u003d\n        parentNode.getLeaf(r.nextInt(totalInScopeNodes), excludedScopeNode);\n    if (!excludedNodes.contains(ret)) {\n      // return if we\u0027re lucky enough to get a valid node at a random first pick\n      LOG.debug(\"Chosen node {} from first random\", ret);\n      return ret;\n    } else {\n      ret \u003d null;\n    }\n    Node lastValidNode \u003d null;\n    for (int i \u003d 0; i \u003c totalInScopeNodes; ++i) {\n      ret \u003d parentNode.getLeaf(i, excludedScopeNode);\n      if (!excludedNodes.contains(ret)) {\n        if (nthValidToReturn \u003d\u003d 0) {\n          break;\n        }\n        --nthValidToReturn;\n        lastValidNode \u003d ret;\n      } else {\n        LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        ret \u003d null;\n      }\n    }\n    if (ret \u003d\u003d null \u0026\u0026 lastValidNode !\u003d null) {\n      LOG.error(\"BUG: Found lastValidNode {} but not nth valid node. \"\n              + \"parentNode\u003d{}, excludedScopeNode\u003d{}, excludedNodes\u003d{}, \"\n              + \"totalInScopeNodes\u003d{}, availableNodes\u003d{}, nthValidToReturn\u003d{}.\",\n          lastValidNode, parentNode, excludedScopeNode, excludedNodes,\n          totalInScopeNodes, availableNodes, nthValidToReturn);\n      ret \u003d lastValidNode;\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "57374c4737ab0fccf52dae3cea911fc6bd90e1b7": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15317. Improve NetworkTopology chooseRandom\u0027s loop.\n",
      "commitDate": "02/04/18 10:48 PM",
      "commitName": "57374c4737ab0fccf52dae3cea911fc6bd90e1b7",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,67 @@\n+  private Node chooseRandom(final InnerNode parentNode,\n+      final Node excludedScopeNode, final Collection\u003cNode\u003e excludedNodes,\n+      final int totalInScopeNodes, final int availableNodes) {\n+    Preconditions.checkArgument(\n+        totalInScopeNodes \u003e\u003d availableNodes \u0026\u0026 availableNodes \u003e 0, String\n+            .format(\"%d should \u003e\u003d %d, and both should be positive.\",\n+                totalInScopeNodes, availableNodes));\n+    if (excludedNodes \u003d\u003d null || excludedNodes.isEmpty()) {\n+      // if there are no excludedNodes, randomly choose a node\n+      final int index \u003d r.nextInt(totalInScopeNodes);\n+      return parentNode.getLeaf(index, excludedScopeNode);\n+    }\n+\n+    // excludedNodes non empty.\n+    // Choose the nth VALID node, where n is random. VALID meaning it can be\n+    // returned, after considering exclude scope and exclude nodes.\n+    // The probability of being chosen should be equal for all VALID nodes.\n+    // Notably, we do NOT choose nth node, and find the next valid node\n+    // if n is excluded - this will make the probability of the node immediately\n+    // after an excluded node higher.\n+    //\n+    // Start point is always 0 and that\u0027s fine, because the nth valid node\n+    // logic provides equal randomness.\n+    //\n+    // Consider this example, where 1,3,5 out of the 10 nodes are excluded:\n+    // 1 2 3 4 5 6 7 8 9 10\n+    // x   x   x\n+    // We will randomly choose the nth valid node where n is [0,6].\n+    // We do NOT choose a random number n and just use the closest valid node,\n+    // for example both n\u003d3 and n\u003d4 will choose 4, making it a 2/10 probability,\n+    // higher than the expected 1/7\n+    // totalInScopeNodes\u003d10 and availableNodes\u003d7 in this example.\n+    int nthValidToReturn \u003d r.nextInt(availableNodes);\n+    LOG.debug(\"nthValidToReturn is {}\", nthValidToReturn);\n+    Node ret \u003d\n+        parentNode.getLeaf(r.nextInt(totalInScopeNodes), excludedScopeNode);\n+    if (!excludedNodes.contains(ret)) {\n+      // return if we\u0027re lucky enough to get a valid node at a random first pick\n+      LOG.debug(\"Chosen node {} from first random\", ret);\n+      return ret;\n+    } else {\n+      ret \u003d null;\n+    }\n+    Node lastValidNode \u003d null;\n+    for (int i \u003d 0; i \u003c totalInScopeNodes; ++i) {\n+      ret \u003d parentNode.getLeaf(i, excludedScopeNode);\n+      if (!excludedNodes.contains(ret)) {\n+        if (nthValidToReturn \u003d\u003d 0) {\n+          break;\n+        }\n+        --nthValidToReturn;\n+        lastValidNode \u003d ret;\n+      } else {\n+        LOG.debug(\"Node {} is excluded, continuing.\", ret);\n+        ret \u003d null;\n+      }\n+    }\n+    if (ret \u003d\u003d null \u0026\u0026 lastValidNode !\u003d null) {\n+      LOG.error(\"BUG: Found lastValidNode {} but not nth valid node. \"\n+              + \"parentNode\u003d{}, excludedScopeNode\u003d{}, excludedNodes\u003d{}, \"\n+              + \"totalInScopeNodes\u003d{}, availableNodes\u003d{}, nthValidToReturn\u003d{}.\",\n+          lastValidNode, parentNode, excludedScopeNode, excludedNodes,\n+          totalInScopeNodes, availableNodes, nthValidToReturn);\n+      ret \u003d lastValidNode;\n+    }\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(final InnerNode parentNode,\n      final Node excludedScopeNode, final Collection\u003cNode\u003e excludedNodes,\n      final int totalInScopeNodes, final int availableNodes) {\n    Preconditions.checkArgument(\n        totalInScopeNodes \u003e\u003d availableNodes \u0026\u0026 availableNodes \u003e 0, String\n            .format(\"%d should \u003e\u003d %d, and both should be positive.\",\n                totalInScopeNodes, availableNodes));\n    if (excludedNodes \u003d\u003d null || excludedNodes.isEmpty()) {\n      // if there are no excludedNodes, randomly choose a node\n      final int index \u003d r.nextInt(totalInScopeNodes);\n      return parentNode.getLeaf(index, excludedScopeNode);\n    }\n\n    // excludedNodes non empty.\n    // Choose the nth VALID node, where n is random. VALID meaning it can be\n    // returned, after considering exclude scope and exclude nodes.\n    // The probability of being chosen should be equal for all VALID nodes.\n    // Notably, we do NOT choose nth node, and find the next valid node\n    // if n is excluded - this will make the probability of the node immediately\n    // after an excluded node higher.\n    //\n    // Start point is always 0 and that\u0027s fine, because the nth valid node\n    // logic provides equal randomness.\n    //\n    // Consider this example, where 1,3,5 out of the 10 nodes are excluded:\n    // 1 2 3 4 5 6 7 8 9 10\n    // x   x   x\n    // We will randomly choose the nth valid node where n is [0,6].\n    // We do NOT choose a random number n and just use the closest valid node,\n    // for example both n\u003d3 and n\u003d4 will choose 4, making it a 2/10 probability,\n    // higher than the expected 1/7\n    // totalInScopeNodes\u003d10 and availableNodes\u003d7 in this example.\n    int nthValidToReturn \u003d r.nextInt(availableNodes);\n    LOG.debug(\"nthValidToReturn is {}\", nthValidToReturn);\n    Node ret \u003d\n        parentNode.getLeaf(r.nextInt(totalInScopeNodes), excludedScopeNode);\n    if (!excludedNodes.contains(ret)) {\n      // return if we\u0027re lucky enough to get a valid node at a random first pick\n      LOG.debug(\"Chosen node {} from first random\", ret);\n      return ret;\n    } else {\n      ret \u003d null;\n    }\n    Node lastValidNode \u003d null;\n    for (int i \u003d 0; i \u003c totalInScopeNodes; ++i) {\n      ret \u003d parentNode.getLeaf(i, excludedScopeNode);\n      if (!excludedNodes.contains(ret)) {\n        if (nthValidToReturn \u003d\u003d 0) {\n          break;\n        }\n        --nthValidToReturn;\n        lastValidNode \u003d ret;\n      } else {\n        LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        ret \u003d null;\n      }\n    }\n    if (ret \u003d\u003d null \u0026\u0026 lastValidNode !\u003d null) {\n      LOG.error(\"BUG: Found lastValidNode {} but not nth valid node. \"\n              + \"parentNode\u003d{}, excludedScopeNode\u003d{}, excludedNodes\u003d{}, \"\n              + \"totalInScopeNodes\u003d{}, availableNodes\u003d{}, nthValidToReturn\u003d{}.\",\n          lastValidNode, parentNode, excludedScopeNode, excludedNodes,\n          totalInScopeNodes, availableNodes, nthValidToReturn);\n      ret \u003d lastValidNode;\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java"
    }
  }
}