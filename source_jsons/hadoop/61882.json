{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineEntityV2Converter.java",
  "functionName": "convertToApplicationReport",
  "functionId": "convertToApplicationReport___entity-TimelineEntity",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java",
  "functionStartLine": 253,
  "functionEndLine": 461,
  "numCommitsSeen": 4,
  "timeTaken": 1250,
  "changeHistory": [
    "7fa62e150ce86f7cb0e88d593b8f07e3384a9a60",
    "ee3355be3cd1cd956296a1b79b264177ff139ce6"
  ],
  "changeHistoryShort": {
    "7fa62e150ce86f7cb0e88d593b8f07e3384a9a60": "Ybodychange",
    "ee3355be3cd1cd956296a1b79b264177ff139ce6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7fa62e150ce86f7cb0e88d593b8f07e3384a9a60": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8219. Add application launch time to ATSV2. Contributed by Abhishek Modi.\n",
      "commitDate": "06/02/19 8:28 PM",
      "commitName": "7fa62e150ce86f7cb0e88d593b8f07e3384a9a60",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "04/02/19 11:09 PM",
      "commitNameOld": "571838920d2faca703e3c3417d64123927dfc4ad",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 1.89,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,204 +1,209 @@\n   public static ApplicationReport convertToApplicationReport(\n       TimelineEntity entity) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n+    long launchTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(\n           ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(\n           ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(\n           ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(\n           ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(\n           ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(\n               ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003c\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n       if (entityInfo\n           .containsKey(\n               ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n         latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n             entityInfo.get(\n                 ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                 .toString());\n       }\n       if (entityInfo.containsKey(\n           ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n         diagnosticsInfo \u003d\n             entityInfo.get(\n                 ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n         finalStatus \u003d\n             FinalApplicationStatus.valueOf(entityInfo.get(\n                 ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n         state \u003d\n             YarnApplicationState.valueOf(entityInfo.get(\n                 ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n       }\n     }\n \n     Map\u003cString, String\u003e configs \u003d entity.getConfigs();\n     if (configs\n         .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n       appNodeLabelExpression \u003d configs\n           .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION);\n     }\n     if (configs\n         .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n       amNodeLabelExpression \u003d\n           configs.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION);\n     }\n \n     Set\u003cTimelineMetric\u003e metrics \u003d entity.getMetrics();\n     if (metrics !\u003d null) {\n       long vcoreSeconds \u003d 0;\n       long memorySeconds \u003d 0;\n       long preemptedVcoreSeconds \u003d 0;\n       long preemptedMemorySeconds \u003d 0;\n \n       for (TimelineMetric metric : metrics) {\n         switch (metric.getId()) {\n         case ApplicationMetricsConstants.APP_CPU_METRICS:\n           vcoreSeconds \u003d getAverageValue(metric.getValues().values());\n           break;\n         case ApplicationMetricsConstants.APP_MEM_METRICS:\n           memorySeconds \u003d getAverageValue(metric.getValues().values());\n           break;\n         case ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS:\n           preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n           break;\n         case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS:\n           preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n           break;\n         default:\n           // Should not happen..\n           break;\n         }\n       }\n       Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n       Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n       resourceSecondsMap\n           .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n       resourceSecondsMap\n           .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n       preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n           preemptedMemorySeconds);\n       preemptedResoureSecondsMap\n           .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n \n       appResources \u003d ApplicationResourceUsageReport\n           .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n               preemptedResoureSecondsMap);\n     }\n \n     NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getId().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getId().equals(\n+            ApplicationMetricsConstants.LAUNCHED_EVENT_TYPE)) {\n+          launchTime \u003d event.getTimestamp();\n+        } else if (event.getId().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           }\n         } else if (event.getId().equals(\n             ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (state \u003d\u003d YarnApplicationState.ACCEPTED) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getId().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           state \u003d YarnApplicationState.FINISHED;\n           finishedTime \u003d event.getTimestamp();\n         }\n       }\n     }\n     return ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n-        appResources, null, progress, type, null, appTags, unmanagedApplication,\n+        diagnosticsInfo, null, createdTime, launchTime,\n+        finishedTime, finalStatus, appResources, null,\n+        progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static ApplicationReport convertToApplicationReport(\n      TimelineEntity entity) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long launchTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(\n              ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003c\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n      if (entityInfo\n          .containsKey(\n              ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n        latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n            entityInfo.get(\n                ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                .toString());\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n        diagnosticsInfo \u003d\n            entityInfo.get(\n                ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n        finalStatus \u003d\n            FinalApplicationStatus.valueOf(entityInfo.get(\n                ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n        state \u003d\n            YarnApplicationState.valueOf(entityInfo.get(\n                ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n      }\n    }\n\n    Map\u003cString, String\u003e configs \u003d entity.getConfigs();\n    if (configs\n        .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n      appNodeLabelExpression \u003d configs\n          .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION);\n    }\n    if (configs\n        .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n      amNodeLabelExpression \u003d\n          configs.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION);\n    }\n\n    Set\u003cTimelineMetric\u003e metrics \u003d entity.getMetrics();\n    if (metrics !\u003d null) {\n      long vcoreSeconds \u003d 0;\n      long memorySeconds \u003d 0;\n      long preemptedVcoreSeconds \u003d 0;\n      long preemptedMemorySeconds \u003d 0;\n\n      for (TimelineMetric metric : metrics) {\n        switch (metric.getId()) {\n        case ApplicationMetricsConstants.APP_CPU_METRICS:\n          vcoreSeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        case ApplicationMetricsConstants.APP_MEM_METRICS:\n          memorySeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        case ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS:\n          preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS:\n          preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        default:\n          // Should not happen..\n          break;\n        }\n      }\n      Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n      Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n      resourceSecondsMap\n          .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n      resourceSecondsMap\n          .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n      preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n          preemptedMemorySeconds);\n      preemptedResoureSecondsMap\n          .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n\n      appResources \u003d ApplicationResourceUsageReport\n          .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n              preemptedResoureSecondsMap);\n    }\n\n    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getId().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.LAUNCHED_EVENT_TYPE)) {\n          launchTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          }\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (state \u003d\u003d YarnApplicationState.ACCEPTED) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          state \u003d YarnApplicationState.FINISHED;\n          finishedTime \u003d event.getTimestamp();\n        }\n      }\n    }\n    return ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, launchTime,\n        finishedTime, finalStatus, appResources, null,\n        progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java",
      "extendedDetails": {}
    },
    "ee3355be3cd1cd956296a1b79b264177ff139ce6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8303. YarnClient should contact TimelineReader for application/attempt/container report.\n",
      "commitDate": "16/11/18 4:28 AM",
      "commitName": "ee3355be3cd1cd956296a1b79b264177ff139ce6",
      "commitAuthor": "Rohith Sharma K S",
      "diff": "@@ -0,0 +1,204 @@\n+  public static ApplicationReport convertToApplicationReport(\n+      TimelineEntity entity) {\n+    String user \u003d null;\n+    String queue \u003d null;\n+    String name \u003d null;\n+    String type \u003d null;\n+    boolean unmanagedApplication \u003d false;\n+    long createdTime \u003d 0;\n+    long finishedTime \u003d 0;\n+    float progress \u003d 0.0f;\n+    int applicationPriority \u003d 0;\n+    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n+    String diagnosticsInfo \u003d null;\n+    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n+    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n+    ApplicationResourceUsageReport appResources \u003d null;\n+    Set\u003cString\u003e appTags \u003d null;\n+    String appNodeLabelExpression \u003d null;\n+    String amNodeLabelExpression \u003d null;\n+    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n+    if (entityInfo !\u003d null) {\n+      if (entityInfo.containsKey(\n+          ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n+        user \u003d\n+            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(\n+          ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n+        queue \u003d\n+            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(\n+          ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n+        name \u003d\n+            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(\n+          ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n+        type \u003d\n+            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(\n+          ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n+        type \u003d\n+            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo\n+          .containsKey(\n+              ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n+        unmanagedApplication \u003d\n+            Boolean.parseBoolean(entityInfo.get(\n+                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n+                .toString());\n+      }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n+        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n+            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n+      }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n+        appTags \u003d new HashSet\u003c\u003e();\n+        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n+        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n+          for(Object o : (Collection\u003c?\u003e)obj) {\n+            if (o !\u003d null) {\n+              appTags.add(o.toString());\n+            }\n+          }\n+        }\n+      }\n+      if (entityInfo\n+          .containsKey(\n+              ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n+        latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n+            entityInfo.get(\n+                ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n+                .toString());\n+      }\n+      if (entityInfo.containsKey(\n+          ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n+        diagnosticsInfo \u003d\n+            entityInfo.get(\n+                ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n+                .toString();\n+      }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n+        finalStatus \u003d\n+            FinalApplicationStatus.valueOf(entityInfo.get(\n+                ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n+                .toString());\n+      }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n+        state \u003d\n+            YarnApplicationState.valueOf(entityInfo.get(\n+                ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n+      }\n+    }\n+\n+    Map\u003cString, String\u003e configs \u003d entity.getConfigs();\n+    if (configs\n+        .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n+      appNodeLabelExpression \u003d configs\n+          .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION);\n+    }\n+    if (configs\n+        .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n+      amNodeLabelExpression \u003d\n+          configs.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION);\n+    }\n+\n+    Set\u003cTimelineMetric\u003e metrics \u003d entity.getMetrics();\n+    if (metrics !\u003d null) {\n+      long vcoreSeconds \u003d 0;\n+      long memorySeconds \u003d 0;\n+      long preemptedVcoreSeconds \u003d 0;\n+      long preemptedMemorySeconds \u003d 0;\n+\n+      for (TimelineMetric metric : metrics) {\n+        switch (metric.getId()) {\n+        case ApplicationMetricsConstants.APP_CPU_METRICS:\n+          vcoreSeconds \u003d getAverageValue(metric.getValues().values());\n+          break;\n+        case ApplicationMetricsConstants.APP_MEM_METRICS:\n+          memorySeconds \u003d getAverageValue(metric.getValues().values());\n+          break;\n+        case ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS:\n+          preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n+          break;\n+        case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS:\n+          preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n+          break;\n+        default:\n+          // Should not happen..\n+          break;\n+        }\n+      }\n+      Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n+      Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n+      resourceSecondsMap\n+          .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n+      resourceSecondsMap\n+          .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n+      preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n+          preemptedMemorySeconds);\n+      preemptedResoureSecondsMap\n+          .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n+\n+      appResources \u003d ApplicationResourceUsageReport\n+          .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n+              preemptedResoureSecondsMap);\n+    }\n+\n+    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+    long updatedTimeStamp \u003d 0L;\n+    if (events !\u003d null) {\n+      for (TimelineEvent event : events) {\n+        if (event.getId().equals(\n+            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n+          createdTime \u003d event.getTimestamp();\n+        } else if (event.getId().equals(\n+            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n+          // This type of events are parsed in time-stamp descending order\n+          // which means the previous event could override the information\n+          // from the later same type of event. Hence compare timestamp\n+          // before over writing.\n+          if (event.getTimestamp() \u003e updatedTimeStamp) {\n+            updatedTimeStamp \u003d event.getTimestamp();\n+          }\n+        } else if (event.getId().equals(\n+            ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n+          Map\u003cString, Object\u003e eventInfo \u003d event.getInfo();\n+          if (eventInfo \u003d\u003d null) {\n+            continue;\n+          }\n+          if (eventInfo.containsKey(\n+              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n+            if (state \u003d\u003d YarnApplicationState.ACCEPTED) {\n+              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n+                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n+            }\n+          }\n+        } else if (event.getId().equals(\n+            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n+          progress\u003d1.0F;\n+          state \u003d YarnApplicationState.FINISHED;\n+          finishedTime \u003d event.getTimestamp();\n+        }\n+      }\n+    }\n+    return ApplicationReport.newInstance(\n+        ApplicationId.fromString(entity.getId()),\n+        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n+        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n+        appResources, null, progress, type, null, appTags, unmanagedApplication,\n+        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n+        amNodeLabelExpression);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static ApplicationReport convertToApplicationReport(\n      TimelineEntity entity) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(\n              ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003c\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n      if (entityInfo\n          .containsKey(\n              ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n        latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n            entityInfo.get(\n                ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                .toString());\n      }\n      if (entityInfo.containsKey(\n          ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n        diagnosticsInfo \u003d\n            entityInfo.get(\n                ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n        finalStatus \u003d\n            FinalApplicationStatus.valueOf(entityInfo.get(\n                ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n        state \u003d\n            YarnApplicationState.valueOf(entityInfo.get(\n                ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n      }\n    }\n\n    Map\u003cString, String\u003e configs \u003d entity.getConfigs();\n    if (configs\n        .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n      appNodeLabelExpression \u003d configs\n          .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION);\n    }\n    if (configs\n        .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n      amNodeLabelExpression \u003d\n          configs.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION);\n    }\n\n    Set\u003cTimelineMetric\u003e metrics \u003d entity.getMetrics();\n    if (metrics !\u003d null) {\n      long vcoreSeconds \u003d 0;\n      long memorySeconds \u003d 0;\n      long preemptedVcoreSeconds \u003d 0;\n      long preemptedMemorySeconds \u003d 0;\n\n      for (TimelineMetric metric : metrics) {\n        switch (metric.getId()) {\n        case ApplicationMetricsConstants.APP_CPU_METRICS:\n          vcoreSeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        case ApplicationMetricsConstants.APP_MEM_METRICS:\n          memorySeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        case ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS:\n          preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS:\n          preemptedVcoreSeconds \u003d getAverageValue(metric.getValues().values());\n          break;\n        default:\n          // Should not happen..\n          break;\n        }\n      }\n      Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n      Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n      resourceSecondsMap\n          .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n      resourceSecondsMap\n          .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n      preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n          preemptedMemorySeconds);\n      preemptedResoureSecondsMap\n          .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n\n      appResources \u003d ApplicationResourceUsageReport\n          .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n              preemptedResoureSecondsMap);\n    }\n\n    NavigableSet\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getId().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          }\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (state \u003d\u003d YarnApplicationState.ACCEPTED) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getId().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          state \u003d YarnApplicationState.FINISHED;\n          finishedTime \u003d event.getTimestamp();\n        }\n      }\n    }\n    return ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/timeline/TimelineEntityV2Converter.java"
    }
  }
}