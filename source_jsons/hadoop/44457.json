{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMaster.java",
  "functionName": "onContainersAllocated",
  "functionId": "onContainersAllocated___allocatedContainers-List__Container__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
  "functionStartLine": 1170,
  "functionEndLine": 1216,
  "numCommitsSeen": 113,
  "timeTaken": 3726,
  "changeHistory": [
    "4e1382aca4cf23ca229bdd24e0f143c22449b329",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "2b2bd9214604bc2e14e41e08d30bf86f512151bd",
    "7438966586f1896ab3e8b067d47a4af28a894106",
    "735d8b27f78ea8be839008650a3e88db37dc507d",
    "b503b6a07d7210c94657131dcd97239012ecb313",
    "1fd462b118664b302c67bcc9543cdccdaaec30e9",
    "28bac402953a4337deedf0472611f5775c7a74c9"
  ],
  "changeHistoryShort": {
    "4e1382aca4cf23ca229bdd24e0f143c22449b329": "Ybodychange",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "2b2bd9214604bc2e14e41e08d30bf86f512151bd": "Ybodychange",
    "7438966586f1896ab3e8b067d47a4af28a894106": "Ybodychange",
    "735d8b27f78ea8be839008650a3e88db37dc507d": "Ybodychange",
    "b503b6a07d7210c94657131dcd97239012ecb313": "Ybodychange",
    "1fd462b118664b302c67bcc9543cdccdaaec30e9": "Ybodychange",
    "28bac402953a4337deedf0472611f5775c7a74c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4e1382aca4cf23ca229bdd24e0f143c22449b329": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2674. Fix distributed shell AM container relaunch during RM work preserving restart. Contributed by Shane Kumpf\n",
      "commitDate": "01/05/18 7:27 AM",
      "commitName": "4e1382aca4cf23ca229bdd24e0f143c22449b329",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "27/03/18 7:33 PM",
      "commitNameOld": "d1e378d02bdaec2f078ccc89698e7959ffcc71b3",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 34.5,
      "commitsBetweenForRepo": 724,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,47 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n-      numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n-        String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n-        yarnShellIdCounter++;\n-        LOG.info(\"Launching shell command on a new container.\"\n-            + \", containerId\u003d\" + allocatedContainer.getId()\n-            + \", yarnShellId\u003d\" + yarnShellId\n-            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n-            + \":\" + allocatedContainer.getNodeId().getPort()\n-            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n-            + \", containerResourceMemory\"\n-            + allocatedContainer.getResource().getMemorySize()\n-            + \", containerResourceVirtualCores\"\n-            + allocatedContainer.getResource().getVirtualCores());\n-        // + \", containerToken\"\n-        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n+        if (numAllocatedContainers.get() \u003d\u003d numTotalContainers) {\n+          LOG.info(\"The requested number of containers have been allocated.\"\n+              + \" Releasing the extra container allocation from the RM.\");\n+          amRMClient.releaseAssignedContainer(allocatedContainer.getId());\n+        } else {\n+          numAllocatedContainers.addAndGet(1);\n+          String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n+          yarnShellIdCounter++;\n+          LOG.info(\n+              \"Launching shell command on a new container.\"\n+                  + \", containerId\u003d\" + allocatedContainer.getId()\n+                  + \", yarnShellId\u003d\" + yarnShellId\n+                  + \", containerNode\u003d\"\n+                  + allocatedContainer.getNodeId().getHost()\n+                  + \":\" + allocatedContainer.getNodeId().getPort()\n+                  + \", containerNodeURI\u003d\"\n+                  + allocatedContainer.getNodeHttpAddress()\n+                  + \", containerResourceMemory\"\n+                  + allocatedContainer.getResource().getMemorySize()\n+                  + \", containerResourceVirtualCores\"\n+                  + allocatedContainer.getResource().getVirtualCores());\n \n-        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer,\n-            yarnShellId);\n+          Thread launchThread \u003d\n+              createLaunchContainerThread(allocatedContainer, yarnShellId);\n \n-        // launch and start the container on a separate thread to keep\n-        // the main thread unblocked\n-        // as all containers may not be allocated at one go.\n-        launchThreads.add(launchThread);\n-        launchedContainers.add(allocatedContainer.getId());\n-        launchThread.start();\n+          // launch and start the container on a separate thread to keep\n+          // the main thread unblocked\n+          // as all containers may not be allocated at one go.\n+          launchThreads.add(launchThread);\n+          launchedContainers.add(allocatedContainer.getId());\n+          launchThread.start();\n+\n+          // Remove the corresponding request\n+          Collection\u003cAMRMClient.ContainerRequest\u003e requests \u003d\n+              amRMClient.getMatchingRequests(\n+                  allocatedContainer.getAllocationRequestId());\n+          if (requests.iterator().hasNext()) {\n+            AMRMClient.ContainerRequest request \u003d requests.iterator().next();\n+            amRMClient.removeContainerRequest(request);\n+          }\n+        }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        if (numAllocatedContainers.get() \u003d\u003d numTotalContainers) {\n          LOG.info(\"The requested number of containers have been allocated.\"\n              + \" Releasing the extra container allocation from the RM.\");\n          amRMClient.releaseAssignedContainer(allocatedContainer.getId());\n        } else {\n          numAllocatedContainers.addAndGet(1);\n          String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n          yarnShellIdCounter++;\n          LOG.info(\n              \"Launching shell command on a new container.\"\n                  + \", containerId\u003d\" + allocatedContainer.getId()\n                  + \", yarnShellId\u003d\" + yarnShellId\n                  + \", containerNode\u003d\"\n                  + allocatedContainer.getNodeId().getHost()\n                  + \":\" + allocatedContainer.getNodeId().getPort()\n                  + \", containerNodeURI\u003d\"\n                  + allocatedContainer.getNodeHttpAddress()\n                  + \", containerResourceMemory\"\n                  + allocatedContainer.getResource().getMemorySize()\n                  + \", containerResourceVirtualCores\"\n                  + allocatedContainer.getResource().getVirtualCores());\n\n          Thread launchThread \u003d\n              createLaunchContainerThread(allocatedContainer, yarnShellId);\n\n          // launch and start the container on a separate thread to keep\n          // the main thread unblocked\n          // as all containers may not be allocated at one go.\n          launchThreads.add(launchThread);\n          launchedContainers.add(allocatedContainer.getId());\n          launchThread.start();\n\n          // Remove the corresponding request\n          Collection\u003cAMRMClient.ContainerRequest\u003e requests \u003d\n              amRMClient.getMatchingRequests(\n                  allocatedContainer.getAllocationRequestId());\n          if (requests.iterator().hasNext()) {\n            AMRMClient.ContainerRequest request \u003d requests.iterator().next();\n            amRMClient.removeContainerRequest(request);\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "25/05/16 6:18 AM",
      "commitNameOld": "48c931331cc43970e31866732f9ac82ee806ee03",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n       numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n         String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n         yarnShellIdCounter++;\n         LOG.info(\"Launching shell command on a new container.\"\n             + \", containerId\u003d\" + allocatedContainer.getId()\n             + \", yarnShellId\u003d\" + yarnShellId\n             + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n             + \":\" + allocatedContainer.getNodeId().getPort()\n             + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n             + \", containerResourceMemory\"\n-            + allocatedContainer.getResource().getMemory()\n+            + allocatedContainer.getResource().getMemorySize()\n             + \", containerResourceVirtualCores\"\n             + allocatedContainer.getResource().getVirtualCores());\n         // + \", containerToken\"\n         // +allocatedContainer.getContainerToken().getIdentifier().toString());\n \n         Thread launchThread \u003d createLaunchContainerThread(allocatedContainer,\n             yarnShellId);\n \n         // launch and start the container on a separate thread to keep\n         // the main thread unblocked\n         // as all containers may not be allocated at one go.\n         launchThreads.add(launchThread);\n         launchedContainers.add(allocatedContainer.getId());\n         launchThread.start();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n        yarnShellIdCounter++;\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", yarnShellId\u003d\" + yarnShellId\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemorySize()\n            + \", containerResourceVirtualCores\"\n            + allocatedContainer.getResource().getVirtualCores());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer,\n            yarnShellId);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchedContainers.add(allocatedContainer.getId());\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "2b2bd9214604bc2e14e41e08d30bf86f512151bd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3950. Add unique SHELL_ID environment variable to DistributedShell. Contributed by Robert Kanter\n",
      "commitDate": "29/07/15 8:16 AM",
      "commitName": "2b2bd9214604bc2e14e41e08d30bf86f512151bd",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "19/05/15 2:20 PM",
      "commitNameOld": "7438966586f1896ab3e8b067d47a4af28a894106",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 70.75,
      "commitsBetweenForRepo": 469,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,31 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n       numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n+        String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n+        yarnShellIdCounter++;\n         LOG.info(\"Launching shell command on a new container.\"\n             + \", containerId\u003d\" + allocatedContainer.getId()\n+            + \", yarnShellId\u003d\" + yarnShellId\n             + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n             + \":\" + allocatedContainer.getNodeId().getPort()\n             + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n             + \", containerResourceMemory\"\n             + allocatedContainer.getResource().getMemory()\n             + \", containerResourceVirtualCores\"\n             + allocatedContainer.getResource().getVirtualCores());\n         // + \", containerToken\"\n         // +allocatedContainer.getContainerToken().getIdentifier().toString());\n \n-        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer);\n+        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer,\n+            yarnShellId);\n \n         // launch and start the container on a separate thread to keep\n         // the main thread unblocked\n         // as all containers may not be allocated at one go.\n         launchThreads.add(launchThread);\n         launchedContainers.add(allocatedContainer.getId());\n         launchThread.start();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        String yarnShellId \u003d Integer.toString(yarnShellIdCounter);\n        yarnShellIdCounter++;\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", yarnShellId\u003d\" + yarnShellId\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemory()\n            + \", containerResourceVirtualCores\"\n            + allocatedContainer.getResource().getVirtualCores());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer,\n            yarnShellId);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchedContainers.add(allocatedContainer.getId());\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "7438966586f1896ab3e8b067d47a4af28a894106": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2821. Fixed a problem that DistributedShell AM may hang if restarted. Contributed by Varun Vasudev\n",
      "commitDate": "19/05/15 2:20 PM",
      "commitName": "7438966586f1896ab3e8b067d47a4af28a894106",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/04/15 2:08 PM",
      "commitNameOld": "5ce3a77f3c00aeabcd791c3373dd3c8c25160ce2",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 25.01,
      "commitsBetweenForRepo": 293,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,27 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n       numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n         LOG.info(\"Launching shell command on a new container.\"\n             + \", containerId\u003d\" + allocatedContainer.getId()\n             + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n             + \":\" + allocatedContainer.getNodeId().getPort()\n             + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n             + \", containerResourceMemory\"\n             + allocatedContainer.getResource().getMemory()\n             + \", containerResourceVirtualCores\"\n             + allocatedContainer.getResource().getVirtualCores());\n         // + \", containerToken\"\n         // +allocatedContainer.getContainerToken().getIdentifier().toString());\n \n-        LaunchContainerRunnable runnableLaunchContainer \u003d\n-            new LaunchContainerRunnable(allocatedContainer, containerListener);\n-        Thread launchThread \u003d new Thread(runnableLaunchContainer);\n+        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer);\n \n         // launch and start the container on a separate thread to keep\n         // the main thread unblocked\n         // as all containers may not be allocated at one go.\n         launchThreads.add(launchThread);\n+        launchedContainers.add(allocatedContainer.getId());\n         launchThread.start();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemory()\n            + \", containerResourceVirtualCores\"\n            + allocatedContainer.getResource().getVirtualCores());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        Thread launchThread \u003d createLaunchContainerThread(allocatedContainer);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchedContainers.add(allocatedContainer.getId());\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "735d8b27f78ea8be839008650a3e88db37dc507d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7. Support CPU resource for DistributedShell. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1531222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/10/13 1:18 AM",
      "commitName": "735d8b27f78ea8be839008650a3e88db37dc507d",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "04/10/13 11:08 PM",
      "commitNameOld": "be3edccf0acf55e710b0ec8ab8ce8418da74c615",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,28 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n       numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n         LOG.info(\"Launching shell command on a new container.\"\n             + \", containerId\u003d\" + allocatedContainer.getId()\n             + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n             + \":\" + allocatedContainer.getNodeId().getPort()\n             + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n             + \", containerResourceMemory\"\n-            + allocatedContainer.getResource().getMemory());\n+            + allocatedContainer.getResource().getMemory()\n+            + \", containerResourceVirtualCores\"\n+            + allocatedContainer.getResource().getVirtualCores());\n         // + \", containerToken\"\n         // +allocatedContainer.getContainerToken().getIdentifier().toString());\n \n         LaunchContainerRunnable runnableLaunchContainer \u003d\n             new LaunchContainerRunnable(allocatedContainer, containerListener);\n         Thread launchThread \u003d new Thread(runnableLaunchContainer);\n \n         // launch and start the container on a separate thread to keep\n         // the main thread unblocked\n         // as all containers may not be allocated at one go.\n         launchThreads.add(launchThread);\n         launchThread.start();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemory()\n            + \", containerResourceVirtualCores\"\n            + allocatedContainer.getResource().getVirtualCores());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        LaunchContainerRunnable runnableLaunchContainer \u003d\n            new LaunchContainerRunnable(allocatedContainer, containerListener);\n        Thread launchThread \u003d new Thread(runnableLaunchContainer);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "b503b6a07d7210c94657131dcd97239012ecb313": {
      "type": "Ybodychange",
      "commitMessage": "YARN-639. Modified Distributed Shell application to start using the new NMClient library. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493280 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/06/13 4:18 PM",
      "commitName": "b503b6a07d7210c94657131dcd97239012ecb313",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/06/13 9:10 AM",
      "commitNameOld": "fdc9412a810564c79fbebf5eb730cb1018a95c6c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,26 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n       numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n         LOG.info(\"Launching shell command on a new container.\"\n             + \", containerId\u003d\" + allocatedContainer.getId()\n             + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n             + \":\" + allocatedContainer.getNodeId().getPort()\n             + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n             + \", containerResourceMemory\"\n             + allocatedContainer.getResource().getMemory());\n         // + \", containerToken\"\n         // +allocatedContainer.getContainerToken().getIdentifier().toString());\n \n-        LaunchContainerRunnable runnableLaunchContainer \u003d new LaunchContainerRunnable(\n-            allocatedContainer);\n+        LaunchContainerRunnable runnableLaunchContainer \u003d\n+            new LaunchContainerRunnable(allocatedContainer, containerListener);\n         Thread launchThread \u003d new Thread(runnableLaunchContainer);\n \n         // launch and start the container on a separate thread to keep\n         // the main thread unblocked\n         // as all containers may not be allocated at one go.\n         launchThreads.add(launchThread);\n         launchThread.start();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemory());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        LaunchContainerRunnable runnableLaunchContainer \u003d\n            new LaunchContainerRunnable(allocatedContainer, containerListener);\n        Thread launchThread \u003d new Thread(runnableLaunchContainer);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "1fd462b118664b302c67bcc9543cdccdaaec30e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-536. Removed the unused objects ContainerStatus and ContainerStatus from Container which also don\u0027t belong to the container. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1464271 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/13 8:41 PM",
      "commitName": "1fd462b118664b302c67bcc9543cdccdaaec30e9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/03/13 7:34 PM",
      "commitNameOld": "2aed48a67f408c290e90c83af9f76165d695f91a",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 9.05,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,26 @@\n     public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n       LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n           + allocatedContainers.size());\n       numAllocatedContainers.addAndGet(allocatedContainers.size());\n       for (Container allocatedContainer : allocatedContainers) {\n         LOG.info(\"Launching shell command on a new container.\"\n             + \", containerId\u003d\" + allocatedContainer.getId()\n             + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n             + \":\" + allocatedContainer.getNodeId().getPort()\n             + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n-            + \", containerState\" + allocatedContainer.getState()\n             + \", containerResourceMemory\"\n             + allocatedContainer.getResource().getMemory());\n         // + \", containerToken\"\n         // +allocatedContainer.getContainerToken().getIdentifier().toString());\n \n         LaunchContainerRunnable runnableLaunchContainer \u003d new LaunchContainerRunnable(\n             allocatedContainer);\n         Thread launchThread \u003d new Thread(runnableLaunchContainer);\n \n         // launch and start the container on a separate thread to keep\n         // the main thread unblocked\n         // as all containers may not be allocated at one go.\n         launchThreads.add(launchThread);\n         launchThread.start();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemory());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        LaunchContainerRunnable runnableLaunchContainer \u003d new LaunchContainerRunnable(\n            allocatedContainer);\n        Thread launchThread \u003d new Thread(runnableLaunchContainer);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "28bac402953a4337deedf0472611f5775c7a74c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-417. Create AMRMClient wrapper that provides asynchronous callbacks. (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459555 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 3:26 PM",
      "commitName": "28bac402953a4337deedf0472611f5775c7a74c9",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,27 @@\n+    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n+      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n+          + allocatedContainers.size());\n+      numAllocatedContainers.addAndGet(allocatedContainers.size());\n+      for (Container allocatedContainer : allocatedContainers) {\n+        LOG.info(\"Launching shell command on a new container.\"\n+            + \", containerId\u003d\" + allocatedContainer.getId()\n+            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n+            + \":\" + allocatedContainer.getNodeId().getPort()\n+            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n+            + \", containerState\" + allocatedContainer.getState()\n+            + \", containerResourceMemory\"\n+            + allocatedContainer.getResource().getMemory());\n+        // + \", containerToken\"\n+        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n+\n+        LaunchContainerRunnable runnableLaunchContainer \u003d new LaunchContainerRunnable(\n+            allocatedContainer);\n+        Thread launchThread \u003d new Thread(runnableLaunchContainer);\n+\n+        // launch and start the container on a separate thread to keep\n+        // the main thread unblocked\n+        // as all containers may not be allocated at one go.\n+        launchThreads.add(launchThread);\n+        launchThread.start();\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersAllocated(List\u003cContainer\u003e allocatedContainers) {\n      LOG.info(\"Got response from RM for container ask, allocatedCnt\u003d\"\n          + allocatedContainers.size());\n      numAllocatedContainers.addAndGet(allocatedContainers.size());\n      for (Container allocatedContainer : allocatedContainers) {\n        LOG.info(\"Launching shell command on a new container.\"\n            + \", containerId\u003d\" + allocatedContainer.getId()\n            + \", containerNode\u003d\" + allocatedContainer.getNodeId().getHost()\n            + \":\" + allocatedContainer.getNodeId().getPort()\n            + \", containerNodeURI\u003d\" + allocatedContainer.getNodeHttpAddress()\n            + \", containerState\" + allocatedContainer.getState()\n            + \", containerResourceMemory\"\n            + allocatedContainer.getResource().getMemory());\n        // + \", containerToken\"\n        // +allocatedContainer.getContainerToken().getIdentifier().toString());\n\n        LaunchContainerRunnable runnableLaunchContainer \u003d new LaunchContainerRunnable(\n            allocatedContainer);\n        Thread launchThread \u003d new Thread(runnableLaunchContainer);\n\n        // launch and start the container on a separate thread to keep\n        // the main thread unblocked\n        // as all containers may not be allocated at one go.\n        launchThreads.add(launchThread);\n        launchThread.start();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
    }
  }
}