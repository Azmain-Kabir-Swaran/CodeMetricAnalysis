{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "rename",
  "functionId": "rename___src-Path__dst-Path",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 1329,
  "functionEndLine": 1345,
  "numCommitsSeen": 141,
  "timeTaken": 6163,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "d60a60be8aa450c44d3be69d26c88025e253ac0c",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "29ae25801380b94442253c4202dee782dc4713f5",
    "709ff99cff4124823bde631e272af7be9a22f83b",
    "aa1c437b6a806de612f030a68984c606c623f1d9",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "d60a60be8aa450c44d3be69d26c88025e253ac0c": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "29ae25801380b94442253c4202dee782dc4713f5": "Ybodychange",
    "709ff99cff4124823bde631e272af7be9a22f83b": "Ybodychange",
    "aa1c437b6a806de612f030a68984c606c623f1d9": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "07/01/20 3:17 AM",
      "commitNameOld": "2bbf73f1df96ebe7e6fcf64a724ae846230a8487",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,17 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     try (DurationInfo ignored \u003d new DurationInfo(LOG, false,\n         \"rename(%s, %s\", src, dst)) {\n       long bytesCopied \u003d innerRename(src, dst);\n       LOG.debug(\"Copied {} bytes\", bytesCopied);\n       return true;\n     } catch (AmazonClientException e) {\n       throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n     } catch (RenameFailedException e) {\n-      LOG.debug(e.getMessage());\n+      LOG.info(\"{}\", e.getMessage());\n+      LOG.debug(\"rename failure\", e);\n       return e.getExitCode();\n     } catch (FileNotFoundException e) {\n       LOG.debug(e.toString());\n       return false;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    try (DurationInfo ignored \u003d new DurationInfo(LOG, false,\n        \"rename(%s, %s\", src, dst)) {\n      long bytesCopied \u003d innerRename(src, dst);\n      LOG.debug(\"Copied {} bytes\", bytesCopied);\n      return true;\n    } catch (AmazonClientException e) {\n      throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n    } catch (RenameFailedException e) {\n      LOG.info(\"{}\", e.getMessage());\n      LOG.debug(\"rename failure\", e);\n      return e.getExitCode();\n    } catch (FileNotFoundException e) {\n      LOG.debug(e.toString());\n      return false;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,16 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n-    try {\n-      return innerRename(src, dst);\n+    try (DurationInfo ignored \u003d new DurationInfo(LOG, false,\n+        \"rename(%s, %s\", src, dst)) {\n+      long bytesCopied \u003d innerRename(src, dst);\n+      LOG.debug(\"Copied {} bytes\", bytesCopied);\n+      return true;\n     } catch (AmazonClientException e) {\n       throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n     } catch (RenameFailedException e) {\n       LOG.debug(e.getMessage());\n       return e.getExitCode();\n     } catch (FileNotFoundException e) {\n       LOG.debug(e.toString());\n       return false;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    try (DurationInfo ignored \u003d new DurationInfo(LOG, false,\n        \"rename(%s, %s\", src, dst)) {\n      long bytesCopied \u003d innerRename(src, dst);\n      LOG.debug(\"Copied {} bytes\", bytesCopied);\n      return true;\n    } catch (AmazonClientException e) {\n      throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n    } catch (RenameFailedException e) {\n      LOG.debug(e.getMessage());\n      return e.getExitCode();\n    } catch (FileNotFoundException e) {\n      LOG.debug(e.toString());\n      return false;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "d60a60be8aa450c44d3be69d26c88025e253ac0c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13823. s3a rename: fail if dest file exists. Contributed by Steve Loughran\n",
      "commitDate": "28/11/16 4:30 PM",
      "commitName": "d60a60be8aa450c44d3be69d26c88025e253ac0c",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "31/10/16 1:54 PM",
      "commitNameOld": "a1761a841e95ef7d2296ac3e40b3a26d97787eab",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 28.15,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,7 +1,13 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     try {\n       return innerRename(src, dst);\n     } catch (AmazonClientException e) {\n       throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n+    } catch (RenameFailedException e) {\n+      LOG.debug(e.getMessage());\n+      return e.getExitCode();\n+    } catch (FileNotFoundException e) {\n+      LOG.debug(e.toString());\n+      return false;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    try {\n      return innerRename(src, dst);\n    } catch (AmazonClientException e) {\n      throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n    } catch (RenameFailedException e) {\n      LOG.debug(e.getMessage());\n      return e.getExitCode();\n    } catch (FileNotFoundException e) {\n      LOG.debug(e.toString());\n      return false;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/05/16 5:52 AM",
      "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,7 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n-    LOG.debug(\"Rename path {} to {}\", src, dst);\n-\n-    String srcKey \u003d pathToKey(src);\n-    String dstKey \u003d pathToKey(dst);\n-\n-    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n-      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n-      return false;\n-    }\n-\n-    S3AFileStatus srcStatus;\n     try {\n-      srcStatus \u003d getFileStatus(src);\n-    } catch (FileNotFoundException e) {\n-      LOG.error(\"rename: src not found {}\", src);\n-      return false;\n+      return innerRename(src, dst);\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n     }\n-\n-    if (srcKey.equals(dstKey)) {\n-      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n-          dst);\n-      return srcStatus.isFile();\n-    }\n-\n-    S3AFileStatus dstStatus \u003d null;\n-    try {\n-      dstStatus \u003d getFileStatus(dst);\n-\n-      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n-            src, dst);\n-        return false;\n-      }\n-\n-      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n-        return false;\n-      }\n-    } catch (FileNotFoundException e) {\n-      LOG.debug(\"rename: destination path {} not found\", dst);\n-      // Parent must exist\n-      Path parent \u003d dst.getParent();\n-      if (!pathToKey(parent).isEmpty()) {\n-        try {\n-          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n-          if (!dstParentStatus.isDirectory()) {\n-            return false;\n-          }\n-        } catch (FileNotFoundException e2) {\n-          LOG.debug(\"rename: destination path {} has no parent {}\",\n-              dst, parent);\n-          return false;\n-        }\n-      }\n-    }\n-\n-    // Ok! Time to start\n-    if (srcStatus.isFile()) {\n-      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n-        String newDstKey \u003d dstKey;\n-        if (!newDstKey.endsWith(\"/\")) {\n-          newDstKey \u003d newDstKey + \"/\";\n-        }\n-        String filename \u003d\n-            srcKey.substring(pathToKey(src.getParent()).length()+1);\n-        newDstKey \u003d newDstKey + filename;\n-        copyFile(srcKey, newDstKey, srcStatus.getLen());\n-      } else {\n-        copyFile(srcKey, dstKey, srcStatus.getLen());\n-      }\n-      delete(src, false);\n-    } else {\n-      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n-\n-      // This is a directory to directory copy\n-      if (!dstKey.endsWith(\"/\")) {\n-        dstKey \u003d dstKey + \"/\";\n-      }\n-\n-      if (!srcKey.endsWith(\"/\")) {\n-        srcKey \u003d srcKey + \"/\";\n-      }\n-\n-      //Verify dest is not a child of the source directory\n-      if (dstKey.startsWith(srcKey)) {\n-        LOG.debug(\"cannot rename a directory {}\" +\n-              \" to a subdirectory of self: {}\", srcKey, dstKey);\n-        return false;\n-      }\n-\n-      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n-        // delete unnecessary fake directory.\n-        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n-      }\n-\n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(srcKey);\n-      request.setMaxKeys(maxKeys);\n-\n-      ObjectListing objects \u003d s3.listObjects(request);\n-      statistics.incrementReadOps(1);\n-\n-      while (true) {\n-        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n-          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n-          copyFile(summary.getKey(), newDstKey, summary.getSize());\n-\n-          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-            removeKeys(keysToDelete, true);\n-          }\n-        }\n-\n-        if (objects.isTruncated()) {\n-          objects \u003d s3.listNextBatchOfObjects(objects);\n-          statistics.incrementReadOps(1);\n-        } else {\n-          if (!keysToDelete.isEmpty()) {\n-            removeKeys(keysToDelete, false);\n-          }\n-          break;\n-        }\n-      }\n-    }\n-\n-    if (src.getParent() !\u003d dst.getParent()) {\n-      deleteUnnecessaryFakeDirectories(dst.getParent());\n-      createFakeDirectoryIfNecessary(src.getParent());\n-    }\n-    return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    try {\n      return innerRename(src, dst);\n    } catch (AmazonClientException e) {\n      throw translateException(\"rename(\" + src +\", \" + dst + \")\", src, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,134 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Rename path {} to {}\", src, dst);\n-    }\n+    LOG.debug(\"Rename path {} to {}\", src, dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: src or dst are empty\");\n-      }\n+      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n-      }\n+      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n+          dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"rename: src is a directory and dst is a file\");\n-        }\n+        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n+            src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n+      LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n+          LOG.debug(\"rename: destination path {} has no parent {}\",\n+              dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n-      }\n+      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n-        copyFile(srcKey, newDstKey);\n+        copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n-        copyFile(srcKey, dstKey);\n+        copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       delete(src, false);\n     } else {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n-      }\n+      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n-        }\n+        LOG.debug(\"cannot rename a directory {}\" +\n+              \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n-      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d\n-        new ArrayList\u003c\u003e();\n+      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n-          copyFile(summary.getKey(), newDstKey);\n+          copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      delete(src, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "29ae25801380b94442253c4202dee782dc4713f5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12292. Make use of DeleteObjects optional.  (Thomas Demoor via stevel)\n",
      "commitDate": "06/02/16 7:05 AM",
      "commitName": "29ae25801380b94442253c4202dee782dc4713f5",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/01/16 12:19 PM",
      "commitNameOld": "126705f67eaa6d866f7572fbddf133c5d7552353",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 24.78,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,143 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Rename path {} to {}\", src, dst);\n     }\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src or dst are empty\");\n       }\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src and dst refer to the same file or directory\");\n       }\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"rename: src is a directory and dst is a file\");\n         }\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey);\n       } else {\n         copyFile(srcKey, dstKey);\n       }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n         }\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n         new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-            DeleteObjectsRequest deleteRequest \u003d\n-                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n-            s3.deleteObjects(deleteRequest);\n-            statistics.incrementWriteOps(1);\n-            keysToDelete.clear();\n+            removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n-          if (keysToDelete.size() \u003e 0) {\n-            DeleteObjectsRequest deleteRequest \u003d\n-                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n-            s3.deleteObjects(deleteRequest);\n-            statistics.incrementWriteOps(1);\n+          if (!keysToDelete.isEmpty()) {\n+            removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Rename path {} to {}\", src, dst);\n    }\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "709ff99cff4124823bde631e272af7be9a22f83b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11584 s3a file block size set to 0 in getFileStatus. (Brahma Reddy Battula via stevel)\n",
      "commitDate": "21/02/15 4:03 AM",
      "commitName": "709ff99cff4124823bde631e272af7be9a22f83b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/02/15 12:51 PM",
      "commitNameOld": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Rename path {} to {}\", src, dst);\n     }\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n-    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n+    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src or dst are empty\");\n       }\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src and dst refer to the same file or directory\");\n       }\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"rename: src is a directory and dst is a file\");\n         }\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey);\n       } else {\n         copyFile(srcKey, dstKey);\n       }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n         }\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n-        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n+        new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n             keysToDelete.clear();\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (keysToDelete.size() \u003e 0) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Rename path {} to {}\", src, dst);\n    }\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n            keysToDelete.clear();\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (keysToDelete.size() \u003e 0) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "aa1c437b6a806de612f030a68984c606c623f1d9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11607. Reduce log spew in S3AFileSystem. (Lei (Eddy) Xu via stevel)\n",
      "commitDate": "20/02/15 12:51 PM",
      "commitName": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/02/15 12:06 PM",
      "commitNameOld": "00b80958d862dbcc08d6f186c09963d3351ba0fd",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 3.03,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,150 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n-    LOG.info(\"Rename path \" + src + \" to \" + dst);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Rename path {} to {}\", src, dst);\n+    }\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src or dst are empty\");\n       }\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n-      LOG.info(\"rename: src not found \" + src);\n+      LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src and dst refer to the same file or directory\");\n       }\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"rename: src is a directory and dst is a file\");\n         }\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey);\n       } else {\n         copyFile(srcKey, dstKey);\n       }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n         }\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n         new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n             keysToDelete.clear();\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (keysToDelete.size() \u003e 0) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Rename path {} to {}\", src, dst);\n    }\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n            keysToDelete.clear();\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (keysToDelete.size() \u003e 0) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 4:49 PM",
      "commitNameOld": "0ac760a58d96b36ab30e9d60679bbea6365ef120",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,148 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     LOG.info(\"Rename path \" + src + \" to \" + dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n-      LOG.info(\"rename: src or dst are empty\");\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: src or dst are empty\");\n+      }\n       return false;\n     }\n \n-    if (srcKey.equals(dstKey)) {\n-      LOG.info(\"rename: src and dst refer to the same file\");\n-      return true;\n-    }\n-\n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.info(\"rename: src not found \" + src);\n       return false;\n     }\n \n+    if (srcKey.equals(dstKey)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n+      }\n+      return srcStatus.isFile();\n+    }\n+\n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n-      if (srcStatus.isFile() \u0026\u0026 dstStatus.isDirectory()) {\n-        LOG.info(\"rename: src is a file and dst is a directory\");\n-        return false;\n-      }\n-\n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        LOG.info(\"rename: src is a directory and dst is a file\");\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"rename: src is a directory and dst is a file\");\n+        }\n         return false;\n       }\n \n+      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n+        return false;\n+      }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n-      copyFile(srcKey, dstKey);\n+      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n+        String newDstKey \u003d dstKey;\n+        if (!newDstKey.endsWith(\"/\")) {\n+          newDstKey \u003d newDstKey + \"/\";\n+        }\n+        String filename \u003d\n+            srcKey.substring(pathToKey(src.getParent()).length()+1);\n+        newDstKey \u003d newDstKey + filename;\n+        copyFile(srcKey, newDstKey);\n+      } else {\n+        copyFile(srcKey, dstKey);\n+      }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n+      //Verify dest is not a child of the source directory\n+      if (dstKey.startsWith(srcKey)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n+        }\n+        return false;\n+      }\n+\n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n         new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n-        copyFile(srcKey, dstKey);\n-        statistics.incrementWriteOps(1);\n-        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(srcKey));\n+        // delete unnecessary fake directory.\n+        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n+\n+          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+            DeleteObjectsRequest deleteRequest \u003d\n+                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n+            s3.deleteObjects(deleteRequest);\n+            statistics.incrementWriteOps(1);\n+            keysToDelete.clear();\n+          }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n+          if (keysToDelete.size() \u003e 0) {\n+            DeleteObjectsRequest deleteRequest \u003d\n+                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n+            s3.deleteObjects(deleteRequest);\n+            statistics.incrementWriteOps(1);\n+          }\n           break;\n         }\n       }\n-\n-\n-      if (!keysToDelete.isEmpty()) {\n-        DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n-        deleteRequest.setKeys(keysToDelete);\n-        s3.deleteObjects(deleteRequest);\n-        statistics.incrementWriteOps(1);\n-      }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"Rename path \" + src + \" to \" + dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.info(\"rename: src not found \" + src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n            keysToDelete.clear();\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (keysToDelete.size() \u003e 0) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,120 @@\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Rename path \" + src + \" to \" + dst);\n+\n+    String srcKey \u003d pathToKey(src);\n+    String dstKey \u003d pathToKey(dst);\n+\n+    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n+      LOG.info(\"rename: src or dst are empty\");\n+      return false;\n+    }\n+\n+    if (srcKey.equals(dstKey)) {\n+      LOG.info(\"rename: src and dst refer to the same file\");\n+      return true;\n+    }\n+\n+    S3AFileStatus srcStatus;\n+    try {\n+      srcStatus \u003d getFileStatus(src);\n+    } catch (FileNotFoundException e) {\n+      LOG.info(\"rename: src not found \" + src);\n+      return false;\n+    }\n+\n+    S3AFileStatus dstStatus \u003d null;\n+    try {\n+      dstStatus \u003d getFileStatus(dst);\n+\n+      if (srcStatus.isFile() \u0026\u0026 dstStatus.isDirectory()) {\n+        LOG.info(\"rename: src is a file and dst is a directory\");\n+        return false;\n+      }\n+\n+      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n+        LOG.info(\"rename: src is a directory and dst is a file\");\n+        return false;\n+      }\n+\n+    } catch (FileNotFoundException e) {\n+      // Parent must exist\n+      Path parent \u003d dst.getParent();\n+      if (!pathToKey(parent).isEmpty()) {\n+        try {\n+          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n+          if (!dstParentStatus.isDirectory()) {\n+            return false;\n+          }\n+        } catch (FileNotFoundException e2) {\n+          return false;\n+        }\n+      }\n+    }\n+\n+    // Ok! Time to start\n+    if (srcStatus.isFile()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n+      }\n+      copyFile(srcKey, dstKey);\n+      delete(src, false);\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n+      }\n+\n+      // This is a directory to directory copy\n+      if (!dstKey.endsWith(\"/\")) {\n+        dstKey \u003d dstKey + \"/\";\n+      }\n+\n+      if (!srcKey.endsWith(\"/\")) {\n+        srcKey \u003d srcKey + \"/\";\n+      }\n+\n+      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n+        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n+      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n+        copyFile(srcKey, dstKey);\n+        statistics.incrementWriteOps(1);\n+        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(srcKey));\n+      }\n+\n+      ListObjectsRequest request \u003d new ListObjectsRequest();\n+      request.setBucketName(bucket);\n+      request.setPrefix(srcKey);\n+      request.setMaxKeys(maxKeys);\n+\n+      ObjectListing objects \u003d s3.listObjects(request);\n+      statistics.incrementReadOps(1);\n+\n+      while (true) {\n+        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n+          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n+          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n+          copyFile(summary.getKey(), newDstKey);\n+        }\n+\n+        if (objects.isTruncated()) {\n+          objects \u003d s3.listNextBatchOfObjects(objects);\n+          statistics.incrementReadOps(1);\n+        } else {\n+          break;\n+        }\n+      }\n+\n+\n+      if (!keysToDelete.isEmpty()) {\n+        DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n+        deleteRequest.setKeys(keysToDelete);\n+        s3.deleteObjects(deleteRequest);\n+        statistics.incrementWriteOps(1);\n+      }\n+    }\n+\n+    if (src.getParent() !\u003d dst.getParent()) {\n+      deleteUnnecessaryFakeDirectories(dst.getParent());\n+      createFakeDirectoryIfNecessary(src.getParent());\n+    }\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"Rename path \" + src + \" to \" + dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n      LOG.info(\"rename: src or dst are empty\");\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.info(\"rename: src and dst refer to the same file\");\n      return true;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.info(\"rename: src not found \" + src);\n      return false;\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isFile() \u0026\u0026 dstStatus.isDirectory()) {\n        LOG.info(\"rename: src is a file and dst is a directory\");\n        return false;\n      }\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.info(\"rename: src is a directory and dst is a file\");\n        return false;\n      }\n\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      copyFile(srcKey, dstKey);\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        copyFile(srcKey, dstKey);\n        statistics.incrementWriteOps(1);\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(srcKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n\n\n      if (!keysToDelete.isEmpty()) {\n        DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n        deleteRequest.setKeys(keysToDelete);\n        s3.deleteObjects(deleteRequest);\n        statistics.incrementWriteOps(1);\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}