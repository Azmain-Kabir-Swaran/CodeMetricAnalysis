{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CopyCommitter.java",
  "functionName": "deleteMissing",
  "functionId": "deleteMissing___conf-Configuration",
  "sourceFilePath": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
  "functionStartLine": 397,
  "functionEndLine": 521,
  "numCommitsSeen": 23,
  "timeTaken": 3186,
  "changeHistory": [
    "19a001826f6ab9ac2caa92b66864f62218557beb",
    "ee3115f488ce8e44bffac15af9c646190bf67b88",
    "ca8b80bf59c0570bb9172208d3a6c993a6854514",
    "1976e0066e9ae8852715fa69d8aea3769330e933",
    "26172a94d6431e70d7fe15d66be9a7e195f79f60",
    "5af572b6443715b7a741296c1bd520a1840f9a7c",
    "0a85d079838f532a13ca237300386d1b3bc1b178",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
    "640a097533e0883bf49504673228d5a327089b44",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67"
  ],
  "changeHistoryShort": {
    "19a001826f6ab9ac2caa92b66864f62218557beb": "Ybodychange",
    "ee3115f488ce8e44bffac15af9c646190bf67b88": "Ybodychange",
    "ca8b80bf59c0570bb9172208d3a6c993a6854514": "Ybodychange",
    "1976e0066e9ae8852715fa69d8aea3769330e933": "Ybodychange",
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": "Ybodychange",
    "5af572b6443715b7a741296c1bd520a1840f9a7c": "Ybodychange",
    "0a85d079838f532a13ca237300386d1b3bc1b178": "Ybodychange",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": "Ybodychange",
    "640a097533e0883bf49504673228d5a327089b44": "Ybodychange",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": "Yintroduced"
  },
  "changeHistoryDetails": {
    "19a001826f6ab9ac2caa92b66864f62218557beb": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9913. DistCp to add -useTrash to move deleted files to Trash.\"\n\nReverting due to test failures if ~/.Trash not present during test setup.\n\nThis reverts commit ee3115f488ce8e44bffac15af9c646190bf67b88.\n\nChange-Id: Icbeeb261570b9131ff99d765ac0945c335b26658\n",
      "commitDate": "17/07/19 5:13 AM",
      "commitName": "19a001826f6ab9ac2caa92b66864f62218557beb",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/07/19 3:50 AM",
      "commitNameOld": "ee3115f488ce8e44bffac15af9c646190bf67b88",
      "commitAuthorOld": "Shen Yinjie",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,125 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n     long listingStart \u003d System.currentTimeMillis();\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n     long sourceListingCompleted \u003d System.currentTimeMillis();\n     LOG.info(\"Source listing completed in {}\",\n         formatDuration(sourceListingCompleted - listingStart));\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n \n     Path targetFinalPath \u003d listTargetFiles(conf,\n         targetListing, sortedTargetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletionStart \u003d System.currentTimeMillis();\n     LOG.info(\"Destination listing completed in {}\",\n         formatDuration(deletionStart - sourceListingCompleted));\n \n     long deletedEntries \u003d 0;\n     long filesDeleted \u003d 0;\n     long missingDeletes \u003d 0;\n     long failedDeletes \u003d 0;\n     long skippedDeletes \u003d 0;\n     long deletedDirectories \u003d 0;\n     // this is an arbitrary constant.\n     final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean showProgress;\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n         Path targetEntry \u003d trgtFileStatus.getPath();\n         LOG.debug(\"Comparing {} and {}\",\n             srcFileStatus.getPath(), targetEntry);\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Try to delete it.\n         if (tracker.shouldDelete(trgtFileStatus)) {\n           showProgress \u003d true;\n           try {\n-            boolean result \u003d deletePath(targetFS, targetEntry, conf);\n-            if (result) {\n+            if (targetFS.delete(targetEntry, true)) {\n               // the delete worked. Unless the file is actually missing, this is the\n               LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n               deletedEntries++;\n               if (trgtFileStatus.isDirectory()) {\n                 deletedDirectories++;\n               } else {\n                 filesDeleted++;\n               }\n             } else {\n               // delete returned false.\n               // For all the filestores which implement the FS spec properly,\n               // this means \"the file wasn\u0027t there\".\n               // so track but don\u0027t worry about it.\n-              LOG.info(\"delete({}) returned false ({}). Consider using \" +\n-                      \"-useTrash option if trash is enabled.\",\n+              LOG.info(\"delete({}) returned false ({})\",\n                   targetEntry, trgtFileStatus);\n               missingDeletes++;\n             }\n           } catch (IOException e) {\n             if (!ignoreFailures) {\n               throw e;\n             } else {\n               // failed to delete, but ignoring errors. So continue\n               LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                   targetEntry, e.toString());\n               LOG.debug(\"Failed to delete {}\", targetEntry, e);\n               // count and break out the loop\n               failedDeletes++;\n             }\n           }\n         } else {\n           LOG.debug(\"Skipping deletion of {}\", targetEntry);\n           skippedDeletes++;\n           showProgress \u003d false;\n         }\n         if (showProgress) {\n           // update progress if there\u0027s been any FS IO/files deleted.\n           taskAttemptContext.progress();\n           taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n               targetReader.getPosition() * 100 / totalLen + \"%]\");\n         }\n       }\n       // if the FS toString() call prints statistics, they get logged here\n       LOG.info(\"Completed deletion of files from {}\", targetFS);\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     long deletionEnd \u003d System.currentTimeMillis();\n     long deletedFileCount \u003d deletedEntries - deletedDirectories;\n     LOG.info(\"Deleted from target: files: {} directories: {};\"\n             + \" skipped deletions {}; deletions already missing {};\"\n             + \" failed deletes {}\",\n         deletedFileCount, deletedDirectories, skippedDeletes,\n         missingDeletes, failedDeletes);\n     LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n     LOG.info(\"Duration of deletions: {}\",\n         formatDuration(deletionEnd - deletionStart));\n     LOG.info(\"Total duration of deletion operation: {}\",\n         formatDuration(deletionEnd - listingStart));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n    long listingStart \u003d System.currentTimeMillis();\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n    long sourceListingCompleted \u003d System.currentTimeMillis();\n    LOG.info(\"Source listing completed in {}\",\n        formatDuration(sourceListingCompleted - listingStart));\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n\n    Path targetFinalPath \u003d listTargetFiles(conf,\n        targetListing, sortedTargetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletionStart \u003d System.currentTimeMillis();\n    LOG.info(\"Destination listing completed in {}\",\n        formatDuration(deletionStart - sourceListingCompleted));\n\n    long deletedEntries \u003d 0;\n    long filesDeleted \u003d 0;\n    long missingDeletes \u003d 0;\n    long failedDeletes \u003d 0;\n    long skippedDeletes \u003d 0;\n    long deletedDirectories \u003d 0;\n    // this is an arbitrary constant.\n    final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean showProgress;\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n        Path targetEntry \u003d trgtFileStatus.getPath();\n        LOG.debug(\"Comparing {} and {}\",\n            srcFileStatus.getPath(), targetEntry);\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Try to delete it.\n        if (tracker.shouldDelete(trgtFileStatus)) {\n          showProgress \u003d true;\n          try {\n            if (targetFS.delete(targetEntry, true)) {\n              // the delete worked. Unless the file is actually missing, this is the\n              LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n              deletedEntries++;\n              if (trgtFileStatus.isDirectory()) {\n                deletedDirectories++;\n              } else {\n                filesDeleted++;\n              }\n            } else {\n              // delete returned false.\n              // For all the filestores which implement the FS spec properly,\n              // this means \"the file wasn\u0027t there\".\n              // so track but don\u0027t worry about it.\n              LOG.info(\"delete({}) returned false ({})\",\n                  targetEntry, trgtFileStatus);\n              missingDeletes++;\n            }\n          } catch (IOException e) {\n            if (!ignoreFailures) {\n              throw e;\n            } else {\n              // failed to delete, but ignoring errors. So continue\n              LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                  targetEntry, e.toString());\n              LOG.debug(\"Failed to delete {}\", targetEntry, e);\n              // count and break out the loop\n              failedDeletes++;\n            }\n          }\n        } else {\n          LOG.debug(\"Skipping deletion of {}\", targetEntry);\n          skippedDeletes++;\n          showProgress \u003d false;\n        }\n        if (showProgress) {\n          // update progress if there\u0027s been any FS IO/files deleted.\n          taskAttemptContext.progress();\n          taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n              targetReader.getPosition() * 100 / totalLen + \"%]\");\n        }\n      }\n      // if the FS toString() call prints statistics, they get logged here\n      LOG.info(\"Completed deletion of files from {}\", targetFS);\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    long deletionEnd \u003d System.currentTimeMillis();\n    long deletedFileCount \u003d deletedEntries - deletedDirectories;\n    LOG.info(\"Deleted from target: files: {} directories: {};\"\n            + \" skipped deletions {}; deletions already missing {};\"\n            + \" failed deletes {}\",\n        deletedFileCount, deletedDirectories, skippedDeletes,\n        missingDeletes, failedDeletes);\n    LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n    LOG.info(\"Duration of deletions: {}\",\n        formatDuration(deletionEnd - deletionStart));\n    LOG.info(\"Total duration of deletion operation: {}\",\n        formatDuration(deletionEnd - listingStart));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "ee3115f488ce8e44bffac15af9c646190bf67b88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9913. DistCp to add -useTrash to move deleted files to Trash.\n\nContributed by Shen Yinjie.\n\nChange-Id: I03ac7d22ab1054f8e5de4aa7552909c734438f4a\n",
      "commitDate": "17/07/19 3:50 AM",
      "commitName": "ee3115f488ce8e44bffac15af9c646190bf67b88",
      "commitAuthor": "Shen Yinjie",
      "commitDateOld": "19/10/18 1:21 PM",
      "commitNameOld": "e2cecb681e2aab8b7c5465719cac53dce407a64c",
      "commitAuthorOld": "Ted Yu",
      "daysBetweenCommits": 270.6,
      "commitsBetweenForRepo": 1924,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,127 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n     long listingStart \u003d System.currentTimeMillis();\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n     long sourceListingCompleted \u003d System.currentTimeMillis();\n     LOG.info(\"Source listing completed in {}\",\n         formatDuration(sourceListingCompleted - listingStart));\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n \n     Path targetFinalPath \u003d listTargetFiles(conf,\n         targetListing, sortedTargetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletionStart \u003d System.currentTimeMillis();\n     LOG.info(\"Destination listing completed in {}\",\n         formatDuration(deletionStart - sourceListingCompleted));\n \n     long deletedEntries \u003d 0;\n     long filesDeleted \u003d 0;\n     long missingDeletes \u003d 0;\n     long failedDeletes \u003d 0;\n     long skippedDeletes \u003d 0;\n     long deletedDirectories \u003d 0;\n     // this is an arbitrary constant.\n     final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean showProgress;\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n         Path targetEntry \u003d trgtFileStatus.getPath();\n         LOG.debug(\"Comparing {} and {}\",\n             srcFileStatus.getPath(), targetEntry);\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Try to delete it.\n         if (tracker.shouldDelete(trgtFileStatus)) {\n           showProgress \u003d true;\n           try {\n-            if (targetFS.delete(targetEntry, true)) {\n+            boolean result \u003d deletePath(targetFS, targetEntry, conf);\n+            if (result) {\n               // the delete worked. Unless the file is actually missing, this is the\n               LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n               deletedEntries++;\n               if (trgtFileStatus.isDirectory()) {\n                 deletedDirectories++;\n               } else {\n                 filesDeleted++;\n               }\n             } else {\n               // delete returned false.\n               // For all the filestores which implement the FS spec properly,\n               // this means \"the file wasn\u0027t there\".\n               // so track but don\u0027t worry about it.\n-              LOG.info(\"delete({}) returned false ({})\",\n+              LOG.info(\"delete({}) returned false ({}). Consider using \" +\n+                      \"-useTrash option if trash is enabled.\",\n                   targetEntry, trgtFileStatus);\n               missingDeletes++;\n             }\n           } catch (IOException e) {\n             if (!ignoreFailures) {\n               throw e;\n             } else {\n               // failed to delete, but ignoring errors. So continue\n               LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                   targetEntry, e.toString());\n               LOG.debug(\"Failed to delete {}\", targetEntry, e);\n               // count and break out the loop\n               failedDeletes++;\n             }\n           }\n         } else {\n           LOG.debug(\"Skipping deletion of {}\", targetEntry);\n           skippedDeletes++;\n           showProgress \u003d false;\n         }\n         if (showProgress) {\n           // update progress if there\u0027s been any FS IO/files deleted.\n           taskAttemptContext.progress();\n           taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n               targetReader.getPosition() * 100 / totalLen + \"%]\");\n         }\n       }\n       // if the FS toString() call prints statistics, they get logged here\n       LOG.info(\"Completed deletion of files from {}\", targetFS);\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     long deletionEnd \u003d System.currentTimeMillis();\n     long deletedFileCount \u003d deletedEntries - deletedDirectories;\n     LOG.info(\"Deleted from target: files: {} directories: {};\"\n             + \" skipped deletions {}; deletions already missing {};\"\n             + \" failed deletes {}\",\n         deletedFileCount, deletedDirectories, skippedDeletes,\n         missingDeletes, failedDeletes);\n     LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n     LOG.info(\"Duration of deletions: {}\",\n         formatDuration(deletionEnd - deletionStart));\n     LOG.info(\"Total duration of deletion operation: {}\",\n         formatDuration(deletionEnd - listingStart));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n    long listingStart \u003d System.currentTimeMillis();\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n    long sourceListingCompleted \u003d System.currentTimeMillis();\n    LOG.info(\"Source listing completed in {}\",\n        formatDuration(sourceListingCompleted - listingStart));\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n\n    Path targetFinalPath \u003d listTargetFiles(conf,\n        targetListing, sortedTargetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletionStart \u003d System.currentTimeMillis();\n    LOG.info(\"Destination listing completed in {}\",\n        formatDuration(deletionStart - sourceListingCompleted));\n\n    long deletedEntries \u003d 0;\n    long filesDeleted \u003d 0;\n    long missingDeletes \u003d 0;\n    long failedDeletes \u003d 0;\n    long skippedDeletes \u003d 0;\n    long deletedDirectories \u003d 0;\n    // this is an arbitrary constant.\n    final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean showProgress;\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n        Path targetEntry \u003d trgtFileStatus.getPath();\n        LOG.debug(\"Comparing {} and {}\",\n            srcFileStatus.getPath(), targetEntry);\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Try to delete it.\n        if (tracker.shouldDelete(trgtFileStatus)) {\n          showProgress \u003d true;\n          try {\n            boolean result \u003d deletePath(targetFS, targetEntry, conf);\n            if (result) {\n              // the delete worked. Unless the file is actually missing, this is the\n              LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n              deletedEntries++;\n              if (trgtFileStatus.isDirectory()) {\n                deletedDirectories++;\n              } else {\n                filesDeleted++;\n              }\n            } else {\n              // delete returned false.\n              // For all the filestores which implement the FS spec properly,\n              // this means \"the file wasn\u0027t there\".\n              // so track but don\u0027t worry about it.\n              LOG.info(\"delete({}) returned false ({}). Consider using \" +\n                      \"-useTrash option if trash is enabled.\",\n                  targetEntry, trgtFileStatus);\n              missingDeletes++;\n            }\n          } catch (IOException e) {\n            if (!ignoreFailures) {\n              throw e;\n            } else {\n              // failed to delete, but ignoring errors. So continue\n              LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                  targetEntry, e.toString());\n              LOG.debug(\"Failed to delete {}\", targetEntry, e);\n              // count and break out the loop\n              failedDeletes++;\n            }\n          }\n        } else {\n          LOG.debug(\"Skipping deletion of {}\", targetEntry);\n          skippedDeletes++;\n          showProgress \u003d false;\n        }\n        if (showProgress) {\n          // update progress if there\u0027s been any FS IO/files deleted.\n          taskAttemptContext.progress();\n          taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n              targetReader.getPosition() * 100 / totalLen + \"%]\");\n        }\n      }\n      // if the FS toString() call prints statistics, they get logged here\n      LOG.info(\"Completed deletion of files from {}\", targetFS);\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    long deletionEnd \u003d System.currentTimeMillis();\n    long deletedFileCount \u003d deletedEntries - deletedDirectories;\n    LOG.info(\"Deleted from target: files: {} directories: {};\"\n            + \" skipped deletions {}; deletions already missing {};\"\n            + \" failed deletes {}\",\n        deletedFileCount, deletedDirectories, skippedDeletes,\n        missingDeletes, failedDeletes);\n    LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n    LOG.info(\"Duration of deletions: {}\",\n        formatDuration(deletionEnd - deletionStart));\n    LOG.info(\"Total duration of deletion operation: {}\",\n        formatDuration(deletionEnd - listingStart));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "ca8b80bf59c0570bb9172208d3a6c993a6854514": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15384. distcp numListstatusThreads option doesn\u0027t get to -delete scan.\nContributed by Steve Loughran.\n",
      "commitDate": "10/07/18 2:43 AM",
      "commitName": "ca8b80bf59c0570bb9172208d3a6c993a6854514",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "15/03/18 11:05 AM",
      "commitNameOld": "1976e0066e9ae8852715fa69d8aea3769330e933",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 116.65,
      "commitsBetweenForRepo": 1436,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,125 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n     long listingStart \u003d System.currentTimeMillis();\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n+    long sourceListingCompleted \u003d System.currentTimeMillis();\n+    LOG.info(\"Source listing completed in {}\",\n+        formatDuration(sourceListingCompleted - listingStart));\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n \n     Path targetFinalPath \u003d listTargetFiles(conf,\n         targetListing, sortedTargetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletionStart \u003d System.currentTimeMillis();\n-    LOG.info(\"Listing completed in {}\",\n-        formatDuration(deletionStart - listingStart));\n+    LOG.info(\"Destination listing completed in {}\",\n+        formatDuration(deletionStart - sourceListingCompleted));\n \n     long deletedEntries \u003d 0;\n     long filesDeleted \u003d 0;\n     long missingDeletes \u003d 0;\n     long failedDeletes \u003d 0;\n     long skippedDeletes \u003d 0;\n     long deletedDirectories \u003d 0;\n     // this is an arbitrary constant.\n     final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean showProgress;\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n         Path targetEntry \u003d trgtFileStatus.getPath();\n         LOG.debug(\"Comparing {} and {}\",\n             srcFileStatus.getPath(), targetEntry);\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Try to delete it.\n         if (tracker.shouldDelete(trgtFileStatus)) {\n           showProgress \u003d true;\n           try {\n             if (targetFS.delete(targetEntry, true)) {\n               // the delete worked. Unless the file is actually missing, this is the\n               LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n               deletedEntries++;\n               if (trgtFileStatus.isDirectory()) {\n                 deletedDirectories++;\n               } else {\n                 filesDeleted++;\n               }\n             } else {\n               // delete returned false.\n               // For all the filestores which implement the FS spec properly,\n               // this means \"the file wasn\u0027t there\".\n               // so track but don\u0027t worry about it.\n               LOG.info(\"delete({}) returned false ({})\",\n                   targetEntry, trgtFileStatus);\n               missingDeletes++;\n             }\n           } catch (IOException e) {\n             if (!ignoreFailures) {\n               throw e;\n             } else {\n               // failed to delete, but ignoring errors. So continue\n               LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                   targetEntry, e.toString());\n               LOG.debug(\"Failed to delete {}\", targetEntry, e);\n               // count and break out the loop\n               failedDeletes++;\n             }\n           }\n         } else {\n           LOG.debug(\"Skipping deletion of {}\", targetEntry);\n           skippedDeletes++;\n           showProgress \u003d false;\n         }\n         if (showProgress) {\n           // update progress if there\u0027s been any FS IO/files deleted.\n           taskAttemptContext.progress();\n           taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n               targetReader.getPosition() * 100 / totalLen + \"%]\");\n         }\n       }\n       // if the FS toString() call prints statistics, they get logged here\n       LOG.info(\"Completed deletion of files from {}\", targetFS);\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     long deletionEnd \u003d System.currentTimeMillis();\n     long deletedFileCount \u003d deletedEntries - deletedDirectories;\n     LOG.info(\"Deleted from target: files: {} directories: {};\"\n             + \" skipped deletions {}; deletions already missing {};\"\n             + \" failed deletes {}\",\n         deletedFileCount, deletedDirectories, skippedDeletes,\n         missingDeletes, failedDeletes);\n     LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n     LOG.info(\"Duration of deletions: {}\",\n         formatDuration(deletionEnd - deletionStart));\n     LOG.info(\"Total duration of deletion operation: {}\",\n         formatDuration(deletionEnd - listingStart));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n    long listingStart \u003d System.currentTimeMillis();\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n    long sourceListingCompleted \u003d System.currentTimeMillis();\n    LOG.info(\"Source listing completed in {}\",\n        formatDuration(sourceListingCompleted - listingStart));\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n\n    Path targetFinalPath \u003d listTargetFiles(conf,\n        targetListing, sortedTargetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletionStart \u003d System.currentTimeMillis();\n    LOG.info(\"Destination listing completed in {}\",\n        formatDuration(deletionStart - sourceListingCompleted));\n\n    long deletedEntries \u003d 0;\n    long filesDeleted \u003d 0;\n    long missingDeletes \u003d 0;\n    long failedDeletes \u003d 0;\n    long skippedDeletes \u003d 0;\n    long deletedDirectories \u003d 0;\n    // this is an arbitrary constant.\n    final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean showProgress;\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n        Path targetEntry \u003d trgtFileStatus.getPath();\n        LOG.debug(\"Comparing {} and {}\",\n            srcFileStatus.getPath(), targetEntry);\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Try to delete it.\n        if (tracker.shouldDelete(trgtFileStatus)) {\n          showProgress \u003d true;\n          try {\n            if (targetFS.delete(targetEntry, true)) {\n              // the delete worked. Unless the file is actually missing, this is the\n              LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n              deletedEntries++;\n              if (trgtFileStatus.isDirectory()) {\n                deletedDirectories++;\n              } else {\n                filesDeleted++;\n              }\n            } else {\n              // delete returned false.\n              // For all the filestores which implement the FS spec properly,\n              // this means \"the file wasn\u0027t there\".\n              // so track but don\u0027t worry about it.\n              LOG.info(\"delete({}) returned false ({})\",\n                  targetEntry, trgtFileStatus);\n              missingDeletes++;\n            }\n          } catch (IOException e) {\n            if (!ignoreFailures) {\n              throw e;\n            } else {\n              // failed to delete, but ignoring errors. So continue\n              LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                  targetEntry, e.toString());\n              LOG.debug(\"Failed to delete {}\", targetEntry, e);\n              // count and break out the loop\n              failedDeletes++;\n            }\n          }\n        } else {\n          LOG.debug(\"Skipping deletion of {}\", targetEntry);\n          skippedDeletes++;\n          showProgress \u003d false;\n        }\n        if (showProgress) {\n          // update progress if there\u0027s been any FS IO/files deleted.\n          taskAttemptContext.progress();\n          taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n              targetReader.getPosition() * 100 / totalLen + \"%]\");\n        }\n      }\n      // if the FS toString() call prints statistics, they get logged here\n      LOG.info(\"Completed deletion of files from {}\", targetFS);\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    long deletionEnd \u003d System.currentTimeMillis();\n    long deletedFileCount \u003d deletedEntries - deletedDirectories;\n    LOG.info(\"Deleted from target: files: {} directories: {};\"\n            + \" skipped deletions {}; deletions already missing {};\"\n            + \" failed deletes {}\",\n        deletedFileCount, deletedDirectories, skippedDeletes,\n        missingDeletes, failedDeletes);\n    LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n    LOG.info(\"Duration of deletions: {}\",\n        formatDuration(deletionEnd - deletionStart));\n    LOG.info(\"Total duration of deletion operation: {}\",\n        formatDuration(deletionEnd - listingStart));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "1976e0066e9ae8852715fa69d8aea3769330e933": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15209. DistCp to eliminate needless deletion of files under already-deleted directories.\nContributed by Steve Loughran.\n",
      "commitDate": "15/03/18 11:05 AM",
      "commitName": "1976e0066e9ae8852715fa69d8aea3769330e933",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "31/03/17 8:04 PM",
      "commitNameOld": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 348.63,
      "commitsBetweenForRepo": 2337,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,122 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n+    long listingStart \u003d System.currentTimeMillis();\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n-    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n+    Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n-    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n+    Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n \n-    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n-    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n-    targets.add(targetFinalPath);\n-    Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n-        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n-        ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n-    //\n-    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n-    // so to collect similar listings as when doing the copy\n-    //\n-    DistCpOptions options \u003d new DistCpOptions.Builder(targets, resultNonePath)\n-        .withOverwrite(overwrite)\n-        .withSyncFolder(syncFolder)\n-        .build();\n-    DistCpContext distCpContext \u003d new DistCpContext(options);\n-    distCpContext.setTargetPathExists(targetPathExists);\n-\n-    target.buildListing(targetListing, distCpContext);\n-    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n+    Path targetFinalPath \u003d listTargetFiles(conf,\n+        targetListing, sortedTargetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n+    long deletionStart \u003d System.currentTimeMillis();\n+    LOG.info(\"Listing completed in {}\",\n+        formatDuration(deletionStart - listingStart));\n+\n     long deletedEntries \u003d 0;\n+    long filesDeleted \u003d 0;\n+    long missingDeletes \u003d 0;\n+    long failedDeletes \u003d 0;\n+    long skippedDeletes \u003d 0;\n+    long deletedDirectories \u003d 0;\n+    // this is an arbitrary constant.\n+    final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n-      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n+      final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n+      boolean showProgress;\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n+        Path targetEntry \u003d trgtFileStatus.getPath();\n+        LOG.debug(\"Comparing {} and {}\",\n+            srcFileStatus.getPath(), targetEntry);\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n-        // Target doesn\u0027t exist at source. Delete.\n-        boolean result \u003d targetFS.delete(trgtFileStatus.getPath(), true)\n-            || !targetFS.exists(trgtFileStatus.getPath());\n-        if (result) {\n-          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n-          deletedEntries++;\n+        // Target doesn\u0027t exist at source. Try to delete it.\n+        if (tracker.shouldDelete(trgtFileStatus)) {\n+          showProgress \u003d true;\n+          try {\n+            if (targetFS.delete(targetEntry, true)) {\n+              // the delete worked. Unless the file is actually missing, this is the\n+              LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n+              deletedEntries++;\n+              if (trgtFileStatus.isDirectory()) {\n+                deletedDirectories++;\n+              } else {\n+                filesDeleted++;\n+              }\n+            } else {\n+              // delete returned false.\n+              // For all the filestores which implement the FS spec properly,\n+              // this means \"the file wasn\u0027t there\".\n+              // so track but don\u0027t worry about it.\n+              LOG.info(\"delete({}) returned false ({})\",\n+                  targetEntry, trgtFileStatus);\n+              missingDeletes++;\n+            }\n+          } catch (IOException e) {\n+            if (!ignoreFailures) {\n+              throw e;\n+            } else {\n+              // failed to delete, but ignoring errors. So continue\n+              LOG.info(\"Failed to delete {}, ignoring exception {}\",\n+                  targetEntry, e.toString());\n+              LOG.debug(\"Failed to delete {}\", targetEntry, e);\n+              // count and break out the loop\n+              failedDeletes++;\n+            }\n+          }\n         } else {\n-          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n+          LOG.debug(\"Skipping deletion of {}\", targetEntry);\n+          skippedDeletes++;\n+          showProgress \u003d false;\n         }\n-        taskAttemptContext.progress();\n-        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n-            targetReader.getPosition() * 100 / totalLen + \"%]\");\n+        if (showProgress) {\n+          // update progress if there\u0027s been any FS IO/files deleted.\n+          taskAttemptContext.progress();\n+          taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n+              targetReader.getPosition() * 100 / totalLen + \"%]\");\n+        }\n       }\n+      // if the FS toString() call prints statistics, they get logged here\n+      LOG.info(\"Completed deletion of files from {}\", targetFS);\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n-    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n+    long deletionEnd \u003d System.currentTimeMillis();\n+    long deletedFileCount \u003d deletedEntries - deletedDirectories;\n+    LOG.info(\"Deleted from target: files: {} directories: {};\"\n+            + \" skipped deletions {}; deletions already missing {};\"\n+            + \" failed deletes {}\",\n+        deletedFileCount, deletedDirectories, skippedDeletes,\n+        missingDeletes, failedDeletes);\n+    LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n+    LOG.info(\"Duration of deletions: {}\",\n+        formatDuration(deletionEnd - deletionStart));\n+    LOG.info(\"Total duration of deletion operation: {}\",\n+        formatDuration(deletionEnd - listingStart));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n    long listingStart \u003d System.currentTimeMillis();\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    Path sortedTargetListing \u003d new Path(targetListing.toString() + \"_sorted\");\n\n    Path targetFinalPath \u003d listTargetFiles(conf,\n        targetListing, sortedTargetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletionStart \u003d System.currentTimeMillis();\n    LOG.info(\"Listing completed in {}\",\n        formatDuration(deletionStart - listingStart));\n\n    long deletedEntries \u003d 0;\n    long filesDeleted \u003d 0;\n    long missingDeletes \u003d 0;\n    long failedDeletes \u003d 0;\n    long skippedDeletes \u003d 0;\n    long deletedDirectories \u003d 0;\n    // this is an arbitrary constant.\n    final DeletedDirTracker tracker \u003d new DeletedDirTracker(1000);\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      final FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean showProgress;\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n        Path targetEntry \u003d trgtFileStatus.getPath();\n        LOG.debug(\"Comparing {} and {}\",\n            srcFileStatus.getPath(), targetEntry);\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Try to delete it.\n        if (tracker.shouldDelete(trgtFileStatus)) {\n          showProgress \u003d true;\n          try {\n            if (targetFS.delete(targetEntry, true)) {\n              // the delete worked. Unless the file is actually missing, this is the\n              LOG.info(\"Deleted \" + targetEntry + \" - missing at source\");\n              deletedEntries++;\n              if (trgtFileStatus.isDirectory()) {\n                deletedDirectories++;\n              } else {\n                filesDeleted++;\n              }\n            } else {\n              // delete returned false.\n              // For all the filestores which implement the FS spec properly,\n              // this means \"the file wasn\u0027t there\".\n              // so track but don\u0027t worry about it.\n              LOG.info(\"delete({}) returned false ({})\",\n                  targetEntry, trgtFileStatus);\n              missingDeletes++;\n            }\n          } catch (IOException e) {\n            if (!ignoreFailures) {\n              throw e;\n            } else {\n              // failed to delete, but ignoring errors. So continue\n              LOG.info(\"Failed to delete {}, ignoring exception {}\",\n                  targetEntry, e.toString());\n              LOG.debug(\"Failed to delete {}\", targetEntry, e);\n              // count and break out the loop\n              failedDeletes++;\n            }\n          }\n        } else {\n          LOG.debug(\"Skipping deletion of {}\", targetEntry);\n          skippedDeletes++;\n          showProgress \u003d false;\n        }\n        if (showProgress) {\n          // update progress if there\u0027s been any FS IO/files deleted.\n          taskAttemptContext.progress();\n          taskAttemptContext.setStatus(\"Deleting removed files from target. [\" +\n              targetReader.getPosition() * 100 / totalLen + \"%]\");\n        }\n      }\n      // if the FS toString() call prints statistics, they get logged here\n      LOG.info(\"Completed deletion of files from {}\", targetFS);\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    long deletionEnd \u003d System.currentTimeMillis();\n    long deletedFileCount \u003d deletedEntries - deletedDirectories;\n    LOG.info(\"Deleted from target: files: {} directories: {};\"\n            + \" skipped deletions {}; deletions already missing {};\"\n            + \" failed deletes {}\",\n        deletedFileCount, deletedDirectories, skippedDeletes,\n        missingDeletes, failedDeletes);\n    LOG.info(\"Number of tracked deleted directories {}\", tracker.size());\n    LOG.info(\"Duration of deletions: {}\",\n        formatDuration(deletionEnd - deletionStart));\n    LOG.info(\"Total duration of deletion operation: {}\",\n        formatDuration(deletionEnd - listingStart));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
      "commitDate": "31/03/17 8:04 PM",
      "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "30/03/17 5:38 PM",
      "commitNameOld": "bf3fb585aaf2b179836e139c041fc87920a3c886",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,77 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n \n     List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n     Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n     targets.add(targetFinalPath);\n     Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n         .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n         ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n-    DistCpOptions options \u003d new DistCpOptions(targets, resultNonePath);\n     //\n     // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n     // so to collect similar listings as when doing the copy\n     //\n-    options.setOverwrite(overwrite);\n-    options.setSyncFolder(syncFolder);\n-    options.setTargetPathExists(targetPathExists);\n-    \n-    target.buildListing(targetListing, options);\n+    DistCpOptions options \u003d new DistCpOptions.Builder(targets, resultNonePath)\n+        .withOverwrite(overwrite)\n+        .withSyncFolder(syncFolder)\n+        .build();\n+    DistCpContext distCpContext \u003d new DistCpContext(options);\n+    distCpContext.setTargetPathExists(targetPathExists);\n+\n+    target.buildListing(targetListing, distCpContext);\n     Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletedEntries \u003d 0;\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Delete.\n         boolean result \u003d targetFS.delete(trgtFileStatus.getPath(), true)\n             || !targetFS.exists(trgtFileStatus.getPath());\n         if (result) {\n           LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n           deletedEntries++;\n         } else {\n           throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n         }\n         taskAttemptContext.progress();\n         taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n             targetReader.getPosition() * 100 / totalLen + \"%]\");\n       }\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n\n    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n    targets.add(targetFinalPath);\n    Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n        ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n    //\n    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n    // so to collect similar listings as when doing the copy\n    //\n    DistCpOptions options \u003d new DistCpOptions.Builder(targets, resultNonePath)\n        .withOverwrite(overwrite)\n        .withSyncFolder(syncFolder)\n        .build();\n    DistCpContext distCpContext \u003d new DistCpContext(options);\n    distCpContext.setTargetPathExists(targetPathExists);\n\n    target.buildListing(targetListing, distCpContext);\n    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletedEntries \u003d 0;\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Delete.\n        boolean result \u003d targetFS.delete(trgtFileStatus.getPath(), true)\n            || !targetFS.exists(trgtFileStatus.getPath());\n        if (result) {\n          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n          deletedEntries++;\n        } else {\n          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n        }\n        taskAttemptContext.progress();\n        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n            targetReader.getPosition() * 100 / totalLen + \"%]\");\n      }\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "5af572b6443715b7a741296c1bd520a1840f9a7c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13427. Eliminate needless uses of FileSystem#{exists(), isFile(), isDirectory()}. Contributed by Steve Loughran and Mingliang Liu\n",
      "commitDate": "15/11/16 10:57 AM",
      "commitName": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "13/10/16 1:24 PM",
      "commitNameOld": "0a85d079838f532a13ca237300386d1b3bc1b178",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 32.94,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n \n     List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n     Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n     targets.add(targetFinalPath);\n     Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n         .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n         ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n     DistCpOptions options \u003d new DistCpOptions(targets, resultNonePath);\n     //\n     // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n     // so to collect similar listings as when doing the copy\n     //\n     options.setOverwrite(overwrite);\n     options.setSyncFolder(syncFolder);\n     options.setTargetPathExists(targetPathExists);\n     \n     target.buildListing(targetListing, options);\n     Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletedEntries \u003d 0;\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Delete.\n-        boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n-            targetFS.delete(trgtFileStatus.getPath(), true));\n+        boolean result \u003d targetFS.delete(trgtFileStatus.getPath(), true)\n+            || !targetFS.exists(trgtFileStatus.getPath());\n         if (result) {\n           LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n           deletedEntries++;\n         } else {\n           throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n         }\n         taskAttemptContext.progress();\n         taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n             targetReader.getPosition() * 100 / totalLen + \"%]\");\n       }\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n\n    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n    targets.add(targetFinalPath);\n    Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n        ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n    DistCpOptions options \u003d new DistCpOptions(targets, resultNonePath);\n    //\n    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n    // so to collect similar listings as when doing the copy\n    //\n    options.setOverwrite(overwrite);\n    options.setSyncFolder(syncFolder);\n    options.setTargetPathExists(targetPathExists);\n    \n    target.buildListing(targetListing, options);\n    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletedEntries \u003d 0;\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Delete.\n        boolean result \u003d targetFS.delete(trgtFileStatus.getPath(), true)\n            || !targetFS.exists(trgtFileStatus.getPath());\n        if (result) {\n          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n          deletedEntries++;\n        } else {\n          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n        }\n        taskAttemptContext.progress();\n        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n            targetReader.getPosition() * 100 / totalLen + \"%]\");\n      }\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "0a85d079838f532a13ca237300386d1b3bc1b178": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13024. Distcp with -delete feature on raw data not implemented. Contributed by Mavin Martin.\n",
      "commitDate": "13/10/16 1:24 PM",
      "commitName": "0a85d079838f532a13ca237300386d1b3bc1b178",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "11/01/16 9:46 AM",
      "commitNameOld": "95f32015ad9273420299130a9f10acdbafe63556",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 276.11,
      "commitsBetweenForRepo": 1957,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,75 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n \n     List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n     Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n     targets.add(targetFinalPath);\n-    DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n+    Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n+        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n+        ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n+    DistCpOptions options \u003d new DistCpOptions(targets, resultNonePath);\n     //\n     // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n     // so to collect similar listings as when doing the copy\n     //\n     options.setOverwrite(overwrite);\n     options.setSyncFolder(syncFolder);\n     options.setTargetPathExists(targetPathExists);\n     \n     target.buildListing(targetListing, options);\n     Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletedEntries \u003d 0;\n     try {\n       CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n       CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Delete.\n         boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n             targetFS.delete(trgtFileStatus.getPath(), true));\n         if (result) {\n           LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n           deletedEntries++;\n         } else {\n           throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n         }\n         taskAttemptContext.progress();\n         taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n             targetReader.getPosition() * 100 / totalLen + \"%]\");\n       }\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n\n    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n    targets.add(targetFinalPath);\n    Path resultNonePath \u003d Path.getPathWithoutSchemeAndAuthority(targetFinalPath)\n        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)\n        ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;\n    DistCpOptions options \u003d new DistCpOptions(targets, resultNonePath);\n    //\n    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n    // so to collect similar listings as when doing the copy\n    //\n    options.setOverwrite(overwrite);\n    options.setSyncFolder(syncFolder);\n    options.setTargetPathExists(targetPathExists);\n    \n    target.buildListing(targetListing, options);\n    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletedEntries \u003d 0;\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Delete.\n        boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n            targetFS.delete(trgtFileStatus.getPath(), true));\n        if (result) {\n          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n          deletedEntries++;\n        } else {\n          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n        }\n        taskAttemptContext.progress();\n        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n            targetReader.getPosition() * 100 / totalLen + \"%]\");\n      }\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/14 11:25 AM",
      "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "02/04/14 5:32 PM",
      "commitNameOld": "640a097533e0883bf49504673228d5a327089b44",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 43.75,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n \n     List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n     Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n     targets.add(targetFinalPath);\n     DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n     //\n     // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n     // so to collect similar listings as when doing the copy\n     //\n     options.setOverwrite(overwrite);\n     options.setSyncFolder(syncFolder);\n     options.setTargetPathExists(targetPathExists);\n     \n     target.buildListing(targetListing, options);\n     Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletedEntries \u003d 0;\n     try {\n-      FileStatus srcFileStatus \u003d new FileStatus();\n+      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n       Text srcRelPath \u003d new Text();\n-      FileStatus trgtFileStatus \u003d new FileStatus();\n+      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Delete.\n         boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n             targetFS.delete(trgtFileStatus.getPath(), true));\n         if (result) {\n           LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n           deletedEntries++;\n         } else {\n           throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n         }\n         taskAttemptContext.progress();\n         taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n             targetReader.getPosition() * 100 / totalLen + \"%]\");\n       }\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n\n    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n    targets.add(targetFinalPath);\n    DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n    //\n    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n    // so to collect similar listings as when doing the copy\n    //\n    options.setOverwrite(overwrite);\n    options.setSyncFolder(syncFolder);\n    options.setTargetPathExists(targetPathExists);\n    \n    target.buildListing(targetListing, options);\n    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletedEntries \u003d 0;\n    try {\n      CopyListingFileStatus srcFileStatus \u003d new CopyListingFileStatus();\n      Text srcRelPath \u003d new Text();\n      CopyListingFileStatus trgtFileStatus \u003d new CopyListingFileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Delete.\n        boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n            targetFS.delete(trgtFileStatus.getPath(), true));\n        if (result) {\n          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n          deletedEntries++;\n        } else {\n          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n        }\n        taskAttemptContext.progress();\n        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n            targetReader.getPosition() * 100 / totalLen + \"%]\");\n      }\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "640a097533e0883bf49504673228d5a327089b44": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10459. distcp V2 doesn\u0027t preserve root dir\u0027s attributes when -p is specified. Contributed by Yongjun Zhang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1584227 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/14 5:32 PM",
      "commitName": "640a097533e0883bf49504673228d5a327089b44",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "25/01/12 10:36 PM",
      "commitNameOld": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 797.75,
      "commitsBetweenForRepo": 5080,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,72 @@\n   private void deleteMissing(Configuration conf) throws IOException {\n     LOG.info(\"-delete option is enabled. About to remove entries from \" +\n         \"target that are missing in source\");\n \n     // Sort the source-file listing alphabetically.\n     Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n     FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n     Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n \n     // Similarly, create the listing of target-files. Sort alphabetically.\n     Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n     CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n \n     List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n     Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n     targets.add(targetFinalPath);\n     DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n-\n+    //\n+    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n+    // so to collect similar listings as when doing the copy\n+    //\n+    options.setOverwrite(overwrite);\n+    options.setSyncFolder(syncFolder);\n+    options.setTargetPathExists(targetPathExists);\n+    \n     target.buildListing(targetListing, options);\n     Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n     long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n \n     SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedSourceListing));\n     SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                  SequenceFile.Reader.file(sortedTargetListing));\n \n     // Walk both source and target file listings.\n     // Delete all from target that doesn\u0027t also exist on source.\n     long deletedEntries \u003d 0;\n     try {\n       FileStatus srcFileStatus \u003d new FileStatus();\n       Text srcRelPath \u003d new Text();\n       FileStatus trgtFileStatus \u003d new FileStatus();\n       Text trgtRelPath \u003d new Text();\n \n       FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n       boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n       while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n         // Skip sources that don\u0027t exist on target.\n         while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n           srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n         }\n \n         if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n \n         // Target doesn\u0027t exist at source. Delete.\n         boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n             targetFS.delete(trgtFileStatus.getPath(), true));\n         if (result) {\n           LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n           deletedEntries++;\n         } else {\n           throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n         }\n         taskAttemptContext.progress();\n         taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n             targetReader.getPosition() * 100 / totalLen + \"%]\");\n       }\n     } finally {\n       IOUtils.closeStream(sourceReader);\n       IOUtils.closeStream(targetReader);\n     }\n     LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n\n    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n    targets.add(targetFinalPath);\n    DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n    //\n    // Set up options to be the same from the CopyListing.buildListing\u0027s perspective,\n    // so to collect similar listings as when doing the copy\n    //\n    options.setOverwrite(overwrite);\n    options.setSyncFolder(syncFolder);\n    options.setTargetPathExists(targetPathExists);\n    \n    target.buildListing(targetListing, options);\n    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletedEntries \u003d 0;\n    try {\n      FileStatus srcFileStatus \u003d new FileStatus();\n      Text srcRelPath \u003d new Text();\n      FileStatus trgtFileStatus \u003d new FileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Delete.\n        boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n            targetFS.delete(trgtFileStatus.getPath(), true));\n        if (result) {\n          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n          deletedEntries++;\n        } else {\n          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n        }\n        taskAttemptContext.progress();\n        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n            targetReader.getPosition() * 100 / totalLen + \"%]\");\n      }\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java",
      "extendedDetails": {}
    },
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2765. DistCp Rewrite. (Mithun Radhakrishnan via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236045 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 10:36 PM",
      "commitName": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthor": "Mahadev Konar",
      "diff": "@@ -0,0 +1,65 @@\n+  private void deleteMissing(Configuration conf) throws IOException {\n+    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n+        \"target that are missing in source\");\n+\n+    // Sort the source-file listing alphabetically.\n+    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n+    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n+    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n+\n+    // Similarly, create the listing of target-files. Sort alphabetically.\n+    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n+    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n+\n+    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n+    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n+    targets.add(targetFinalPath);\n+    DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n+\n+    target.buildListing(targetListing, options);\n+    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n+    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n+\n+    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n+                                 SequenceFile.Reader.file(sortedSourceListing));\n+    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n+                                 SequenceFile.Reader.file(sortedTargetListing));\n+\n+    // Walk both source and target file listings.\n+    // Delete all from target that doesn\u0027t also exist on source.\n+    long deletedEntries \u003d 0;\n+    try {\n+      FileStatus srcFileStatus \u003d new FileStatus();\n+      Text srcRelPath \u003d new Text();\n+      FileStatus trgtFileStatus \u003d new FileStatus();\n+      Text trgtRelPath \u003d new Text();\n+\n+      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n+      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n+      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n+        // Skip sources that don\u0027t exist on target.\n+        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n+          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n+        }\n+\n+        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n+\n+        // Target doesn\u0027t exist at source. Delete.\n+        boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n+            targetFS.delete(trgtFileStatus.getPath(), true));\n+        if (result) {\n+          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n+          deletedEntries++;\n+        } else {\n+          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n+        }\n+        taskAttemptContext.progress();\n+        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n+            targetReader.getPosition() * 100 / totalLen + \"%]\");\n+      }\n+    } finally {\n+      IOUtils.closeStream(sourceReader);\n+      IOUtils.closeStream(targetReader);\n+    }\n+    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void deleteMissing(Configuration conf) throws IOException {\n    LOG.info(\"-delete option is enabled. About to remove entries from \" +\n        \"target that are missing in source\");\n\n    // Sort the source-file listing alphabetically.\n    Path sourceListing \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));\n    FileSystem clusterFS \u003d sourceListing.getFileSystem(conf);\n    Path sortedSourceListing \u003d DistCpUtils.sortListing(clusterFS, conf, sourceListing);\n\n    // Similarly, create the listing of target-files. Sort alphabetically.\n    Path targetListing \u003d new Path(sourceListing.getParent(), \"targetListing.seq\");\n    CopyListing target \u003d new GlobbedCopyListing(new Configuration(conf), null);\n\n    List\u003cPath\u003e targets \u003d new ArrayList\u003cPath\u003e(1);\n    Path targetFinalPath \u003d new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));\n    targets.add(targetFinalPath);\n    DistCpOptions options \u003d new DistCpOptions(targets, new Path(\"/NONE\"));\n\n    target.buildListing(targetListing, options);\n    Path sortedTargetListing \u003d DistCpUtils.sortListing(clusterFS, conf, targetListing);\n    long totalLen \u003d clusterFS.getFileStatus(sortedTargetListing).getLen();\n\n    SequenceFile.Reader sourceReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedSourceListing));\n    SequenceFile.Reader targetReader \u003d new SequenceFile.Reader(conf,\n                                 SequenceFile.Reader.file(sortedTargetListing));\n\n    // Walk both source and target file listings.\n    // Delete all from target that doesn\u0027t also exist on source.\n    long deletedEntries \u003d 0;\n    try {\n      FileStatus srcFileStatus \u003d new FileStatus();\n      Text srcRelPath \u003d new Text();\n      FileStatus trgtFileStatus \u003d new FileStatus();\n      Text trgtRelPath \u003d new Text();\n\n      FileSystem targetFS \u003d targetFinalPath.getFileSystem(conf);\n      boolean srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n      while (targetReader.next(trgtRelPath, trgtFileStatus)) {\n        // Skip sources that don\u0027t exist on target.\n        while (srcAvailable \u0026\u0026 trgtRelPath.compareTo(srcRelPath) \u003e 0) {\n          srcAvailable \u003d sourceReader.next(srcRelPath, srcFileStatus);\n        }\n\n        if (srcAvailable \u0026\u0026 trgtRelPath.equals(srcRelPath)) continue;\n\n        // Target doesn\u0027t exist at source. Delete.\n        boolean result \u003d (!targetFS.exists(trgtFileStatus.getPath()) ||\n            targetFS.delete(trgtFileStatus.getPath(), true));\n        if (result) {\n          LOG.info(\"Deleted \" + trgtFileStatus.getPath() + \" - Missing at source\");\n          deletedEntries++;\n        } else {\n          throw new IOException(\"Unable to delete \" + trgtFileStatus.getPath());\n        }\n        taskAttemptContext.progress();\n        taskAttemptContext.setStatus(\"Deleting missing files from target. [\" +\n            targetReader.getPosition() * 100 / totalLen + \"%]\");\n      }\n    } finally {\n      IOUtils.closeStream(sourceReader);\n      IOUtils.closeStream(targetReader);\n    }\n    LOG.info(\"Deleted \" + deletedEntries + \" from target: \" + targets.get(0));\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/CopyCommitter.java"
    }
  }
}