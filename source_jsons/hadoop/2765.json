{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractNNFailoverProxyProvider.java",
  "functionName": "getResolvedHostsIfNecessary",
  "functionId": "getResolvedHostsIfNecessary___addressesOfNns-Collection__InetSocketAddress____nameNodeUri-URI",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
  "functionStartLine": 212,
  "functionEndLine": 251,
  "numCommitsSeen": 21,
  "timeTaken": 2398,
  "changeHistory": [
    "ecc8acfd242ab933d2bd616fffacacca9011a6b1",
    "7b5b783f66f32012c00bef7593851392dd8cf2d5",
    "f7a27cdee4e6829ebea4ea965e549a27acbf4310"
  ],
  "changeHistoryShort": {
    "ecc8acfd242ab933d2bd616fffacacca9011a6b1": "Ybodychange",
    "7b5b783f66f32012c00bef7593851392dd8cf2d5": "Ymultichange(Yrename,Ybodychange)",
    "f7a27cdee4e6829ebea4ea965e549a27acbf4310": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ecc8acfd242ab933d2bd616fffacacca9011a6b1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14673. The console log is noisy when using DNSDomainNameResolver to resolve NameNode.\n\n",
      "commitDate": "26/07/19 11:08 AM",
      "commitName": "ecc8acfd242ab933d2bd616fffacacca9011a6b1",
      "commitAuthor": "HUAN-PING SU",
      "commitDateOld": "13/05/19 8:39 AM",
      "commitNameOld": "5847e0014343f60f853cb796781ca1fa03a72efd",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 74.1,
      "commitsBetweenForRepo": 576,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   Collection\u003cInetSocketAddress\u003e getResolvedHostsIfNecessary(\n       Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n           throws IOException {\n     // \u0027host\u0027 here is usually the ID of the nameservice when address\n     // resolving is needed.\n     String host \u003d nameNodeUri.getHost();\n     String configKeyWithHost \u003d\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n     boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n     if (!resolveNeeded) {\n       // Early return is no resolve is necessary\n       return addressesOfNns;\n     }\n     // decide whether to access server by IP or by host name\n     String useFQDNKeyWithHost \u003d\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN + \".\" + host;\n     boolean requireFQDN \u003d conf.getBoolean(useFQDNKeyWithHost,\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN_DEFAULT);\n \n     Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n     DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n           conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n     // If the address needs to be resolved, get all of the IP addresses\n     // from this address and pass them into the proxy\n-    LOG.info(\"Namenode domain name will be resolved with {}\",\n+    LOG.debug(\"Namenode domain name will be resolved with {}\",\n         dnr.getClass().getName());\n     for (InetSocketAddress address : addressesOfNns) {\n       String[] resolvedHostNames \u003d dnr.getAllResolvedHostnameByDomainName(\n           address.getHostName(), requireFQDN);\n       int port \u003d address.getPort();\n       for (String hostname : resolvedHostNames) {\n         InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n             hostname, port);\n         addressOfResolvedNns.add(resolvedAddress);\n       }\n     }\n \n     return addressOfResolvedNns;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Collection\u003cInetSocketAddress\u003e getResolvedHostsIfNecessary(\n      Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n          throws IOException {\n    // \u0027host\u0027 here is usually the ID of the nameservice when address\n    // resolving is needed.\n    String host \u003d nameNodeUri.getHost();\n    String configKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n    boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n    if (!resolveNeeded) {\n      // Early return is no resolve is necessary\n      return addressesOfNns;\n    }\n    // decide whether to access server by IP or by host name\n    String useFQDNKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN + \".\" + host;\n    boolean requireFQDN \u003d conf.getBoolean(useFQDNKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN_DEFAULT);\n\n    Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n    DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n          conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n    // If the address needs to be resolved, get all of the IP addresses\n    // from this address and pass them into the proxy\n    LOG.debug(\"Namenode domain name will be resolved with {}\",\n        dnr.getClass().getName());\n    for (InetSocketAddress address : addressesOfNns) {\n      String[] resolvedHostNames \u003d dnr.getAllResolvedHostnameByDomainName(\n          address.getHostName(), requireFQDN);\n      int port \u003d address.getPort();\n      for (String hostname : resolvedHostNames) {\n        InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n            hostname, port);\n        addressOfResolvedNns.add(resolvedAddress);\n      }\n    }\n\n    return addressOfResolvedNns;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "7b5b783f66f32012c00bef7593851392dd8cf2d5": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HDFS-14327. Using FQDN instead of IP to access servers with DNS resolving. Contributed by Fengnan Li.\n",
      "commitDate": "03/04/19 4:11 PM",
      "commitName": "7b5b783f66f32012c00bef7593851392dd8cf2d5",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-14327. Using FQDN instead of IP to access servers with DNS resolving. Contributed by Fengnan Li.\n",
          "commitDate": "03/04/19 4:11 PM",
          "commitName": "7b5b783f66f32012c00bef7593851392dd8cf2d5",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "23/02/19 9:35 AM",
          "commitNameOld": "f7a27cdee4e6829ebea4ea965e549a27acbf4310",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 39.23,
          "commitsBetweenForRepo": 331,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,40 @@\n-  Collection\u003cInetSocketAddress\u003e getResolvedAddressesIfNecessary(\n+  Collection\u003cInetSocketAddress\u003e getResolvedHostsIfNecessary(\n       Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n           throws IOException {\n     // \u0027host\u0027 here is usually the ID of the nameservice when address\n     // resolving is needed.\n     String host \u003d nameNodeUri.getHost();\n     String configKeyWithHost \u003d\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n     boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n     if (!resolveNeeded) {\n       // Early return is no resolve is necessary\n       return addressesOfNns;\n     }\n+    // decide whether to access server by IP or by host name\n+    String useFQDNKeyWithHost \u003d\n+        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN + \".\" + host;\n+    boolean requireFQDN \u003d conf.getBoolean(useFQDNKeyWithHost,\n+        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN_DEFAULT);\n \n     Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n     DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n           conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n     // If the address needs to be resolved, get all of the IP addresses\n     // from this address and pass them into the proxy\n     LOG.info(\"Namenode domain name will be resolved with {}\",\n         dnr.getClass().getName());\n     for (InetSocketAddress address : addressesOfNns) {\n-      InetAddress[] resolvedAddresses \u003d dnr.getAllByDomainName(\n-          address.getHostName());\n+      String[] resolvedHostNames \u003d dnr.getAllResolvedHostnameByDomainName(\n+          address.getHostName(), requireFQDN);\n       int port \u003d address.getPort();\n-      for (InetAddress raddress : resolvedAddresses) {\n+      for (String hostname : resolvedHostNames) {\n         InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n-            raddress, port);\n+            hostname, port);\n         addressOfResolvedNns.add(resolvedAddress);\n       }\n     }\n \n     return addressOfResolvedNns;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Collection\u003cInetSocketAddress\u003e getResolvedHostsIfNecessary(\n      Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n          throws IOException {\n    // \u0027host\u0027 here is usually the ID of the nameservice when address\n    // resolving is needed.\n    String host \u003d nameNodeUri.getHost();\n    String configKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n    boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n    if (!resolveNeeded) {\n      // Early return is no resolve is necessary\n      return addressesOfNns;\n    }\n    // decide whether to access server by IP or by host name\n    String useFQDNKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN + \".\" + host;\n    boolean requireFQDN \u003d conf.getBoolean(useFQDNKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN_DEFAULT);\n\n    Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n    DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n          conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n    // If the address needs to be resolved, get all of the IP addresses\n    // from this address and pass them into the proxy\n    LOG.info(\"Namenode domain name will be resolved with {}\",\n        dnr.getClass().getName());\n    for (InetSocketAddress address : addressesOfNns) {\n      String[] resolvedHostNames \u003d dnr.getAllResolvedHostnameByDomainName(\n          address.getHostName(), requireFQDN);\n      int port \u003d address.getPort();\n      for (String hostname : resolvedHostNames) {\n        InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n            hostname, port);\n        addressOfResolvedNns.add(resolvedAddress);\n      }\n    }\n\n    return addressOfResolvedNns;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
          "extendedDetails": {
            "oldValue": "getResolvedAddressesIfNecessary",
            "newValue": "getResolvedHostsIfNecessary"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-14327. Using FQDN instead of IP to access servers with DNS resolving. Contributed by Fengnan Li.\n",
          "commitDate": "03/04/19 4:11 PM",
          "commitName": "7b5b783f66f32012c00bef7593851392dd8cf2d5",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "23/02/19 9:35 AM",
          "commitNameOld": "f7a27cdee4e6829ebea4ea965e549a27acbf4310",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 39.23,
          "commitsBetweenForRepo": 331,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,40 @@\n-  Collection\u003cInetSocketAddress\u003e getResolvedAddressesIfNecessary(\n+  Collection\u003cInetSocketAddress\u003e getResolvedHostsIfNecessary(\n       Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n           throws IOException {\n     // \u0027host\u0027 here is usually the ID of the nameservice when address\n     // resolving is needed.\n     String host \u003d nameNodeUri.getHost();\n     String configKeyWithHost \u003d\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n     boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n         HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n     if (!resolveNeeded) {\n       // Early return is no resolve is necessary\n       return addressesOfNns;\n     }\n+    // decide whether to access server by IP or by host name\n+    String useFQDNKeyWithHost \u003d\n+        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN + \".\" + host;\n+    boolean requireFQDN \u003d conf.getBoolean(useFQDNKeyWithHost,\n+        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN_DEFAULT);\n \n     Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n     DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n           conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n     // If the address needs to be resolved, get all of the IP addresses\n     // from this address and pass them into the proxy\n     LOG.info(\"Namenode domain name will be resolved with {}\",\n         dnr.getClass().getName());\n     for (InetSocketAddress address : addressesOfNns) {\n-      InetAddress[] resolvedAddresses \u003d dnr.getAllByDomainName(\n-          address.getHostName());\n+      String[] resolvedHostNames \u003d dnr.getAllResolvedHostnameByDomainName(\n+          address.getHostName(), requireFQDN);\n       int port \u003d address.getPort();\n-      for (InetAddress raddress : resolvedAddresses) {\n+      for (String hostname : resolvedHostNames) {\n         InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n-            raddress, port);\n+            hostname, port);\n         addressOfResolvedNns.add(resolvedAddress);\n       }\n     }\n \n     return addressOfResolvedNns;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Collection\u003cInetSocketAddress\u003e getResolvedHostsIfNecessary(\n      Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n          throws IOException {\n    // \u0027host\u0027 here is usually the ID of the nameservice when address\n    // resolving is needed.\n    String host \u003d nameNodeUri.getHost();\n    String configKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n    boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n    if (!resolveNeeded) {\n      // Early return is no resolve is necessary\n      return addressesOfNns;\n    }\n    // decide whether to access server by IP or by host name\n    String useFQDNKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN + \".\" + host;\n    boolean requireFQDN \u003d conf.getBoolean(useFQDNKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_TO_FQDN_DEFAULT);\n\n    Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n    DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n          conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n    // If the address needs to be resolved, get all of the IP addresses\n    // from this address and pass them into the proxy\n    LOG.info(\"Namenode domain name will be resolved with {}\",\n        dnr.getClass().getName());\n    for (InetSocketAddress address : addressesOfNns) {\n      String[] resolvedHostNames \u003d dnr.getAllResolvedHostnameByDomainName(\n          address.getHostName(), requireFQDN);\n      int port \u003d address.getPort();\n      for (String hostname : resolvedHostNames) {\n        InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n            hostname, port);\n        addressOfResolvedNns.add(resolvedAddress);\n      }\n    }\n\n    return addressOfResolvedNns;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
          "extendedDetails": {}
        }
      ]
    },
    "f7a27cdee4e6829ebea4ea965e549a27acbf4310": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14118. Support using DNS to resolve nameservices to IP addresses. Contributed by Fengnan Li.\n",
      "commitDate": "23/02/19 9:35 AM",
      "commitName": "f7a27cdee4e6829ebea4ea965e549a27acbf4310",
      "commitAuthor": "Yongjun Zhang",
      "diff": "@@ -0,0 +1,35 @@\n+  Collection\u003cInetSocketAddress\u003e getResolvedAddressesIfNecessary(\n+      Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n+          throws IOException {\n+    // \u0027host\u0027 here is usually the ID of the nameservice when address\n+    // resolving is needed.\n+    String host \u003d nameNodeUri.getHost();\n+    String configKeyWithHost \u003d\n+        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n+    boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n+        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n+    if (!resolveNeeded) {\n+      // Early return is no resolve is necessary\n+      return addressesOfNns;\n+    }\n+\n+    Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n+    DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n+          conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n+    // If the address needs to be resolved, get all of the IP addresses\n+    // from this address and pass them into the proxy\n+    LOG.info(\"Namenode domain name will be resolved with {}\",\n+        dnr.getClass().getName());\n+    for (InetSocketAddress address : addressesOfNns) {\n+      InetAddress[] resolvedAddresses \u003d dnr.getAllByDomainName(\n+          address.getHostName());\n+      int port \u003d address.getPort();\n+      for (InetAddress raddress : resolvedAddresses) {\n+        InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n+            raddress, port);\n+        addressOfResolvedNns.add(resolvedAddress);\n+      }\n+    }\n+\n+    return addressOfResolvedNns;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  Collection\u003cInetSocketAddress\u003e getResolvedAddressesIfNecessary(\n      Collection\u003cInetSocketAddress\u003e addressesOfNns, URI nameNodeUri)\n          throws IOException {\n    // \u0027host\u0027 here is usually the ID of the nameservice when address\n    // resolving is needed.\n    String host \u003d nameNodeUri.getHost();\n    String configKeyWithHost \u003d\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_KEY  + \".\" + host;\n    boolean resolveNeeded \u003d conf.getBoolean(configKeyWithHost,\n        HdfsClientConfigKeys.Failover.RESOLVE_ADDRESS_NEEDED_DEFAULT);\n    if (!resolveNeeded) {\n      // Early return is no resolve is necessary\n      return addressesOfNns;\n    }\n\n    Collection\u003cInetSocketAddress\u003e addressOfResolvedNns \u003d new ArrayList\u003c\u003e();\n    DomainNameResolver dnr \u003d DomainNameResolverFactory.newInstance(\n          conf, nameNodeUri, HdfsClientConfigKeys.Failover.RESOLVE_SERVICE_KEY);\n    // If the address needs to be resolved, get all of the IP addresses\n    // from this address and pass them into the proxy\n    LOG.info(\"Namenode domain name will be resolved with {}\",\n        dnr.getClass().getName());\n    for (InetSocketAddress address : addressesOfNns) {\n      InetAddress[] resolvedAddresses \u003d dnr.getAllByDomainName(\n          address.getHostName());\n      int port \u003d address.getPort();\n      for (InetAddress raddress : resolvedAddresses) {\n        InetSocketAddress resolvedAddress \u003d new InetSocketAddress(\n            raddress, port);\n        addressOfResolvedNns.add(resolvedAddress);\n      }\n    }\n\n    return addressOfResolvedNns;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java"
    }
  }
}