{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Invoker.java",
  "functionName": "retryUntranslated",
  "functionId": "retryUntranslated___text-String__idempotent-boolean__retrying-Retried__operation-Operation__T__",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/Invoker.java",
  "functionStartLine": 390,
  "functionEndLine": 461,
  "numCommitsSeen": 12,
  "timeTaken": 1620,
  "changeHistory": [
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c"
  ],
  "changeHistoryShort": {
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13761. S3Guard: implement retries for DDB failures and throttling; translate exceptions.\nContributed by Aaron Fabbri.\n",
      "commitDate": "05/03/18 6:06 AM",
      "commitName": "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/01/18 5:13 AM",
      "commitNameOld": "1093a73689912f78547e6d23023be2fd1c7ddc85",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 46.04,
      "commitsBetweenForRepo": 297,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n   public \u003cT\u003e T retryUntranslated(\n       String text,\n       boolean idempotent,\n       Retried retrying,\n       Operation\u003cT\u003e operation) throws IOException {\n \n     Preconditions.checkArgument(retrying !\u003d null, \"null retrying argument\");\n     int retryCount \u003d 0;\n     Exception caught;\n     RetryPolicy.RetryAction retryAction;\n     boolean shouldRetry;\n     do {\n       try {\n+        if (retryCount \u003e 0) {\n+          LOG.debug(\"retry #{}\", retryCount);\n+        }\n         // execute the operation, returning if successful\n         return operation.execute();\n       } catch (IOException | SdkBaseException e) {\n         caught \u003d e;\n       }\n       // you only get here if the operation didn\u0027t complete\n       // normally, hence caught !\u003d null\n \n       // translate the exception into an IOE for the retry logic\n       IOException translated;\n       if (caught instanceof IOException) {\n         translated \u003d (IOException) caught;\n       } else {\n         translated \u003d S3AUtils.translateException(text, \"\",\n             (SdkBaseException)caught);\n       }\n \n-\n-      int attempts \u003d retryCount + 1;\n       try {\n         // decide action base on operation, invocation count, etc\n         retryAction \u003d retryPolicy.shouldRetry(translated, retryCount, 0,\n             idempotent);\n         // is it a retry operation?\n         shouldRetry \u003d retryAction.action.equals(\n             RetryPolicy.RetryAction.RETRY.action);\n         if (shouldRetry) {\n           // notify the callback\n           retrying.onFailure(text, translated, retryCount, idempotent);\n           // then sleep for the policy delay\n           Thread.sleep(retryAction.delayMillis);\n         }\n         // increment the retry count\n         retryCount++;\n       } catch (InterruptedException e) {\n         // sleep was interrupted\n         // change the exception\n         caught \u003d new InterruptedIOException(\"Interrupted\");\n         caught.initCause(e);\n         // no retry\n         shouldRetry \u003d false;\n         // and re-interrupt the thread\n         Thread.currentThread().interrupt();\n       } catch (Exception e) {\n         // The retry policy raised an exception\n         // log that something happened\n         LOG.warn(\"{}: exception in retry processing\", text, e);\n         // and fail the execution with the last execution exception.\n         shouldRetry \u003d false;\n       }\n     } while (shouldRetry);\n \n     if (caught instanceof IOException) {\n       throw (IOException) caught;\n     } else {\n       throw (SdkBaseException) caught;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT\u003e T retryUntranslated(\n      String text,\n      boolean idempotent,\n      Retried retrying,\n      Operation\u003cT\u003e operation) throws IOException {\n\n    Preconditions.checkArgument(retrying !\u003d null, \"null retrying argument\");\n    int retryCount \u003d 0;\n    Exception caught;\n    RetryPolicy.RetryAction retryAction;\n    boolean shouldRetry;\n    do {\n      try {\n        if (retryCount \u003e 0) {\n          LOG.debug(\"retry #{}\", retryCount);\n        }\n        // execute the operation, returning if successful\n        return operation.execute();\n      } catch (IOException | SdkBaseException e) {\n        caught \u003d e;\n      }\n      // you only get here if the operation didn\u0027t complete\n      // normally, hence caught !\u003d null\n\n      // translate the exception into an IOE for the retry logic\n      IOException translated;\n      if (caught instanceof IOException) {\n        translated \u003d (IOException) caught;\n      } else {\n        translated \u003d S3AUtils.translateException(text, \"\",\n            (SdkBaseException)caught);\n      }\n\n      try {\n        // decide action base on operation, invocation count, etc\n        retryAction \u003d retryPolicy.shouldRetry(translated, retryCount, 0,\n            idempotent);\n        // is it a retry operation?\n        shouldRetry \u003d retryAction.action.equals(\n            RetryPolicy.RetryAction.RETRY.action);\n        if (shouldRetry) {\n          // notify the callback\n          retrying.onFailure(text, translated, retryCount, idempotent);\n          // then sleep for the policy delay\n          Thread.sleep(retryAction.delayMillis);\n        }\n        // increment the retry count\n        retryCount++;\n      } catch (InterruptedException e) {\n        // sleep was interrupted\n        // change the exception\n        caught \u003d new InterruptedIOException(\"Interrupted\");\n        caught.initCause(e);\n        // no retry\n        shouldRetry \u003d false;\n        // and re-interrupt the thread\n        Thread.currentThread().interrupt();\n      } catch (Exception e) {\n        // The retry policy raised an exception\n        // log that something happened\n        LOG.warn(\"{}: exception in retry processing\", text, e);\n        // and fail the execution with the last execution exception.\n        shouldRetry \u003d false;\n      }\n    } while (shouldRetry);\n\n    if (caught instanceof IOException) {\n      throw (IOException) caught;\n    } else {\n      throw (SdkBaseException) caught;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/Invoker.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,71 @@\n+  public \u003cT\u003e T retryUntranslated(\n+      String text,\n+      boolean idempotent,\n+      Retried retrying,\n+      Operation\u003cT\u003e operation) throws IOException {\n+\n+    Preconditions.checkArgument(retrying !\u003d null, \"null retrying argument\");\n+    int retryCount \u003d 0;\n+    Exception caught;\n+    RetryPolicy.RetryAction retryAction;\n+    boolean shouldRetry;\n+    do {\n+      try {\n+        // execute the operation, returning if successful\n+        return operation.execute();\n+      } catch (IOException | SdkBaseException e) {\n+        caught \u003d e;\n+      }\n+      // you only get here if the operation didn\u0027t complete\n+      // normally, hence caught !\u003d null\n+\n+      // translate the exception into an IOE for the retry logic\n+      IOException translated;\n+      if (caught instanceof IOException) {\n+        translated \u003d (IOException) caught;\n+      } else {\n+        translated \u003d S3AUtils.translateException(text, \"\",\n+            (SdkBaseException)caught);\n+      }\n+\n+\n+      int attempts \u003d retryCount + 1;\n+      try {\n+        // decide action base on operation, invocation count, etc\n+        retryAction \u003d retryPolicy.shouldRetry(translated, retryCount, 0,\n+            idempotent);\n+        // is it a retry operation?\n+        shouldRetry \u003d retryAction.action.equals(\n+            RetryPolicy.RetryAction.RETRY.action);\n+        if (shouldRetry) {\n+          // notify the callback\n+          retrying.onFailure(text, translated, retryCount, idempotent);\n+          // then sleep for the policy delay\n+          Thread.sleep(retryAction.delayMillis);\n+        }\n+        // increment the retry count\n+        retryCount++;\n+      } catch (InterruptedException e) {\n+        // sleep was interrupted\n+        // change the exception\n+        caught \u003d new InterruptedIOException(\"Interrupted\");\n+        caught.initCause(e);\n+        // no retry\n+        shouldRetry \u003d false;\n+        // and re-interrupt the thread\n+        Thread.currentThread().interrupt();\n+      } catch (Exception e) {\n+        // The retry policy raised an exception\n+        // log that something happened\n+        LOG.warn(\"{}: exception in retry processing\", text, e);\n+        // and fail the execution with the last execution exception.\n+        shouldRetry \u003d false;\n+      }\n+    } while (shouldRetry);\n+\n+    if (caught instanceof IOException) {\n+      throw (IOException) caught;\n+    } else {\n+      throw (SdkBaseException) caught;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT\u003e T retryUntranslated(\n      String text,\n      boolean idempotent,\n      Retried retrying,\n      Operation\u003cT\u003e operation) throws IOException {\n\n    Preconditions.checkArgument(retrying !\u003d null, \"null retrying argument\");\n    int retryCount \u003d 0;\n    Exception caught;\n    RetryPolicy.RetryAction retryAction;\n    boolean shouldRetry;\n    do {\n      try {\n        // execute the operation, returning if successful\n        return operation.execute();\n      } catch (IOException | SdkBaseException e) {\n        caught \u003d e;\n      }\n      // you only get here if the operation didn\u0027t complete\n      // normally, hence caught !\u003d null\n\n      // translate the exception into an IOE for the retry logic\n      IOException translated;\n      if (caught instanceof IOException) {\n        translated \u003d (IOException) caught;\n      } else {\n        translated \u003d S3AUtils.translateException(text, \"\",\n            (SdkBaseException)caught);\n      }\n\n\n      int attempts \u003d retryCount + 1;\n      try {\n        // decide action base on operation, invocation count, etc\n        retryAction \u003d retryPolicy.shouldRetry(translated, retryCount, 0,\n            idempotent);\n        // is it a retry operation?\n        shouldRetry \u003d retryAction.action.equals(\n            RetryPolicy.RetryAction.RETRY.action);\n        if (shouldRetry) {\n          // notify the callback\n          retrying.onFailure(text, translated, retryCount, idempotent);\n          // then sleep for the policy delay\n          Thread.sleep(retryAction.delayMillis);\n        }\n        // increment the retry count\n        retryCount++;\n      } catch (InterruptedException e) {\n        // sleep was interrupted\n        // change the exception\n        caught \u003d new InterruptedIOException(\"Interrupted\");\n        caught.initCause(e);\n        // no retry\n        shouldRetry \u003d false;\n        // and re-interrupt the thread\n        Thread.currentThread().interrupt();\n      } catch (Exception e) {\n        // The retry policy raised an exception\n        // log that something happened\n        LOG.warn(\"{}: exception in retry processing\", text, e);\n        // and fail the execution with the last execution exception.\n        shouldRetry \u003d false;\n      }\n    } while (shouldRetry);\n\n    if (caught instanceof IOException) {\n      throw (IOException) caught;\n    } else {\n      throw (SdkBaseException) caught;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/Invoker.java"
    }
  }
}