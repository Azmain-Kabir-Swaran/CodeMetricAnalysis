{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CompileMojo.java",
  "functionName": "runMake",
  "functionId": "runMake",
  "sourceFilePath": "hadoop-maven-plugins/src/main/java/org/apache/hadoop/maven/plugin/cmakebuilder/CompileMojo.java",
  "functionStartLine": 200,
  "functionEndLine": 265,
  "numCommitsSeen": 4,
  "timeTaken": 682,
  "changeHistory": [
    "b2c155f810888480d058512a326a5083e1bb4eaa",
    "b1ed28fa77cb2fab80c54f9dfeb5d8b7139eca34"
  ],
  "changeHistoryShort": {
    "b2c155f810888480d058512a326a5083e1bb4eaa": "Ybodychange",
    "b1ed28fa77cb2fab80c54f9dfeb5d8b7139eca34": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b2c155f810888480d058512a326a5083e1bb4eaa": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12712. Fix some cmake plugin and native build warnings (cmccabe)\n",
      "commitDate": "15/01/16 12:29 PM",
      "commitName": "b2c155f810888480d058512a326a5083e1bb4eaa",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "14/01/16 11:02 AM",
      "commitNameOld": "b1ed28fa77cb2fab80c54f9dfeb5d8b7139eca34",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 1.06,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void runMake() throws MojoExecutionException {\n     List\u003cString\u003e cmd \u003d new LinkedList\u003cString\u003e();\n     cmd.add(\"make\");\n-    // TODO: it would be nice to determine the number of CPUs and set the\n-    // parallelism to that.  It requires some platform-specific logic, though.\n     cmd.add(\"-j\");\n     cmd.add(String.valueOf(availableProcessors));\n     cmd.add(\"VERBOSE\u003d1\");\n     if (target !\u003d null) {\n       cmd.add(target);\n     }\n     StringBuilder bld \u003d new StringBuilder();\n     String prefix \u003d \"\";\n     for (String c : cmd) {\n       bld.append(prefix).append(c);\n       prefix \u003d \" \";\n     }\n     getLog().info(\"Running \" + bld.toString());\n     ProcessBuilder pb \u003d new ProcessBuilder(cmd);\n     pb.directory(output);\n     Process proc \u003d null;\n     int retCode \u003d -1;\n     OutputBufferThread stdoutThread \u003d null, stderrThread \u003d null;\n     try {\n       proc \u003d pb.start();\n       stdoutThread \u003d new OutputBufferThread(proc.getInputStream());\n       stderrThread \u003d new OutputBufferThread(proc.getErrorStream());\n       stdoutThread.start();\n       stderrThread.start();\n       retCode \u003d proc.waitFor();\n       if (retCode !\u003d 0) {\n         throw new MojoExecutionException(\"make failed with error code \" +\n             retCode);\n       }\n     } catch (InterruptedException e) {\n       throw new MojoExecutionException(\"Interrupted during Process#waitFor\", e);\n     } catch (IOException e) {\n       throw new MojoExecutionException(\"Error executing make\", e);\n     } finally {\n       if (stdoutThread !\u003d null) {\n         try {\n           stdoutThread.join();\n         } catch (InterruptedException e) {\n           getLog().error(\"Interrupted while joining stdoutThread\", e);\n         }\n         if (retCode !\u003d 0) {\n           for (String line: stdoutThread.getOutput()) {\n             getLog().warn(line);\n           }\n         }\n       }\n       if (stderrThread !\u003d null) {\n         try {\n           stderrThread.join();\n         } catch (InterruptedException e) {\n           getLog().error(\"Interrupted while joining stderrThread\", e);\n         }\n         // We always print stderr, since it contains the compiler warning\n         // messages.  These are interesting even if compilation succeeded.\n-          for (String line: stderrThread.getOutput()) {\n-            getLog().warn(line);\n-          }\n+        for (String line: stderrThread.getOutput()) {\n+          getLog().warn(line);\n+        }\n       }\n-      if (proc !\u003d null) proc.destroy();\n+      if (proc !\u003d null) {\n+        proc.destroy();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void runMake() throws MojoExecutionException {\n    List\u003cString\u003e cmd \u003d new LinkedList\u003cString\u003e();\n    cmd.add(\"make\");\n    cmd.add(\"-j\");\n    cmd.add(String.valueOf(availableProcessors));\n    cmd.add(\"VERBOSE\u003d1\");\n    if (target !\u003d null) {\n      cmd.add(target);\n    }\n    StringBuilder bld \u003d new StringBuilder();\n    String prefix \u003d \"\";\n    for (String c : cmd) {\n      bld.append(prefix).append(c);\n      prefix \u003d \" \";\n    }\n    getLog().info(\"Running \" + bld.toString());\n    ProcessBuilder pb \u003d new ProcessBuilder(cmd);\n    pb.directory(output);\n    Process proc \u003d null;\n    int retCode \u003d -1;\n    OutputBufferThread stdoutThread \u003d null, stderrThread \u003d null;\n    try {\n      proc \u003d pb.start();\n      stdoutThread \u003d new OutputBufferThread(proc.getInputStream());\n      stderrThread \u003d new OutputBufferThread(proc.getErrorStream());\n      stdoutThread.start();\n      stderrThread.start();\n      retCode \u003d proc.waitFor();\n      if (retCode !\u003d 0) {\n        throw new MojoExecutionException(\"make failed with error code \" +\n            retCode);\n      }\n    } catch (InterruptedException e) {\n      throw new MojoExecutionException(\"Interrupted during Process#waitFor\", e);\n    } catch (IOException e) {\n      throw new MojoExecutionException(\"Error executing make\", e);\n    } finally {\n      if (stdoutThread !\u003d null) {\n        try {\n          stdoutThread.join();\n        } catch (InterruptedException e) {\n          getLog().error(\"Interrupted while joining stdoutThread\", e);\n        }\n        if (retCode !\u003d 0) {\n          for (String line: stdoutThread.getOutput()) {\n            getLog().warn(line);\n          }\n        }\n      }\n      if (stderrThread !\u003d null) {\n        try {\n          stderrThread.join();\n        } catch (InterruptedException e) {\n          getLog().error(\"Interrupted while joining stderrThread\", e);\n        }\n        // We always print stderr, since it contains the compiler warning\n        // messages.  These are interesting even if compilation succeeded.\n        for (String line: stderrThread.getOutput()) {\n          getLog().warn(line);\n        }\n      }\n      if (proc !\u003d null) {\n        proc.destroy();\n      }\n    }\n  }",
      "path": "hadoop-maven-plugins/src/main/java/org/apache/hadoop/maven/plugin/cmakebuilder/CompileMojo.java",
      "extendedDetails": {}
    },
    "b1ed28fa77cb2fab80c54f9dfeb5d8b7139eca34": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8887. Use a Maven plugin to build the native code using CMake (cmccabe)\n",
      "commitDate": "14/01/16 11:02 AM",
      "commitName": "b1ed28fa77cb2fab80c54f9dfeb5d8b7139eca34",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,66 @@\n+  public void runMake() throws MojoExecutionException {\n+    List\u003cString\u003e cmd \u003d new LinkedList\u003cString\u003e();\n+    cmd.add(\"make\");\n+    // TODO: it would be nice to determine the number of CPUs and set the\n+    // parallelism to that.  It requires some platform-specific logic, though.\n+    cmd.add(\"-j\");\n+    cmd.add(String.valueOf(availableProcessors));\n+    cmd.add(\"VERBOSE\u003d1\");\n+    if (target !\u003d null) {\n+      cmd.add(target);\n+    }\n+    StringBuilder bld \u003d new StringBuilder();\n+    String prefix \u003d \"\";\n+    for (String c : cmd) {\n+      bld.append(prefix).append(c);\n+      prefix \u003d \" \";\n+    }\n+    getLog().info(\"Running \" + bld.toString());\n+    ProcessBuilder pb \u003d new ProcessBuilder(cmd);\n+    pb.directory(output);\n+    Process proc \u003d null;\n+    int retCode \u003d -1;\n+    OutputBufferThread stdoutThread \u003d null, stderrThread \u003d null;\n+    try {\n+      proc \u003d pb.start();\n+      stdoutThread \u003d new OutputBufferThread(proc.getInputStream());\n+      stderrThread \u003d new OutputBufferThread(proc.getErrorStream());\n+      stdoutThread.start();\n+      stderrThread.start();\n+      retCode \u003d proc.waitFor();\n+      if (retCode !\u003d 0) {\n+        throw new MojoExecutionException(\"make failed with error code \" +\n+            retCode);\n+      }\n+    } catch (InterruptedException e) {\n+      throw new MojoExecutionException(\"Interrupted during Process#waitFor\", e);\n+    } catch (IOException e) {\n+      throw new MojoExecutionException(\"Error executing make\", e);\n+    } finally {\n+      if (stdoutThread !\u003d null) {\n+        try {\n+          stdoutThread.join();\n+        } catch (InterruptedException e) {\n+          getLog().error(\"Interrupted while joining stdoutThread\", e);\n+        }\n+        if (retCode !\u003d 0) {\n+          for (String line: stdoutThread.getOutput()) {\n+            getLog().warn(line);\n+          }\n+        }\n+      }\n+      if (stderrThread !\u003d null) {\n+        try {\n+          stderrThread.join();\n+        } catch (InterruptedException e) {\n+          getLog().error(\"Interrupted while joining stderrThread\", e);\n+        }\n+        // We always print stderr, since it contains the compiler warning\n+        // messages.  These are interesting even if compilation succeeded.\n+          for (String line: stderrThread.getOutput()) {\n+            getLog().warn(line);\n+          }\n+      }\n+      if (proc !\u003d null) proc.destroy();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void runMake() throws MojoExecutionException {\n    List\u003cString\u003e cmd \u003d new LinkedList\u003cString\u003e();\n    cmd.add(\"make\");\n    // TODO: it would be nice to determine the number of CPUs and set the\n    // parallelism to that.  It requires some platform-specific logic, though.\n    cmd.add(\"-j\");\n    cmd.add(String.valueOf(availableProcessors));\n    cmd.add(\"VERBOSE\u003d1\");\n    if (target !\u003d null) {\n      cmd.add(target);\n    }\n    StringBuilder bld \u003d new StringBuilder();\n    String prefix \u003d \"\";\n    for (String c : cmd) {\n      bld.append(prefix).append(c);\n      prefix \u003d \" \";\n    }\n    getLog().info(\"Running \" + bld.toString());\n    ProcessBuilder pb \u003d new ProcessBuilder(cmd);\n    pb.directory(output);\n    Process proc \u003d null;\n    int retCode \u003d -1;\n    OutputBufferThread stdoutThread \u003d null, stderrThread \u003d null;\n    try {\n      proc \u003d pb.start();\n      stdoutThread \u003d new OutputBufferThread(proc.getInputStream());\n      stderrThread \u003d new OutputBufferThread(proc.getErrorStream());\n      stdoutThread.start();\n      stderrThread.start();\n      retCode \u003d proc.waitFor();\n      if (retCode !\u003d 0) {\n        throw new MojoExecutionException(\"make failed with error code \" +\n            retCode);\n      }\n    } catch (InterruptedException e) {\n      throw new MojoExecutionException(\"Interrupted during Process#waitFor\", e);\n    } catch (IOException e) {\n      throw new MojoExecutionException(\"Error executing make\", e);\n    } finally {\n      if (stdoutThread !\u003d null) {\n        try {\n          stdoutThread.join();\n        } catch (InterruptedException e) {\n          getLog().error(\"Interrupted while joining stdoutThread\", e);\n        }\n        if (retCode !\u003d 0) {\n          for (String line: stdoutThread.getOutput()) {\n            getLog().warn(line);\n          }\n        }\n      }\n      if (stderrThread !\u003d null) {\n        try {\n          stderrThread.join();\n        } catch (InterruptedException e) {\n          getLog().error(\"Interrupted while joining stderrThread\", e);\n        }\n        // We always print stderr, since it contains the compiler warning\n        // messages.  These are interesting even if compilation succeeded.\n          for (String line: stderrThread.getOutput()) {\n            getLog().warn(line);\n          }\n      }\n      if (proc !\u003d null) proc.destroy();\n    }\n  }",
      "path": "hadoop-maven-plugins/src/main/java/org/apache/hadoop/maven/plugin/cmakebuilder/CompileMojo.java"
    }
  }
}