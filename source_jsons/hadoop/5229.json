{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirWriteFileOp.java",
  "functionName": "addFile",
  "functionId": "addFile___fsd-FSDirectory__existing-INodesInPath__localName-byte[]__permissions-PermissionStatus__replication-short__preferredBlockSize-long__clientName-String__clientMachine-String__shouldReplicate-boolean__ecPolicyName-String__storagePolicy-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
  "functionStartLine": 540,
  "functionEndLine": 594,
  "numCommitsSeen": 1161,
  "timeTaken": 18379,
  "changeHistory": [
    "0d7a5ac5f526801367a9ec963e6d72783b637d55",
    "cf4108313da83e28d07676078a33016ec8856ff6",
    "96b3a6b9721e922d33fadc2459b561a85dbf9b8e",
    "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
    "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
    "3085a604300ed76d06a0011bd5555e419897b6cd",
    "55c07bbed2f475f7b584a86112ee1b6fe0221e98",
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce",
    "8b7adf4ddf420a93c586c4b2eac27dd0f649682e",
    "6ae39199dac6ac7be6802b31452552c76da16e24",
    "a5fb298e56220a35d61b8d2bda716d8fb8ef8bb7",
    "7600e3c48ff2043654dbe9f415a186a336b5ea6c",
    "f62237bc2f02afe11ce185e13aa51a60b5960037",
    "7e091de1366f4b57b5433bc19d738199dc05313d",
    "98d340745be682fb251677bb4830aca76119868f",
    "1299357a05c52ad45513ed0ea854edc9c7ec3de8",
    "1af8c148626effe1b41fc536019fd3349f485d59",
    "1e1e93040748231dc913190aec1e031c379d8271",
    "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0",
    "bb84f1fccb18c6c7373851e05d2451d55e908242"
  ],
  "changeHistoryShort": {
    "0d7a5ac5f526801367a9ec963e6d72783b637d55": "Ymultichange(Yparameterchange,Ybodychange)",
    "cf4108313da83e28d07676078a33016ec8856ff6": "Ybodychange",
    "96b3a6b9721e922d33fadc2459b561a85dbf9b8e": "Ybodychange",
    "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405": "Ymultichange(Yparameterchange,Ybodychange)",
    "a7312715a66dec5173c3a0a78dff4e0333e7f0b1": "Ymultichange(Yparameterchange,Ybodychange)",
    "3085a604300ed76d06a0011bd5555e419897b6cd": "Ybodychange",
    "55c07bbed2f475f7b584a86112ee1b6fe0221e98": "Ybodychange",
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce": "Ybodychange",
    "8b7adf4ddf420a93c586c4b2eac27dd0f649682e": "Ymultichange(Yparameterchange,Ybodychange)",
    "6ae39199dac6ac7be6802b31452552c76da16e24": "Ybodychange",
    "a5fb298e56220a35d61b8d2bda716d8fb8ef8bb7": "Ybodychange",
    "7600e3c48ff2043654dbe9f415a186a336b5ea6c": "Ybodychange",
    "f62237bc2f02afe11ce185e13aa51a60b5960037": "Ybodychange",
    "7e091de1366f4b57b5433bc19d738199dc05313d": "Ybodychange",
    "98d340745be682fb251677bb4830aca76119868f": "Ybodychange",
    "1299357a05c52ad45513ed0ea854edc9c7ec3de8": "Ybodychange",
    "1af8c148626effe1b41fc536019fd3349f485d59": "Ybodychange",
    "1e1e93040748231dc913190aec1e031c379d8271": "Ybodychange",
    "2b6bcfdafa91223a4116e3e9304579f5f91dccac": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yparameterchange,Ybodychange)",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": "Ybodychange",
    "bb84f1fccb18c6c7373851e05d2451d55e908242": "Ymultichange(Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "0d7a5ac5f526801367a9ec963e6d72783b637d55": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13209. DistributedFileSystem.create should allow an option to provide StoragePolicy. Contributed by Ayush Saxena.\n",
      "commitDate": "14/02/19 8:43 AM",
      "commitName": "0d7a5ac5f526801367a9ec963e6d72783b637d55",
      "commitAuthor": "Surendra Singh Lilhore",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13209. DistributedFileSystem.create should allow an option to provide StoragePolicy. Contributed by Ayush Saxena.\n",
          "commitDate": "14/02/19 8:43 AM",
          "commitName": "0d7a5ac5f526801367a9ec963e6d72783b637d55",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "24/07/18 4:05 PM",
          "commitNameOld": "849c45db187224095b13fe297a4d7377fbb9d2cd",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 204.73,
          "commitsBetweenForRepo": 1621,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,55 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine, boolean shouldReplicate,\n-      String ecPolicyName) throws IOException {\n+      String ecPolicyName, String storagePolicy) throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n       ErasureCodingPolicy ecPolicy \u003d null;\n+      byte storagepolicyid \u003d 0;\n+      if (storagePolicy !\u003d null \u0026\u0026 !storagePolicy.isEmpty()) {\n+        BlockStoragePolicy policy \u003d\n+            fsd.getBlockManager().getStoragePolicy(storagePolicy);\n+        if (policy \u003d\u003d null) {\n+          throw new HadoopIllegalArgumentException(\n+              \"Cannot find a block policy with the name \" + storagePolicy);\n+        }\n+        storagepolicyid \u003d policy.getId();\n+      }\n       if (!shouldReplicate) {\n         ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n             fsd.getFSNamesystem(), ecPolicyName, existing);\n         if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n           isStriped \u003d true;\n         }\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n-          blockType);\n+          storagepolicyid, blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, boolean shouldReplicate,\n      String ecPolicyName, String storagePolicy) throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d null;\n      byte storagepolicyid \u003d 0;\n      if (storagePolicy !\u003d null \u0026\u0026 !storagePolicy.isEmpty()) {\n        BlockStoragePolicy policy \u003d\n            fsd.getBlockManager().getStoragePolicy(storagePolicy);\n        if (policy \u003d\u003d null) {\n          throw new HadoopIllegalArgumentException(\n              \"Cannot find a block policy with the name \" + storagePolicy);\n        }\n        storagepolicyid \u003d policy.getId();\n      }\n      if (!shouldReplicate) {\n        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n            fsd.getFSNamesystem(), ecPolicyName, existing);\n        if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n          isStriped \u003d true;\n        }\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          storagepolicyid, blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String, shouldReplicate-boolean, ecPolicyName-String]",
            "newValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String, shouldReplicate-boolean, ecPolicyName-String, storagePolicy-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13209. DistributedFileSystem.create should allow an option to provide StoragePolicy. Contributed by Ayush Saxena.\n",
          "commitDate": "14/02/19 8:43 AM",
          "commitName": "0d7a5ac5f526801367a9ec963e6d72783b637d55",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "24/07/18 4:05 PM",
          "commitNameOld": "849c45db187224095b13fe297a4d7377fbb9d2cd",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 204.73,
          "commitsBetweenForRepo": 1621,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,55 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine, boolean shouldReplicate,\n-      String ecPolicyName) throws IOException {\n+      String ecPolicyName, String storagePolicy) throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n       ErasureCodingPolicy ecPolicy \u003d null;\n+      byte storagepolicyid \u003d 0;\n+      if (storagePolicy !\u003d null \u0026\u0026 !storagePolicy.isEmpty()) {\n+        BlockStoragePolicy policy \u003d\n+            fsd.getBlockManager().getStoragePolicy(storagePolicy);\n+        if (policy \u003d\u003d null) {\n+          throw new HadoopIllegalArgumentException(\n+              \"Cannot find a block policy with the name \" + storagePolicy);\n+        }\n+        storagepolicyid \u003d policy.getId();\n+      }\n       if (!shouldReplicate) {\n         ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n             fsd.getFSNamesystem(), ecPolicyName, existing);\n         if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n           isStriped \u003d true;\n         }\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n-          blockType);\n+          storagepolicyid, blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, boolean shouldReplicate,\n      String ecPolicyName, String storagePolicy) throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d null;\n      byte storagepolicyid \u003d 0;\n      if (storagePolicy !\u003d null \u0026\u0026 !storagePolicy.isEmpty()) {\n        BlockStoragePolicy policy \u003d\n            fsd.getBlockManager().getStoragePolicy(storagePolicy);\n        if (policy \u003d\u003d null) {\n          throw new HadoopIllegalArgumentException(\n              \"Cannot find a block policy with the name \" + storagePolicy);\n        }\n        storagepolicyid \u003d policy.getId();\n      }\n      if (!shouldReplicate) {\n        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n            fsd.getFSNamesystem(), ecPolicyName, existing);\n        if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n          isStriped \u003d true;\n        }\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          storagepolicyid, blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "cf4108313da83e28d07676078a33016ec8856ff6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13642. Creating a file with block size smaller than EC policy\u0027s cell size should fail.\n",
      "commitDate": "08/06/18 3:14 PM",
      "commitName": "cf4108313da83e28d07676078a33016ec8856ff6",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "11/12/17 8:14 PM",
      "commitNameOld": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 178.75,
      "commitsBetweenForRepo": 1836,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,45 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine, boolean shouldReplicate,\n       String ecPolicyName) throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n       ErasureCodingPolicy ecPolicy \u003d null;\n       if (!shouldReplicate) {\n-        if (!StringUtils.isEmpty(ecPolicyName)) {\n-          ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n-              fsd.getFSNamesystem(), ecPolicyName);\n-        } else {\n-          ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n-              fsd.getFSNamesystem(), existing);\n-        }\n+        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n+            fsd.getFSNamesystem(), ecPolicyName, existing);\n         if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n           isStriped \u003d true;\n         }\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, boolean shouldReplicate,\n      String ecPolicyName) throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d null;\n      if (!shouldReplicate) {\n        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n            fsd.getFSNamesystem(), ecPolicyName, existing);\n        if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n          isStriped \u003d true;\n        }\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "96b3a6b9721e922d33fadc2459b561a85dbf9b8e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11082. Provide replicated EC policy to replicate files. Contributed by SammiChen.\n",
      "commitDate": "16/08/17 10:17 PM",
      "commitName": "96b3a6b9721e922d33fadc2459b561a85dbf9b8e",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "04/05/17 11:39 AM",
      "commitNameOld": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 104.44,
      "commitsBetweenForRepo": 600,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine, boolean shouldReplicate,\n       String ecPolicyName) throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n       ErasureCodingPolicy ecPolicy \u003d null;\n       if (!shouldReplicate) {\n         if (!StringUtils.isEmpty(ecPolicyName)) {\n           ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n               fsd.getFSNamesystem(), ecPolicyName);\n         } else {\n           ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n               fsd.getFSNamesystem(), existing);\n         }\n-        if (ecPolicy !\u003d null) {\n+        if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n           isStriped \u003d true;\n         }\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, boolean shouldReplicate,\n      String ecPolicyName) throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d null;\n      if (!shouldReplicate) {\n        if (!StringUtils.isEmpty(ecPolicyName)) {\n          ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n              fsd.getFSNamesystem(), ecPolicyName);\n        } else {\n          ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n              fsd.getFSNamesystem(), existing);\n        }\n        if (ecPolicy !\u003d null \u0026\u0026 (!ecPolicy.isReplicationPolicy())) {\n          isStriped \u003d true;\n        }\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-11643. Add shouldReplicate option to create builder. Contributed by SammiChen.\n",
      "commitDate": "04/05/17 11:39 AM",
      "commitName": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11643. Add shouldReplicate option to create builder. Contributed by SammiChen.\n",
          "commitDate": "04/05/17 11:39 AM",
          "commitName": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "12/04/17 12:27 PM",
          "commitNameOld": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 21.97,
          "commitsBetweenForRepo": 111,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,50 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n-      String clientName, String clientMachine, String ecPolicyName)\n-      throws IOException {\n+      String clientName, String clientMachine, boolean shouldReplicate,\n+      String ecPolicyName) throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n-      ErasureCodingPolicy ecPolicy;\n-      if (!StringUtils.isEmpty(ecPolicyName)) {\n-        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n-            fsd.getFSNamesystem(), ecPolicyName);\n-      } else {\n-        ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n-            fsd.getFSNamesystem(), existing);\n-      }\n-      if (ecPolicy !\u003d null) {\n-        isStriped \u003d true;\n+      ErasureCodingPolicy ecPolicy \u003d null;\n+      if (!shouldReplicate) {\n+        if (!StringUtils.isEmpty(ecPolicyName)) {\n+          ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n+              fsd.getFSNamesystem(), ecPolicyName);\n+        } else {\n+          ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n+              fsd.getFSNamesystem(), existing);\n+        }\n+        if (ecPolicy !\u003d null) {\n+          isStriped \u003d true;\n+        }\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, boolean shouldReplicate,\n      String ecPolicyName) throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d null;\n      if (!shouldReplicate) {\n        if (!StringUtils.isEmpty(ecPolicyName)) {\n          ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n              fsd.getFSNamesystem(), ecPolicyName);\n        } else {\n          ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n              fsd.getFSNamesystem(), existing);\n        }\n        if (ecPolicy !\u003d null) {\n          isStriped \u003d true;\n        }\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String, ecPolicyName-String]",
            "newValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String, shouldReplicate-boolean, ecPolicyName-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11643. Add shouldReplicate option to create builder. Contributed by SammiChen.\n",
          "commitDate": "04/05/17 11:39 AM",
          "commitName": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "12/04/17 12:27 PM",
          "commitNameOld": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 21.97,
          "commitsBetweenForRepo": 111,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,50 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n-      String clientName, String clientMachine, String ecPolicyName)\n-      throws IOException {\n+      String clientName, String clientMachine, boolean shouldReplicate,\n+      String ecPolicyName) throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n-      ErasureCodingPolicy ecPolicy;\n-      if (!StringUtils.isEmpty(ecPolicyName)) {\n-        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n-            fsd.getFSNamesystem(), ecPolicyName);\n-      } else {\n-        ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n-            fsd.getFSNamesystem(), existing);\n-      }\n-      if (ecPolicy !\u003d null) {\n-        isStriped \u003d true;\n+      ErasureCodingPolicy ecPolicy \u003d null;\n+      if (!shouldReplicate) {\n+        if (!StringUtils.isEmpty(ecPolicyName)) {\n+          ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n+              fsd.getFSNamesystem(), ecPolicyName);\n+        } else {\n+          ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n+              fsd.getFSNamesystem(), existing);\n+        }\n+        if (ecPolicy !\u003d null) {\n+          isStriped \u003d true;\n+        }\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, boolean shouldReplicate,\n      String ecPolicyName) throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d null;\n      if (!shouldReplicate) {\n        if (!StringUtils.isEmpty(ecPolicyName)) {\n          ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n              fsd.getFSNamesystem(), ecPolicyName);\n        } else {\n          ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n              fsd.getFSNamesystem(), existing);\n        }\n        if (ecPolicy !\u003d null) {\n          isStriped \u003d true;\n        }\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "a7312715a66dec5173c3a0a78dff4e0333e7f0b1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10996. Ability to specify per-file EC policy at create time. Contributed by SammiChen.\n",
      "commitDate": "12/04/17 12:27 PM",
      "commitName": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10996. Ability to specify per-file EC policy at create time. Contributed by SammiChen.\n",
          "commitDate": "12/04/17 12:27 PM",
          "commitName": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "03/03/17 1:00 PM",
          "commitNameOld": "3085a604300ed76d06a0011bd5555e419897b6cd",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 39.94,
          "commitsBetweenForRepo": 250,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,48 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n-      String clientName, String clientMachine)\n+      String clientName, String clientMachine, String ecPolicyName)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n-      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n-          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n+      ErasureCodingPolicy ecPolicy;\n+      if (!StringUtils.isEmpty(ecPolicyName)) {\n+        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n+            fsd.getFSNamesystem(), ecPolicyName);\n+      } else {\n+        ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n+            fsd.getFSNamesystem(), existing);\n+      }\n       if (ecPolicy !\u003d null) {\n         isStriped \u003d true;\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, String ecPolicyName)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy;\n      if (!StringUtils.isEmpty(ecPolicyName)) {\n        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n            fsd.getFSNamesystem(), ecPolicyName);\n      } else {\n        ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n            fsd.getFSNamesystem(), existing);\n      }\n      if (ecPolicy !\u003d null) {\n        isStriped \u003d true;\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]",
            "newValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String, ecPolicyName-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10996. Ability to specify per-file EC policy at create time. Contributed by SammiChen.\n",
          "commitDate": "12/04/17 12:27 PM",
          "commitName": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "03/03/17 1:00 PM",
          "commitNameOld": "3085a604300ed76d06a0011bd5555e419897b6cd",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 39.94,
          "commitsBetweenForRepo": 250,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,48 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n-      String clientName, String clientMachine)\n+      String clientName, String clientMachine, String ecPolicyName)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n-      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n-          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n+      ErasureCodingPolicy ecPolicy;\n+      if (!StringUtils.isEmpty(ecPolicyName)) {\n+        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n+            fsd.getFSNamesystem(), ecPolicyName);\n+      } else {\n+        ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n+            fsd.getFSNamesystem(), existing);\n+      }\n       if (ecPolicy !\u003d null) {\n         isStriped \u003d true;\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine, String ecPolicyName)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy;\n      if (!StringUtils.isEmpty(ecPolicyName)) {\n        ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicyByName(\n            fsd.getFSNamesystem(), ecPolicyName);\n      } else {\n        ecPolicy \u003d FSDirErasureCodingOp.unprotectedGetErasureCodingPolicy(\n            fsd.getFSNamesystem(), existing);\n      }\n      if (ecPolicy !\u003d null) {\n        isStriped \u003d true;\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "3085a604300ed76d06a0011bd5555e419897b6cd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8112. Relax permission checking for EC related operations.\n",
      "commitDate": "03/03/17 1:00 PM",
      "commitName": "3085a604300ed76d06a0011bd5555e419897b6cd",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/02/17 5:07 PM",
      "commitNameOld": "55c07bbed2f475f7b584a86112ee1b6fe0221e98",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 3.83,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       boolean isStriped \u003d false;\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n-          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n+          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         isStriped \u003d true;\n       }\n       final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n       final Short replicationFactor \u003d (!isStriped ? replication : null);\n       final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n           blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        isStriped \u003d true;\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "55c07bbed2f475f7b584a86112ee1b6fe0221e98": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11382. Persist Erasure Coding Policy ID in a new optional field in INodeFile in FSImage. Contributed by Manoj Govindassamy.\n",
      "commitDate": "27/02/17 5:07 PM",
      "commitName": "55c07bbed2f475f7b584a86112ee1b6fe0221e98",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "18/01/17 1:31 PM",
      "commitNameOld": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 40.15,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,42 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n+      boolean isStriped \u003d false;\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n-        replication \u003d ecPolicy.getId();\n+        isStriped \u003d true;\n       }\n-      final BlockType blockType \u003d ecPolicy !\u003d null?\n+      final BlockType blockType \u003d isStriped ?\n           BlockType.STRIPED : BlockType.CONTIGUOUS;\n+      final Short replicationFactor \u003d (!isStriped ? replication : null);\n+      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n-          modTime, modTime, replication, preferredBlockSize, blockType);\n+          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n+          blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      boolean isStriped \u003d false;\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        isStriped \u003d true;\n      }\n      final BlockType blockType \u003d isStriped ?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      final Short replicationFactor \u003d (!isStriped ? replication : null);\n      final Byte ecPolicyID \u003d (isStriped ? ecPolicy.getId() : null);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replicationFactor, ecPolicyID, preferredBlockSize,\n          blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 85.97,
      "commitsBetweenForRepo": 568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         replication \u003d ecPolicy.getId();\n       }\n+      final BlockType blockType \u003d ecPolicy !\u003d null?\n+          BlockType.STRIPED : BlockType.CONTIGUOUS;\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n-          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n+          modTime, modTime, replication, preferredBlockSize, blockType);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      final BlockType blockType \u003d ecPolicy !\u003d null?\n          BlockType.STRIPED : BlockType.CONTIGUOUS;\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, blockType);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6962. ACL inheritance conflicts with umaskmode. Contributed by Chris Nauroth.\n",
      "commitDate": "06/09/16 11:02 AM",
      "commitName": "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "31/08/16 12:02 PM",
      "commitNameOld": "01721dd88ee532d20eda841254437da4dfd69db5",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 5.96,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         replication \u003d ecPolicy.getId();\n       }\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n       newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n-      newiip \u003d fsd.addINode(existing, newNode);\n+      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n           DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode, permissions.getPermission());\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "8b7adf4ddf420a93c586c4b2eac27dd0f649682e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10768. Optimize mkdir ops. Contributed by Daryn Sharp.\n",
      "commitDate": "26/08/16 1:39 PM",
      "commitName": "8b7adf4ddf420a93c586c4b2eac27dd0f649682e",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10768. Optimize mkdir ops. Contributed by Daryn Sharp.\n",
          "commitDate": "26/08/16 1:39 PM",
          "commitName": "8b7adf4ddf420a93c586c4b2eac27dd0f649682e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "24/08/16 6:46 AM",
          "commitNameOld": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 2.29,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,36 @@\n   private static INodesInPath addFile(\n-      FSDirectory fsd, INodesInPath existing, String localName,\n+      FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         replication \u003d ecPolicy.getId();\n       }\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n-      newNode.setLocalName(DFSUtil.string2Bytes(localName));\n+      newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n+      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n+          DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, existing-INodesInPath, localName-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]",
            "newValue": "[fsd-FSDirectory, existing-INodesInPath, localName-byte[], permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10768. Optimize mkdir ops. Contributed by Daryn Sharp.\n",
          "commitDate": "26/08/16 1:39 PM",
          "commitName": "8b7adf4ddf420a93c586c4b2eac27dd0f649682e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "24/08/16 6:46 AM",
          "commitNameOld": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 2.29,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,36 @@\n   private static INodesInPath addFile(\n-      FSDirectory fsd, INodesInPath existing, String localName,\n+      FSDirectory fsd, INodesInPath existing, byte[] localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         replication \u003d ecPolicy.getId();\n       }\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n-      newNode.setLocalName(DFSUtil.string2Bytes(localName));\n+      newNode.setLocalName(localName);\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n+      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n+          DFSUtil.bytes2String(localName) + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, byte[] localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n      newNode.setLocalName(localName);\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + DFSUtil.bytes2String(localName));\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" +\n          DFSUtil.bytes2String(localName) + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "6ae39199dac6ac7be6802b31452552c76da16e24": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10662. Optimize UTF8 string/byte conversions. Contributed by Daryn Sharp.\n",
      "commitDate": "04/08/16 7:07 AM",
      "commitName": "6ae39199dac6ac7be6802b31452552c76da16e24",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "02/08/16 1:07 AM",
      "commitNameOld": "a5fb298e56220a35d61b8d2bda716d8fb8ef8bb7",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 2.25,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         replication \u003d ecPolicy.getId();\n       }\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n-      newNode.setLocalName(localName.getBytes(StandardCharsets.UTF_8));\n+      newNode.setLocalName(DFSUtil.string2Bytes(localName));\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n      newNode.setLocalName(DFSUtil.string2Bytes(localName));\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "a5fb298e56220a35d61b8d2bda716d8fb8ef8bb7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10707. Replace org.apache.commons.io.Charsets with java.nio.charset.StandardCharsets. Contributed by Vincent Poon.\n",
      "commitDate": "02/08/16 1:07 AM",
      "commitName": "a5fb298e56220a35d61b8d2bda716d8fb8ef8bb7",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "27/04/16 2:22 PM",
      "commitNameOld": "0a152103f19a3e8e1b7f33aeb9dd115ba231d7b7",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 96.45,
      "commitsBetweenForRepo": 752,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n       if (ecPolicy !\u003d null) {\n         replication \u003d ecPolicy.getId();\n       }\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n-      newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n+      newNode.setLocalName(localName.getBytes(StandardCharsets.UTF_8));\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n      newNode.setLocalName(localName.getBytes(StandardCharsets.UTF_8));\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "7600e3c48ff2043654dbe9f415a186a336b5ea6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7866. Erasure coding: NameNode manages multiple erasure coding policies. Contributed by Rui Li.\n",
      "commitDate": "08/03/16 10:30 PM",
      "commitName": "7600e3c48ff2043654dbe9f415a186a336b5ea6c",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "25/01/16 7:20 PM",
      "commitNameOld": "45c763ad6171bc7808c2ddcb9099a4215113da2a",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 43.13,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,35 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n-      final boolean isStriped \u003d FSDirErasureCodingOp.hasErasureCodingPolicy(\n-          fsd.getFSNamesystem(), existing);\n+      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n+          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n+      if (ecPolicy !\u003d null) {\n+        replication \u003d ecPolicy.getId();\n+      }\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n-          modTime, modTime, replication, preferredBlockSize, isStriped);\n+          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n       newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), existing);\n      if (ecPolicy !\u003d null) {\n        replication \u003d ecPolicy.getId();\n      }\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, ecPolicy !\u003d null);\n      newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "f62237bc2f02afe11ce185e13aa51a60b5960037": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
      "commitDate": "09/09/15 11:07 PM",
      "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "01/09/15 2:30 PM",
      "commitNameOld": "ab56fcdb1219d03713b408dd3a95d7405635254d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 8.36,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n-      final boolean isStriped \u003d FSDirErasureCodingOp.isInErasureCodingZone(\n+      final boolean isStriped \u003d FSDirErasureCodingOp.hasErasureCodingPolicy(\n           fsd.getFSNamesystem(), existing);\n       INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n           modTime, modTime, replication, preferredBlockSize, isStriped);\n       newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n       newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      final boolean isStriped \u003d FSDirErasureCodingOp.hasErasureCodingPolicy(\n          fsd.getFSNamesystem(), existing);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, isStriped);\n      newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "7e091de1366f4b57b5433bc19d738199dc05313d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8058. Erasure coding: use BlockInfo[] for both striped and contiguous blocks in INodeFile. Contributed by Zhe Zhang and Yi Liu.\n",
      "commitDate": "15/07/15 9:49 AM",
      "commitName": "7e091de1366f4b57b5433bc19d738199dc05313d",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "17/06/15 11:35 AM",
      "commitNameOld": "c12a974ccf5f52f63e4f825d8b4d2385953cd119",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 27.93,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,32 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n+    Preconditions.checkNotNull(existing);\n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n-        modTime, modTime, replication, preferredBlockSize);\n-    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n-    newNode.toUnderConstruction(clientName, clientMachine);\n-\n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n+      final boolean isStriped \u003d FSDirErasureCodingOp.isInErasureCodingZone(\n+          fsd.getFSNamesystem(), existing);\n+      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n+          modTime, modTime, replication, preferredBlockSize, isStriped);\n+      newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n+      newNode.toUnderConstruction(clientName, clientMachine);\n       newiip \u003d fsd.addINode(existing, newNode);\n-      if (newiip !\u003d null\n-          \u0026\u0026 FSDirErasureCodingOp.isInErasureCodingZone(fsd.getFSNamesystem(),\n-              newiip)) {\n-        newNode.addStripedBlocksFeature();\n-      }\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    Preconditions.checkNotNull(existing);\n    long modTime \u003d now();\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      final boolean isStriped \u003d FSDirErasureCodingOp.isInErasureCodingZone(\n          fsd.getFSNamesystem(), existing);\n      INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n          modTime, modTime, replication, preferredBlockSize, isStriped);\n      newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n      newNode.toUnderConstruction(clientName, clientMachine);\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "98d340745be682fb251677bb4830aca76119868f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8450. Erasure Coding: Consolidate erasure coding zone related implementation into a single class (Contributed by Rakesh R)\n",
      "commitDate": "10/06/15 10:18 PM",
      "commitName": "98d340745be682fb251677bb4830aca76119868f",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "26/05/15 4:06 PM",
      "commitNameOld": "1299357a05c52ad45513ed0ea854edc9c7ec3de8",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 15.26,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,35 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n         modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       newiip \u003d fsd.addINode(existing, newNode);\n-      if (newiip !\u003d null \u0026\u0026 fsd.isInECZone(newiip)) {\n+      if (newiip !\u003d null\n+          \u0026\u0026 FSDirErasureCodingOp.isInErasureCodingZone(fsd.getFSNamesystem(),\n+              newiip)) {\n         newNode.addStripedBlocksFeature();\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n        modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n      if (newiip !\u003d null\n          \u0026\u0026 FSDirErasureCodingOp.isInErasureCodingZone(fsd.getFSNamesystem(),\n              newiip)) {\n        newNode.addStripedBlocksFeature();\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "1299357a05c52ad45513ed0ea854edc9c7ec3de8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8479. Erasure coding: fix striping related logic in FSDirWriteFileOp to sync with HDFS-8421. Contributed by Zhe Zhang.\n",
      "commitDate": "26/05/15 4:06 PM",
      "commitName": "1299357a05c52ad45513ed0ea854edc9c7ec3de8",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "e53fa769c97416af69ea567aecd44f67e896688b",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,33 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n         modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       newiip \u003d fsd.addINode(existing, newNode);\n+      if (newiip !\u003d null \u0026\u0026 fsd.isInECZone(newiip)) {\n+        newNode.addStripedBlocksFeature();\n+      }\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n        modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n      if (newiip !\u003d null \u0026\u0026 fsd.isInECZone(newiip)) {\n        newNode.addStripedBlocksFeature();\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "1af8c148626effe1b41fc536019fd3349f485d59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7839. Erasure coding: implement facilities in NameNode to create and manage EC zones. Contributed by Zhe Zhang\n",
      "commitDate": "26/05/15 11:55 AM",
      "commitName": "1af8c148626effe1b41fc536019fd3349f485d59",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 11:32 AM",
      "commitNameOld": "1e1e93040748231dc913190aec1e031c379d8271",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,30 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n         modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       newiip \u003d fsd.addINode(existing, newNode);\n-      if (newiip !\u003d null \u0026\u0026 newNode.isStriped()) {\n-        newNode.addStripedBlocksFeature();\n-      }\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n           existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n        modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "1e1e93040748231dc913190aec1e031c379d8271": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7837. Erasure Coding: allocate and persist striped blocks in NameNode. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:32 AM",
      "commitName": "1e1e93040748231dc913190aec1e031c379d8271",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/05/15 8:08 AM",
      "commitNameOld": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.14,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,33 @@\n   private static INodesInPath addFile(\n       FSDirectory fsd, INodesInPath existing, String localName,\n       PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n       throws IOException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n-                                     modTime, modTime, replication, preferredBlockSize);\n+        modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n     fsd.writeLock();\n     try {\n       newiip \u003d fsd.addINode(existing, newNode);\n+      if (newiip !\u003d null \u0026\u0026 newNode.isStriped()) {\n+        newNode.addStripedBlocksFeature();\n+      }\n     } finally {\n       fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-                                       existing.getPath() + \"/\" + localName);\n+          existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n        modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n      if (newiip !\u003d null \u0026\u0026 newNode.isStriped()) {\n        newNode.addStripedBlocksFeature();\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "2b6bcfdafa91223a4116e3e9304579f5f91dccac": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
      "commitDate": "21/05/15 8:08 AM",
      "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n-      permissions, short replication, long preferredBlockSize,\n+  private static INodesInPath addFile(\n+      FSDirectory fsd, INodesInPath existing, String localName,\n+      PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n-    throws FileAlreadyExistsException, QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n+      throws IOException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n-        modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n+                                     modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n-    writeLock();\n+    fsd.writeLock();\n     try {\n-      newiip \u003d addINode(existing, newNode);\n+      newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n-      writeUnlock();\n+      fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+                                       existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n                                     modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n                                       existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
            "oldMethodName": "addFile",
            "newMethodName": "addFile"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n-      permissions, short replication, long preferredBlockSize,\n+  private static INodesInPath addFile(\n+      FSDirectory fsd, INodesInPath existing, String localName,\n+      PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n-    throws FileAlreadyExistsException, QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n+      throws IOException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n-        modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n+                                     modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n-    writeLock();\n+    fsd.writeLock();\n     try {\n-      newiip \u003d addINode(existing, newNode);\n+      newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n-      writeUnlock();\n+      fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+                                       existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n                                     modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n                                       existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n-      permissions, short replication, long preferredBlockSize,\n+  private static INodesInPath addFile(\n+      FSDirectory fsd, INodesInPath existing, String localName,\n+      PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n-    throws FileAlreadyExistsException, QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n+      throws IOException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n-        modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n+                                     modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n-    writeLock();\n+    fsd.writeLock();\n     try {\n-      newiip \u003d addINode(existing, newNode);\n+      newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n-      writeUnlock();\n+      fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+                                       existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n                                     modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n                                       existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[FileAlreadyExistsException, QuotaExceededException, UnresolvedLinkException, SnapshotAccessControlException, AclException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n-      permissions, short replication, long preferredBlockSize,\n+  private static INodesInPath addFile(\n+      FSDirectory fsd, INodesInPath existing, String localName,\n+      PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n-    throws FileAlreadyExistsException, QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n+      throws IOException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n-        modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n+                                     modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n-    writeLock();\n+    fsd.writeLock();\n     try {\n-      newiip \u003d addINode(existing, newNode);\n+      newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n-      writeUnlock();\n+      fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+                                       existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n                                     modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n                                       existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n-      permissions, short replication, long preferredBlockSize,\n+  private static INodesInPath addFile(\n+      FSDirectory fsd, INodesInPath existing, String localName,\n+      PermissionStatus permissions, short replication, long preferredBlockSize,\n       String clientName, String clientMachine)\n-    throws FileAlreadyExistsException, QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n+      throws IOException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n-        modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n+                                     modTime, modTime, replication, preferredBlockSize);\n     newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     INodesInPath newiip;\n-    writeLock();\n+    fsd.writeLock();\n     try {\n-      newiip \u003d addINode(existing, newNode);\n+      newiip \u003d fsd.addINode(existing, newNode);\n     } finally {\n-      writeUnlock();\n+      fsd.writeUnlock();\n     }\n     if (newiip \u003d\u003d null) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n-          existing.getPath() + \"/\" + localName);\n+                                       existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n     return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static INodesInPath addFile(\n      FSDirectory fsd, INodesInPath existing, String localName,\n      PermissionStatus permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n      throws IOException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(fsd.allocateNewInodeId(), permissions,\n                                     modTime, modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    fsd.writeLock();\n    try {\n      newiip \u003d fsd.addINode(existing, newNode);\n    } finally {\n      fsd.writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n                                       existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[existing-INodesInPath, localName-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]",
            "newValue": "[fsd-FSDirectory, existing-INodesInPath, localName-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]"
          }
        }
      ]
    },
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
      "commitDate": "22/12/14 11:19 PM",
      "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
          "commitDate": "22/12/14 11:19 PM",
          "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "18/12/14 11:25 AM",
          "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 4.5,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n-                    short replication, long preferredBlockSize,\n-                    String clientName, String clientMachine)\n+  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n+      permissions, short replication, long preferredBlockSize,\n+      String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n         modTime, replication, preferredBlockSize);\n+    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n-    boolean added \u003d false;\n+    INodesInPath newiip;\n     writeLock();\n     try {\n-      added \u003d addINode(iip, newNode);\n+      newiip \u003d addINode(existing, newNode);\n     } finally {\n       writeUnlock();\n     }\n-    if (!added) {\n-      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n+    if (newiip \u003d\u003d null) {\n+      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n+          existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n+      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n-    return newNode;\n+    return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n      permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n        modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    writeLock();\n    try {\n      newiip \u003d addINode(existing, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[iip-INodesInPath, path-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]",
            "newValue": "[existing-INodesInPath, localName-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
          "commitDate": "22/12/14 11:19 PM",
          "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "18/12/14 11:25 AM",
          "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 4.5,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n-                    short replication, long preferredBlockSize,\n-                    String clientName, String clientMachine)\n+  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n+      permissions, short replication, long preferredBlockSize,\n+      String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n         modTime, replication, preferredBlockSize);\n+    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n-    boolean added \u003d false;\n+    INodesInPath newiip;\n     writeLock();\n     try {\n-      added \u003d addINode(iip, newNode);\n+      newiip \u003d addINode(existing, newNode);\n     } finally {\n       writeUnlock();\n     }\n-    if (!added) {\n-      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n+    if (newiip \u003d\u003d null) {\n+      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n+          existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n+      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n-    return newNode;\n+    return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n      permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n        modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    writeLock();\n    try {\n      newiip \u003d addINode(existing, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "INodeFile",
            "newValue": "INodesInPath"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
          "commitDate": "22/12/14 11:19 PM",
          "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "18/12/14 11:25 AM",
          "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 4.5,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,30 @@\n-  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n-                    short replication, long preferredBlockSize,\n-                    String clientName, String clientMachine)\n+  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n+      permissions, short replication, long preferredBlockSize,\n+      String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n         modTime, replication, preferredBlockSize);\n+    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n-    boolean added \u003d false;\n+    INodesInPath newiip;\n     writeLock();\n     try {\n-      added \u003d addINode(iip, newNode);\n+      newiip \u003d addINode(existing, newNode);\n     } finally {\n       writeUnlock();\n     }\n-    if (!added) {\n-      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n+    if (newiip \u003d\u003d null) {\n+      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n+          existing.getPath() + \"/\" + localName);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n-      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n+      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n     }\n-    return newNode;\n+    return newiip;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus\n      permissions, short replication, long preferredBlockSize,\n      String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n        modTime, replication, preferredBlockSize);\n    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    INodesInPath newiip;\n    writeLock();\n    try {\n      newiip \u003d addINode(existing, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (newiip \u003d\u003d null) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" +\n          existing.getPath() + \"/\" + localName);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + localName + \" is added\");\n    }\n    return newiip;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/12/14 11:37 AM",
          "commitNameOld": "5776a41da08af653206bb94d7c76c9c4dcce059a",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 3.15,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,28 @@\n-  INodeFile addFile(String path, PermissionStatus permissions,\n+  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n                     short replication, long preferredBlockSize,\n                     String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime, modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n+        modTime, replication, preferredBlockSize);\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     boolean added \u003d false;\n     writeLock();\n     try {\n-      added \u003d addINode(path, newNode);\n+      added \u003d addINode(iip, newNode);\n     } finally {\n       writeUnlock();\n     }\n     if (!added) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n     }\n     return newNode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n                    short replication, long preferredBlockSize,\n                    String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n        modTime, replication, preferredBlockSize);\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    boolean added \u003d false;\n    writeLock();\n    try {\n      added \u003d addINode(iip, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (!added) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n    }\n    return newNode;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[path-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]",
            "newValue": "[iip-INodesInPath, path-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/12/14 11:37 AM",
          "commitNameOld": "5776a41da08af653206bb94d7c76c9c4dcce059a",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 3.15,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,28 @@\n-  INodeFile addFile(String path, PermissionStatus permissions,\n+  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n                     short replication, long preferredBlockSize,\n                     String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime, modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n+        modTime, replication, preferredBlockSize);\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     boolean added \u003d false;\n     writeLock();\n     try {\n-      added \u003d addINode(path, newNode);\n+      added \u003d addINode(iip, newNode);\n     } finally {\n       writeUnlock();\n     }\n     if (!added) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n     }\n     return newNode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,\n                    short replication, long preferredBlockSize,\n                    String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime,\n        modTime, replication, preferredBlockSize);\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    boolean added \u003d false;\n    writeLock();\n    try {\n      added \u003d addINode(iip, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (!added) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n    }\n    return newNode;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7462. Consolidate implementation of mkdirs() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "02/12/14 2:53 PM",
      "commitName": "185e0c7b4c056b88f606362c71e4a22aae7076e0",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/12/14 9:48 PM",
      "commitNameOld": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,27 @@\n   INodeFile addFile(String path, PermissionStatus permissions,\n                     short replication, long preferredBlockSize,\n                     String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n-    INodeFile newNode \u003d newINodeFile(namesystem.allocateNewInodeId(),\n-        permissions, modTime, modTime, replication, preferredBlockSize);\n+    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime, modTime, replication, preferredBlockSize);\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     boolean added \u003d false;\n     writeLock();\n     try {\n       added \u003d addINode(path, newNode);\n     } finally {\n       writeUnlock();\n     }\n     if (!added) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n     }\n     return newNode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INodeFile addFile(String path, PermissionStatus permissions,\n                    short replication, long preferredBlockSize,\n                    String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(allocateNewInodeId(), permissions, modTime, modTime, replication, preferredBlockSize);\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    boolean added \u003d false;\n    writeLock();\n    try {\n      added \u003d addINode(path, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (!added) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n    }\n    return newNode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "bb84f1fccb18c6c7373851e05d2451d55e908242": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
      "commitDate": "29/09/14 10:27 PM",
      "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthor": "arp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
          "commitDate": "29/09/14 10:27 PM",
          "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
          "commitAuthor": "arp",
          "commitDateOld": "29/09/14 4:29 PM",
          "commitNameOld": "7f0422be763b7ab6a60a0e90670e12661683f835",
          "commitAuthorOld": "",
          "daysBetweenCommits": 0.25,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,28 @@\n   INodeFile addFile(String path, PermissionStatus permissions,\n                     short replication, long preferredBlockSize,\n-                    boolean isLazyPersist,\n                     String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(namesystem.allocateNewInodeId(),\n-        permissions, modTime, modTime, replication, preferredBlockSize,\n-        isLazyPersist);\n+        permissions, modTime, modTime, replication, preferredBlockSize);\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     boolean added \u003d false;\n     writeLock();\n     try {\n       added \u003d addINode(path, newNode);\n     } finally {\n       writeUnlock();\n     }\n     if (!added) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n     }\n     return newNode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodeFile addFile(String path, PermissionStatus permissions,\n                    short replication, long preferredBlockSize,\n                    String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(namesystem.allocateNewInodeId(),\n        permissions, modTime, modTime, replication, preferredBlockSize);\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    boolean added \u003d false;\n    writeLock();\n    try {\n      added \u003d addINode(path, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (!added) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n    }\n    return newNode;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[path-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, isLazyPersist-boolean, clientName-String, clientMachine-String]",
            "newValue": "[path-String, permissions-PermissionStatus, replication-short, preferredBlockSize-long, clientName-String, clientMachine-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
          "commitDate": "29/09/14 10:27 PM",
          "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
          "commitAuthor": "arp",
          "commitDateOld": "29/09/14 4:29 PM",
          "commitNameOld": "7f0422be763b7ab6a60a0e90670e12661683f835",
          "commitAuthorOld": "",
          "daysBetweenCommits": 0.25,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,28 @@\n   INodeFile addFile(String path, PermissionStatus permissions,\n                     short replication, long preferredBlockSize,\n-                    boolean isLazyPersist,\n                     String clientName, String clientMachine)\n     throws FileAlreadyExistsException, QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException, AclException {\n \n     long modTime \u003d now();\n     INodeFile newNode \u003d newINodeFile(namesystem.allocateNewInodeId(),\n-        permissions, modTime, modTime, replication, preferredBlockSize,\n-        isLazyPersist);\n+        permissions, modTime, modTime, replication, preferredBlockSize);\n     newNode.toUnderConstruction(clientName, clientMachine);\n \n     boolean added \u003d false;\n     writeLock();\n     try {\n       added \u003d addINode(path, newNode);\n     } finally {\n       writeUnlock();\n     }\n     if (!added) {\n       NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n       return null;\n     }\n \n     if(NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n     }\n     return newNode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INodeFile addFile(String path, PermissionStatus permissions,\n                    short replication, long preferredBlockSize,\n                    String clientName, String clientMachine)\n    throws FileAlreadyExistsException, QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException, AclException {\n\n    long modTime \u003d now();\n    INodeFile newNode \u003d newINodeFile(namesystem.allocateNewInodeId(),\n        permissions, modTime, modTime, replication, preferredBlockSize);\n    newNode.toUnderConstruction(clientName, clientMachine);\n\n    boolean added \u003d false;\n    writeLock();\n    try {\n      added \u003d addINode(path, newNode);\n    } finally {\n      writeUnlock();\n    }\n    if (!added) {\n      NameNode.stateChangeLog.info(\"DIR* addFile: failed to add \" + path);\n      return null;\n    }\n\n    if(NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* addFile: \" + path + \" is added\");\n    }\n    return newNode;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}