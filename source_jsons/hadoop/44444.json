{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMaster.java",
  "functionName": "init",
  "functionId": "init___args-String[]",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
  "functionStartLine": 465,
  "functionEndLine": 746,
  "numCommitsSeen": 121,
  "timeTaken": 11274,
  "changeHistory": [
    "30c6dd92e1d4075d143adc891dc8ec536dddc0d9",
    "f738b397ae021c9be900e4ec51ab55cd69b075e0",
    "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93",
    "33d8327cffdc483b538aec3022fd8730b85babdb",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
    "8956e5b8db3059e0872e49f59adc6affc76e2274",
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
    "e60f51299dba360d13aa39f9ab714fdfc666b532",
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90",
    "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14",
    "928964102029e96406f5482e8900802f38164501",
    "40b0045ebe0752cd3d1d09be00acbabdea983799",
    "7805deed4896e470ebd2f6bbd1ba9962947c63cd",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "0d02ab8729630ad3cfb4300702927333b1d349e3",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
    "aa4a192feb8939353254d058c5f81bddbd0335c0",
    "d468c9aaf15e977f12e6214b47996412c907e069",
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
    "ca3381de61ff53604d9389694049a1a4dedc7571",
    "c298a9a845f89317eb9efad332e6657c56736a4d",
    "a8c120222047280234c3411ce1c1c9b17f08c851",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef",
    "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
    "fd1c424548999cb8843f40cb6a342387f98bde6c",
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
    "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
    "33a8234040959ecd0d0202162e1b18c990effabe",
    "a802ef4a5f2e71eed2cbdc053258ae2f66af4755",
    "ad558cf2b3650530c741f1cfafb0cf47e60c8b77",
    "735d8b27f78ea8be839008650a3e88db37dc507d",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "2aed48a67f408c290e90c83af9f76165d695f91a",
    "7c325a5d7186b831b793df239600191601ec635f",
    "f5551bf8091c11586d402cdd4a0b09aa0498b673",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5"
  ],
  "changeHistoryShort": {
    "30c6dd92e1d4075d143adc891dc8ec536dddc0d9": "Ybodychange",
    "f738b397ae021c9be900e4ec51ab55cd69b075e0": "Ybodychange",
    "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93": "Ybodychange",
    "33d8327cffdc483b538aec3022fd8730b85babdb": "Ybodychange",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": "Ybodychange",
    "8956e5b8db3059e0872e49f59adc6affc76e2274": "Ybodychange",
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde": "Ybodychange",
    "e60f51299dba360d13aa39f9ab714fdfc666b532": "Ybodychange",
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90": "Ybodychange",
    "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14": "Ybodychange",
    "928964102029e96406f5482e8900802f38164501": "Ybodychange",
    "40b0045ebe0752cd3d1d09be00acbabdea983799": "Ybodychange",
    "7805deed4896e470ebd2f6bbd1ba9962947c63cd": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ybodychange",
    "0d02ab8729630ad3cfb4300702927333b1d349e3": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": "Ybodychange",
    "aa4a192feb8939353254d058c5f81bddbd0335c0": "Ybodychange",
    "d468c9aaf15e977f12e6214b47996412c907e069": "Ybodychange",
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488": "Ybodychange",
    "ca3381de61ff53604d9389694049a1a4dedc7571": "Ybodychange",
    "c298a9a845f89317eb9efad332e6657c56736a4d": "Ybodychange",
    "a8c120222047280234c3411ce1c1c9b17f08c851": "Ybodychange",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": "Ybodychange",
    "6c2a0ce30b8bc54998ec40551bc14f478a353e10": "Ybodychange",
    "fd1c424548999cb8843f40cb6a342387f98bde6c": "Ybodychange",
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f": "Ybodychange",
    "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4": "Ybodychange",
    "33a8234040959ecd0d0202162e1b18c990effabe": "Ybodychange",
    "a802ef4a5f2e71eed2cbdc053258ae2f66af4755": "Ybodychange",
    "ad558cf2b3650530c741f1cfafb0cf47e60c8b77": "Ybodychange",
    "735d8b27f78ea8be839008650a3e88db37dc507d": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "2aed48a67f408c290e90c83af9f76165d695f91a": "Ybodychange",
    "7c325a5d7186b831b793df239600191601ec635f": "Ybodychange",
    "f5551bf8091c11586d402cdd4a0b09aa0498b673": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5": "Ybodychange",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": "Ybodychange",
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "30c6dd92e1d4075d143adc891dc8ec536dddc0d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9452. Fix TestDistributedShell and TestTimelineAuthFilterForV2 failures. Contributed by Prabhu Joseph.\n",
      "commitDate": "30/05/19 10:02 AM",
      "commitName": "30c6dd92e1d4075d143adc891dc8ec536dddc0d9",
      "commitAuthor": "Sunil G",
      "commitDateOld": "23/05/19 1:27 PM",
      "commitNameOld": "6a0e7dd454d587266a6020f83c6d07efb946d6ce",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.86,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,276 +1,282 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"appname\", true,\n         \"Application Name. Default value - DistributedShell\");\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"enforce_execution_type\", false,\n         \"Flag to indicate whether to enforce execution type of containers\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"container_failures_validity_interval\", true,\n         \"Failures which are out of the time window will not be added to\"\n             + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"keep_containers_across_application_attempts\", false,\n         \"Flag to indicate whether to keep containers across application \"\n             + \"attempts.\"\n             + \" If the flag is true, running containers will not be killed when\"\n             + \" application attempt fails and these containers will be \"\n             + \"retrieved by\"\n             + \" the new application attempt \");\n     opts.addOption(\"localized_files\", true, \"List of localized files\");\n+    opts.addOption(\"homedir\", true, \"Home Directory of Job Owner\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n+    homeDirectory \u003d cliParser.hasOption(\"homedir\") ?\n+        new Path(cliParser.getOptionValue(\"homedir\")) :\n+        new Path(\"/user/\" + System.getenv(ApplicationConstants.\n+        Environment.USER.name()));\n+\n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n       LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n \n       this.numTotalContainers \u003d 0;\n       int globalNumOfContainers \u003d Integer\n           .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n       parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n \n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n       appId \u003d appAttemptID.getApplicationId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     if (cliParser.hasOption(\"enforce_execution_type\")) {\n       enforceExecType \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n     keepContainersAcrossAttempts \u003d cliParser.hasOption(\n         \"keep_containers_across_application_attempts\");\n \n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     containerFailuresValidityInterval \u003d Long.parseLong(\n         cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     if (cliParser.hasOption(\"localized_files\")) {\n       String localizedFilesArg \u003d cliParser.getOptionValue(\"localized_files\");\n       if (localizedFilesArg.contains(\",\")) {\n         String[] files \u003d localizedFilesArg.split(\",\");\n         localizableFiles \u003d Arrays.asList(files);\n       } else {\n         localizableFiles.add(localizedFilesArg);\n       }\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true,\n        \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"enforce_execution_type\", false,\n        \"Flag to indicate whether to enforce execution type of containers\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"keep_containers_across_application_attempts\", false,\n        \"Flag to indicate whether to keep containers across application \"\n            + \"attempts.\"\n            + \" If the flag is true, running containers will not be killed when\"\n            + \" application attempt fails and these containers will be \"\n            + \"retrieved by\"\n            + \" the new application attempt \");\n    opts.addOption(\"localized_files\", true, \"List of localized files\");\n    opts.addOption(\"homedir\", true, \"Home Directory of Job Owner\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    homeDirectory \u003d cliParser.hasOption(\"homedir\") ?\n        new Path(cliParser.getOptionValue(\"homedir\")) :\n        new Path(\"/user/\" + System.getenv(ApplicationConstants.\n        Environment.USER.name()));\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n      LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n\n      this.numTotalContainers \u003d 0;\n      int globalNumOfContainers \u003d Integer\n          .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n      parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n      appId \u003d appAttemptID.getApplicationId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    if (cliParser.hasOption(\"enforce_execution_type\")) {\n      enforceExecType \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n        \"keep_containers_across_application_attempts\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    if (cliParser.hasOption(\"localized_files\")) {\n      String localizedFilesArg \u003d cliParser.getOptionValue(\"localized_files\");\n      if (localizedFilesArg.contains(\",\")) {\n        String[] files \u003d localizedFilesArg.split(\",\");\n        localizableFiles \u003d Arrays.asList(files);\n      } else {\n        localizableFiles.add(localizedFilesArg);\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "f738b397ae021c9be900e4ec51ab55cd69b075e0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9191. Add cli option in DS to support enforceExecutionType in resource requests. Contributed by Abhishek Modi.\n",
      "commitDate": "31/01/19 11:24 AM",
      "commitName": "f738b397ae021c9be900e4ec51ab55cd69b075e0",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "11/12/18 2:13 PM",
      "commitNameOld": "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 50.88,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,271 +1,276 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"appname\", true,\n         \"Application Name. Default value - DistributedShell\");\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n+    opts.addOption(\"enforce_execution_type\", false,\n+        \"Flag to indicate whether to enforce execution type of containers\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"container_failures_validity_interval\", true,\n         \"Failures which are out of the time window will not be added to\"\n             + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"keep_containers_across_application_attempts\", false,\n         \"Flag to indicate whether to keep containers across application \"\n             + \"attempts.\"\n             + \" If the flag is true, running containers will not be killed when\"\n             + \" application attempt fails and these containers will be \"\n             + \"retrieved by\"\n             + \" the new application attempt \");\n     opts.addOption(\"localized_files\", true, \"List of localized files\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n       LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n \n       this.numTotalContainers \u003d 0;\n       int globalNumOfContainers \u003d Integer\n           .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n       parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n \n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n       appId \u003d appAttemptID.getApplicationId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n+    if (cliParser.hasOption(\"enforce_execution_type\")) {\n+      enforceExecType \u003d true;\n+    }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n     keepContainersAcrossAttempts \u003d cliParser.hasOption(\n         \"keep_containers_across_application_attempts\");\n \n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     containerFailuresValidityInterval \u003d Long.parseLong(\n         cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     if (cliParser.hasOption(\"localized_files\")) {\n       String localizedFilesArg \u003d cliParser.getOptionValue(\"localized_files\");\n       if (localizedFilesArg.contains(\",\")) {\n         String[] files \u003d localizedFilesArg.split(\",\");\n         localizableFiles \u003d Arrays.asList(files);\n       } else {\n         localizableFiles.add(localizedFilesArg);\n       }\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true,\n        \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"enforce_execution_type\", false,\n        \"Flag to indicate whether to enforce execution type of containers\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"keep_containers_across_application_attempts\", false,\n        \"Flag to indicate whether to keep containers across application \"\n            + \"attempts.\"\n            + \" If the flag is true, running containers will not be killed when\"\n            + \" application attempt fails and these containers will be \"\n            + \"retrieved by\"\n            + \" the new application attempt \");\n    opts.addOption(\"localized_files\", true, \"List of localized files\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n      LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n\n      this.numTotalContainers \u003d 0;\n      int globalNumOfContainers \u003d Integer\n          .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n      parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n      appId \u003d appAttemptID.getApplicationId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    if (cliParser.hasOption(\"enforce_execution_type\")) {\n      enforceExecType \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n        \"keep_containers_across_application_attempts\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    if (cliParser.hasOption(\"localized_files\")) {\n      String localizedFilesArg \u003d cliParser.getOptionValue(\"localized_files\");\n      if (localizedFilesArg.contains(\",\")) {\n        String[] files \u003d localizedFilesArg.split(\",\");\n        localizableFiles \u003d Arrays.asList(files);\n      } else {\n        localizableFiles.add(localizedFilesArg);\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9008. Extend YARN distributed shell with file localization feature. (Contributed by Peter Bacsko)\n",
      "commitDate": "11/12/18 2:13 PM",
      "commitName": "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "16/09/18 9:37 PM",
      "commitNameOld": "33d8327cffdc483b538aec3022fd8730b85babdb",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 85.73,
      "commitsBetweenForRepo": 734,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,255 +1,271 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n+    opts.addOption(\"appname\", true,\n+        \"Application Name. Default value - DistributedShell\");\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"container_failures_validity_interval\", true,\n         \"Failures which are out of the time window will not be added to\"\n             + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"keep_containers_across_application_attempts\", false,\n         \"Flag to indicate whether to keep containers across application \"\n             + \"attempts.\"\n             + \" If the flag is true, running containers will not be killed when\"\n             + \" application attempt fails and these containers will be \"\n             + \"retrieved by\"\n             + \" the new application attempt \");\n+    opts.addOption(\"localized_files\", true, \"List of localized files\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n+    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n+\n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n       LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n \n       this.numTotalContainers \u003d 0;\n       int globalNumOfContainers \u003d Integer\n           .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n       parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n \n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n+      appId \u003d appAttemptID.getApplicationId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n     keepContainersAcrossAttempts \u003d cliParser.hasOption(\n         \"keep_containers_across_application_attempts\");\n \n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     containerFailuresValidityInterval \u003d Long.parseLong(\n         cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n+    if (cliParser.hasOption(\"localized_files\")) {\n+      String localizedFilesArg \u003d cliParser.getOptionValue(\"localized_files\");\n+      if (localizedFilesArg.contains(\",\")) {\n+        String[] files \u003d localizedFilesArg.split(\",\");\n+        localizableFiles \u003d Arrays.asList(files);\n+      } else {\n+        localizableFiles.add(localizedFilesArg);\n+      }\n+    }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true,\n        \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"keep_containers_across_application_attempts\", false,\n        \"Flag to indicate whether to keep containers across application \"\n            + \"attempts.\"\n            + \" If the flag is true, running containers will not be killed when\"\n            + \" application attempt fails and these containers will be \"\n            + \"retrieved by\"\n            + \" the new application attempt \");\n    opts.addOption(\"localized_files\", true, \"List of localized files\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n      LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n\n      this.numTotalContainers \u003d 0;\n      int globalNumOfContainers \u003d Integer\n          .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n      parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n      appId \u003d appAttemptID.getApplicationId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n        \"keep_containers_across_application_attempts\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    if (cliParser.hasOption(\"localized_files\")) {\n      String localizedFilesArg \u003d cliParser.getOptionValue(\"localized_files\");\n      if (localizedFilesArg.contains(\",\")) {\n        String[] files \u003d localizedFilesArg.split(\",\");\n        localizableFiles \u003d Arrays.asList(files);\n      } else {\n        localizableFiles.add(localizedFilesArg);\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "33d8327cffdc483b538aec3022fd8730b85babdb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8715. Make allocation tags in the placement spec optional for node-attributes. Contributed by Weiwei Yang.\n",
      "commitDate": "16/09/18 9:37 PM",
      "commitName": "33d8327cffdc483b538aec3022fd8730b85babdb",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,253 +1,255 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"container_failures_validity_interval\", true,\n         \"Failures which are out of the time window will not be added to\"\n             + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"keep_containers_across_application_attempts\", false,\n         \"Flag to indicate whether to keep containers across application \"\n             + \"attempts.\"\n             + \" If the flag is true, running containers will not be killed when\"\n             + \" application attempt fails and these containers will be \"\n             + \"retrieved by\"\n             + \" the new application attempt \");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n       LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n \n       this.numTotalContainers \u003d 0;\n-      parsePlacementSpecs(decodedSpec);\n+      int globalNumOfContainers \u003d Integer\n+          .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n+      parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n \n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n     keepContainersAcrossAttempts \u003d cliParser.hasOption(\n         \"keep_containers_across_application_attempts\");\n \n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     containerFailuresValidityInterval \u003d Long.parseLong(\n         cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"keep_containers_across_application_attempts\", false,\n        \"Flag to indicate whether to keep containers across application \"\n            + \"attempts.\"\n            + \" If the flag is true, running containers will not be killed when\"\n            + \" application attempt fails and these containers will be \"\n            + \"retrieved by\"\n            + \" the new application attempt \");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n      LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n\n      this.numTotalContainers \u003d 0;\n      int globalNumOfContainers \u003d Integer\n          .parseInt(cliParser.getOptionValue(\"num_containers\", \"0\"));\n      parsePlacementSpecs(decodedSpec, globalNumOfContainers);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n        \"keep_containers_across_application_attempts\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7863. Modify placement constraints to support node attributes. Contributed by Sunil Govindan.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "02/09/18 1:05 AM",
      "commitNameOld": "eed8415dc18fa7415ebd105350bd0532b3b1b6bb",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 10.1,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,249 +1,253 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"container_failures_validity_interval\", true,\n         \"Failures which are out of the time window will not be added to\"\n             + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"keep_containers_across_application_attempts\", false,\n         \"Flag to indicate whether to keep containers across application \"\n             + \"attempts.\"\n             + \" If the flag is true, running containers will not be killed when\"\n             + \" application attempt fails and these containers will be \"\n             + \"retrieved by\"\n             + \" the new application attempt \");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n-      LOG.info(\"Placement Spec received [{}]\", placementSpec);\n-      parsePlacementSpecs(placementSpec);\n+      String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n+      LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n+\n+      this.numTotalContainers \u003d 0;\n+      parsePlacementSpecs(decodedSpec);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n+\n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n     keepContainersAcrossAttempts \u003d cliParser.hasOption(\n         \"keep_containers_across_application_attempts\");\n \n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     containerFailuresValidityInterval \u003d Long.parseLong(\n         cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"keep_containers_across_application_attempts\", false,\n        \"Flag to indicate whether to keep containers across application \"\n            + \"attempts.\"\n            + \" If the flag is true, running containers will not be killed when\"\n            + \" application attempt fails and these containers will be \"\n            + \"retrieved by\"\n            + \" the new application attempt \");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      String decodedSpec \u003d getDecodedPlacementSpec(placementSpec);\n      LOG.info(\"Placement Spec received [{}]\", decodedSpec);\n\n      this.numTotalContainers \u003d 0;\n      parsePlacementSpecs(decodedSpec);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n        \"keep_containers_across_application_attempts\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "8956e5b8db3059e0872e49f59adc6affc76e2274": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8372. Distributed shell app master should not release containers when shutdown if keep-container is true. (Suma Shivaprasad via wangda)\n\nChange-Id: Ief04d1ca865621f348fba4ac85fa78bc47465904\n",
      "commitDate": "01/06/18 2:49 PM",
      "commitName": "8956e5b8db3059e0872e49f59adc6affc76e2274",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/05/18 1:49 PM",
      "commitNameOld": "1ef0a1db1d6a412b2a26782329a8325635866d0a",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 24.04,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,239 +1,249 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"container_failures_validity_interval\", true,\n         \"Failures which are out of the time window will not be added to\"\n             + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n+    opts.addOption(\"keep_containers_across_application_attempts\", false,\n+        \"Flag to indicate whether to keep containers across application \"\n+            + \"attempts.\"\n+            + \" If the flag is true, running containers will not be killed when\"\n+            + \" application attempt fails and these containers will be \"\n+            + \"retrieved by\"\n+            + \" the new application attempt \");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       LOG.info(\"Placement Spec received [{}]\", placementSpec);\n       parsePlacementSpecs(placementSpec);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n+    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n+        \"keep_containers_across_application_attempts\");\n+\n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     containerFailuresValidityInterval \u003d Long.parseLong(\n         cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"keep_containers_across_application_attempts\", false,\n        \"Flag to indicate whether to keep containers across application \"\n            + \"attempts.\"\n            + \" If the flag is true, running containers will not be killed when\"\n            + \" application attempt fails and these containers will be \"\n            + \"retrieved by\"\n            + \" the new application attempt \");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      LOG.info(\"Placement Spec received [{}]\", placementSpec);\n      parsePlacementSpecs(placementSpec);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    keepContainersAcrossAttempts \u003d cliParser.hasOption(\n        \"keep_containers_across_application_attempts\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5015. Support sliding window retry capability for container restart. (Chandni Singh via wangda)\n\nChange-Id: I07addd3e4ba8d98456ee2ff1d5c540a38fe61dea\n",
      "commitDate": "13/03/18 5:55 PM",
      "commitName": "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "15/02/18 11:07 PM",
      "commitNameOld": "aae629913cee0157c945a2c7384c7bf398f10616",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 25.74,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,235 +1,239 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n+    opts.addOption(\"container_failures_validity_interval\", true,\n+        \"Failures which are out of the time window will not be added to\"\n+            + \" the number of container retry attempts\");\n     opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       LOG.info(\"Placement Spec received [{}]\", placementSpec);\n       parsePlacementSpecs(placementSpec);\n       LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n       if (numTotalContainers \u003d\u003d 0) {\n         throw new IllegalArgumentException(\n             \"Cannot run distributed shell with no containers\");\n       }\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n \n     if (this.placementSpecs \u003d\u003d null) {\n       numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n           \"num_containers\", \"1\"));\n     }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n-\n+    containerFailuresValidityInterval \u003d Long.parseLong(\n+        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"container_failures_validity_interval\", true,\n        \"Failures which are out of the time window will not be added to\"\n            + \" the number of container retry attempts\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      LOG.info(\"Placement Spec received [{}]\", placementSpec);\n      parsePlacementSpecs(placementSpec);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    containerFailuresValidityInterval \u003d Long.parseLong(\n        cliParser.getOptionValue(\"container_failures_validity_interval\", \"-1\"));\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "e60f51299dba360d13aa39f9ab714fdfc666b532": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7745. Allow DistributedShell to take a placement specification for containers it wants to launch. (Arun Suresh via wangda)\n\nChange-Id: Ided146d662e944a8a4692e5d6885f23fd9bbcad5\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "e60f51299dba360d13aa39f9ab714fdfc666b532",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/01/18 3:26 AM",
      "commitNameOld": "97607617ce01ee21af4fb9eb8df26fc6986a38a2",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,220 +1,235 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n+    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n+    if (cliParser.hasOption(\"placement_spec\")) {\n+      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n+      LOG.info(\"Placement Spec received [{}]\", placementSpec);\n+      parsePlacementSpecs(placementSpec);\n+      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n+      if (numTotalContainers \u003d\u003d 0) {\n+        throw new IllegalArgumentException(\n+            \"Cannot run distributed shell with no containers\");\n+      }\n+    }\n+\n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n-    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n-        \"num_containers\", \"1\"));\n+\n+    if (this.placementSpecs \u003d\u003d null) {\n+      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n+          \"num_containers\", \"1\"));\n+    }\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"placement_spec\", true, \"Placement specification\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      String placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      LOG.info(\"Placement Spec received [{}]\", placementSpec);\n      parsePlacementSpecs(placementSpec);\n      LOG.info(\"Total num containers requested [{}]\", numTotalContainers);\n      if (numTotalContainers \u003d\u003d 0) {\n        throw new IllegalArgumentException(\n            \"Cannot run distributed shell with no containers\");\n      }\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n\n    if (this.placementSpecs \u003d\u003d null) {\n      numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n          \"num_containers\", \"1\"));\n    }\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6736. Consider writing to both ats v1 \u0026 v2 from RM for smoother upgrades. Contributed by Aaron Gresch.\n",
      "commitDate": "15/01/18 6:28 PM",
      "commitName": "d09058b2fd18803d12f0835fdf78aef5e0b99c90",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "09/01/18 3:09 AM",
      "commitNameOld": "783a01eb4a155044a54a30a636b86b3ab2b33044",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,224 +1,220 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resources\", true,\n         \"Amount of resources to be requested to run the shell command. \" +\n         \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n         \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResources \u003d new HashMap\u003c\u003e();\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n           cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         containerResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n-    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n-      timelineServiceV2Enabled \u003d\n-          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n-      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n-    } else {\n+    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (!YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7242. Support to specify values of different resource types in DistributedShell for easier testing. Contributed by Gergely Novák.\n",
      "commitDate": "07/01/18 10:29 PM",
      "commitName": "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14",
      "commitAuthor": "Sunil G",
      "commitDateOld": "17/12/17 6:07 PM",
      "commitNameOld": "928964102029e96406f5482e8900802f38164501",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 21.18,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,224 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"promote_opportunistic_after_start\", false,\n         \"Flag to indicate whether to automatically promote opportunistic\"\n             + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n+    opts.addOption(\"container_resources\", true,\n+        \"Amount of resources to be requested to run the shell command. \" +\n+        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n+        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n+    containerResources \u003d new HashMap\u003c\u003e();\n+    if (cliParser.hasOption(\"container_resources\")) {\n+      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n+          cliParser.getOptionValue(\"container_resources\"));\n+      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n+        containerResources.put(entry.getKey(), entry.getValue());\n+      }\n+    }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineServiceV2Enabled \u003d\n           ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n       timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n     } else {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resources\", true,\n        \"Amount of resources to be requested to run the shell command. \" +\n        \"Specified as resource type\u003dvalue pairs separated by commas. \" +\n        \"E.g. -container_resources memory-mb\u003d512,vcores\u003d1\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResources \u003d new HashMap\u003c\u003e();\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d Client.parseResourcesString(\n          cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        containerResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2Enabled \u003d\n          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n    } else {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "928964102029e96406f5482e8900802f38164501": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7617. Add a flag in distributed shell to automatically PROMOTE opportunistic containers to guaranteed once they are started. Contributed by Weiwei Yang.\n",
      "commitDate": "17/12/17 6:07 PM",
      "commitName": "928964102029e96406f5482e8900802f38164501",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "06/12/17 1:52 AM",
      "commitNameOld": "40b0045ebe0752cd3d1d09be00acbabdea983799",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 11.68,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,206 +1,212 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_type\", true,\n         \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n+    opts.addOption(\"promote_opportunistic_after_start\", false,\n+        \"Flag to indicate whether to automatically promote opportunistic\"\n+            + \" containers to guaranteed.\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n               .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n+    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n+      autoPromoteContainers \u003d true;\n+    }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineServiceV2Enabled \u003d\n           ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n       timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n     } else {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"promote_opportunistic_after_start\", false,\n        \"Flag to indicate whether to automatically promote opportunistic\"\n            + \" containers to guaranteed.\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2Enabled \u003d\n          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n    } else {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "40b0045ebe0752cd3d1d09be00acbabdea983799": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7610. Extend Distributed Shell to support launching job with opportunistic containers. Contributed by Weiwei Yang.\n",
      "commitDate": "06/12/17 1:52 AM",
      "commitName": "40b0045ebe0752cd3d1d09be00acbabdea983799",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "31/10/17 12:36 AM",
      "commitNameOld": "785f1b0d11a3bf0af9851c080ff0acc34539f17b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 36.09,
      "commitsBetweenForRepo": 295,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,194 +1,206 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n+    opts.addOption(\"container_type\", true,\n+        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"container_resource_profile\", true,\n         \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n+    if (cliParser.hasOption(\"container_type\")) {\n+      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n+      if (Arrays.stream(ExecutionType.values()).noneMatch(\n+          executionType -\u003e executionType.toString()\n+              .equals(containerTypeStr))) {\n+        throw new IllegalArgumentException(\"Invalid container_type: \"\n+            + containerTypeStr);\n+      }\n+      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n+    }\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"-1\"));\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineServiceV2Enabled \u003d\n           ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n       timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n     } else {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_type\", true,\n        \"Container execution type, GUARANTEED or OPPORTUNISTIC\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n              .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2Enabled \u003d\n          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n    } else {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "7805deed4896e470ebd2f6bbd1ba9962947c63cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5588. [YARN-3926] Add support for resource profiles in distributed shell. Contributed by Varun Vasudev.\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "7805deed4896e470ebd2f6bbd1ba9962947c63cd",
      "commitAuthor": "Sunil G",
      "commitDateOld": "07/09/17 10:23 AM",
      "commitNameOld": "c41118a7f826dcbb269b4bd3d5877b35fbbee2b1",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 4.96,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,190 +1,194 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n+    opts.addOption(\"container_resource_profile\", true,\n+        \"Resource profile to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n-        \"container_memory\", \"10\"));\n+        \"container_memory\", \"-1\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n-        \"container_vcores\", \"1\"));\n+        \"container_vcores\", \"-1\"));\n+    containerResourceProfile \u003d\n+        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (YarnConfiguration.timelineServiceEnabled(conf)) {\n       timelineServiceV2Enabled \u003d\n           ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n       timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n     } else {\n       timelineClient \u003d null;\n       timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"container_resource_profile\", true,\n        \"Resource profile to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"-1\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"-1\"));\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2Enabled \u003d\n          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n    } else {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "06/01/17 2:26 PM",
      "commitNameOld": "71a4acf74bc9ca34f0e57835c9d6e3efbe7c0567",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 40.89,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,190 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (YarnConfiguration.timelineServiceEnabled(conf)) {\n-      timelineServiceV2 \u003d YarnConfiguration.timelineServiceV2Enabled(conf);\n+      timelineServiceV2Enabled \u003d\n+          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n+      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n     } else {\n       timelineClient \u003d null;\n+      timelineV2Client \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2Enabled \u003d\n          ((int) YarnConfiguration.getTimelineServiceVersion(conf) \u003d\u003d 2);\n      timelineServiceV1Enabled \u003d !timelineServiceV2Enabled;\n    } else {\n      timelineClient \u003d null;\n      timelineV2Client \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "0d02ab8729630ad3cfb4300702927333b1d349e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3367. Replace starting a separate thread for post entity with event loop in TimelineClient (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,191 +1,187 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n     if (YarnConfiguration.timelineServiceEnabled(conf)) {\n-      timelineServiceV2 \u003d\n-          YarnConfiguration.timelineServiceV2Enabled(conf);\n-      if (timelineServiceV2) {\n-        threadPool \u003d createThreadPool();\n-      }\n+      timelineServiceV2 \u003d YarnConfiguration.timelineServiceV2Enabled(conf);\n     } else {\n       timelineClient \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2 \u003d YarnConfiguration.timelineServiceV2Enabled(conf);\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,204 +1,191 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n-    opts.addOption(\"timeline_service_version\", true,\n-        \"Version for timeline service\");\n+\n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n \n-    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n-      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n-      if (cliParser.hasOption(\"timeline_service_version\")) {\n-        String timelineServiceVersion \u003d\n-            cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n-        if (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\")) {\n-          newTimelineService \u003d false;\n-        } else if (timelineServiceVersion.trim().equalsIgnoreCase(\"v2\")) {\n-          newTimelineService \u003d true;\n-        } else {\n-          throw new IllegalArgumentException(\n-              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n-        }\n+    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n+      timelineServiceV2 \u003d\n+          YarnConfiguration.timelineServiceV2Enabled(conf);\n+      if (timelineServiceV2) {\n+        threadPool \u003d createThreadPool();\n       }\n     } else {\n       timelineClient \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n-      if (cliParser.hasOption(\"timeline_service_version\")) {\n-        throw new IllegalArgumentException(\n-            \"Timeline service is not enabled\");\n-      }\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (YarnConfiguration.timelineServiceEnabled(conf)) {\n      timelineServiceV2 \u003d\n          YarnConfiguration.timelineServiceV2Enabled(conf);\n      if (timelineServiceV2) {\n        threadPool \u003d createThreadPool();\n      }\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "09/07/16 5:09 AM",
      "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,204 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n-\n+    opts.addOption(\"timeline_service_version\", true, \n+        \"Version for timeline service\");\n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n+\n+    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n+      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n+      if (cliParser.hasOption(\"timeline_service_version\")) {\n+        String timelineServiceVersion \u003d \n+            cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n+        if (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\")) {\n+          newTimelineService \u003d false;\n+        } else if (timelineServiceVersion.trim().equalsIgnoreCase(\"v2\")) {\n+          newTimelineService \u003d true;\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n+        }\n+      }\n+    } else {\n+      timelineClient \u003d null;\n+      LOG.warn(\"Timeline service is not enabled\");\n+      if (cliParser.hasOption(\"timeline_service_version\")) {\n+        throw new IllegalArgumentException(\n+            \"Timeline service is not enabled\");\n+      }\n+    }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"timeline_service_version\", true, \n        \"Version for timeline service\");\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n\n    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n      if (cliParser.hasOption(\"timeline_service_version\")) {\n        String timelineServiceVersion \u003d \n            cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n        if (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\")) {\n          newTimelineService \u003d false;\n        } else if (timelineServiceVersion.trim().equalsIgnoreCase(\"v2\")) {\n          newTimelineService \u003d true;\n        } else {\n          throw new IllegalArgumentException(\n              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n        }\n      }\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n      if (cliParser.hasOption(\"timeline_service_version\")) {\n        throw new IllegalArgumentException(\n            \"Timeline service is not enabled\");\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 16.26,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,179 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"container_retry_policy\", true,\n         \"Retry policy when container fails to run, \"\n             + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n             + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n     opts.addOption(\"container_retry_error_codes\", true,\n         \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n             + \"codes is specified with this option, \"\n             + \"e.g. --container_retry_error_codes 1,2,3\");\n     opts.addOption(\"container_max_retries\", true,\n         \"If container could retry, it specifies max retires\");\n     opts.addOption(\"container_retry_interval\", true,\n         \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n-        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n+        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n-      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n+      ContainerId containerId \u003d ContainerId.fromString(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n         Integer.parseInt(cliParser.getOptionValue(\n             \"container_retry_policy\", \"0\"))];\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n       for (String errorCode :\n           cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n         containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n       }\n     }\n     containerMaxRetries \u003d Integer.parseInt(\n         cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n     containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_retry_interval\", \"0\"));\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ApplicationAttemptId.fromString(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ContainerId.fromString(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3998. Add support in the NodeManager to re-launch containers. Contributed by Jun Gong.\n",
      "commitDate": "29/04/16 3:39 AM",
      "commitName": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "16/04/16 7:39 PM",
      "commitNameOld": "e6c0742012ffeacad2bcaf712d86a7e5d1420b26",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 12.33,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,179 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n+    opts.addOption(\"container_retry_policy\", true,\n+        \"Retry policy when container fails to run, \"\n+            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n+            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n+    opts.addOption(\"container_retry_error_codes\", true,\n+        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n+            + \"codes is specified with this option, \"\n+            + \"e.g. --container_retry_error_codes 1,2,3\");\n+    opts.addOption(\"container_max_retries\", true,\n+        \"If container could retry, it specifies max retires\");\n+    opts.addOption(\"container_retry_interval\", true,\n+        \"Interval between each retry, unit is milliseconds\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n+\n+    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n+        Integer.parseInt(cliParser.getOptionValue(\n+            \"container_retry_policy\", \"0\"))];\n+    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n+      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n+      for (String errorCode :\n+          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n+        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n+      }\n+    }\n+    containerMaxRetries \u003d Integer.parseInt(\n+        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n+    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n+        \"container_retry_interval\", \"0\"));\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"container_retry_policy\", true,\n        \"Retry policy when container fails to run, \"\n            + \"0: NEVER_RETRY, 1: RETRY_ON_ALL_ERRORS, \"\n            + \"2: RETRY_ON_SPECIFIC_ERROR_CODES\");\n    opts.addOption(\"container_retry_error_codes\", true,\n        \"When retry policy is set to RETRY_ON_SPECIFIC_ERROR_CODES, error \"\n            + \"codes is specified with this option, \"\n            + \"e.g. --container_retry_error_codes 1,2,3\");\n    opts.addOption(\"container_max_retries\", true,\n        \"If container could retry, it specifies max retires\");\n    opts.addOption(\"container_retry_interval\", true,\n        \"Interval between each retry, unit is milliseconds\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    containerRetryPolicy \u003d ContainerRetryPolicy.values()[\n        Integer.parseInt(cliParser.getOptionValue(\n            \"container_retry_policy\", \"0\"))];\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryErrorCodes \u003d new HashSet\u003c\u003e();\n      for (String errorCode :\n          cliParser.getOptionValue(\"container_retry_error_codes\").split(\",\")) {\n        containerRetryErrorCodes.add(Integer.parseInt(errorCode));\n      }\n    }\n    containerMaxRetries \u003d Integer.parseInt(\n        cliParser.getOptionValue(\"container_max_retries\", \"0\"));\n    containrRetryInterval \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_retry_interval\", \"0\"));\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "aa4a192feb8939353254d058c5f81bddbd0335c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3522. Fixed DistributedShell to instantiate TimeLineClient as the correct user. Contributed by Zhijie Shen\n",
      "commitDate": "23/04/15 11:07 AM",
      "commitName": "aa4a192feb8939353254d058c5f81bddbd0335c0",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/12/14 8:04 PM",
      "commitNameOld": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 120.59,
      "commitsBetweenForRepo": 969,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,152 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n-\n-    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n-      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n-      // Creating the Timeline Client\n-      timelineClient \u003d TimelineClient.createTimelineClient();\n-      timelineClient.init(conf);\n-      timelineClient.start();\n-    } else {\n-      timelineClient \u003d null;\n-      LOG.warn(\"Timeline service is not enabled\");\n-    }\n-\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d468c9aaf15e977f12e6214b47996412c907e069": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2940. Fix new findbugs warnings in rest of the hadoop-yarn components. (Contributed by Li Lu)\n",
      "commitDate": "23/12/14 8:04 PM",
      "commitName": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/12/14 8:02 PM",
      "commitNameOld": "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,164 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n-        shellScriptPathTimestamp \u003d Long.valueOf(envs\n+        shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n-        shellScriptPathLen \u003d Long.valueOf(envs\n+        shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n       YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n       // Creating the Timeline Client\n       timelineClient \u003d TimelineClient.createTimelineClient();\n       timelineClient.init(conf);\n       timelineClient.start();\n     } else {\n       timelineClient \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n      // Creating the Timeline Client\n      timelineClient \u003d TimelineClient.createTimelineClient();\n      timelineClient.init(conf);\n      timelineClient.start();\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488": {
      "type": "Ybodychange",
      "commitMessage": "Revert ca3381de61ff53604d9389694049a1a4dedc7571 and 20674255ad891bb693ecb2faa5bdb37477073dac as missing JIRA number in commit message\n",
      "commitDate": "23/12/14 8:02 PM",
      "commitName": "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/12/14 6:57 PM",
      "commitNameOld": "ca3381de61ff53604d9389694049a1a4dedc7571",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,164 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n-        shellScriptPathTimestamp \u003d Long.parseLong(envs\n+        shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n-        shellScriptPathLen \u003d Long.parseLong(envs\n+        shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n       YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n       // Creating the Timeline Client\n       timelineClient \u003d TimelineClient.createTimelineClient();\n       timelineClient.init(conf);\n       timelineClient.start();\n     } else {\n       timelineClient \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n      // Creating the Timeline Client\n      timelineClient \u003d TimelineClient.createTimelineClient();\n      timelineClient.init(conf);\n      timelineClient.start();\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "ca3381de61ff53604d9389694049a1a4dedc7571": {
      "type": "Ybodychange",
      "commitMessage": "Fix new findbugs warnings in rest of the hadoop-yarn components. (Contributed by Li Lu)\n",
      "commitDate": "23/12/14 6:57 PM",
      "commitName": "ca3381de61ff53604d9389694049a1a4dedc7571",
      "commitAuthor": "Junping Du",
      "commitDateOld": "20/11/14 9:34 PM",
      "commitNameOld": "c298a9a845f89317eb9efad332e6657c56736a4d",
      "commitAuthorOld": "Jonathan Eagles",
      "daysBetweenCommits": 32.89,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,164 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n-        shellScriptPathTimestamp \u003d Long.valueOf(envs\n+        shellScriptPathTimestamp \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n-        shellScriptPathLen \u003d Long.valueOf(envs\n+        shellScriptPathLen \u003d Long.parseLong(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n       YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n       // Creating the Timeline Client\n       timelineClient \u003d TimelineClient.createTimelineClient();\n       timelineClient.init(conf);\n       timelineClient.start();\n     } else {\n       timelineClient \u003d null;\n       LOG.warn(\"Timeline service is not enabled\");\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.parseLong(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n      // Creating the Timeline Client\n      timelineClient \u003d TimelineClient.createTimelineClient();\n      timelineClient.init(conf);\n      timelineClient.start();\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "c298a9a845f89317eb9efad332e6657c56736a4d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2375. Allow enabling/disabling timeline server per framework. (Mit Desai via jeagles)\n",
      "commitDate": "20/11/14 9:34 PM",
      "commitName": "c298a9a845f89317eb9efad332e6657c56736a4d",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "29/10/14 12:12 PM",
      "commitNameOld": "a8c120222047280234c3411ce1c1c9b17f08c851",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 22.43,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,164 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n       domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n-    // Creating the Timeline Client\n-    timelineClient \u003d TimelineClient.createTimelineClient();\n-    timelineClient.init(conf);\n-    timelineClient.start();\n+    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n+      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n+      // Creating the Timeline Client\n+      timelineClient \u003d TimelineClient.createTimelineClient();\n+      timelineClient.init(conf);\n+      timelineClient.start();\n+    } else {\n+      timelineClient \u003d null;\n+      LOG.warn(\"Timeline service is not enabled\");\n+    }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,\n      YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {\n      // Creating the Timeline Client\n      timelineClient \u003d TimelineClient.createTimelineClient();\n      timelineClient.init(conf);\n      timelineClient.start();\n    } else {\n      timelineClient \u003d null;\n      LOG.warn(\"Timeline service is not enabled\");\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "a8c120222047280234c3411ce1c1c9b17f08c851": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2769. Fixed the problem that timeline domain is not set in distributed shell AM when using shell_command on Windows. Contributed by Varun Vasudev.\n",
      "commitDate": "29/10/14 12:12 PM",
      "commitName": "a8c120222047280234c3411ce1c1c9b17f08c851",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "09/10/14 12:59 PM",
      "commitNameOld": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 19.97,
      "commitsBetweenForRepo": 172,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,158 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n-      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n-        domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n-      }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n+    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n+      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n+    }\n+\n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     // Creating the Timeline Client\n     timelineClient \u003d TimelineClient.createTimelineClient();\n     timelineClient.init(conf);\n     timelineClient.start();\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n      domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    // Creating the Timeline Client\n    timelineClient \u003d TimelineClient.createTimelineClient();\n    timelineClient.init(conf);\n    timelineClient.start();\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
      "commitDate": "09/10/14 12:59 PM",
      "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "01/10/14 3:38 PM",
      "commitNameOld": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 7.89,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,157 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n-\n+      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n+        domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n+      }\n       if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     // Creating the Timeline Client\n     timelineClient \u003d TimelineClient.createTimelineClient();\n     timelineClient.init(conf);\n     timelineClient.start();\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN)) {\n        domainId \u003d envs.get(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN);\n      }\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    // Creating the Timeline Client\n    timelineClient \u003d TimelineClient.createTimelineClient();\n    timelineClient.init(conf);\n    timelineClient.start();\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "6c2a0ce30b8bc54998ec40551bc14f478a353e10": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1908. Fixed DistributedShell to not fail in secure clusters. Contributed by Vinod Kumar Vavilapalli and Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585849 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/04/14 3:11 PM",
      "commitName": "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/03/14 8:49 PM",
      "commitNameOld": "fd1c424548999cb8843f40cb6a342387f98bde6c",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 20.77,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,155 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n-      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n+      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n-      if (!shellScriptPath.isEmpty()\n+      if (!scriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n-            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n+            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     // Creating the Timeline Client\n     timelineClient \u003d TimelineClient.createTimelineClient();\n     timelineClient.init(conf);\n     timelineClient.start();\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      scriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!scriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + scriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    // Creating the Timeline Client\n    timelineClient \u003d TimelineClient.createTimelineClient();\n    timelineClient.init(conf);\n    timelineClient.start();\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "fd1c424548999cb8843f40cb6a342387f98bde6c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1690. Made DistributedShell send timeline entities+events. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579123 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/14 8:49 PM",
      "commitName": "fd1c424548999cb8843f40cb6a342387f98bde6c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "16/03/14 11:32 AM",
      "commitNameOld": "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.39,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,155 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n-\n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!fileExist(shellCommandPath)\n         \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     }\n \n     if (fileExist(shellCommandPath)) {\n       shellCommand \u003d readContent(shellCommandPath);\n     }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n+    // Creating the Timeline Client\n+    timelineClient \u003d TimelineClient.createTimelineClient();\n+    timelineClient.init(conf);\n+    timelineClient.start();\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    // Creating the Timeline Client\n    timelineClient \u003d TimelineClient.createTimelineClient();\n    timelineClient.init(conf);\n    timelineClient.start();\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1435. Modified Distributed Shell to accept either the command or the custom script. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550867 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/13 6:00 PM",
      "commitName": "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "25/11/13 5:10 PM",
      "commitNameOld": "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 18.03,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,151 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n-    opts.addOption(\"shell_script\", true,\n-        \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n     if (fileExist(log4jPath)) {\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n             log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n-    if (!fileExist(shellCommandPath)) {\n+    if (!fileExist(shellCommandPath)\n+        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n       throw new IllegalArgumentException(\n-          \"No shell command specified to be executed by application master\");\n+          \"No shell command or shell script specified to be executed by application master\");\n     }\n-    shellCommand \u003d readContent(shellCommandPath);\n+\n+    if (fileExist(shellCommandPath)) {\n+      shellCommand \u003d readContent(shellCommandPath);\n+    }\n \n     if (fileExist(shellArgsPath)) {\n       shellArgs \u003d readContent(shellArgsPath);\n     }\n \n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)\n        \u0026\u0026 envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION).isEmpty()) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    }\n\n    if (fileExist(shellCommandPath)) {\n      shellCommand \u003d readContent(shellCommandPath);\n    }\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1314. Fixed DistributedShell to not fail with multiple arguments for a shell command separated by spaces. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/11/13 5:10 PM",
      "commitName": "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/11/13 3:16 PM",
      "commitNameOld": "33a8234040959ecd0d0202162e1b18c990effabe",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.08,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,149 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n-    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     //Check whether customer log4j.properties file exists\n-    File customerLog4jFile \u003d new File(log4jPath);\n-    if (customerLog4jFile.exists()) {\n+    if (fileExist(log4jPath)) {\n       try {\n-        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class, log4jPath);\n+        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n+            log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n-    File shellCommandFile \u003d new File(shellCommandPath);\n-    if (!shellCommandFile.exists()) {\n+    if (!fileExist(shellCommandPath)) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n-    FileInputStream fs \u003d null;\n-    DataInputStream ds \u003d null;\n-    try {\n-      ds \u003d new DataInputStream(new FileInputStream(shellCommandFile));\n-      shellCommand \u003d ds.readUTF();\n-    } finally {\n-      org.apache.commons.io.IOUtils.closeQuietly(ds);\n-      org.apache.commons.io.IOUtils.closeQuietly(fs);\n+    shellCommand \u003d readContent(shellCommandPath);\n+\n+    if (fileExist(shellArgsPath)) {\n+      shellArgs \u003d readContent(shellArgsPath);\n     }\n \n-    if (cliParser.hasOption(\"shell_args\")) {\n-      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n-    }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    if (fileExist(log4jPath)) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class,\n            log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!fileExist(shellCommandPath)) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d readContent(shellCommandPath);\n\n    if (fileExist(shellArgsPath)) {\n      shellArgs \u003d readContent(shellArgsPath);\n    }\n\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "33a8234040959ecd0d0202162e1b18c990effabe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1320. Fixed Distributed Shell application to respect custom log4j properties file. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544364 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 3:16 PM",
      "commitName": "33a8234040959ecd0d0202162e1b18c990effabe",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/11/13 8:09 PM",
      "commitNameOld": "a802ef4a5f2e71eed2cbdc053258ae2f66af4755",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,158 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n+    //Check whether customer log4j.properties file exists\n+    File customerLog4jFile \u003d new File(log4jPath);\n+    if (customerLog4jFile.exists()) {\n+      try {\n+        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class, log4jPath);\n+      } catch (Exception e) {\n+        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n+      }\n+    }\n+\n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     File shellCommandFile \u003d new File(shellCommandPath);\n     if (!shellCommandFile.exists()) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n     FileInputStream fs \u003d null;\n     DataInputStream ds \u003d null;\n     try {\n       ds \u003d new DataInputStream(new FileInputStream(shellCommandFile));\n       shellCommand \u003d ds.readUTF();\n     } finally {\n       org.apache.commons.io.IOUtils.closeQuietly(ds);\n       org.apache.commons.io.IOUtils.closeQuietly(fs);\n     }\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    //Check whether customer log4j.properties file exists\n    File customerLog4jFile \u003d new File(log4jPath);\n    if (customerLog4jFile.exists()) {\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    File shellCommandFile \u003d new File(shellCommandPath);\n    if (!shellCommandFile.exists()) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    FileInputStream fs \u003d null;\n    DataInputStream ds \u003d null;\n    try {\n      ds \u003d new DataInputStream(new FileInputStream(shellCommandFile));\n      shellCommand \u003d ds.readUTF();\n    } finally {\n      org.apache.commons.io.IOUtils.closeQuietly(ds);\n      org.apache.commons.io.IOUtils.closeQuietly(fs);\n    }\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "a802ef4a5f2e71eed2cbdc053258ae2f66af4755": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1303. Reverted the wrong patch committed earlier and committing the correct patch now. In one go.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/11/13 8:09 PM",
      "commitName": "a802ef4a5f2e71eed2cbdc053258ae2f66af4755",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/11/13 7:47 PM",
      "commitNameOld": "ad558cf2b3650530c741f1cfafb0cf47e60c8b77",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,148 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n-    opts.addOption(\"shell_command\", true,\n-        \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n-    if (!cliParser.hasOption(\"shell_command\")) {\n+    File shellCommandFile \u003d new File(shellCommandPath);\n+    if (!shellCommandFile.exists()) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n-    String shellCommandPath \u003d cliParser.getOptionValue(\"shell_command\");\n     FileInputStream fs \u003d null;\n     DataInputStream ds \u003d null;\n     try {\n-      ds \u003d new DataInputStream(new FileInputStream(shellCommandPath));\n+      ds \u003d new DataInputStream(new FileInputStream(shellCommandFile));\n       shellCommand \u003d ds.readUTF();\n     } finally {\n       org.apache.commons.io.IOUtils.closeQuietly(ds);\n       org.apache.commons.io.IOUtils.closeQuietly(fs);\n     }\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    File shellCommandFile \u003d new File(shellCommandPath);\n    if (!shellCommandFile.exists()) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    FileInputStream fs \u003d null;\n    DataInputStream ds \u003d null;\n    try {\n      ds \u003d new DataInputStream(new FileInputStream(shellCommandFile));\n      shellCommand \u003d ds.readUTF();\n    } finally {\n      org.apache.commons.io.IOUtils.closeQuietly(ds);\n      org.apache.commons.io.IOUtils.closeQuietly(fs);\n    }\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "ad558cf2b3650530c741f1cfafb0cf47e60c8b77": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1303. Fixed DistributedShell to not fail with multiple commands separated by a semi-colon as shell-command. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544023 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/11/13 7:47 PM",
      "commitName": "ad558cf2b3650530c741f1cfafb0cf47e60c8b77",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/11/13 12:46 PM",
      "commitNameOld": "5a5ba62a851f0b29434b76a5530a64f7714d3f95",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 9.29,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,150 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true,\n         \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"container_vcores\", true,\n         \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n-    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n+    String shellCommandPath \u003d cliParser.getOptionValue(\"shell_command\");\n+    FileInputStream fs \u003d null;\n+    DataInputStream ds \u003d null;\n+    try {\n+      ds \u003d new DataInputStream(new FileInputStream(shellCommandPath));\n+      shellCommand \u003d ds.readUTF();\n+    } finally {\n+      org.apache.commons.io.IOUtils.closeQuietly(ds);\n+      org.apache.commons.io.IOUtils.closeQuietly(fs);\n+    }\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true,\n        \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    String shellCommandPath \u003d cliParser.getOptionValue(\"shell_command\");\n    FileInputStream fs \u003d null;\n    DataInputStream ds \u003d null;\n    try {\n      ds \u003d new DataInputStream(new FileInputStream(shellCommandPath));\n      shellCommand \u003d ds.readUTF();\n    } finally {\n      org.apache.commons.io.IOUtils.closeQuietly(ds);\n      org.apache.commons.io.IOUtils.closeQuietly(fs);\n    }\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "735d8b27f78ea8be839008650a3e88db37dc507d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7. Support CPU resource for DistributedShell. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1531222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/10/13 1:18 AM",
      "commitName": "735d8b27f78ea8be839008650a3e88db37dc507d",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "04/10/13 11:08 PM",
      "commitNameOld": "be3edccf0acf55e710b0ec8ab8ce8418da74c615",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,141 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true,\n         \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n+    opts.addOption(\"container_vcores\", true,\n+        \"Amount of virtual cores to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HOST.name())) {\n       throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n       throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n     if (!envs.containsKey(Environment.NM_PORT.name())) {\n       throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n+    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n+        \"container_vcores\", \"1\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true,\n        \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"container_vcores\", true,\n        \"Amount of virtual cores to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_vcores\", \"1\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/04/13 4:54 PM",
      "commitNameOld": "0e01f26821caa3bf8554afe422bb080abcfe1e83",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.91,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true,\n         \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n-    if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n+    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n-          .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n+          .get(Environment.CONTAINER_ID.name()));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n       throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n           + \" not set in the environment\");\n     }\n-    if (!envs.containsKey(ApplicationConstants.NM_HOST_ENV)) {\n-      throw new RuntimeException(ApplicationConstants.NM_HOST_ENV\n+    if (!envs.containsKey(Environment.NM_HOST.name())) {\n+      throw new RuntimeException(Environment.NM_HOST.name()\n           + \" not set in the environment\");\n     }\n-    if (!envs.containsKey(ApplicationConstants.NM_HTTP_PORT_ENV)) {\n-      throw new RuntimeException(ApplicationConstants.NM_HTTP_PORT_ENV\n+    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n+      throw new RuntimeException(Environment.NM_HTTP_PORT\n           + \" not set in the environment\");\n     }\n-    if (!envs.containsKey(ApplicationConstants.NM_PORT_ENV)) {\n-      throw new RuntimeException(ApplicationConstants.NM_PORT_ENV\n+    if (!envs.containsKey(Environment.NM_PORT.name())) {\n+      throw new RuntimeException(Environment.NM_PORT.name()\n           + \" not set in the environment\");\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true,\n        \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(Environment.CONTAINER_ID.name()));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HOST.name())) {\n      throw new RuntimeException(Environment.NM_HOST.name()\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {\n      throw new RuntimeException(Environment.NM_HTTP_PORT\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(Environment.NM_PORT.name())) {\n      throw new RuntimeException(Environment.NM_PORT.name()\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "2aed48a67f408c290e90c83af9f76165d695f91a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-498. Unmanaged AM launcher does not set various constants in env for an AM, also does not handle failed AMs properly (Hitesh Shah via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460954 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 7:34 PM",
      "commitName": "2aed48a67f408c290e90c83af9f76165d695f91a",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "22/03/13 5:08 PM",
      "commitNameOld": "7c325a5d7186b831b793df239600191601ec635f",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,137 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true,\n         \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n-    if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n-      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n-          .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n-    } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n+    if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n+    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n+      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n+          + \" not set in the environment\");\n+    }\n+    if (!envs.containsKey(ApplicationConstants.NM_HOST_ENV)) {\n+      throw new RuntimeException(ApplicationConstants.NM_HOST_ENV\n+          + \" not set in the environment\");\n+    }\n+    if (!envs.containsKey(ApplicationConstants.NM_HTTP_PORT_ENV)) {\n+      throw new RuntimeException(ApplicationConstants.NM_HTTP_PORT_ENV\n+          + \" not set in the environment\");\n+    }\n+    if (!envs.containsKey(ApplicationConstants.NM_PORT_ENV)) {\n+      throw new RuntimeException(ApplicationConstants.NM_PORT_ENV\n+          + \" not set in the environment\");\n+    }\n+\n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n     if (numTotalContainers \u003d\u003d 0) {\n       throw new IllegalArgumentException(\n           \"Cannot run distributed shell with no containers\");\n     }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true,\n        \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {\n      throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(ApplicationConstants.NM_HOST_ENV)) {\n      throw new RuntimeException(ApplicationConstants.NM_HOST_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(ApplicationConstants.NM_HTTP_PORT_ENV)) {\n      throw new RuntimeException(ApplicationConstants.NM_HTTP_PORT_ENV\n          + \" not set in the environment\");\n    }\n    if (!envs.containsKey(ApplicationConstants.NM_PORT_ENV)) {\n      throw new RuntimeException(ApplicationConstants.NM_PORT_ENV\n          + \" not set in the environment\");\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "7c325a5d7186b831b793df239600191601ec635f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-417. Addendum patch to fix broken test (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460064 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/03/13 5:08 PM",
      "commitName": "7c325a5d7186b831b793df239600191601ec635f",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "21/03/13 3:26 PM",
      "commitNameOld": "28bac402953a4337deedf0472611f5775c7a74c9",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 1.07,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,123 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true,\n         \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true,\n         \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true,\n         \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true,\n         \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true,\n         \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true,\n         \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\n           \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n       appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n           .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n     } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } else {\n         throw new IllegalArgumentException(\n             \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n           .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     LOG.info(\"Application master for app\" + \", appId\u003d\"\n         + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n         + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\n           \"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length() - 1)) {\n           val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs\n             .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n             + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n             + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\n             \"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"container_memory\", \"10\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n         \"num_containers\", \"1\"));\n+    if (numTotalContainers \u003d\u003d 0) {\n+      throw new IllegalArgumentException(\n+          \"Cannot run distributed shell with no containers\");\n+    }\n     requestPriority \u003d Integer.parseInt(cliParser\n         .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true,\n        \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n          .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n    } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    if (numTotalContainers \u003d\u003d 0) {\n      throw new IllegalArgumentException(\n          \"Cannot run distributed shell with no containers\");\n    }\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "f5551bf8091c11586d402cdd4a0b09aa0498b673": {
      "type": "Ybodychange",
      "commitMessage": "YARN-277. Use AMRMClient in DistributedShell to exemplify the approach. Contributed by Bikas Saha\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1437156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/01/13 12:49 PM",
      "commitName": "f5551bf8091c11586d402cdd4a0b09aa0498b673",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 167.64,
      "commitsBetweenForRepo": 901,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,119 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n-    opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n-    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n-    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n+    opts.addOption(\"app_attempt_id\", true,\n+        \"App Attempt ID. Not to be used unless for testing purposes\");\n+    opts.addOption(\"shell_command\", true,\n+        \"Shell command to be executed by the Application Master\");\n+    opts.addOption(\"shell_script\", true,\n+        \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n-    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n-    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n-    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n+    opts.addOption(\"shell_env\", true,\n+        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n+    opts.addOption(\"container_memory\", true,\n+        \"Amount of memory in MB to be requested to run the shell command\");\n+    opts.addOption(\"num_containers\", true,\n+        \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n-      throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n+      throw new IllegalArgumentException(\n+          \"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n-    appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n     if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n       appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n           .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n     } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n-      } \n-      else {\n-        throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Application Attempt Id not set in the environment\");\n       }\n     } else {\n-      ContainerId containerId \u003d ConverterUtils.toContainerId(envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n+      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n+          .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n-    LOG.info(\"Application master for app\"\n-        + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n-        + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n+    LOG.info(\"Application master for app\" + \", appId\u003d\"\n+        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n+        + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n-      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n+      throw new IllegalArgumentException(\n+          \"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n-    if (cliParser.hasOption(\"shell_env\")) { \n+    if (cliParser.hasOption(\"shell_env\")) {\n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n-        if (index \u003c (env.length()-1)) {\n-          val \u003d env.substring(index+1);\n+        if (index \u003c (env.length() - 1)) {\n+          val \u003d env.substring(index + 1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n-        shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n+        shellScriptPathTimestamp \u003d Long.valueOf(envs\n+            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n-        shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n+        shellScriptPathLen \u003d Long.valueOf(envs\n+            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n-          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n-          || shellScriptPathLen \u003c\u003d 0)) {\n-        LOG.error(\"Illegal values in env for shell script path\"\n-            + \", path\u003d\" + shellScriptPath\n-            + \", len\u003d\" + shellScriptPathLen\n-            + \", timestamp\u003d\" + shellScriptPathTimestamp);\n-        throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n+          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n+        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n+            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n+            + shellScriptPathTimestamp);\n+        throw new IllegalArgumentException(\n+            \"Illegal values in env for shell script path\");\n       }\n     }\n \n-    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n-    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n-    requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n+    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n+        \"container_memory\", \"10\"));\n+    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n+        \"num_containers\", \"1\"));\n+    requestPriority \u003d Integer.parseInt(cliParser\n+        .getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true,\n        \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true,\n        \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true,\n        \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true,\n        \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true,\n        \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true,\n        \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\n          \"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n          .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n    } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } else {\n        throw new IllegalArgumentException(\n            \"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs\n          .get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    LOG.info(\"Application master for app\" + \", appId\u003d\"\n        + appAttemptID.getApplicationId().getId() + \", clustertimestamp\u003d\"\n        + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\n          \"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) {\n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length() - 1)) {\n          val \u003d env.substring(index + 1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs\n            .get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\" + \", path\u003d\"\n            + shellScriptPath + \", len\u003d\" + shellScriptPathLen + \", timestamp\u003d\"\n            + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\n            \"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\n        \"num_containers\", \"1\"));\n    requestPriority \u003d Integer.parseInt(cliParser\n        .getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n    if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n          .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n    } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } \n      else {\n        throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    LOG.info(\"Application master for app\"\n        + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n        + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n          || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\"\n            + \", path\u003d\" + shellScriptPath\n            + \", len\u003d\" + shellScriptPathLen\n            + \", timestamp\u003d\" + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
      }
    },
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4438. Add a simple, generic client to run \u0027easy\u0027 AMs in YARN. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1365185 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/07/12 10:33 AM",
      "commitName": "3ef19e9dbd5995634aac9b4011765e1d889ea6f5",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "19/06/12 3:00 PM",
      "commitNameOld": "daa28cc6ce23ef5c8db8b9f896f342cb770dd092",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 34.81,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,107 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n-    if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n+    if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n+      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n+          .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n+    } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } \n       else {\n         throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\n       }\n     } else {\n       ContainerId containerId \u003d ConverterUtils.toContainerId(envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n       appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     LOG.info(\"Application master for app\"\n         + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n         + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n         shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n       }\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n           || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\"\n             + \", path\u003d\" + shellScriptPath\n             + \", len\u003d\" + shellScriptPathLen\n             + \", timestamp\u003d\" + shellScriptPathTimestamp);\n         throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n    if (envs.containsKey(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV)) {\n      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs\n          .get(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV));\n    } else if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } \n      else {\n        throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\n      }\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    LOG.info(\"Application master for app\"\n        + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n        + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\n        shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\n      }\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n          || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\"\n            + \", path\u003d\" + shellScriptPath\n            + \", len\u003d\" + shellScriptPathLen\n            + \", timestamp\u003d\" + shellScriptPathTimestamp);\n        throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 10:21 PM",
      "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/09/11 3:25 PM",
      "commitNameOld": "fad230a49d0d4cdbb2062b10c3dea6c755737db5",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 18.29,
      "commitsBetweenForRepo": 135,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   public boolean init(String[] args) throws ParseException, IOException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n     opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n \n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n     }\t\t\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       dumpOutDebugInfo();\n     }\n \n     Map\u003cString, String\u003e envs \u003d System.getenv();\n \n     appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n-    if (!envs.containsKey(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV)) {\n+    if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n       if (cliParser.hasOption(\"app_attempt_id\")) {\n         String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n         appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n       } \n       else {\n         throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\t\t\t\t\n       }\t\n     } else {\n-      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs.get(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV));\n+      ContainerId containerId \u003d ConverterUtils.toContainerId(envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n+      appAttemptID \u003d containerId.getApplicationAttemptId();\n     }\n \n     LOG.info(\"Application master for app\"\n         + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n         + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n         + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : shellEnvs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n \n     if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n       shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n \n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\t\t\t\t\n         shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\t\t\t\t\n       }\t\t\t\t\t\n       if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n         shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\t\t\t\t\n       }\n \n       if (!shellScriptPath.isEmpty()\n           \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n           || shellScriptPathLen \u003c\u003d 0)) {\n         LOG.error(\"Illegal values in env for shell script path\"\n             + \", path\u003d\" + shellScriptPath\n             + \", len\u003d\" + shellScriptPathLen\n             + \", timestamp\u003d\" + shellScriptPathTimestamp);\t\n         throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n       }\n     }\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n    if (!envs.containsKey(ApplicationConstants.AM_CONTAINER_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } \n      else {\n        throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\t\t\t\t\n      }\t\n    } else {\n      ContainerId containerId \u003d ConverterUtils.toContainerId(envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV));\n      appAttemptID \u003d containerId.getApplicationAttemptId();\n    }\n\n    LOG.info(\"Application master for app\"\n        + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n        + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\t\t\t\t\n        shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\t\t\t\t\n      }\t\t\t\t\t\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\t\t\t\t\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n          || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\"\n            + \", path\u003d\" + shellScriptPath\n            + \", len\u003d\" + shellScriptPathLen\n            + \", timestamp\u003d\" + shellScriptPathTimestamp);\t\n        throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2719. Add a simple, DistributedShell, application to illustrate alternate frameworks on YARN. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177864 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/11 3:25 PM",
      "commitName": "fad230a49d0d4cdbb2062b10c3dea6c755737db5",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,103 @@\n+  public boolean init(String[] args) throws ParseException, IOException {\n+\n+    Options opts \u003d new Options();\n+    opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n+    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n+    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n+    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n+    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n+    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n+    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n+    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n+    opts.addOption(\"debug\", false, \"Dump out debug information\");\n+\n+    opts.addOption(\"help\", false, \"Print usage\");\n+    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n+\n+    if (args.length \u003d\u003d 0) {\n+      printUsage(opts);\n+      throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n+    }\t\t\n+\n+    if (cliParser.hasOption(\"help\")) {\n+      printUsage(opts);\n+      return false;\n+    }\n+\n+    if (cliParser.hasOption(\"debug\")) {\n+      dumpOutDebugInfo();\n+    }\n+\n+    Map\u003cString, String\u003e envs \u003d System.getenv();\n+\n+    appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n+    if (!envs.containsKey(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV)) {\n+      if (cliParser.hasOption(\"app_attempt_id\")) {\n+        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n+        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n+      } \n+      else {\n+        throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\t\t\t\t\n+      }\t\n+    } else {\n+      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs.get(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV));\n+    }\n+\n+    LOG.info(\"Application master for app\"\n+        + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n+        + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n+        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n+\n+    if (!cliParser.hasOption(\"shell_command\")) {\n+      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n+    }\n+    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n+\n+    if (cliParser.hasOption(\"shell_args\")) {\n+      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n+    }\n+    if (cliParser.hasOption(\"shell_env\")) { \n+      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n+      for (String env : shellEnvs) {\n+        env \u003d env.trim();\n+        int index \u003d env.indexOf(\u0027\u003d\u0027);\n+        if (index \u003d\u003d -1) {\n+          shellEnv.put(env, \"\");\n+          continue;\n+        }\n+        String key \u003d env.substring(0, index);\n+        String val \u003d \"\";\n+        if (index \u003c (env.length()-1)) {\n+          val \u003d env.substring(index+1);\n+        }\n+        shellEnv.put(key, val);\n+      }\n+    }\n+\n+    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n+      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n+\n+      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\t\t\t\t\n+        shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\t\t\t\t\n+      }\t\t\t\t\t\n+      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n+        shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\t\t\t\t\n+      }\n+\n+      if (!shellScriptPath.isEmpty()\n+          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n+          || shellScriptPathLen \u003c\u003d 0)) {\n+        LOG.error(\"Illegal values in env for shell script path\"\n+            + \", path\u003d\" + shellScriptPath\n+            + \", len\u003d\" + shellScriptPathLen\n+            + \", timestamp\u003d\" + shellScriptPathTimestamp);\t\n+        throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n+      }\n+    }\n+\n+    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n+    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n+    requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n+\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException, IOException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"app_attempt_id\", true, \"App Attempt ID. Not to be used unless for testing purposes\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for application master to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      dumpOutDebugInfo();\n    }\n\n    Map\u003cString, String\u003e envs \u003d System.getenv();\n\n    appAttemptID \u003d Records.newRecord(ApplicationAttemptId.class);\n    if (!envs.containsKey(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV)) {\n      if (cliParser.hasOption(\"app_attempt_id\")) {\n        String appIdStr \u003d cliParser.getOptionValue(\"app_attempt_id\", \"\");\n        appAttemptID \u003d ConverterUtils.toApplicationAttemptId(appIdStr);\n      } \n      else {\n        throw new IllegalArgumentException(\"Application Attempt Id not set in the environment\");\t\t\t\t\n      }\t\n    } else {\n      appAttemptID \u003d ConverterUtils.toApplicationAttemptId(envs.get(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV));\n    }\n\n    LOG.info(\"Application master for app\"\n        + \", appId\u003d\" + appAttemptID.getApplicationId().getId()\n        + \", clustertimestamp\u003d\" + appAttemptID.getApplicationId().getClusterTimestamp()\n        + \", attemptId\u003d\" + appAttemptID.getAttemptId());\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String shellEnvs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : shellEnvs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n\n    if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION)) {\n      shellScriptPath \u003d envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION);\n\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP)) {\t\t\t\t\n        shellScriptPathTimestamp \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP));\t\t\t\t\n      }\t\t\t\t\t\n      if (envs.containsKey(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN)) {\n        shellScriptPathLen \u003d Long.valueOf(envs.get(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN));\t\t\t\t\n      }\n\n      if (!shellScriptPath.isEmpty()\n          \u0026\u0026 (shellScriptPathTimestamp \u003c\u003d 0 \n          || shellScriptPathLen \u003c\u003d 0)) {\n        LOG.error(\"Illegal values in env for shell script path\"\n            + \", path\u003d\" + shellScriptPath\n            + \", len\u003d\" + shellScriptPathLen\n            + \", timestamp\u003d\" + shellScriptPathTimestamp);\t\n        throw new IllegalArgumentException(\"Illegal values in env for shell script path\");\n      }\n    }\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numTotalContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    requestPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
    }
  }
}