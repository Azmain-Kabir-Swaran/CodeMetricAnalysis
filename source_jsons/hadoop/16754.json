{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Router.java",
  "functionName": "serviceInit",
  "functionId": "serviceInit___configuration-Configuration",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
  "functionStartLine": 154,
  "functionEndLine": 303,
  "numCommitsSeen": 28,
  "timeTaken": 8296,
  "changeHistory": [
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
    "2f70b52a5bc6d057232a07916c1cc9c0af4ade47",
    "6915d7e13c2afbb2738176ba55ea0774f25e1264",
    "fcabc8f0e4097cce934308fdd28cd3bcdbb66877",
    "8f6f9d9c8398567064c9369f48213db63f45538c",
    "6f2c871b05b97ea0e18f3c431af8b0d606f88561",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "58ea2d7a65ccd8b7775021bae1d24b9e5561e67b",
    "dbb9dded33b3cff3b630e98300d30515a9d1eec4",
    "7721fff74494eb7fbbbba7f8bb4b4692d880d301",
    "d98a2e6e2383f8b66def346409b0517aa32d298d",
    "81601dac8ec7650bec14700b174910390a92fe1f",
    "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
    "b3e6bd22e3c02b3e4f50396538f56a1bcb007638",
    "6f0de2731806628b5b01bd1350225692147590da",
    "d8c81073320320a019fb3868be4f06f46aebea43",
    "ca4f209b49e3aad6a80306f7342c9b6b560a79a7",
    "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b"
  ],
  "changeHistoryShort": {
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619": "Ybodychange",
    "2f70b52a5bc6d057232a07916c1cc9c0af4ade47": "Ybodychange",
    "6915d7e13c2afbb2738176ba55ea0774f25e1264": "Ybodychange",
    "fcabc8f0e4097cce934308fdd28cd3bcdbb66877": "Ybodychange",
    "8f6f9d9c8398567064c9369f48213db63f45538c": "Ybodychange",
    "6f2c871b05b97ea0e18f3c431af8b0d606f88561": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Ymultichange(Yfilerename,Ybodychange)",
    "58ea2d7a65ccd8b7775021bae1d24b9e5561e67b": "Ybodychange",
    "dbb9dded33b3cff3b630e98300d30515a9d1eec4": "Ybodychange",
    "7721fff74494eb7fbbbba7f8bb4b4692d880d301": "Ybodychange",
    "d98a2e6e2383f8b66def346409b0517aa32d298d": "Ybodychange",
    "81601dac8ec7650bec14700b174910390a92fe1f": "Ybodychange",
    "bc9e588a19c0aaf518de8dab719362be4a8d6a54": "Ybodychange",
    "b3e6bd22e3c02b3e4f50396538f56a1bcb007638": "Ybodychange",
    "6f0de2731806628b5b01bd1350225692147590da": "Ybodychange",
    "d8c81073320320a019fb3868be4f06f46aebea43": "Ybodychange",
    "ca4f209b49e3aad6a80306f7342c9b6b560a79a7": "Ybodychange",
    "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13811. RBF: Race condition between router admin quota update and periodic quota update service. Contributed by Jinglun.\n",
      "commitDate": "04/12/19 2:19 AM",
      "commitName": "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "04/09/19 7:59 PM",
      "commitNameOld": "2f70b52a5bc6d057232a07916c1cc9c0af4ade47",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 90.31,
      "commitsBetweenForRepo": 506,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,150 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     // Enable the security for the Router\n     UserGroupInformation.setConfiguration(conf);\n     SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n         DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     boolean isRouterHeartbeatEnabled \u003d conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT);\n     boolean isNamenodeHeartbeatEnable \u003d conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_NAMENODE_HEARTBEAT_ENABLE,\n         isRouterHeartbeatEnabled);\n     if (isNamenodeHeartbeatEnable) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService heartbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(heartbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n     if (isRouterHeartbeatEnabled) {\n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     /*\n      * Refresh mount table cache immediately after adding, modifying or deleting\n      * the mount table entries. If this service is not enabled mount table cache\n      * are refreshed periodically by StateStoreCacheUpdateService\n      */\n     if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n         RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n       // There is no use of starting refresh service if state store and admin\n       // servers are not enabled\n       String disabledDependentServices \u003d getDisabledDependentServices();\n       /*\n        * disabledDependentServices null means all dependent services are\n        * enabled.\n        */\n       if (disabledDependentServices \u003d\u003d null) {\n \n         MountTableRefresherService refreshService \u003d\n             new MountTableRefresherService(this);\n         addService(refreshService);\n         LOG.info(\"Service {} is enabled.\",\n             MountTableRefresherService.class.getSimpleName());\n       } else {\n         LOG.warn(\n             \"Service {} not enabled: dependent service(s) {} not enabled.\",\n             MountTableRefresherService.class.getSimpleName(),\n             disabledDependentServices);\n       }\n     }\n \n     super.serviceInit(conf);\n+\n+    // Set quota manager in mount store to update quota usage in mount table.\n+    if (stateStore !\u003d null) {\n+      MountTableStore mountstore \u003d\n+          this.stateStore.getRegisteredRecordStore(MountTableStore.class);\n+      mountstore.setQuotaManager(this.quotaManager);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    // Enable the security for the Router\n    UserGroupInformation.setConfiguration(conf);\n    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    boolean isRouterHeartbeatEnabled \u003d conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT);\n    boolean isNamenodeHeartbeatEnable \u003d conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_NAMENODE_HEARTBEAT_ENABLE,\n        isRouterHeartbeatEnabled);\n    if (isNamenodeHeartbeatEnable) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService heartbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(heartbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n    if (isRouterHeartbeatEnabled) {\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    /*\n     * Refresh mount table cache immediately after adding, modifying or deleting\n     * the mount table entries. If this service is not enabled mount table cache\n     * are refreshed periodically by StateStoreCacheUpdateService\n     */\n    if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n        RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n      // There is no use of starting refresh service if state store and admin\n      // servers are not enabled\n      String disabledDependentServices \u003d getDisabledDependentServices();\n      /*\n       * disabledDependentServices null means all dependent services are\n       * enabled.\n       */\n      if (disabledDependentServices \u003d\u003d null) {\n\n        MountTableRefresherService refreshService \u003d\n            new MountTableRefresherService(this);\n        addService(refreshService);\n        LOG.info(\"Service {} is enabled.\",\n            MountTableRefresherService.class.getSimpleName());\n      } else {\n        LOG.warn(\n            \"Service {} not enabled: dependent service(s) {} not enabled.\",\n            MountTableRefresherService.class.getSimpleName(),\n            disabledDependentServices);\n      }\n    }\n\n    super.serviceInit(conf);\n\n    // Set quota manager in mount store to update quota usage in mount table.\n    if (stateStore !\u003d null) {\n      MountTableStore mountstore \u003d\n          this.stateStore.getRegisteredRecordStore(MountTableStore.class);\n      mountstore.setQuotaManager(this.quotaManager);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "2f70b52a5bc6d057232a07916c1cc9c0af4ade47": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14812. RBF: MountTableRefresherService should load cache when refresh. Contributed by xuzq.\n",
      "commitDate": "04/09/19 7:59 PM",
      "commitName": "2f70b52a5bc6d057232a07916c1cc9c0af4ade47",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "ade8d3b60ecdab55bd61a71905ea3dbba0922f3e",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 72.44,
      "commitsBetweenForRepo": 594,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,143 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     // Enable the security for the Router\n     UserGroupInformation.setConfiguration(conf);\n     SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n         DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     boolean isRouterHeartbeatEnabled \u003d conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT);\n     boolean isNamenodeHeartbeatEnable \u003d conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_NAMENODE_HEARTBEAT_ENABLE,\n         isRouterHeartbeatEnabled);\n     if (isNamenodeHeartbeatEnable) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService heartbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(heartbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n     if (isRouterHeartbeatEnabled) {\n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     /*\n      * Refresh mount table cache immediately after adding, modifying or deleting\n      * the mount table entries. If this service is not enabled mount table cache\n      * are refreshed periodically by StateStoreCacheUpdateService\n      */\n     if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n         RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n       // There is no use of starting refresh service if state store and admin\n       // servers are not enabled\n       String disabledDependentServices \u003d getDisabledDependentServices();\n       /*\n        * disabledDependentServices null means all dependent services are\n        * enabled.\n        */\n       if (disabledDependentServices \u003d\u003d null) {\n \n         MountTableRefresherService refreshService \u003d\n             new MountTableRefresherService(this);\n         addService(refreshService);\n         LOG.info(\"Service {} is enabled.\",\n             MountTableRefresherService.class.getSimpleName());\n       } else {\n         LOG.warn(\n-            \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n+            \"Service {} not enabled: dependent service(s) {} not enabled.\",\n             MountTableRefresherService.class.getSimpleName(),\n             disabledDependentServices);\n       }\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    // Enable the security for the Router\n    UserGroupInformation.setConfiguration(conf);\n    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    boolean isRouterHeartbeatEnabled \u003d conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT);\n    boolean isNamenodeHeartbeatEnable \u003d conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_NAMENODE_HEARTBEAT_ENABLE,\n        isRouterHeartbeatEnabled);\n    if (isNamenodeHeartbeatEnable) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService heartbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(heartbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n    if (isRouterHeartbeatEnabled) {\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    /*\n     * Refresh mount table cache immediately after adding, modifying or deleting\n     * the mount table entries. If this service is not enabled mount table cache\n     * are refreshed periodically by StateStoreCacheUpdateService\n     */\n    if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n        RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n      // There is no use of starting refresh service if state store and admin\n      // servers are not enabled\n      String disabledDependentServices \u003d getDisabledDependentServices();\n      /*\n       * disabledDependentServices null means all dependent services are\n       * enabled.\n       */\n      if (disabledDependentServices \u003d\u003d null) {\n\n        MountTableRefresherService refreshService \u003d\n            new MountTableRefresherService(this);\n        addService(refreshService);\n        LOG.info(\"Service {} is enabled.\",\n            MountTableRefresherService.class.getSimpleName());\n      } else {\n        LOG.warn(\n            \"Service {} not enabled: dependent service(s) {} not enabled.\",\n            MountTableRefresherService.class.getSimpleName(),\n            disabledDependentServices);\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "6915d7e13c2afbb2738176ba55ea0774f25e1264": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13480. RBF: Separate namenodeHeartbeat and routerHeartbeat to different config key. Contributed by Ayush Saxena.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "6915d7e13c2afbb2738176ba55ea0774f25e1264",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "021a43b1a4bbc8a68c31461e206214a5eadc38dd",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,143 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     // Enable the security for the Router\n     UserGroupInformation.setConfiguration(conf);\n     SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n         DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n-    if (conf.getBoolean(\n+    boolean isRouterHeartbeatEnabled \u003d conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n-        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT);\n+    boolean isNamenodeHeartbeatEnable \u003d conf.getBoolean(\n+        RBFConfigKeys.DFS_ROUTER_NAMENODE_HEARTBEAT_ENABLE,\n+        isRouterHeartbeatEnabled);\n+    if (isNamenodeHeartbeatEnable) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService heartbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(heartbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n-\n+    }\n+    if (isRouterHeartbeatEnabled) {\n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     /*\n      * Refresh mount table cache immediately after adding, modifying or deleting\n      * the mount table entries. If this service is not enabled mount table cache\n      * are refreshed periodically by StateStoreCacheUpdateService\n      */\n     if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n         RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n       // There is no use of starting refresh service if state store and admin\n       // servers are not enabled\n       String disabledDependentServices \u003d getDisabledDependentServices();\n       /*\n        * disabledDependentServices null means all dependent services are\n        * enabled.\n        */\n       if (disabledDependentServices \u003d\u003d null) {\n \n         MountTableRefresherService refreshService \u003d\n             new MountTableRefresherService(this);\n         addService(refreshService);\n         LOG.info(\"Service {} is enabled.\",\n             MountTableRefresherService.class.getSimpleName());\n       } else {\n         LOG.warn(\n             \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n             MountTableRefresherService.class.getSimpleName(),\n             disabledDependentServices);\n       }\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    // Enable the security for the Router\n    UserGroupInformation.setConfiguration(conf);\n    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    boolean isRouterHeartbeatEnabled \u003d conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT);\n    boolean isNamenodeHeartbeatEnable \u003d conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_NAMENODE_HEARTBEAT_ENABLE,\n        isRouterHeartbeatEnabled);\n    if (isNamenodeHeartbeatEnable) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService heartbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(heartbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n    if (isRouterHeartbeatEnabled) {\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    /*\n     * Refresh mount table cache immediately after adding, modifying or deleting\n     * the mount table entries. If this service is not enabled mount table cache\n     * are refreshed periodically by StateStoreCacheUpdateService\n     */\n    if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n        RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n      // There is no use of starting refresh service if state store and admin\n      // servers are not enabled\n      String disabledDependentServices \u003d getDisabledDependentServices();\n      /*\n       * disabledDependentServices null means all dependent services are\n       * enabled.\n       */\n      if (disabledDependentServices \u003d\u003d null) {\n\n        MountTableRefresherService refreshService \u003d\n            new MountTableRefresherService(this);\n        addService(refreshService);\n        LOG.info(\"Service {} is enabled.\",\n            MountTableRefresherService.class.getSimpleName());\n      } else {\n        LOG.warn(\n            \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n            MountTableRefresherService.class.getSimpleName(),\n            disabledDependentServices);\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "fcabc8f0e4097cce934308fdd28cd3bcdbb66877": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14335. RBF: Fix heartbeat typos in the Router. Contributed by CR Hota.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "fcabc8f0e4097cce934308fdd28cd3bcdbb66877",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "b8bcbd0ed2d9552ca4e5a4b429b8852a5932407c",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,138 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     // Enable the security for the Router\n     UserGroupInformation.setConfiguration(conf);\n     SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n         DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n-      for (NamenodeHeartbeatService hearbeatService :\n+      for (NamenodeHeartbeatService heartbeatService :\n           this.namenodeHeartbeatServices) {\n-        addService(hearbeatService);\n+        addService(heartbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     /*\n      * Refresh mount table cache immediately after adding, modifying or deleting\n      * the mount table entries. If this service is not enabled mount table cache\n      * are refreshed periodically by StateStoreCacheUpdateService\n      */\n     if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n         RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n       // There is no use of starting refresh service if state store and admin\n       // servers are not enabled\n       String disabledDependentServices \u003d getDisabledDependentServices();\n       /*\n        * disabledDependentServices null means all dependent services are\n        * enabled.\n        */\n       if (disabledDependentServices \u003d\u003d null) {\n \n         MountTableRefresherService refreshService \u003d\n             new MountTableRefresherService(this);\n         addService(refreshService);\n         LOG.info(\"Service {} is enabled.\",\n             MountTableRefresherService.class.getSimpleName());\n       } else {\n         LOG.warn(\n             \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n             MountTableRefresherService.class.getSimpleName(),\n             disabledDependentServices);\n       }\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    // Enable the security for the Router\n    UserGroupInformation.setConfiguration(conf);\n    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService heartbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(heartbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    /*\n     * Refresh mount table cache immediately after adding, modifying or deleting\n     * the mount table entries. If this service is not enabled mount table cache\n     * are refreshed periodically by StateStoreCacheUpdateService\n     */\n    if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n        RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n      // There is no use of starting refresh service if state store and admin\n      // servers are not enabled\n      String disabledDependentServices \u003d getDisabledDependentServices();\n      /*\n       * disabledDependentServices null means all dependent services are\n       * enabled.\n       */\n      if (disabledDependentServices \u003d\u003d null) {\n\n        MountTableRefresherService refreshService \u003d\n            new MountTableRefresherService(this);\n        addService(refreshService);\n        LOG.info(\"Service {} is enabled.\",\n            MountTableRefresherService.class.getSimpleName());\n      } else {\n        LOG.warn(\n            \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n            MountTableRefresherService.class.getSimpleName(),\n            disabledDependentServices);\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "8f6f9d9c8398567064c9369f48213db63f45538c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13443. RBF: Update mount table cache immediately after changing (add/update/remove) mount table entries. Contributed by Mohammad Arshad.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "8f6f9d9c8398567064c9369f48213db63f45538c",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "bbe859177d67fcdfd5377b1abff4a637fbbd4587",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,138 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     // Enable the security for the Router\n     UserGroupInformation.setConfiguration(conf);\n     SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n         DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n+    /*\n+     * Refresh mount table cache immediately after adding, modifying or deleting\n+     * the mount table entries. If this service is not enabled mount table cache\n+     * are refreshed periodically by StateStoreCacheUpdateService\n+     */\n+    if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n+        RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n+      // There is no use of starting refresh service if state store and admin\n+      // servers are not enabled\n+      String disabledDependentServices \u003d getDisabledDependentServices();\n+      /*\n+       * disabledDependentServices null means all dependent services are\n+       * enabled.\n+       */\n+      if (disabledDependentServices \u003d\u003d null) {\n+\n+        MountTableRefresherService refreshService \u003d\n+            new MountTableRefresherService(this);\n+        addService(refreshService);\n+        LOG.info(\"Service {} is enabled.\",\n+            MountTableRefresherService.class.getSimpleName());\n+      } else {\n+        LOG.warn(\n+            \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n+            MountTableRefresherService.class.getSimpleName(),\n+            disabledDependentServices);\n+      }\n+    }\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    // Enable the security for the Router\n    UserGroupInformation.setConfiguration(conf);\n    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    /*\n     * Refresh mount table cache immediately after adding, modifying or deleting\n     * the mount table entries. If this service is not enabled mount table cache\n     * are refreshed periodically by StateStoreCacheUpdateService\n     */\n    if (conf.getBoolean(RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE,\n        RBFConfigKeys.MOUNT_TABLE_CACHE_UPDATE_DEFAULT)) {\n      // There is no use of starting refresh service if state store and admin\n      // servers are not enabled\n      String disabledDependentServices \u003d getDisabledDependentServices();\n      /*\n       * disabledDependentServices null means all dependent services are\n       * enabled.\n       */\n      if (disabledDependentServices \u003d\u003d null) {\n\n        MountTableRefresherService refreshService \u003d\n            new MountTableRefresherService(this);\n        addService(refreshService);\n        LOG.info(\"Service {} is enabled.\",\n            MountTableRefresherService.class.getSimpleName());\n      } else {\n        LOG.warn(\n            \"Service {} not enabled: depenendent service(s) {} not enabled.\",\n            MountTableRefresherService.class.getSimpleName(),\n            disabledDependentServices);\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "6f2c871b05b97ea0e18f3c431af8b0d606f88561": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12284. RBF: Support for Kerberos authentication. Contributed by Sherwood Zheng and Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "6f2c871b05b97ea0e18f3c431af8b0d606f88561",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "02/10/18 8:48 PM",
      "commitNameOld": "fa7f7078a713c44783425195a891582bcf8a6d5c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 264.53,
      "commitsBetweenForRepo": 1929,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,109 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n+    // Enable the security for the Router\n+    UserGroupInformation.setConfiguration(conf);\n+    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n+        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n+\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    // Enable the security for the Router\n    UserGroupInformation.setConfiguration(conf);\n    SecurityUtil.login(conf, DFS_ROUTER_KEYTAB_FILE_KEY,\n        DFS_ROUTER_KERBEROS_PRINCIPAL_KEY, getHostName(conf));\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
          "commitDate": "19/03/18 10:13 PM",
          "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
          "commitAuthor": "weiy",
          "commitDateOld": "19/03/18 5:19 PM",
          "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,104 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n-    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n+    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
          "commitDate": "19/03/18 10:13 PM",
          "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
          "commitAuthor": "weiy",
          "commitDateOld": "19/03/18 5:19 PM",
          "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,104 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHeartbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n-    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n+    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n-        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n-        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n+        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n+        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        RBFConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
          "extendedDetails": {}
        }
      ]
    },
    "58ea2d7a65ccd8b7775021bae1d24b9e5561e67b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13214. RBF: Complete document of Router configuration. Contributed by Yiqun Lin.\n",
      "commitDate": "06/03/18 11:26 PM",
      "commitName": "58ea2d7a65ccd8b7775021bae1d24b9e5561e67b",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "29/01/18 8:12 PM",
      "commitNameOld": "dbb9dded33b3cff3b630e98300d30515a9d1eec4",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 36.14,
      "commitsBetweenForRepo": 248,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n-      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n+      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n-          this.namenodeHearbeatServices) {\n+          this.namenodeHeartbeatServices) {\n         addService(hearbeatService);\n       }\n \n-      if (this.namenodeHearbeatServices.isEmpty()) {\n+      if (this.namenodeHeartbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     // Safemode service to refuse RPC calls when the router is out of sync\n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n       // Create safemode monitoring service\n       this.safemodeService \u003d new RouterSafemodeService(this);\n       addService(this.safemodeService);\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHeartbeatServices \u003d createNamenodeHeartbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHeartbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHeartbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "dbb9dded33b3cff3b630e98300d30515a9d1eec4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13044. RBF: Add a safe mode for the Router. Contributed by Inigo Goiri.\n",
      "commitDate": "29/01/18 8:12 PM",
      "commitName": "dbb9dded33b3cff3b630e98300d30515a9d1eec4",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "24/01/18 11:51 PM",
      "commitNameOld": "7721fff74494eb7fbbbba7f8bb4b4692d880d301",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 4.85,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,104 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n     updateRouterState(RouterServiceState.INITIALIZING);\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n \n       // Periodically update the router state\n       this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n       addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n+    // Safemode service to refuse RPC calls when the router is out of sync\n+    if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n+      // Create safemode monitoring service\n+      this.safemodeService \u003d new RouterSafemodeService(this);\n+      addService(this.safemodeService);\n+    }\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    // Safemode service to refuse RPC calls when the router is out of sync\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT)) {\n      // Create safemode monitoring service\n      this.safemodeService \u003d new RouterSafemodeService(this);\n      addService(this.safemodeService);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "7721fff74494eb7fbbbba7f8bb4b4692d880d301": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13042. RBF: Heartbeat Router State. Contributed by Inigo Goiri.\n",
      "commitDate": "24/01/18 11:51 PM",
      "commitName": "7721fff74494eb7fbbbba7f8bb4b4692d880d301",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "09/01/18 9:59 PM",
      "commitNameOld": "d98a2e6e2383f8b66def346409b0517aa32d298d",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 15.08,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,95 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n+    updateRouterState(RouterServiceState.INITIALIZING);\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n+\n+      // Periodically update the router state\n+      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n+      addService(this.routerHeartbeatService);\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     // Initial quota relevant service\n     if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n       this.quotaManager \u003d new RouterQuotaManager();\n       this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n       addService(this.quotaUpdateService);\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n    updateRouterState(RouterServiceState.INITIALIZING);\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n\n      // Periodically update the router state\n      this.routerHeartbeatService \u003d new RouterHeartbeatService(this);\n      addService(this.routerHeartbeatService);\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "d98a2e6e2383f8b66def346409b0517aa32d298d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12934. RBF: Federation supports global quota. Contributed by Yiqun Lin.\n",
      "commitDate": "09/01/18 9:59 PM",
      "commitName": "d98a2e6e2383f8b66def346409b0517aa32d298d",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "29/11/17 9:43 AM",
      "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
      "commitAuthorOld": "Wei Yan",
      "daysBetweenCommits": 41.51,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,90 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n       // Create HTTP server\n       this.httpServer \u003d createHttpServer();\n       addService(this.httpServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n+    // Initial quota relevant service\n+    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n+      this.quotaManager \u003d new RouterQuotaManager();\n+      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n+      addService(this.quotaUpdateService);\n+    }\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    // Initial quota relevant service\n    if (conf.getBoolean(DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_QUOTA_ENABLED_DEFAULT)) {\n      this.quotaManager \u003d new RouterQuotaManager();\n      this.quotaUpdateService \u003d new RouterQuotaUpdateService(this);\n      addService(this.quotaUpdateService);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "81601dac8ec7650bec14700b174910390a92fe1f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12273. Federation UI. Contributed by Inigo Goiri.\n\n(cherry picked from commit adbb2e00c7b85524fd43bd68895d49814c16680a)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "81601dac8ec7650bec14700b174910390a92fe1f",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,82 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n+      // Create HTTP server\n+      this.httpServer \u003d createHttpServer();\n+      addService(this.httpServer);\n+    }\n+\n+    if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n \n     // Router metrics system\n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n \n       DefaultMetricsSystem.initialize(\"Router\");\n \n       this.metrics \u003d new RouterMetricsService(this);\n       addService(this.metrics);\n \n       // JVM pause monitor\n       this.pauseMonitor \u003d new JvmPauseMonitor();\n       this.pauseMonitor.init(conf);\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HTTP_ENABLE_DEFAULT)) {\n      // Create HTTP server\n      this.httpServer \u003d createHttpServer();\n      addService(this.httpServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "bc9e588a19c0aaf518de8dab719362be4a8d6a54": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12335. Federation Metrics. Contributed by Inigo Goiri.\n\n(cherry picked from commit 3b19e77752afce87936f5c0d1e6d272fba798d7b)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "b3e6bd22e3c02b3e4f50396538f56a1bcb007638",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,74 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n       // Service that maintains the State Store connection\n       this.stateStore \u003d new StateStoreService();\n       addService(this.stateStore);\n     }\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n       // Create admin server\n       this.adminServer \u003d createAdminServer();\n       addService(this.adminServer);\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n \n+    // Router metrics system\n+    if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n+\n+      DefaultMetricsSystem.initialize(\"Router\");\n+\n+      this.metrics \u003d new RouterMetricsService(this);\n+      addService(this.metrics);\n+\n+      // JVM pause monitor\n+      this.pauseMonitor \u003d new JvmPauseMonitor();\n+      this.pauseMonitor.init(conf);\n+    }\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n\n    // Router metrics system\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_METRICS_ENABLE_DEFAULT)) {\n\n      DefaultMetricsSystem.initialize(\"Router\");\n\n      this.metrics \u003d new RouterMetricsService(this);\n      addService(this.metrics);\n\n      // JVM pause monitor\n      this.pauseMonitor \u003d new JvmPauseMonitor();\n      this.pauseMonitor.init(conf);\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "b3e6bd22e3c02b3e4f50396538f56a1bcb007638": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10646. Federation admin tool. Contributed by Inigo Goiri.\n\n(cherry picked from commit ae27e31fbcf546481db0b0345772db2e9132372e)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "b3e6bd22e3c02b3e4f50396538f56a1bcb007638",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "6f0de2731806628b5b01bd1350225692147590da",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,59 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n+    if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n+      // Service that maintains the State Store connection\n+      this.stateStore \u003d new StateStoreService();\n+      addService(this.stateStore);\n+    }\n+\n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n+      // Create admin server\n+      this.adminServer \u003d createAdminServer();\n+      addService(this.adminServer);\n+    }\n+\n+    if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_STORE_ENABLE_DEFAULT)) {\n      // Service that maintains the State Store connection\n      this.stateStore \u003d new StateStoreService();\n      addService(this.stateStore);\n    }\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_ADMIN_ENABLE_DEFAULT)) {\n      // Create admin server\n      this.adminServer \u003d createAdminServer();\n      addService(this.adminServer);\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "6f0de2731806628b5b01bd1350225692147590da": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "6f0de2731806628b5b01bd1350225692147590da",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,43 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n-    this.subclusterResolver \u003d newFileSubclusterResolver(\n-        this.conf, this.stateStore);\n+    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n \n       // Create status updater for each monitored Namenode\n       this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n       for (NamenodeHeartbeatService hearbeatService :\n           this.namenodeHearbeatServices) {\n         addService(hearbeatService);\n       }\n \n       if (this.namenodeHearbeatServices.isEmpty()) {\n         LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n       }\n     }\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(this.conf, this);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "d8c81073320320a019fb3868be4f06f46aebea43": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11826. Federation Namenode Heartbeat. Contributed by Inigo Goiri.\n\n(cherry picked from commit 928f8dab52191e733984d37f47b69719ccf11313)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "d8c81073320320a019fb3868be4f06f46aebea43",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "ca4f209b49e3aad6a80306f7342c9b6b560a79a7",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,44 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(\n         this.conf, this.stateStore);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n     if (conf.getBoolean(\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n         DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n       // Create RPC server\n       this.rpcServer \u003d createRpcServer();\n       addService(this.rpcServer);\n       this.setRpcServerAddress(rpcServer.getRpcAddress());\n     }\n \n+    if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n+\n+      // Create status updater for each monitored Namenode\n+      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n+      for (NamenodeHeartbeatService hearbeatService :\n+          this.namenodeHearbeatServices) {\n+        addService(hearbeatService);\n+      }\n+\n+      if (this.namenodeHearbeatServices.isEmpty()) {\n+        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n+      }\n+    }\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(\n        this.conf, this.stateStore);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT)) {\n\n      // Create status updater for each monitored Namenode\n      this.namenodeHearbeatServices \u003d createNamenodeHearbeatServices();\n      for (NamenodeHeartbeatService hearbeatService :\n          this.namenodeHearbeatServices) {\n        addService(hearbeatService);\n      }\n\n      if (this.namenodeHearbeatServices.isEmpty()) {\n        LOG.error(\"Heartbeat is enabled but there are no namenodes to monitor\");\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "ca4f209b49e3aad6a80306f7342c9b6b560a79a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11546. Federation Router RPC server. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 8a9cdebebf26841a0f1e99fb08135f4597f2eba2)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "ca4f209b49e3aad6a80306f7342c9b6b560a79a7",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b",
      "commitAuthorOld": "Inigo",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,28 @@\n   protected void serviceInit(Configuration configuration) throws Exception {\n     this.conf \u003d configuration;\n \n-    // TODO Interface to the State Store\n-    this.stateStore \u003d null;\n-\n     // Resolver to track active NNs\n     this.namenodeResolver \u003d newActiveNamenodeResolver(\n         this.conf, this.stateStore);\n     if (this.namenodeResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find namenode resolver.\");\n     }\n \n     // Lookup interface to map between the global and subcluster name spaces\n     this.subclusterResolver \u003d newFileSubclusterResolver(\n         this.conf, this.stateStore);\n     if (this.subclusterResolver \u003d\u003d null) {\n       throw new IOException(\"Cannot find subcluster resolver\");\n     }\n \n+    if (conf.getBoolean(\n+        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n+        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n+      // Create RPC server\n+      this.rpcServer \u003d createRpcServer();\n+      addService(this.rpcServer);\n+      this.setRpcServerAddress(rpcServer.getRpcAddress());\n+    }\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(\n        this.conf, this.stateStore);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    if (conf.getBoolean(\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE,\n        DFSConfigKeys.DFS_ROUTER_RPC_ENABLE_DEFAULT)) {\n      // Create RPC server\n      this.rpcServer \u003d createRpcServer();\n      addService(this.rpcServer);\n      this.setRpcServerAddress(rpcServer.getRpcAddress());\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java",
      "extendedDetails": {}
    },
    "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10629. Federation Roter. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 6821e801724ac38e9737538b2164c9ae88792282)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b",
      "commitAuthor": "Inigo",
      "diff": "@@ -0,0 +1,22 @@\n+  protected void serviceInit(Configuration configuration) throws Exception {\n+    this.conf \u003d configuration;\n+\n+    // TODO Interface to the State Store\n+    this.stateStore \u003d null;\n+\n+    // Resolver to track active NNs\n+    this.namenodeResolver \u003d newActiveNamenodeResolver(\n+        this.conf, this.stateStore);\n+    if (this.namenodeResolver \u003d\u003d null) {\n+      throw new IOException(\"Cannot find namenode resolver.\");\n+    }\n+\n+    // Lookup interface to map between the global and subcluster name spaces\n+    this.subclusterResolver \u003d newFileSubclusterResolver(\n+        this.conf, this.stateStore);\n+    if (this.subclusterResolver \u003d\u003d null) {\n+      throw new IOException(\"Cannot find subcluster resolver\");\n+    }\n+\n+    super.serviceInit(conf);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration configuration) throws Exception {\n    this.conf \u003d configuration;\n\n    // TODO Interface to the State Store\n    this.stateStore \u003d null;\n\n    // Resolver to track active NNs\n    this.namenodeResolver \u003d newActiveNamenodeResolver(\n        this.conf, this.stateStore);\n    if (this.namenodeResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find namenode resolver.\");\n    }\n\n    // Lookup interface to map between the global and subcluster name spaces\n    this.subclusterResolver \u003d newFileSubclusterResolver(\n        this.conf, this.stateStore);\n    if (this.subclusterResolver \u003d\u003d null) {\n      throw new IOException(\"Cannot find subcluster resolver\");\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/Router.java"
    }
  }
}