{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeStatusUpdaterImpl.java",
  "functionName": "startStatusUpdater",
  "functionId": "startStatusUpdater",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
  "functionStartLine": 822,
  "functionEndLine": 827,
  "numCommitsSeen": 135,
  "timeTaken": 16326,
  "changeHistory": [
    "74a61438ca01e2191b54000af73b654a2d0b8253",
    "6cf6ab7b780de2b0c2c9ea730e1f366965a0d682",
    "84c35ac6c4a76c31d9bf9c87b87ed29394564611",
    "0d02ab8729630ad3cfb4300702927333b1d349e3",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "5712b8f9fd1859fe046b482889239bd164ed7dab",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438",
    "9b5636408005676ae580f8d929f8e912c27828e7",
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
    "f0ac18d001d97914a9ee810b1fab56c5cebff830",
    "15c3e7ffe3d1c57ad36afd993f09fc47889c93bd",
    "8f08532bde153811368e1b8336446fba4743f9d2",
    "c3dc1af072574f5890a8d43e4d60526951b4b8bc",
    "fc07464d1a48b0413da5e921614430e41263fdb7",
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59",
    "15ccd967ee3e7046a50522089f67ba01f36ec76a",
    "92431c961741747b5d6442f4025016d48d9a6863",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
    "cc2a745f7e82c9fa6de03242952347c54c52dccc",
    "c3d475070a1ec54c4b05923f4782cef204effd2c",
    "5c0381c96aa79196829edbca497c649eb6776944",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54",
    "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84",
    "b29434a5c8df8757e6bcdcf643df2f5756a221d9",
    "1c4047b0e46e95a92509de2e59a93433f5968538",
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
    "44f7ee7192d150b43a3012f06cec67be5b64edd0",
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
    "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329",
    "412e19f8e3118e602c567d60461e17c0dfe98b88",
    "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
    "33b5a81509ed08e88bb692682e75fb779f8e2e19",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "ca8024673178fa1c80224b390dfba932921693d9",
    "68148989bfb8b893529eb9920d849bce0dd575ec",
    "fbb55784d93e1a819daf55d936e864d344579cbf",
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
    "16fedf5473cd715e3970da700b24ca10656e3576",
    "3e9200ddde4858be8ecdd8347b5fee63ed83df84",
    "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a",
    "18e08a8f511652ed9f4ba386bb4f0cf8339e2729",
    "2cd41855d51fd18955a1ab187900ba02c6a6cfa9",
    "235749a8ab5f303b5b3a2993da8c5bea1818183b",
    "45a8e8c5a46535287de97fd6609c0743eef888ee",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "b9fd9e17598c606d0acd54a68b4693f482ffb3ac",
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
    "cbdb07f4ca358b9507296868a913977ad82ed716",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "68328ae92632afc9cdd6e75b7a8d832723ddbe3b",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "74a61438ca01e2191b54000af73b654a2d0b8253": "Ybodychange",
    "6cf6ab7b780de2b0c2c9ea730e1f366965a0d682": "Ybodychange",
    "84c35ac6c4a76c31d9bf9c87b87ed29394564611": "Ybodychange",
    "0d02ab8729630ad3cfb4300702927333b1d349e3": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "5712b8f9fd1859fe046b482889239bd164ed7dab": "Ybodychange",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": "Ybodychange",
    "9b5636408005676ae580f8d929f8e912c27828e7": "Ybodychange",
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc": "Ybodychange",
    "f0ac18d001d97914a9ee810b1fab56c5cebff830": "Ybodychange",
    "15c3e7ffe3d1c57ad36afd993f09fc47889c93bd": "Ybodychange",
    "8f08532bde153811368e1b8336446fba4743f9d2": "Ybodychange",
    "c3dc1af072574f5890a8d43e4d60526951b4b8bc": "Ybodychange",
    "fc07464d1a48b0413da5e921614430e41263fdb7": "Ybodychange",
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59": "Ybodychange",
    "15ccd967ee3e7046a50522089f67ba01f36ec76a": "Ybodychange",
    "92431c961741747b5d6442f4025016d48d9a6863": "Ybodychange",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": "Ybodychange",
    "cc2a745f7e82c9fa6de03242952347c54c52dccc": "Ybodychange",
    "c3d475070a1ec54c4b05923f4782cef204effd2c": "Ybodychange",
    "5c0381c96aa79196829edbca497c649eb6776944": "Ybodychange",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": "Ybodychange",
    "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76": "Ybodychange",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": "Ybodychange",
    "b29434a5c8df8757e6bcdcf643df2f5756a221d9": "Ybodychange",
    "1c4047b0e46e95a92509de2e59a93433f5968538": "Ybodychange",
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1": "Ybodychange",
    "44f7ee7192d150b43a3012f06cec67be5b64edd0": "Ybodychange",
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b": "Ybodychange",
    "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329": "Ybodychange",
    "412e19f8e3118e602c567d60461e17c0dfe98b88": "Ybodychange",
    "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff": "Ybodychange",
    "33b5a81509ed08e88bb692682e75fb779f8e2e19": "Ybodychange",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "ca8024673178fa1c80224b390dfba932921693d9": "Ybodychange",
    "68148989bfb8b893529eb9920d849bce0dd575ec": "Ybodychange",
    "fbb55784d93e1a819daf55d936e864d344579cbf": "Ybodychange",
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963": "Ybodychange",
    "16fedf5473cd715e3970da700b24ca10656e3576": "Ybodychange",
    "3e9200ddde4858be8ecdd8347b5fee63ed83df84": "Ybodychange",
    "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a": "Ybodychange",
    "18e08a8f511652ed9f4ba386bb4f0cf8339e2729": "Ybodychange",
    "2cd41855d51fd18955a1ab187900ba02c6a6cfa9": "Ybodychange",
    "235749a8ab5f303b5b3a2993da8c5bea1818183b": "Ybodychange",
    "45a8e8c5a46535287de97fd6609c0743eef888ee": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "b9fd9e17598c606d0acd54a68b4693f482ffb3ac": "Ybodychange",
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b": "Ybodychange",
    "cbdb07f4ca358b9507296868a913977ad82ed716": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "68328ae92632afc9cdd6e75b7a8d832723ddbe3b": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "74a61438ca01e2191b54000af73b654a2d0b8253": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6475. Fix some long function checkstyle issues\n(Contributed by Soumabrata Chakraborty via Daniel Templeton)\n",
      "commitDate": "10/05/17 10:46 AM",
      "commitName": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "08/05/17 3:14 PM",
      "commitNameOld": "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.81,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,7 @@\n   protected void startStatusUpdater() {\n \n-    statusUpdaterRunnable \u003d new Runnable() {\n-      @Override\n-      @SuppressWarnings(\"unchecked\")\n-      public void run() {\n-        int lastHeartbeatID \u003d 0;\n-        while (!isStopped) {\n-          // Send heartbeat\n-          try {\n-            NodeHeartbeatResponse response \u003d null;\n-            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n-                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n-            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n-            NodeHeartbeatRequest request \u003d\n-                NodeHeartbeatRequest.newInstance(nodeStatus,\n-                    NodeStatusUpdaterImpl.this.context\n-                        .getContainerTokenSecretManager().getCurrentKey(),\n-                    NodeStatusUpdaterImpl.this.context\n-                        .getNMTokenSecretManager().getCurrentKey(),\n-                    nodeLabelsForHeartbeat,\n-                    NodeStatusUpdaterImpl.this.context\n-                        .getRegisteredCollectors());\n-\n-            if (logAggregationEnabled) {\n-              // pull log aggregation status for application running in this NM\n-              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n-                  getLogAggregationReportsForApps(context\n-                    .getLogAggregationStatusForApps());\n-              if (logAggregationReports !\u003d null\n-                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n-                request.setLogAggregationReportsForApps(logAggregationReports);\n-              }\n-            }\n-\n-            response \u003d resourceTracker.nodeHeartbeat(request);\n-            //get next heartbeat interval from response\n-            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n-            updateMasterKeys(response);\n-\n-            if (!handleShutdownOrResyncCommand(response)) {\n-              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n-                  response);\n-\n-              // Explicitly put this method after checking the resync\n-              // response. We\n-              // don\u0027t want to remove the completed containers before resync\n-              // because these completed containers will be reported back to RM\n-              // when NM re-registers with RM.\n-              // Only remove the cleanedup containers that are acked\n-              removeOrTrackCompletedContainersFromContext(response\n-                  .getContainersToBeRemovedFromNM());\n-\n-              logAggregationReportForAppsTempList.clear();\n-              lastHeartbeatID \u003d response.getResponseId();\n-              List\u003cContainerId\u003e containersToCleanup \u003d response\n-                  .getContainersToCleanup();\n-              if (!containersToCleanup.isEmpty()) {\n-                dispatcher.getEventHandler().handle(\n-                    new CMgrCompletedContainersEvent(containersToCleanup,\n-                        CMgrCompletedContainersEvent.Reason\n-                            .BY_RESOURCEMANAGER));\n-              }\n-              List\u003cApplicationId\u003e appsToCleanup \u003d\n-                  response.getApplicationsToCleanup();\n-              //Only start tracking for keepAlive on FINISH_APP\n-              trackAppsForKeepAlive(appsToCleanup);\n-              if (!appsToCleanup.isEmpty()) {\n-                dispatcher.getEventHandler().handle(\n-                    new CMgrCompletedAppsEvent(appsToCleanup,\n-                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n-              }\n-              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n-                  response.getSystemCredentialsForApps();\n-              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n-                ((NMContext) context).setSystemCrendentialsForApps(\n-                    parseCredentials(systemCredentials));\n-              }\n-              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n-                  containersToDecrease \u003d response.getContainersToDecrease();\n-              if (!containersToDecrease.isEmpty()) {\n-                dispatcher.getEventHandler().handle(\n-                    new CMgrDecreaseContainersResourceEvent(\n-                        containersToDecrease)\n-                );\n-              }\n-\n-              // SignalContainer request originally comes from end users via\n-              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n-              // ContainerManager which will dispatch the event to\n-              // ContainerLauncher.\n-              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n-                  .getContainersToSignalList();\n-              if (containersToSignal.size() !\u003d 0) {\n-                dispatcher.getEventHandler().handle(\n-                    new CMgrSignalContainersEvent(containersToSignal));\n-              }\n-\n-              // Update QueuingLimits if ContainerManager supports queuing\n-              ContainerQueuingLimit queuingLimit \u003d\n-                  response.getContainerQueuingLimit();\n-              if (queuingLimit !\u003d null) {\n-                context.getContainerManager().updateQueuingLimit(queuingLimit);\n-              }\n-            }\n-            // Handling node resource update case.\n-            Resource newResource \u003d response.getResource();\n-            if (newResource !\u003d null) {\n-              updateNMResource(newResource);\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Node\u0027s resource is updated to \" +\n-                    newResource.toString());\n-              }\n-            }\n-            if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n-              updateTimelineClientsAddress(response);\n-            }\n-\n-          } catch (ConnectException e) {\n-            //catch and throw the exception if tried MAX wait time to connect RM\n-            dispatcher.getEventHandler().handle(\n-                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n-            // failed to connect to RM.\n-            failedToConnect \u003d true;\n-            throw new YarnRuntimeException(e);\n-          } catch (Throwable e) {\n-\n-            // TODO Better error handling. Thread can die with the rest of the\n-            // NM still running.\n-            LOG.error(\"Caught exception in status-updater\", e);\n-          } finally {\n-            synchronized (heartbeatMonitor) {\n-              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n-                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n-                    nextHeartBeatInterval;\n-              try {\n-                heartbeatMonitor.wait(nextHeartBeatInterval);\n-              } catch (InterruptedException e) {\n-                // Do Nothing\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      private void updateTimelineClientsAddress(\n-          NodeHeartbeatResponse response) {\n-        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n-            response.getAppCollectorsMap();\n-        if (knownCollectorsMap \u003d\u003d null) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"No collectors to update RM\");\n-          }\n-        } else {\n-          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n-              knownCollectorsMap.entrySet();\n-          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n-            ApplicationId appId \u003d entry.getKey();\n-            String collectorAddr \u003d entry.getValue();\n-\n-            // Only handle applications running on local node.\n-            // Not include apps with timeline collectors running in local\n-            Application application \u003d context.getApplications().get(appId);\n-            // TODO this logic could be problematic if the collector address\n-            // gets updated due to NM restart or collector service failure\n-            if (application !\u003d null \u0026\u0026\n-                !context.getRegisteredCollectors().containsKey(appId)) {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n-                    \" for application: \" + appId + \" from RM.\");\n-              }\n-              NMTimelinePublisher nmTimelinePublisher \u003d\n-                  context.getNMTimelinePublisher();\n-              if (nmTimelinePublisher !\u003d null) {\n-                nmTimelinePublisher.setTimelineServiceAddress(\n-                    application.getAppId(), collectorAddr);\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      private void updateMasterKeys(NodeHeartbeatResponse response) {\n-        // See if the master-key has rolled over\n-        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n-        if (updatedMasterKey !\u003d null) {\n-          // Will be non-null only on roll-over on RM side\n-          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n-        }\n-        \n-        updatedMasterKey \u003d response.getNMTokenMasterKey();\n-        if (updatedMasterKey !\u003d null) {\n-          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n-        }\n-      }\n-    };\n+    statusUpdaterRunnable \u003d new StatusUpdaterRunnable();\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new StatusUpdaterRunnable();\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "6cf6ab7b780de2b0c2c9ea730e1f366965a0d682": {
      "type": "Ybodychange",
      "commitMessage": "Made a number of miscellaneous fixes for javac, javadoc, and checstyle warnings.\n",
      "commitDate": "10/07/16 8:46 AM",
      "commitName": "6cf6ab7b780de2b0c2c9ea730e1f366965a0d682",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:46 AM",
      "commitNameOld": "6d943038f61211594d017f631710e6710ec71372",
      "commitAuthorOld": "Vrushali",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,216 +1,200 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat,\n-                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n+                    NodeStatusUpdaterImpl.this.context\n+                        .getRegisteredCollectors());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n             if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n               updateTimelineClientsAddress(response);\n             }\n \n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n-      /**\n-       * Caller should take care of sending non null nodelabels for both\n-       * arguments\n-       *\n-       * @param nodeLabelsNew\n-       * @param nodeLabelsOld\n-       * @return if the New node labels are diff from the older one.\n-       */\n-      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n-          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n-        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n-            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n-          return true;\n-        }\n-        return false;\n-      }\n-\n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n         Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n             response.getAppCollectorsMap();\n         if (knownCollectorsMap \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"No collectors to update RM\");\n           }\n         } else {\n           Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n               knownCollectorsMap.entrySet();\n           for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n             ApplicationId appId \u003d entry.getKey();\n             String collectorAddr \u003d entry.getValue();\n \n             // Only handle applications running on local node.\n             // Not include apps with timeline collectors running in local\n             Application application \u003d context.getApplications().get(appId);\n             // TODO this logic could be problematic if the collector address\n             // gets updated due to NM restart or collector service failure\n             if (application !\u003d null \u0026\u0026\n                 !context.getRegisteredCollectors().containsKey(appId)) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                     \" for application: \" + appId + \" from RM.\");\n               }\n               NMTimelinePublisher nmTimelinePublisher \u003d\n                   context.getNMTimelinePublisher();\n               if (nmTimelinePublisher !\u003d null) {\n                 nmTimelinePublisher.setTimelineServiceAddress(\n                     application.getAppId(), collectorAddr);\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context\n                        .getRegisteredCollectors());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n            if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n              updateTimelineClientsAddress(response);\n            }\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No collectors to update RM\");\n          }\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              NMTimelinePublisher nmTimelinePublisher \u003d\n                  context.getNMTimelinePublisher();\n              if (nmTimelinePublisher !\u003d null) {\n                nmTimelinePublisher.setTimelineServiceAddress(\n                    application.getAppId(), collectorAddr);\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "84c35ac6c4a76c31d9bf9c87b87ed29394564611": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4711. NM is going down with NPE\u0027s due to single thread processing of events by Timeline client (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "84c35ac6c4a76c31d9bf9c87b87ed29394564611",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,214 +1,216 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat,\n                     NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n             if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n               updateTimelineClientsAddress(response);\n             }\n \n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       /**\n        * Caller should take care of sending non null nodelabels for both\n        * arguments\n        *\n        * @param nodeLabelsNew\n        * @param nodeLabelsOld\n        * @return if the New node labels are diff from the older one.\n        */\n       private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n           Set\u003cNodeLabel\u003e nodeLabelsOld) {\n         if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n             || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n           return true;\n         }\n         return false;\n       }\n \n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n         Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n             response.getAppCollectorsMap();\n         if (knownCollectorsMap \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"No collectors to update RM\");\n           }\n         } else {\n           Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n               knownCollectorsMap.entrySet();\n           for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n             ApplicationId appId \u003d entry.getKey();\n             String collectorAddr \u003d entry.getValue();\n \n             // Only handle applications running on local node.\n             // Not include apps with timeline collectors running in local\n             Application application \u003d context.getApplications().get(appId);\n             // TODO this logic could be problematic if the collector address\n             // gets updated due to NM restart or collector service failure\n             if (application !\u003d null \u0026\u0026\n                 !context.getRegisteredCollectors().containsKey(appId)) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                     \" for application: \" + appId + \" from RM.\");\n               }\n-              TimelineClient client \u003d application.getTimelineClient();\n-              if (client !\u003d null) {\n-                client.setTimelineServiceAddress(collectorAddr);\n+              NMTimelinePublisher nmTimelinePublisher \u003d\n+                  context.getNMTimelinePublisher();\n+              if (nmTimelinePublisher !\u003d null) {\n+                nmTimelinePublisher.setTimelineServiceAddress(\n+                    application.getAppId(), collectorAddr);\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n            if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n              updateTimelineClientsAddress(response);\n            }\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       *\n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No collectors to update RM\");\n          }\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              NMTimelinePublisher nmTimelinePublisher \u003d\n                  context.getNMTimelinePublisher();\n              if (nmTimelinePublisher !\u003d null) {\n                nmTimelinePublisher.setTimelineServiceAddress(\n                    application.getAppId(), collectorAddr);\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "0d02ab8729630ad3cfb4300702927333b1d349e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3367. Replace starting a separate thread for post entity with event loop in TimelineClient (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,214 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat,\n                     NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n             if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n               updateTimelineClientsAddress(response);\n             }\n \n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       /**\n        * Caller should take care of sending non null nodelabels for both\n        * arguments\n        *\n        * @param nodeLabelsNew\n        * @param nodeLabelsOld\n        * @return if the New node labels are diff from the older one.\n        */\n       private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n           Set\u003cNodeLabel\u003e nodeLabelsOld) {\n         if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n             || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n           return true;\n         }\n         return false;\n       }\n \n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n         Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n             response.getAppCollectorsMap();\n         if (knownCollectorsMap \u003d\u003d null) {\n-          LOG.warn(\"the collectors map is null\");\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"No collectors to update RM\");\n+          }\n         } else {\n           Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n               knownCollectorsMap.entrySet();\n           for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n             ApplicationId appId \u003d entry.getKey();\n             String collectorAddr \u003d entry.getValue();\n \n             // Only handle applications running on local node.\n             // Not include apps with timeline collectors running in local\n             Application application \u003d context.getApplications().get(appId);\n             // TODO this logic could be problematic if the collector address\n             // gets updated due to NM restart or collector service failure\n             if (application !\u003d null \u0026\u0026\n                 !context.getRegisteredCollectors().containsKey(appId)) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                     \" for application: \" + appId + \" from RM.\");\n               }\n               TimelineClient client \u003d application.getTimelineClient();\n               if (client !\u003d null) {\n                 client.setTimelineServiceAddress(collectorAddr);\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n            if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n              updateTimelineClientsAddress(response);\n            }\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       *\n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No collectors to update RM\");\n          }\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              TimelineClient client \u003d application.getTimelineClient();\n              if (client !\u003d null) {\n                client.setTimelineServiceAddress(collectorAddr);\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,202 +1,212 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat,\n                     NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n-            if (YarnConfiguration.systemMetricsPublisherEnabled(context.getConf())) {\n+            if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n               updateTimelineClientsAddress(response);\n             }\n \n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       /**\n        * Caller should take care of sending non null nodelabels for both\n        * arguments\n-       * \n+       *\n        * @param nodeLabelsNew\n        * @param nodeLabelsOld\n        * @return if the New node labels are diff from the older one.\n        */\n       private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n           Set\u003cNodeLabel\u003e nodeLabelsOld) {\n         if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n             || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n           return true;\n         }\n         return false;\n       }\n \n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n-        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d \n-            response.getAppCollectorsMap().entrySet();\n-        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n-          ApplicationId appId \u003d entry.getKey();\n-          String collectorAddr \u003d entry.getValue();\n+        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n+            response.getAppCollectorsMap();\n+        if (knownCollectorsMap \u003d\u003d null) {\n+          LOG.warn(\"the collectors map is null\");\n+        } else {\n+          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n+              knownCollectorsMap.entrySet();\n+          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n+            ApplicationId appId \u003d entry.getKey();\n+            String collectorAddr \u003d entry.getValue();\n \n-          // Only handle applications running on local node.\n-          // Not include apps with timeline collectors running in local\n-          Application application \u003d context.getApplications().get(appId);\n-          if (application !\u003d null \u0026\u0026\n-              !context.getRegisteredCollectors().containsKey(appId)) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Sync a new collector address: \" + collectorAddr + \n-                  \" for application: \" + appId + \" from RM.\");\n+            // Only handle applications running on local node.\n+            // Not include apps with timeline collectors running in local\n+            Application application \u003d context.getApplications().get(appId);\n+            // TODO this logic could be problematic if the collector address\n+            // gets updated due to NM restart or collector service failure\n+            if (application !\u003d null \u0026\u0026\n+                !context.getRegisteredCollectors().containsKey(appId)) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n+                    \" for application: \" + appId + \" from RM.\");\n+              }\n+              TimelineClient client \u003d application.getTimelineClient();\n+              if (client !\u003d null) {\n+                client.setTimelineServiceAddress(collectorAddr);\n+              }\n             }\n-            TimelineClient client \u003d application.getTimelineClient();\n-            client.setTimelineServiceAddress(collectorAddr);\n           }\n         }\n       }\n-      \n+\n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n            if (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) {\n              updateTimelineClientsAddress(response);\n            }\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       *\n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          LOG.warn(\"the collectors map is null\");\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              TimelineClient client \u003d application.getTimelineClient();\n              if (client !\u003d null) {\n                client.setTimelineServiceAddress(collectorAddr);\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "5712b8f9fd1859fe046b482889239bd164ed7dab": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3334. NM uses timeline client to publish container metrics to new timeline service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,202 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat,\n                     NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n-\n-            Map\u003cApplicationId, String\u003e knownCollectors \u003d\n-                response.getAppCollectorsMap();\n-            ((NodeManager.NMContext)context).addKnownCollectors(knownCollectors);\n+            if (YarnConfiguration.systemMetricsPublisherEnabled(context.getConf())) {\n+              updateTimelineClientsAddress(response);\n+            }\n \n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n+      /**\n+       * Caller should take care of sending non null nodelabels for both\n+       * arguments\n+       * \n+       * @param nodeLabelsNew\n+       * @param nodeLabelsOld\n+       * @return if the New node labels are diff from the older one.\n+       */\n+      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n+          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n+        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n+            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      private void updateTimelineClientsAddress(\n+          NodeHeartbeatResponse response) {\n+        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d \n+            response.getAppCollectorsMap().entrySet();\n+        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n+          ApplicationId appId \u003d entry.getKey();\n+          String collectorAddr \u003d entry.getValue();\n+\n+          // Only handle applications running on local node.\n+          // Not include apps with timeline collectors running in local\n+          Application application \u003d context.getApplications().get(appId);\n+          if (application !\u003d null \u0026\u0026\n+              !context.getRegisteredCollectors().containsKey(appId)) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Sync a new collector address: \" + collectorAddr + \n+                  \" for application: \" + appId + \" from RM.\");\n+            }\n+            TimelineClient client \u003d application.getTimelineClient();\n+            client.setTimelineServiceAddress(collectorAddr);\n+          }\n+        }\n+      }\n+      \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n            if (YarnConfiguration.systemMetricsPublisherEnabled(context.getConf())) {\n              updateTimelineClientsAddress(response);\n            }\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       * \n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d \n            response.getAppCollectorsMap().entrySet();\n        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n          ApplicationId appId \u003d entry.getKey();\n          String collectorAddr \u003d entry.getValue();\n\n          // Only handle applications running on local node.\n          // Not include apps with timeline collectors running in local\n          Application application \u003d context.getApplications().get(appId);\n          if (application !\u003d null \u0026\u0026\n              !context.getRegisteredCollectors().containsKey(appId)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Sync a new collector address: \" + collectorAddr + \n                  \" for application: \" + appId + \" from RM.\");\n            }\n            TimelineClient client \u003d application.getTimelineClient();\n            client.setTimelineServiceAddress(collectorAddr);\n          }\n        }\n      }\n      \n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,163 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat,\n-                    NodeStatusUpdaterImpl.this.context.getRegisteredAggregators());\n+                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n \n-            Map\u003cApplicationId, String\u003e knownAggregators \u003d response.getAppAggregatorsMap();\n-            ((NodeManager.NMContext)context).addKnownAggregators(knownAggregators);\n+            Map\u003cApplicationId, String\u003e knownCollectors \u003d\n+                response.getAppCollectorsMap();\n+            ((NodeManager.NMContext)context).addKnownCollectors(knownCollectors);\n \n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context.getRegisteredCollectors());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n\n            Map\u003cApplicationId, String\u003e knownCollectors \u003d\n                response.getAppCollectorsMap();\n            ((NodeManager.NMContext)context).addKnownCollectors(knownCollectors);\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "9b5636408005676ae580f8d929f8e912c27828e7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3039. Implemented the app-level timeline aggregator discovery service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "17/05/16 12:52 PM",
      "commitNameOld": "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 53.83,
      "commitsBetweenForRepo": 372,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,162 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n-                    nodeLabelsForHeartbeat);\n+                    nodeLabelsForHeartbeat,\n+                    NodeStatusUpdaterImpl.this.context.getRegisteredAggregators());\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n             // Handling node resource update case.\n             Resource newResource \u003d response.getResource();\n             if (newResource !\u003d null) {\n               updateNMResource(newResource);\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Node\u0027s resource is updated to \" +\n                     newResource.toString());\n               }\n             }\n+\n+            Map\u003cApplicationId, String\u003e knownAggregators \u003d response.getAppAggregatorsMap();\n+            ((NodeManager.NMContext)context).addKnownAggregators(knownAggregators);\n+\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat,\n                    NodeStatusUpdaterImpl.this.context.getRegisteredAggregators());\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n\n            Map\u003cApplicationId, String\u003e knownAggregators \u003d response.getAppAggregatorsMap();\n            ((NodeManager.NMContext)context).addKnownAggregators(knownAggregators);\n\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4832. NM side resource value should get updated if change applied in RM side. Contributed by Junping Du\n",
      "commitDate": "17/05/16 12:52 PM",
      "commitName": "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
      "commitAuthor": "Jian He",
      "commitDateOld": "15/05/16 5:54 PM",
      "commitNameOld": "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.79,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,157 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (!handleShutdownOrResyncCommand(response)) {\n               nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                   response);\n \n               // Explicitly put this method after checking the resync\n               // response. We\n               // don\u0027t want to remove the completed containers before resync\n               // because these completed containers will be reported back to RM\n               // when NM re-registers with RM.\n               // Only remove the cleanedup containers that are acked\n               removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n               logAggregationReportForAppsTempList.clear();\n               lastHeartbeatID \u003d response.getResponseId();\n               List\u003cContainerId\u003e containersToCleanup \u003d response\n                   .getContainersToCleanup();\n               if (!containersToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedContainersEvent(containersToCleanup,\n                         CMgrCompletedContainersEvent.Reason\n                             .BY_RESOURCEMANAGER));\n               }\n               List\u003cApplicationId\u003e appsToCleanup \u003d\n                   response.getApplicationsToCleanup();\n               //Only start tracking for keepAlive on FINISH_APP\n               trackAppsForKeepAlive(appsToCleanup);\n               if (!appsToCleanup.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrCompletedAppsEvent(appsToCleanup,\n                         CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n               }\n               Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                   response.getSystemCredentialsForApps();\n               if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                 ((NMContext) context).setSystemCrendentialsForApps(\n                     parseCredentials(systemCredentials));\n               }\n               List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                   containersToDecrease \u003d response.getContainersToDecrease();\n               if (!containersToDecrease.isEmpty()) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrDecreaseContainersResourceEvent(\n                         containersToDecrease)\n                 );\n               }\n \n               // SignalContainer request originally comes from end users via\n               // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n               // ContainerManager which will dispatch the event to\n               // ContainerLauncher.\n               List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                   .getContainersToSignalList();\n               if (containersToSignal.size() !\u003d 0) {\n                 dispatcher.getEventHandler().handle(\n                     new CMgrSignalContainersEvent(containersToSignal));\n               }\n \n               // Update QueuingLimits if ContainerManager supports queuing\n               ContainerQueuingLimit queuingLimit \u003d\n                   response.getContainerQueuingLimit();\n               if (queuingLimit !\u003d null) {\n                 context.getContainerManager().updateQueuingLimit(queuingLimit);\n               }\n             }\n+            // Handling node resource update case.\n+            Resource newResource \u003d response.getResource();\n+            if (newResource !\u003d null) {\n+              updateNMResource(newResource);\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Node\u0027s resource is updated to \" +\n+                    newResource.toString());\n+              }\n+            }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n            // Handling node resource update case.\n            Resource newResource \u003d response.getResource();\n            if (newResource !\u003d null) {\n              updateNMResource(newResource);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Node\u0027s resource is updated to \" +\n                    newResource.toString());\n              }\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "f0ac18d001d97914a9ee810b1fab56c5cebff830": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2888. Corrective mechanisms for rebalancing NM container queues. (asuresh)\n",
      "commitDate": "13/05/16 1:38 PM",
      "commitName": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "26/04/16 8:12 PM",
      "commitNameOld": "341888a0aa23f24458b4e6e34868794b9735c06a",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 16.73,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,148 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n-\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n-            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n-              LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n-                  + \" heartbeat, hence shutting down.\");\n-              LOG.warn(\"Message from ResourceManager: \"\n-                  + response.getDiagnosticsMessage());\n-              context.setDecommissioned(true);\n-              dispatcher.getEventHandler().handle(\n-                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n-              break;\n-            }\n-            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n-              LOG.warn(\"Node is out of sync with ResourceManager,\"\n-                  + \" hence resyncing.\");\n-              LOG.warn(\"Message from ResourceManager: \"\n-                  + response.getDiagnosticsMessage());\n-              // Invalidate the RMIdentifier while resync\n-              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n-                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n-              dispatcher.getEventHandler().handle(\n-                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n-              pendingCompletedContainers.clear();\n-              break;\n-            }\n+            if (!handleShutdownOrResyncCommand(response)) {\n+              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n+                  response);\n \n-            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n-\n-            // Explicitly put this method after checking the resync response. We\n-            // don\u0027t want to remove the completed containers before resync\n-            // because these completed containers will be reported back to RM\n-            // when NM re-registers with RM.\n-            // Only remove the cleanedup containers that are acked\n-            removeOrTrackCompletedContainersFromContext(response\n+              // Explicitly put this method after checking the resync\n+              // response. We\n+              // don\u0027t want to remove the completed containers before resync\n+              // because these completed containers will be reported back to RM\n+              // when NM re-registers with RM.\n+              // Only remove the cleanedup containers that are acked\n+              removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n-            logAggregationReportForAppsTempList.clear();\n-            lastHeartbeatID \u003d response.getResponseId();\n-            List\u003cContainerId\u003e containersToCleanup \u003d response\n-                .getContainersToCleanup();\n-            if (!containersToCleanup.isEmpty()) {\n-              dispatcher.getEventHandler().handle(\n-                  new CMgrCompletedContainersEvent(containersToCleanup,\n-                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n-            }\n-            List\u003cApplicationId\u003e appsToCleanup \u003d\n-                response.getApplicationsToCleanup();\n-            //Only start tracking for keepAlive on FINISH_APP\n-            trackAppsForKeepAlive(appsToCleanup);\n-            if (!appsToCleanup.isEmpty()) {\n-              dispatcher.getEventHandler().handle(\n-                  new CMgrCompletedAppsEvent(appsToCleanup,\n-                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n-            }\n+              logAggregationReportForAppsTempList.clear();\n+              lastHeartbeatID \u003d response.getResponseId();\n+              List\u003cContainerId\u003e containersToCleanup \u003d response\n+                  .getContainersToCleanup();\n+              if (!containersToCleanup.isEmpty()) {\n+                dispatcher.getEventHandler().handle(\n+                    new CMgrCompletedContainersEvent(containersToCleanup,\n+                        CMgrCompletedContainersEvent.Reason\n+                            .BY_RESOURCEMANAGER));\n+              }\n+              List\u003cApplicationId\u003e appsToCleanup \u003d\n+                  response.getApplicationsToCleanup();\n+              //Only start tracking for keepAlive on FINISH_APP\n+              trackAppsForKeepAlive(appsToCleanup);\n+              if (!appsToCleanup.isEmpty()) {\n+                dispatcher.getEventHandler().handle(\n+                    new CMgrCompletedAppsEvent(appsToCleanup,\n+                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n+              }\n+              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n+                  response.getSystemCredentialsForApps();\n+              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n+                ((NMContext) context).setSystemCrendentialsForApps(\n+                    parseCredentials(systemCredentials));\n+              }\n+              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n+                  containersToDecrease \u003d response.getContainersToDecrease();\n+              if (!containersToDecrease.isEmpty()) {\n+                dispatcher.getEventHandler().handle(\n+                    new CMgrDecreaseContainersResourceEvent(\n+                        containersToDecrease)\n+                );\n+              }\n \n-            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n-                response.getSystemCredentialsForApps();\n-            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n-              ((NMContext) context)\n-                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n-            }\n+              // SignalContainer request originally comes from end users via\n+              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n+              // ContainerManager which will dispatch the event to\n+              // ContainerLauncher.\n+              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n+                  .getContainersToSignalList();\n+              if (containersToSignal.size() !\u003d 0) {\n+                dispatcher.getEventHandler().handle(\n+                    new CMgrSignalContainersEvent(containersToSignal));\n+              }\n \n-            List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n-                containersToDecrease \u003d response.getContainersToDecrease();\n-            if (!containersToDecrease.isEmpty()) {\n-              dispatcher.getEventHandler().handle(\n-                  new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n-              );\n-            }\n-\n-            // SignalContainer request originally comes from end users via\n-            // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n-            // ContainerManager which will dispatch the event to ContainerLauncher.\n-            List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n-                .getContainersToSignalList();\n-            if (containersToSignal.size() !\u003d 0) {\n-              dispatcher.getEventHandler().handle(\n-                  new CMgrSignalContainersEvent(containersToSignal));\n+              // Update QueuingLimits if ContainerManager supports queuing\n+              ContainerQueuingLimit queuingLimit \u003d\n+                  response.getContainerQueuingLimit();\n+              if (queuingLimit !\u003d null) {\n+                context.getContainerManager().updateQueuingLimit(queuingLimit);\n+              }\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             // failed to connect to RM.\n             failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (!handleShutdownOrResyncCommand(response)) {\n              nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(\n                  response);\n\n              // Explicitly put this method after checking the resync\n              // response. We\n              // don\u0027t want to remove the completed containers before resync\n              // because these completed containers will be reported back to RM\n              // when NM re-registers with RM.\n              // Only remove the cleanedup containers that are acked\n              removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n              logAggregationReportForAppsTempList.clear();\n              lastHeartbeatID \u003d response.getResponseId();\n              List\u003cContainerId\u003e containersToCleanup \u003d response\n                  .getContainersToCleanup();\n              if (!containersToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedContainersEvent(containersToCleanup,\n                        CMgrCompletedContainersEvent.Reason\n                            .BY_RESOURCEMANAGER));\n              }\n              List\u003cApplicationId\u003e appsToCleanup \u003d\n                  response.getApplicationsToCleanup();\n              //Only start tracking for keepAlive on FINISH_APP\n              trackAppsForKeepAlive(appsToCleanup);\n              if (!appsToCleanup.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrCompletedAppsEvent(appsToCleanup,\n                        CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n              }\n              Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                  response.getSystemCredentialsForApps();\n              if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n                ((NMContext) context).setSystemCrendentialsForApps(\n                    parseCredentials(systemCredentials));\n              }\n              List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                  containersToDecrease \u003d response.getContainersToDecrease();\n              if (!containersToDecrease.isEmpty()) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrDecreaseContainersResourceEvent(\n                        containersToDecrease)\n                );\n              }\n\n              // SignalContainer request originally comes from end users via\n              // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n              // ContainerManager which will dispatch the event to\n              // ContainerLauncher.\n              List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                  .getContainersToSignalList();\n              if (containersToSignal.size() !\u003d 0) {\n                dispatcher.getEventHandler().handle(\n                    new CMgrSignalContainersEvent(containersToSignal));\n              }\n\n              // Update QueuingLimits if ContainerManager supports queuing\n              ContainerQueuingLimit queuingLimit \u003d\n                  response.getContainerQueuingLimit();\n              if (queuingLimit !\u003d null) {\n                context.getContainerManager().updateQueuingLimit(queuingLimit);\n              }\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "15c3e7ffe3d1c57ad36afd993f09fc47889c93bd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4431. Not necessary to do unRegisterNM() if NM get stop due to failed to connect to RM. (Junpin Du via rohithsharmaks)\n",
      "commitDate": "08/12/15 9:20 PM",
      "commitName": "15c3e7ffe3d1c57ad36afd993f09fc47889c93bd",
      "commitAuthor": "rohithsharmaks",
      "commitDateOld": "24/11/15 12:17 AM",
      "commitNameOld": "52948bb20bd1446164df1d3920c46c96dad750ae",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 14.88,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,159 +1,161 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                   + \" heartbeat, hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n             nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n \n             List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                 containersToDecrease \u003d response.getContainersToDecrease();\n             if (!containersToDecrease.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n               );\n             }\n \n             // SignalContainer request originally comes from end users via\n             // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n             // ContainerManager which will dispatch the event to ContainerLauncher.\n             List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                 .getContainersToSignalList();\n             if (containersToSignal.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrSignalContainersEvent(containersToSignal));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n+            // failed to connect to RM.\n+            failedToConnect \u003d true;\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                  + \" heartbeat, hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n\n            List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                containersToDecrease \u003d response.getContainersToDecrease();\n            if (!containersToDecrease.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n              );\n            }\n\n            // SignalContainer request originally comes from end users via\n            // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n            // ContainerManager which will dispatch the event to ContainerLauncher.\n            List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                .getContainersToSignalList();\n            if (containersToSignal.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrSignalContainersEvent(containersToSignal));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            // failed to connect to RM.\n            failedToConnect \u003d true;\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "8f08532bde153811368e1b8336446fba4743f9d2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1897. CLI and core support for signal container functionality. Contributed by Ming Ma\n",
      "commitDate": "02/10/15 6:50 PM",
      "commitName": "8f08532bde153811368e1b8336446fba4743f9d2",
      "commitAuthor": "Xuan",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "c3dc1af072574f5890a8d43e4d60526951b4b8bc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 9.22,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,159 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                   + \" heartbeat, hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n             nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n \n             List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                 containersToDecrease \u003d response.getContainersToDecrease();\n             if (!containersToDecrease.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n               );\n             }\n+\n+            // SignalContainer request originally comes from end users via\n+            // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n+            // ContainerManager which will dispatch the event to ContainerLauncher.\n+            List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n+                .getContainersToSignalList();\n+            if (containersToSignal.size() !\u003d 0) {\n+              dispatcher.getEventHandler().handle(\n+                  new CMgrSignalContainersEvent(containersToSignal));\n+            }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                  + \" heartbeat, hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n\n            List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                containersToDecrease \u003d response.getContainersToDecrease();\n            if (!containersToDecrease.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n              );\n            }\n\n            // SignalContainer request originally comes from end users via\n            // ClientRMProtocol\u0027s SignalContainer. Forward the request to\n            // ContainerManager which will dispatch the event to ContainerLauncher.\n            List\u003cSignalContainerRequest\u003e containersToSignal \u003d response\n                .getContainersToSignalList();\n            if (containersToSignal.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrSignalContainersEvent(containersToSignal));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "c3dc1af072574f5890a8d43e4d60526951b4b8bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1644. RM-NM protocol changes and NodeStatusUpdater implementation to support container resizing. Contributed by Meng Ding\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "c3dc1af072574f5890a8d43e4d60526951b4b8bc",
      "commitAuthor": "Jian He",
      "commitDateOld": "10/09/15 9:30 AM",
      "commitNameOld": "77666105b4557d5706e5844a4ca286917d966c5f",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.17,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,149 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                 nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                   + \" heartbeat, hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n             nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n+\n+            List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n+                containersToDecrease \u003d response.getContainersToDecrease();\n+            if (!containersToDecrease.isEmpty()) {\n+              dispatcher.getEventHandler().handle(\n+                  new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n+              );\n+            }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                  + \" heartbeat, hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n\n            List\u003corg.apache.hadoop.yarn.api.records.Container\u003e\n                containersToDecrease \u003d response.getContainersToDecrease();\n            if (!containersToDecrease.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrDecreaseContainersResourceEvent(containersToDecrease)\n              );\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "fc07464d1a48b0413da5e921614430e41263fdb7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2923. Support configuration based NodeLabelsProvider Service in Distributed Node Label Configuration Setup. (Naganarasimha G R)\n",
      "commitDate": "20/08/15 11:51 AM",
      "commitName": "fc07464d1a48b0413da5e921614430e41263fdb7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/08/15 3:08 PM",
      "commitNameOld": "13604bd5f119fc81b9942190dfa366afad61bc92",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 3.86,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,141 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n-        Set\u003cNodeLabel\u003e lastUpdatedNodeLabelsToRM \u003d null;\n-        if (hasNodeLabelsProvider) {\n-          lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n-          lastUpdatedNodeLabelsToRM \u003d\n-              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET\n-                  : lastUpdatedNodeLabelsToRM;\n-        }\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n-            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d null;\n+            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n+                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n-            if (hasNodeLabelsProvider) {\n-              nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n-              // if the provider returns null then consider empty labels are set\n-              nodeLabelsForHeartbeat \u003d\n-                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET\n-                      : nodeLabelsForHeartbeat;\n-              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n-                  lastUpdatedNodeLabelsToRM)) {\n-                // if nodelabels have not changed then no need to send\n-                nodeLabelsForHeartbeat \u003d null;\n-              }\n-            }\n-\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n-              LOG\n-                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n-                    + \" hence shutting down.\");\n+              LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n+                  + \" heartbeat, hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n-            if (response.getAreNodeLabelsAcceptedByRM()) {\n-              lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n-              LOG.info(\"Node Labels {\"\n-                  + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n-                  + \"} were Accepted by RM \");\n-            } else if (nodeLabelsForHeartbeat !\u003d null) {\n-              // case where NodeLabelsProvider is set and updated labels were\n-              // sent to RM and RM rejected the labels\n-              LOG.error(response.getDiagnosticsMessage());\n-            }\n+            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n-      /**\n-       * Caller should take care of sending non null nodelabels for both\n-       * arguments\n-       * \n-       * @param nodeLabelsNew\n-       * @param nodeLabelsOld\n-       * @return if the New node labels are diff from the older one.\n-       */\n-      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n-          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n-        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n-            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n-          return true;\n-        }\n-        return false;\n-      }\n-\n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d\n                nodeLabelsHandler.getNodeLabelsForHeartbeat();\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG.warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of\"\n                  + \" heartbeat, hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            nodeLabelsHandler.verifyRMHeartbeatResponseForNodeLabels(response);\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3565. NodeHeartbeatRequest/RegisterNodeManagerRequest should use NodeLabel object instead of String. (Naganarasimha G R via wangda)\n",
      "commitDate": "19/05/15 4:34 PM",
      "commitName": "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/05/15 10:58 AM",
      "commitNameOld": "15ccd967ee3e7046a50522089f67ba01f36ec76a",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 5.23,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,187 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n-        Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n+        Set\u003cNodeLabel\u003e lastUpdatedNodeLabelsToRM \u003d null;\n         if (hasNodeLabelsProvider) {\n           lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n           lastUpdatedNodeLabelsToRM \u003d\n-              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n+              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET\n                   : lastUpdatedNodeLabelsToRM;\n         }\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n-            Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n+            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n             if (hasNodeLabelsProvider) {\n               nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n-              //if the provider returns null then consider empty labels are set\n+              // if the provider returns null then consider empty labels are set\n               nodeLabelsForHeartbeat \u003d\n-                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n+                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET\n                       : nodeLabelsForHeartbeat;\n               if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                   lastUpdatedNodeLabelsToRM)) {\n-                //if nodelabels have not changed then no need to send\n+                // if nodelabels have not changed then no need to send\n                 nodeLabelsForHeartbeat \u003d null;\n               }\n             }\n \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n               List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n             if (response.getAreNodeLabelsAcceptedByRM()) {\n               lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n               LOG.info(\"Node Labels {\"\n                   + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                   + \"} were Accepted by RM \");\n             } else if (nodeLabelsForHeartbeat !\u003d null) {\n               // case where NodeLabelsProvider is set and updated labels were\n               // sent to RM and RM rejected the labels\n               LOG.error(response.getDiagnosticsMessage());\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       /**\n        * Caller should take care of sending non null nodelabels for both\n        * arguments\n        * \n        * @param nodeLabelsNew\n        * @param nodeLabelsOld\n        * @return if the New node labels are diff from the older one.\n        */\n-      private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n-          Set\u003cString\u003e nodeLabelsOld) {\n+      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n+          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n         if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n             || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n           return true;\n         }\n         return false;\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        Set\u003cNodeLabel\u003e lastUpdatedNodeLabelsToRM \u003d null;\n        if (hasNodeLabelsProvider) {\n          lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n          lastUpdatedNodeLabelsToRM \u003d\n              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET\n                  : lastUpdatedNodeLabelsToRM;\n        }\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cNodeLabel\u003e nodeLabelsForHeartbeat \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            if (hasNodeLabelsProvider) {\n              nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n              // if the provider returns null then consider empty labels are set\n              nodeLabelsForHeartbeat \u003d\n                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_NODELABEL_SET\n                      : nodeLabelsForHeartbeat;\n              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                  lastUpdatedNodeLabelsToRM)) {\n                // if nodelabels have not changed then no need to send\n                nodeLabelsForHeartbeat \u003d null;\n              }\n            }\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            if (response.getAreNodeLabelsAcceptedByRM()) {\n              lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n              LOG.info(\"Node Labels {\"\n                  + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                  + \"} were Accepted by RM \");\n            } else if (nodeLabelsForHeartbeat !\u003d null) {\n              // case where NodeLabelsProvider is set and updated labels were\n              // sent to RM and RM rejected the labels\n              LOG.error(response.getDiagnosticsMessage());\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       * \n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cNodeLabel\u003e nodeLabelsNew,\n          Set\u003cNodeLabel\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "15ccd967ee3e7046a50522089f67ba01f36ec76a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3505. Node\u0027s Log Aggregation Report with SUCCEED should not cached in RMApps. Contributed by Xuan Gong.\n",
      "commitDate": "14/05/15 10:58 AM",
      "commitName": "15ccd967ee3e7046a50522089f67ba01f36ec76a",
      "commitAuthor": "Junping Du",
      "commitDateOld": "12/05/15 9:50 AM",
      "commitNameOld": "5c2f05cd9bad9bf9beb0f4ca18f4ae1bc3e84499",
      "commitAuthorOld": "Devaraj K",
      "daysBetweenCommits": 2.05,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,187 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n         if (hasNodeLabelsProvider) {\n           lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n           lastUpdatedNodeLabelsToRM \u003d\n               (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                   : lastUpdatedNodeLabelsToRM;\n         }\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n             if (hasNodeLabelsProvider) {\n               nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n               //if the provider returns null then consider empty labels are set\n               nodeLabelsForHeartbeat \u003d\n                   (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                       : nodeLabelsForHeartbeat;\n               if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                   lastUpdatedNodeLabelsToRM)) {\n                 //if nodelabels have not changed then no need to send\n                 nodeLabelsForHeartbeat \u003d null;\n               }\n             }\n \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n \n             if (logAggregationEnabled) {\n               // pull log aggregation status for application running in this NM\n-              Map\u003cApplicationId, LogAggregationReport\u003e logAggregationReports \u003d\n+              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                   getLogAggregationReportsForApps(context\n                     .getLogAggregationStatusForApps());\n               if (logAggregationReports !\u003d null\n                   \u0026\u0026 !logAggregationReports.isEmpty()) {\n                 request.setLogAggregationReportsForApps(logAggregationReports);\n               }\n             }\n \n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n             if (response.getAreNodeLabelsAcceptedByRM()) {\n               lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n               LOG.info(\"Node Labels {\"\n                   + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                   + \"} were Accepted by RM \");\n             } else if (nodeLabelsForHeartbeat !\u003d null) {\n               // case where NodeLabelsProvider is set and updated labels were\n               // sent to RM and RM rejected the labels\n               LOG.error(response.getDiagnosticsMessage());\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       /**\n        * Caller should take care of sending non null nodelabels for both\n        * arguments\n        * \n        * @param nodeLabelsNew\n        * @param nodeLabelsOld\n        * @return if the New node labels are diff from the older one.\n        */\n       private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n           Set\u003cString\u003e nodeLabelsOld) {\n         if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n             || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n           return true;\n         }\n         return false;\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n        if (hasNodeLabelsProvider) {\n          lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n          lastUpdatedNodeLabelsToRM \u003d\n              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                  : lastUpdatedNodeLabelsToRM;\n        }\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            if (hasNodeLabelsProvider) {\n              nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n              //if the provider returns null then consider empty labels are set\n              nodeLabelsForHeartbeat \u003d\n                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                      : nodeLabelsForHeartbeat;\n              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                  lastUpdatedNodeLabelsToRM)) {\n                //if nodelabels have not changed then no need to send\n                nodeLabelsForHeartbeat \u003d null;\n              }\n            }\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              List\u003cLogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            if (response.getAreNodeLabelsAcceptedByRM()) {\n              lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n              LOG.info(\"Node Labels {\"\n                  + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                  + \"} were Accepted by RM \");\n            } else if (nodeLabelsForHeartbeat !\u003d null) {\n              // case where NodeLabelsProvider is set and updated labels were\n              // sent to RM and RM rejected the labels\n              LOG.error(response.getDiagnosticsMessage());\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       * \n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n          Set\u003cString\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "92431c961741747b5d6442f4025016d48d9a6863": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1376. NM need to notify the log aggregation status to RM through Node heartbeat. Contributed by Xuan Gong.\n",
      "commitDate": "10/04/15 8:56 AM",
      "commitName": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthor": "Junping Du",
      "commitDateOld": "30/03/15 12:05 PM",
      "commitNameOld": "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,174 +1,187 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartbeatID \u003d 0;\n         Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n         if (hasNodeLabelsProvider) {\n           lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n           lastUpdatedNodeLabelsToRM \u003d\n               (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                   : lastUpdatedNodeLabelsToRM;\n         }\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n \n             if (hasNodeLabelsProvider) {\n               nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n               //if the provider returns null then consider empty labels are set\n               nodeLabelsForHeartbeat \u003d\n                   (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                       : nodeLabelsForHeartbeat;\n               if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                   lastUpdatedNodeLabelsToRM)) {\n                 //if nodelabels have not changed then no need to send\n                 nodeLabelsForHeartbeat \u003d null;\n               }\n             }\n \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                     NodeStatusUpdaterImpl.this.context\n                         .getContainerTokenSecretManager().getCurrentKey(),\n                     NodeStatusUpdaterImpl.this.context\n                         .getNMTokenSecretManager().getCurrentKey(),\n                     nodeLabelsForHeartbeat);\n+\n+            if (logAggregationEnabled) {\n+              // pull log aggregation status for application running in this NM\n+              Map\u003cApplicationId, LogAggregationReport\u003e logAggregationReports \u003d\n+                  getLogAggregationReportsForApps(context\n+                    .getLogAggregationStatusForApps());\n+              if (logAggregationReports !\u003d null\n+                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n+                request.setLogAggregationReportsForApps(logAggregationReports);\n+              }\n+            }\n+\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n             if (response.getAreNodeLabelsAcceptedByRM()) {\n               lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n               LOG.info(\"Node Labels {\"\n                   + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                   + \"} were Accepted by RM \");\n             } else if (nodeLabelsForHeartbeat !\u003d null) {\n               // case where NodeLabelsProvider is set and updated labels were\n               // sent to RM and RM rejected the labels\n               LOG.error(response.getDiagnosticsMessage());\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n+            logAggregationReportForAppsTempList.clear();\n             lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       /**\n        * Caller should take care of sending non null nodelabels for both\n        * arguments\n        * \n        * @param nodeLabelsNew\n        * @param nodeLabelsOld\n        * @return if the New node labels are diff from the older one.\n        */\n       private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n           Set\u003cString\u003e nodeLabelsOld) {\n         if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n             || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n           return true;\n         }\n         return false;\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n        if (hasNodeLabelsProvider) {\n          lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n          lastUpdatedNodeLabelsToRM \u003d\n              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                  : lastUpdatedNodeLabelsToRM;\n        }\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            if (hasNodeLabelsProvider) {\n              nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n              //if the provider returns null then consider empty labels are set\n              nodeLabelsForHeartbeat \u003d\n                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                      : nodeLabelsForHeartbeat;\n              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                  lastUpdatedNodeLabelsToRM)) {\n                //if nodelabels have not changed then no need to send\n                nodeLabelsForHeartbeat \u003d null;\n              }\n            }\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n\n            if (logAggregationEnabled) {\n              // pull log aggregation status for application running in this NM\n              Map\u003cApplicationId, LogAggregationReport\u003e logAggregationReports \u003d\n                  getLogAggregationReportsForApps(context\n                    .getLogAggregationStatusForApps());\n              if (logAggregationReports !\u003d null\n                  \u0026\u0026 !logAggregationReports.isEmpty()) {\n                request.setLogAggregationReportsForApps(logAggregationReports);\n              }\n            }\n\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            if (response.getAreNodeLabelsAcceptedByRM()) {\n              lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n              LOG.info(\"Node Labels {\"\n                  + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                  + \"} were Accepted by RM \");\n            } else if (nodeLabelsForHeartbeat !\u003d null) {\n              // case where NodeLabelsProvider is set and updated labels were\n              // sent to RM and RM rejected the labels\n              LOG.error(response.getDiagnosticsMessage());\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            logAggregationReportForAppsTempList.clear();\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       * \n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n          Set\u003cString\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2495. Allow admin specify labels from each NM (Distributed configuration for node label). (Naganarasimha G R via wangda)\n",
      "commitDate": "30/03/15 12:05 PM",
      "commitName": "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/01/15 11:12 AM",
      "commitNameOld": "cc2a745f7e82c9fa6de03242952347c54c52dccc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 80.99,
      "commitsBetweenForRepo": 718,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,174 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n-        int lastHeartBeatID \u003d 0;\n+        int lastHeartbeatID \u003d 0;\n+        Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n+        if (hasNodeLabelsProvider) {\n+          lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n+          lastUpdatedNodeLabelsToRM \u003d\n+              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n+                  : lastUpdatedNodeLabelsToRM;\n+        }\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n-            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n-            \n+            Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n+            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n+\n+            if (hasNodeLabelsProvider) {\n+              nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n+              //if the provider returns null then consider empty labels are set\n+              nodeLabelsForHeartbeat \u003d\n+                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n+                      : nodeLabelsForHeartbeat;\n+              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n+                  lastUpdatedNodeLabelsToRM)) {\n+                //if nodelabels have not changed then no need to send\n+                nodeLabelsForHeartbeat \u003d null;\n+              }\n+            }\n+\n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n-                  NodeStatusUpdaterImpl.this.context\n-                    .getContainerTokenSecretManager().getCurrentKey(),\n-                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n-                    .getCurrentKey());\n+                    NodeStatusUpdaterImpl.this.context\n+                        .getContainerTokenSecretManager().getCurrentKey(),\n+                    NodeStatusUpdaterImpl.this.context\n+                        .getNMTokenSecretManager().getCurrentKey(),\n+                    nodeLabelsForHeartbeat);\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               pendingCompletedContainers.clear();\n               break;\n             }\n \n+            if (response.getAreNodeLabelsAcceptedByRM()) {\n+              lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n+              LOG.info(\"Node Labels {\"\n+                  + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n+                  + \"} were Accepted by RM \");\n+            } else if (nodeLabelsForHeartbeat !\u003d null) {\n+              // case where NodeLabelsProvider is set and updated labels were\n+              // sent to RM and RM rejected the labels\n+              LOG.error(response.getDiagnosticsMessage());\n+            }\n+\n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n-            lastHeartBeatID \u003d response.getResponseId();\n+            lastHeartbeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n+      /**\n+       * Caller should take care of sending non null nodelabels for both\n+       * arguments\n+       * \n+       * @param nodeLabelsNew\n+       * @param nodeLabelsOld\n+       * @return if the New node labels are diff from the older one.\n+       */\n+      private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n+          Set\u003cString\u003e nodeLabelsOld) {\n+        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n+            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartbeatID \u003d 0;\n        Set\u003cString\u003e lastUpdatedNodeLabelsToRM \u003d null;\n        if (hasNodeLabelsProvider) {\n          lastUpdatedNodeLabelsToRM \u003d nodeLabelsProvider.getNodeLabels();\n          lastUpdatedNodeLabelsToRM \u003d\n              (null \u003d\u003d lastUpdatedNodeLabelsToRM) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                  : lastUpdatedNodeLabelsToRM;\n        }\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            Set\u003cString\u003e nodeLabelsForHeartbeat \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartbeatID);\n\n            if (hasNodeLabelsProvider) {\n              nodeLabelsForHeartbeat \u003d nodeLabelsProvider.getNodeLabels();\n              //if the provider returns null then consider empty labels are set\n              nodeLabelsForHeartbeat \u003d\n                  (nodeLabelsForHeartbeat \u003d\u003d null) ? CommonNodeLabelsManager.EMPTY_STRING_SET\n                      : nodeLabelsForHeartbeat;\n              if (!areNodeLabelsUpdated(nodeLabelsForHeartbeat,\n                  lastUpdatedNodeLabelsToRM)) {\n                //if nodelabels have not changed then no need to send\n                nodeLabelsForHeartbeat \u003d null;\n              }\n            }\n\n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                    NodeStatusUpdaterImpl.this.context\n                        .getContainerTokenSecretManager().getCurrentKey(),\n                    NodeStatusUpdaterImpl.this.context\n                        .getNMTokenSecretManager().getCurrentKey(),\n                    nodeLabelsForHeartbeat);\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            if (response.getAreNodeLabelsAcceptedByRM()) {\n              lastUpdatedNodeLabelsToRM \u003d nodeLabelsForHeartbeat;\n              LOG.info(\"Node Labels {\"\n                  + StringUtils.join(\",\", nodeLabelsForHeartbeat)\n                  + \"} were Accepted by RM \");\n            } else if (nodeLabelsForHeartbeat !\u003d null) {\n              // case where NodeLabelsProvider is set and updated labels were\n              // sent to RM and RM rejected the labels\n              LOG.error(response.getDiagnosticsMessage());\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            lastHeartbeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Caller should take care of sending non null nodelabels for both\n       * arguments\n       * \n       * @param nodeLabelsNew\n       * @param nodeLabelsOld\n       * @return if the New node labels are diff from the older one.\n       */\n      private boolean areNodeLabelsUpdated(Set\u003cString\u003e nodeLabelsNew,\n          Set\u003cString\u003e nodeLabelsOld) {\n        if (nodeLabelsNew.size() !\u003d nodeLabelsOld.size()\n            || !nodeLabelsOld.containsAll(nodeLabelsNew)) {\n          return true;\n        }\n        return false;\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "cc2a745f7e82c9fa6de03242952347c54c52dccc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2997. Fixed NodeStatusUpdater to not send alreay-sent completed container statuses on heartbeat. Contributed by Chengbing Liu\n",
      "commitDate": "08/01/15 11:12 AM",
      "commitName": "cc2a745f7e82c9fa6de03242952347c54c52dccc",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/11/14 11:07 AM",
      "commitNameOld": "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 57.0,
      "commitsBetweenForRepo": 342,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,124 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n+              pendingCompletedContainers.clear();\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              pendingCompletedContainers.clear();\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "c3d475070a1ec54c4b05923f4782cef204effd2c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2825. Container leak on NM. Contributed by Jian He\n",
      "commitDate": "07/11/14 3:16 PM",
      "commitName": "c3d475070a1ec54c4b05923f4782cef204effd2c",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/11/14 4:32 PM",
      "commitNameOld": "5c0381c96aa79196829edbca497c649eb6776944",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,123 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n-            removeCompletedContainersFromContext(response\n+            removeOrTrackCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n                 .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeOrTrackCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "5c0381c96aa79196829edbca497c649eb6776944": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2790. Fixed a NodeManager bug that was causing log-aggregation to fail beyond HFDS delegation-token expiry even when RM is a proxy-user (YARN-2704). Contributed by Jian He.\n",
      "commitDate": "01/11/14 4:32 PM",
      "commitName": "5c0381c96aa79196829edbca497c649eb6776944",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/14 3:49 PM",
      "commitNameOld": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.03,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,123 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n \n             Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                 response.getSystemCredentialsForApps();\n             if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n               ((NMContext) context)\n-                .setSystemCrendentials(parseCredentials(systemCredentials));\n+                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentialsForApps(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
      "commitDate": "27/10/14 3:49 PM",
      "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/10/14 10:04 AM",
      "commitNameOld": "3ef1cf187faeb530e74606dd7113fd1ba08140d7",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 25.24,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,123 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeCompletedContainersFromContext(response\n                   .getContainersToBeRemovedFromNM());\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n+\n+            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n+                response.getSystemCredentialsForApps();\n+            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n+              ((NMContext) context)\n+                .setSystemCrendentials(parseCredentials(systemCredentials));\n+            }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n\n            Map\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n                response.getSystemCredentialsForApps();\n            if (systemCredentials !\u003d null \u0026\u0026 !systemCredentials.isEmpty()) {\n              ((NMContext) context)\n                .setSystemCrendentials(parseCredentials(systemCredentials));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2630. Prevented previous AM container status from being acquired by the current restarted AM. Contributed by Jian He.\n",
      "commitDate": "01/10/14 3:38 PM",
      "commitName": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "22/09/14 10:45 PM",
      "commitNameOld": "a9a55db0650b5e6b7d88afb883b88aba7a13cd44",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 8.7,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             // Only remove the cleanedup containers that are acked\n             removeCompletedContainersFromContext(response\n-                  .getFinishedContainersPulledByAM());\n+                  .getContainersToBeRemovedFromNM());\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeCompletedContainersFromContext(response\n                  .getContainersToBeRemovedFromNM());\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1372. Ensure all completed containers are reported to the AMs across RM restart. Contributed by Anubhav Dhoot\n",
      "commitDate": "22/09/14 10:30 AM",
      "commitName": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 41.27,
      "commitsBetweenForRepo": 399,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,116 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n-            removeCompletedContainersFromContext();\n+            // Only remove the cleanedup containers that are acked\n+            removeCompletedContainersFromContext(response\n+                  .getFinishedContainersPulledByAM());\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            // Only remove the cleanedup containers that are acked\n            removeCompletedContainersFromContext(response\n                  .getFinishedContainersPulledByAM());\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "b29434a5c8df8757e6bcdcf643df2f5756a221d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1362. Distinguish between nodemanager shutdown for decommission vs shutdown for restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 5:20 PM",
      "commitName": "b29434a5c8df8757e6bcdcf643df2f5756a221d9",
      "commitAuthor": "Junping Du",
      "commitDateOld": "15/04/14 1:37 PM",
      "commitNameOld": "44b6261bfacddea88a3cf02d406f970bbbb98d04",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 28.15,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,114 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n+              context.setDecommissioned(true);\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             // Explicitly put this method after checking the resync response. We\n             // don\u0027t want to remove the completed containers before resync\n             // because these completed containers will be reported back to RM\n             // when NM re-registers with RM.\n             removeCompletedContainersFromContext();\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              context.setDecommissioned(true);\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            removeCompletedContainersFromContext();\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "1c4047b0e46e95a92509de2e59a93433f5968538": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1783. Fixed a bug in NodeManager\u0027s status-updater that was losing completed container statuses when NodeManager is forced to resync by the ResourceManager. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 2:36 PM",
      "commitName": "1c4047b0e46e95a92509de2e59a93433f5968538",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/11/13 9:17 PM",
      "commitNameOld": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 108.72,
      "commitsBetweenForRepo": 763,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,113 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n-            NodeStatus nodeStatus \u003d\n-                getNodeStatusAndUpdateContainersInContext(lastHeartBeatID);\n+            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d\n                 NodeHeartbeatRequest.newInstance(nodeStatus,\n                   NodeStatusUpdaterImpl.this.context\n                     .getContainerTokenSecretManager().getCurrentKey(),\n                   NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                     .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n+            // Explicitly put this method after checking the resync response. We\n+            // don\u0027t want to remove the completed containers before resync\n+            // because these completed containers will be reported back to RM\n+            // when NM re-registers with RM.\n+            removeCompletedContainersFromContext();\n+\n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatus(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            // Explicitly put this method after checking the resync response. We\n            // don\u0027t want to remove the completed containers before resync\n            // because these completed containers will be reported back to RM\n            // when NM re-registers with RM.\n            removeCompletedContainersFromContext();\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1210. Changed RM to start new app-attempts on RM restart only after ensuring that previous AM exited or after expiry time. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543310 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:17 PM",
      "commitName": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/10/13 5:54 PM",
      "commitNameOld": "defa7af4d3ef327c7c05807f640974e29c6d045b",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 21.18,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,108 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n-            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n-            nodeStatus.setResponseId(lastHeartBeatID);\n+            NodeStatus nodeStatus \u003d\n+                getNodeStatusAndUpdateContainersInContext(lastHeartBeatID);\n             \n-            NodeHeartbeatRequest request \u003d recordFactory\n-                .newRecordInstance(NodeHeartbeatRequest.class);\n-            request.setNodeStatus(nodeStatus);\n-            request\n-              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n-                .getContainerTokenSecretManager().getCurrentKey());\n-            request\n-              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n-                .getNMTokenSecretManager().getCurrentKey());\n+            NodeHeartbeatRequest request \u003d\n+                NodeHeartbeatRequest.newInstance(nodeStatus,\n+                  NodeStatusUpdaterImpl.this.context\n+                    .getContainerTokenSecretManager().getCurrentKey(),\n+                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n+                    .getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup,\n                     CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d\n                getNodeStatusAndUpdateContainersInContext(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d\n                NodeHeartbeatRequest.newInstance(nodeStatus,\n                  NodeStatusUpdaterImpl.this.context\n                    .getContainerTokenSecretManager().getCurrentKey(),\n                  NodeStatusUpdaterImpl.this.context.getNMTokenSecretManager()\n                    .getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "44f7ee7192d150b43a3012f06cec67be5b64edd0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1278. Fixed NodeManager to not delete local resources for apps on resync command from RM - a bug caused by YARN-1149. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/10/13 11:32 AM",
      "commitName": "44f7ee7192d150b43a3012f06cec67be5b64edd0",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/10/13 5:43 PM",
      "commitNameOld": "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 2.74,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,111 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request\n               .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             request\n               .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getNMTokenSecretManager().getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n-                  new CMgrCompletedContainersEvent(containersToCleanup));\n+                  new CMgrCompletedContainersEvent(containersToCleanup,\n+                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup,\n                       CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup,\n                    CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1149. NM throws InvalidStateTransitonException: Invalid event: APPLICATION_LOG_HANDLING_FINISHED at RUNNING. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 5:43 PM",
      "commitName": "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "26/09/13 12:55 PM",
      "commitNameOld": "5a15c392a1a18c5720dbe630bc07e58268c8e6a7",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 7.2,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request\n               .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             request\n               .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getNMTokenSecretManager().getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n-            if (containersToCleanup.size() !\u003d 0) {\n+            if (!containersToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n-                  new CMgrCompletedContainersEvent(containersToCleanup, \n-                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n+                  new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n-            if (appsToCleanup.size() !\u003d 0) {\n+            if (!appsToCleanup.isEmpty()) {\n               dispatcher.getEventHandler().handle(\n-                  new CMgrCompletedAppsEvent(appsToCleanup));\n+                  new CMgrCompletedAppsEvent(appsToCleanup,\n+                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (!containersToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (!appsToCleanup.isEmpty()) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup,\n                      CMgrCompletedAppsEvent.Reason.BY_RESOURCEMANAGER));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329": {
      "type": "Ybodychange",
      "commitMessage": "Reverting YARN-245 to fix a critical bug.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508277 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 8:06 PM",
      "commitName": "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/07/13 11:15 AM",
      "commitNameOld": "412e19f8e3118e602c567d60461e17c0dfe98b88",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,110 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request\n               .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             request\n               .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getNMTokenSecretManager().getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n-            // Checking if the response id is the same which we just processed\n-            // If yes then ignore the update.\n-            if (lastHeartBeatID !\u003d response.getResponseId() - 1) {\n-              LOG.info(\"Discarding the duplicate response \"\n-                  + response.getResponseId());\n-              continue;\n-            }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n+\n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "412e19f8e3118e602c567d60461e17c0dfe98b88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-245. Fixed NodeManager to handle duplicate responses from ResourceManager. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508157 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 11:15 AM",
      "commitName": "412e19f8e3118e602c567d60461e17c0dfe98b88",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/07/13 9:14 PM",
      "commitNameOld": "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.58,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,116 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request\n               .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             request\n               .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getNMTokenSecretManager().getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n+            // Checking if the response id is the same which we just processed\n+            // If yes then ignore the update.\n+            if (lastHeartBeatID !\u003d response.getResponseId() - 1) {\n+              LOG.info(\"Discarding the duplicate response \"\n+                  + response.getResponseId());\n+              continue;\n+            }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n-\n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n \n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            // Checking if the response id is the same which we just processed\n            // If yes then ignore the update.\n            if (lastHeartBeatID !\u003d response.getResponseId() - 1) {\n              LOG.info(\"Discarding the duplicate response \"\n                  + response.getResponseId());\n              continue;\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-688. Fixed NodeManager to properly cleanup containers when it is shut down. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506814 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/07/13 9:14 PM",
      "commitName": "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/07/13 3:47 PM",
      "commitNameOld": "33b5a81509ed08e88bb692682e75fb779f8e2e19",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 8.23,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,110 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request\n               .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             request\n               .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getNMTokenSecretManager().getCurrentKey());\n             response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n-                  + \" hence rebooting.\");\n+                  + \" hence resyncing.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n+\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence resyncing.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "33b5a81509ed08e88bb692682e75fb779f8e2e19": {
      "type": "Ybodychange",
      "commitMessage": "YARN-513. Create common proxy client for communicating with RM (Xuan Gong \u0026 Jian He via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503933 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 3:47 PM",
      "commitName": "33b5a81509ed08e88bb692682e75fb779f8e2e19",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 29.67,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,109 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n-            int rmRetryCount \u003d 0;\n-            long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request\n               .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             request\n               .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getNMTokenSecretManager().getCurrentKey());\n-            while (!isStopped) {\n-              try {\n-                rmRetryCount++;\n-                response \u003d resourceTracker.nodeHeartbeat(request);\n-                break;\n-              } catch (Throwable e) {\n-                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n-                    + \"current no. of failed attempts is \" + rmRetryCount);\n-                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n-                    || waitForEver) {\n-                  try {\n-                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n-                        + \" seconds before next heartbeat to RM\");\n-                    Thread.sleep(rmConnectionRetryIntervalMS);\n-                  } catch(InterruptedException ex) {\n-                    //done nothing\n-                  }\n-                } else {\n-                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n-                      \"no. of failed attempts is \"+rmRetryCount;\n-                  LOG.error(errorMessage,e);\n-                  throw new YarnRuntimeException(errorMessage,e);\n-                }\n-              }\n-            }\n+            response \u003d resourceTracker.nodeHeartbeat(request);\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n-          } catch (YarnRuntimeException e) {\n+          } catch (ConnectException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n-            throw e;\n+            throw new YarnRuntimeException(e);\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n \n       private void updateMasterKeys(NodeHeartbeatResponse response) {\n         // See if the master-key has rolled over\n         MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           // Will be non-null only on roll-over on RM side\n           context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n         \n         updatedMasterKey \u003d response.getNMTokenMasterKey();\n         if (updatedMasterKey !\u003d null) {\n           context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            response \u003d resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (ConnectException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw new YarnRuntimeException(e);\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-692. Creating NMToken master key on RM and sharing it with NM as a part of RM-NM heartbeat. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 5:06 PM",
      "commitName": "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,135 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             int rmRetryCount \u003d 0;\n             long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n-            request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n-              .getContainerTokenSecretManager().getCurrentKey());\n+            request\n+              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n+                .getContainerTokenSecretManager().getCurrentKey());\n+            request\n+              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n+                .getNMTokenSecretManager().getCurrentKey());\n             while (!isStopped) {\n               try {\n                 rmRetryCount++;\n                 response \u003d resourceTracker.nodeHeartbeat(request);\n                 break;\n               } catch (Throwable e) {\n                 LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                     + \"current no. of failed attempts is \" + rmRetryCount);\n                 if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                     || waitForEver) {\n                   try {\n                     LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                         + \" seconds before next heartbeat to RM\");\n                     Thread.sleep(rmConnectionRetryIntervalMS);\n                   } catch(InterruptedException ex) {\n                     //done nothing\n                   }\n                 } else {\n                   String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                       \"no. of failed attempts is \"+rmRetryCount;\n                   LOG.error(errorMessage,e);\n                   throw new YarnRuntimeException(errorMessage,e);\n                 }\n               }\n             }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n-            // See if the master-key has rolled over\n-            MasterKey updatedMasterKey \u003d response.getMasterKey();\n-            if (updatedMasterKey !\u003d null) {\n-              // Will be non-null only on roll-over on RM side\n-              context.getContainerTokenSecretManager().setMasterKey(\n-                updatedMasterKey);\n-            }\n+            updateMasterKeys(response);\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (YarnRuntimeException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw e;\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n+\n+      private void updateMasterKeys(NodeHeartbeatResponse response) {\n+        // See if the master-key has rolled over\n+        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n+        if (updatedMasterKey !\u003d null) {\n+          // Will be non-null only on roll-over on RM side\n+          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n+        }\n+        \n+        updatedMasterKey \u003d response.getNMTokenMasterKey();\n+        if (updatedMasterKey !\u003d null) {\n+          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n+        }\n+      }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request\n              .setLastKnownContainerTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            request\n              .setLastKnownNMTokenMasterKey(NodeStatusUpdaterImpl.this.context\n                .getNMTokenSecretManager().getCurrentKey());\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnRuntimeException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            updateMasterKeys(response);\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnRuntimeException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n\n      private void updateMasterKeys(NodeHeartbeatResponse response) {\n        // See if the master-key has rolled over\n        MasterKey updatedMasterKey \u003d response.getContainerTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          // Will be non-null only on roll-over on RM side\n          context.getContainerTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n        \n        updatedMasterKey \u003d response.getNMTokenMasterKey();\n        if (updatedMasterKey !\u003d null) {\n          context.getNMTokenSecretManager().setMasterKey(updatedMasterKey);\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/05/13 9:13 PM",
      "commitNameOld": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,123 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             int rmRetryCount \u003d 0;\n             long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n               .getContainerTokenSecretManager().getCurrentKey());\n             while (!isStopped) {\n               try {\n                 rmRetryCount++;\n                 response \u003d resourceTracker.nodeHeartbeat(request);\n                 break;\n               } catch (Throwable e) {\n                 LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                     + \"current no. of failed attempts is \" + rmRetryCount);\n                 if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                     || waitForEver) {\n                   try {\n                     LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                         + \" seconds before next heartbeat to RM\");\n                     Thread.sleep(rmConnectionRetryIntervalMS);\n                   } catch(InterruptedException ex) {\n                     //done nothing\n                   }\n                 } else {\n                   String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                       \"no. of failed attempts is \"+rmRetryCount;\n                   LOG.error(errorMessage,e);\n-                  throw new YarnException(errorMessage,e);\n+                  throw new YarnRuntimeException(errorMessage,e);\n                 }\n               }\n             }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             MasterKey updatedMasterKey \u003d response.getMasterKey();\n             if (updatedMasterKey !\u003d null) {\n               // Will be non-null only on roll-over on RM side\n               context.getContainerTokenSecretManager().setMasterKey(\n                 updatedMasterKey);\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n-          } catch (YarnException e) {\n+          } catch (YarnRuntimeException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw e;\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n              .getContainerTokenSecretManager().getCurrentKey());\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnRuntimeException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            MasterKey updatedMasterKey \u003d response.getMasterKey();\n            if (updatedMasterKey !\u003d null) {\n              // Will be non-null only on roll-over on RM side\n              context.getContainerTokenSecretManager().setMasterKey(\n                updatedMasterKey);\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnRuntimeException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "ca8024673178fa1c80224b390dfba932921693d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-617. Made ContainerTokens to be used for validation at NodeManager also in unsecure mode to prevent AMs from faking resource requirements in unsecure mode. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/13 11:36 PM",
      "commitName": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/05/13 4:37 PM",
      "commitNameOld": "68148989bfb8b893529eb9920d849bce0dd575ec",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.29,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,123 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             int rmRetryCount \u003d 0;\n             long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n-            if (isSecurityEnabled()) {\n-              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n-                .getContainerTokenSecretManager().getCurrentKey());\n-            }\n+            request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n+              .getContainerTokenSecretManager().getCurrentKey());\n             while (!isStopped) {\n               try {\n                 rmRetryCount++;\n                 response \u003d resourceTracker.nodeHeartbeat(request);\n                 break;\n               } catch (Throwable e) {\n                 LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                     + \"current no. of failed attempts is \" + rmRetryCount);\n                 if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                     || waitForEver) {\n                   try {\n                     LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                         + \" seconds before next heartbeat to RM\");\n                     Thread.sleep(rmConnectionRetryIntervalMS);\n                   } catch(InterruptedException ex) {\n                     //done nothing\n                   }\n                 } else {\n                   String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                       \"no. of failed attempts is \"+rmRetryCount;\n                   LOG.error(errorMessage,e);\n                   throw new YarnException(errorMessage,e);\n                 }\n               }\n             }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n-            if (isSecurityEnabled()) {\n-              MasterKey updatedMasterKey \u003d response.getMasterKey();\n-              if (updatedMasterKey !\u003d null) {\n-                // Will be non-null only on roll-over on RM side\n-                context.getContainerTokenSecretManager().setMasterKey(\n-                  updatedMasterKey);\n-              }\n+            MasterKey updatedMasterKey \u003d response.getMasterKey();\n+            if (updatedMasterKey !\u003d null) {\n+              // Will be non-null only on roll-over on RM side\n+              context.getContainerTokenSecretManager().setMasterKey(\n+                updatedMasterKey);\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                 .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                     + \" hence shutting down.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               LOG.warn(\"Message from ResourceManager: \"\n                   + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (YarnException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw e;\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n              .getContainerTokenSecretManager().getCurrentKey());\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            MasterKey updatedMasterKey \u003d response.getMasterKey();\n            if (updatedMasterKey !\u003d null) {\n              // Will be non-null only on roll-over on RM side\n              context.getContainerTokenSecretManager().setMasterKey(\n                updatedMasterKey);\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "68148989bfb8b893529eb9920d849bce0dd575ec": {
      "type": "Ybodychange",
      "commitMessage": "YARN-590. Added an optional mesage to be returned by ResourceMaanger when RM asks an RM to shutdown/resync etc so that NMs can log this message locally for better debuggability. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481234 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/13 4:37 PM",
      "commitName": "68148989bfb8b893529eb9920d849bce0dd575ec",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/05/13 2:58 PM",
      "commitNameOld": "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,127 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             int rmRetryCount \u003d 0;\n             long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             while (!isStopped) {\n               try {\n                 rmRetryCount++;\n                 response \u003d resourceTracker.nodeHeartbeat(request);\n                 break;\n               } catch (Throwable e) {\n                 LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                     + \"current no. of failed attempts is \" + rmRetryCount);\n                 if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                     || waitForEver) {\n                   try {\n                     LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                         + \" seconds before next heartbeat to RM\");\n                     Thread.sleep(rmConnectionRetryIntervalMS);\n                   } catch(InterruptedException ex) {\n                     //done nothing\n                   }\n                 } else {\n                   String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                       \"no. of failed attempts is \"+rmRetryCount;\n                   LOG.error(errorMessage,e);\n                   throw new YarnException(errorMessage,e);\n                 }\n               }\n             }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n-                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n-                      \" hence shutting down.\");\n+                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n+                    + \" hence shutting down.\");\n+              LOG.warn(\"Message from ResourceManager: \"\n+                  + response.getDiagnosticsMessage());\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n-              LOG.info(\"Node is out of sync with ResourceManager,\"\n+              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n+              LOG.warn(\"Message from ResourceManager: \"\n+                  + response.getDiagnosticsMessage());\n               // Invalidate the RMIdentifier while resync\n               NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                   ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (YarnException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw e;\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                .warn(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\"\n                    + \" hence shutting down.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.warn(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              LOG.warn(\"Message from ResourceManager: \"\n                  + response.getDiagnosticsMessage());\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "fbb55784d93e1a819daf55d936e864d344579cbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-562. Modified NM to reject any containers allocated by a previous ResourceManager. Contributed by Jian He.\nMAPREDUCE-5167. Update MR App after YARN-562 to use the new builder API for the container. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 8:50 PM",
      "commitName": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/04/13 7:00 PM",
      "commitNameOld": "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.08,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,123 @@\n   protected void startStatusUpdater() {\n \n     statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             int rmRetryCount \u003d 0;\n             long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             while (!isStopped) {\n               try {\n                 rmRetryCount++;\n                 response \u003d resourceTracker.nodeHeartbeat(request);\n                 break;\n               } catch (Throwable e) {\n                 LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                     + \"current no. of failed attempts is \" + rmRetryCount);\n                 if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                     || waitForEver) {\n                   try {\n                     LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                         + \" seconds before next heartbeat to RM\");\n                     Thread.sleep(rmConnectionRetryIntervalMS);\n                   } catch(InterruptedException ex) {\n                     //done nothing\n                   }\n                 } else {\n                   String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                       \"no. of failed attempts is \"+rmRetryCount;\n                   LOG.error(errorMessage,e);\n                   throw new YarnException(errorMessage,e);\n                 }\n               }\n             }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                       \" hence shutting down.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n+              // Invalidate the RMIdentifier while resync\n+              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n+                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (YarnException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw e;\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n     };\n     statusUpdater \u003d\n         new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n     statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                      \" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              // Invalidate the RMIdentifier while resync\n              NodeStatusUpdaterImpl.this.rmIdentifier \u003d\n                  ResourceManagerConstants.RM_INVALID_IDENTIFIER;\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963": {
      "type": "Ybodychange",
      "commitMessage": "YARN-495. Changed NM reboot behaviour to be a simple resync - kill all containers  and re-register with RM. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466752 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 7:00 PM",
      "commitName": "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/04/13 12:17 PM",
      "commitNameOld": "16fedf5473cd715e3970da700b24ca10656e3576",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 2.28,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,120 @@\n   protected void startStatusUpdater() {\n \n-    new Thread(\"Node Status Updater\") {\n+    statusUpdaterRunnable \u003d new Runnable() {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeHeartbeatResponse response \u003d null;\n             int rmRetryCount \u003d 0;\n             long waitStartTime \u003d System.currentTimeMillis();\n-            NodeStatus nodeStatus \u003d getNodeStatus();\n+            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             while (!isStopped) {\n               try {\n                 rmRetryCount++;\n                 response \u003d resourceTracker.nodeHeartbeat(request);\n                 break;\n               } catch (Throwable e) {\n                 LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                     + \"current no. of failed attempts is \" + rmRetryCount);\n                 if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                     || waitForEver) {\n                   try {\n                     LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                         + \" seconds before next heartbeat to RM\");\n                     Thread.sleep(rmConnectionRetryIntervalMS);\n                   } catch(InterruptedException ex) {\n                     //done nothing\n                   }\n                 } else {\n                   String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                       \"no. of failed attempts is \"+rmRetryCount;\n                   LOG.error(errorMessage,e);\n                   throw new YarnException(errorMessage,e);\n                 }\n               }\n             }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                       \" hence shutting down.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n-            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n+            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               dispatcher.getEventHandler().handle(\n-                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n+                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (YarnException e) {\n             //catch and throw the exception if tried MAX wait time to connect RM\n             dispatcher.getEventHandler().handle(\n                 new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n             throw e;\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n-    }.start();\n+    };\n+    statusUpdater \u003d\n+        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n+    statusUpdater.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    statusUpdaterRunnable \u003d new Runnable() {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatusAndUpdateContainersInContext();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                      \" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.RESYNC) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.RESYNC));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    };\n    statusUpdater \u003d\n        new Thread(statusUpdaterRunnable, \"Node Status Updater\");\n    statusUpdater.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "16fedf5473cd715e3970da700b24ca10656e3576": {
      "type": "Ybodychange",
      "commitMessage": "YARN-479. NM retry behavior for connection to RM should be similar for lost heartbeats (Jian He via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465731 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/04/13 12:17 PM",
      "commitName": "16fedf5473cd715e3970da700b24ca10656e3576",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "03/04/13 9:57 AM",
      "commitNameOld": "3e9200ddde4858be8ecdd8347b5fee63ed83df84",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,117 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n+            NodeHeartbeatResponse response \u003d null;\n+            int rmRetryCount \u003d 0;\n+            long waitStartTime \u003d System.currentTimeMillis();\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n-            NodeHeartbeatResponse response \u003d\n-              resourceTracker.nodeHeartbeat(request);\n-            previousHeartBeatSucceeded \u003d true;\n+            while (!isStopped) {\n+              try {\n+                rmRetryCount++;\n+                response \u003d resourceTracker.nodeHeartbeat(request);\n+                break;\n+              } catch (Throwable e) {\n+                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n+                    + \"current no. of failed attempts is \" + rmRetryCount);\n+                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n+                    || waitForEver) {\n+                  try {\n+                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n+                        + \" seconds before next heartbeat to RM\");\n+                    Thread.sleep(rmConnectionRetryIntervalMS);\n+                  } catch(InterruptedException ex) {\n+                    //done nothing\n+                  }\n+                } else {\n+                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n+                      \"no. of failed attempts is \"+rmRetryCount;\n+                  LOG.error(errorMessage,e);\n+                  throw new YarnException(errorMessage,e);\n+                }\n+              }\n+            }\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n-                  \t\t\" hence shutting down.\");\n+                      \" hence shutting down.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.REBOOT));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n+          } catch (YarnException e) {\n+            //catch and throw the exception if tried MAX wait time to connect RM\n+            dispatcher.getEventHandler().handle(\n+                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n+            throw e;\n           } catch (Throwable e) {\n-            previousHeartBeatSucceeded \u003d false;\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeHeartbeatResponse response \u003d null;\n            int rmRetryCount \u003d 0;\n            long waitStartTime \u003d System.currentTimeMillis();\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            while (!isStopped) {\n              try {\n                rmRetryCount++;\n                response \u003d resourceTracker.nodeHeartbeat(request);\n                break;\n              } catch (Throwable e) {\n                LOG.warn(\"Trying to heartbeat to ResourceManager, \"\n                    + \"current no. of failed attempts is \" + rmRetryCount);\n                if(System.currentTimeMillis() - waitStartTime \u003c rmConnectWaitMS\n                    || waitForEver) {\n                  try {\n                    LOG.info(\"Sleeping for \" + rmConnectionRetryIntervalMS/1000\n                        + \" seconds before next heartbeat to RM\");\n                    Thread.sleep(rmConnectionRetryIntervalMS);\n                  } catch(InterruptedException ex) {\n                    //done nothing\n                  }\n                } else {\n                  String errorMessage \u003d \"Failed to heartbeat to RM, \" +\n                      \"no. of failed attempts is \"+rmRetryCount;\n                  LOG.error(errorMessage,e);\n                  throw new YarnException(errorMessage,e);\n                }\n              }\n            }\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                      \" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (YarnException e) {\n            //catch and throw the exception if tried MAX wait time to connect RM\n            dispatcher.getEventHandler().handle(\n                new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n            throw e;\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "3e9200ddde4858be8ecdd8347b5fee63ed83df84": {
      "type": "Ybodychange",
      "commitMessage": "YARN-101. Fix NodeManager heartbeat processing to not lose track of completed containers in case of dropped heartbeats. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1464105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/13 9:57 AM",
      "commitName": "3e9200ddde4858be8ecdd8347b5fee63ed83df84",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/04/13 6:04 PM",
      "commitNameOld": "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,88 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             NodeHeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request);\n+            previousHeartBeatSucceeded \u003d true;\n             //get next heartbeat interval from response\n             nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.REBOOT));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n+            previousHeartBeatSucceeded \u003d false;\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           } finally {\n             synchronized (heartbeatMonitor) {\n               nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                   YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                     nextHeartBeatInterval;\n               try {\n                 heartbeatMonitor.wait(nextHeartBeatInterval);\n               } catch (InterruptedException e) {\n                 // Do Nothing\n               }\n             }\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            NodeHeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request);\n            previousHeartBeatSucceeded \u003d true;\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            previousHeartBeatSucceeded \u003d false;\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-309. Changed NodeManager to obtain heart-beat interval from the ResourceManager. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1463346 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/13 6:04 PM",
      "commitName": "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/03/13 11:20 AM",
      "commitNameOld": "66e90b205a079c7056bd85e6c5e3dbb2a96e7461",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 6.28,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,86 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n-            synchronized (heartbeatMonitor) {\n-              heartbeatMonitor.wait(heartBeatInterval);\n-            }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             NodeHeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request);\n-\n+            //get next heartbeat interval from response\n+            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.REBOOT));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n+          } finally {\n+            synchronized (heartbeatMonitor) {\n+              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n+                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n+                    nextHeartBeatInterval;\n+              try {\n+                heartbeatMonitor.wait(nextHeartBeatInterval);\n+              } catch (InterruptedException e) {\n+                // Do Nothing\n+              }\n+            }\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            NodeHeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request);\n            //get next heartbeat interval from response\n            nextHeartBeatInterval \u003d response.getNextHeartBeatInterval();\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          } finally {\n            synchronized (heartbeatMonitor) {\n              nextHeartBeatInterval \u003d nextHeartBeatInterval \u003c\u003d 0 ?\n                  YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :\n                    nextHeartBeatInterval;\n              try {\n                heartbeatMonitor.wait(nextHeartBeatInterval);\n              } catch (InterruptedException e) {\n                // Do Nothing\n              }\n            }\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "18e08a8f511652ed9f4ba386bb4f0cf8339e2729": {
      "type": "Ybodychange",
      "commitMessage": "YARN-439. Flatten NodeHeartbeatResponse. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 11:28 AM",
      "commitName": "18e08a8f511652ed9f4ba386bb4f0cf8339e2729",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "15/03/13 10:58 AM",
      "commitNameOld": "2ba66a54f5004f93b53d40b6a1cc5029abf5e609",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 10.02,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n-            HeartbeatResponse response \u003d\n-              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n+            NodeHeartbeatResponse response \u003d\n+              resourceTracker.nodeHeartbeat(request);\n \n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               dispatcher.getEventHandler().handle(\n                   new NodeManagerEvent(NodeManagerEventType.REBOOT));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n-                .getContainersToCleanupList();\n+                .getContainersToCleanup();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n-                response.getApplicationsToCleanupList();\n+                response.getApplicationsToCleanup();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            NodeHeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request);\n\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanup();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanup();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "2cd41855d51fd18955a1ab187900ba02c6a6cfa9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-170. Change NodeManager stop to be reentrant. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1429796 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/13 5:43 AM",
      "commitName": "2cd41855d51fd18955a1ab187900ba02c6a6cfa9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/12/12 4:12 AM",
      "commitNameOld": "235749a8ab5f303b5b3a2993da8c5bea1818183b",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 35.06,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,77 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n \n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n-              NodeStatusUpdaterImpl.this.stop();\n+              dispatcher.getEventHandler().handle(\n+                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n-              NodeStatusUpdaterImpl.this.reboot();\n+              dispatcher.getEventHandler().handle(\n+                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup, \n                       CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              dispatcher.getEventHandler().handle(\n                  new NodeManagerEvent(NodeManagerEventType.REBOOT));\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "235749a8ab5f303b5b3a2993da8c5bea1818183b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-72. NM should handle cleaning up containers when it shuts down. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1416484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/12/12 4:12 AM",
      "commitName": "235749a8ab5f303b5b3a2993da8c5bea1818183b",
      "commitAuthor": "Thomas White",
      "commitDateOld": "31/08/12 12:11 PM",
      "commitNameOld": "45a8e8c5a46535287de97fd6609c0743eef888ee",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 93.71,
      "commitsBetweenForRepo": 517,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,75 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);\n             if (isSecurityEnabled()) {\n               request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                 .getContainerTokenSecretManager().getCurrentKey());\n             }\n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n \n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               NodeStatusUpdaterImpl.this.stop();\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               NodeStatusUpdaterImpl.this.reboot();\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n-                  new CMgrCompletedContainersEvent(containersToCleanup));\n+                  new CMgrCompletedContainersEvent(containersToCleanup, \n+                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              NodeStatusUpdaterImpl.this.reboot();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup, \n                      CMgrCompletedContainersEvent.Reason.BY_RESOURCEMANAGER));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "45a8e8c5a46535287de97fd6609c0743eef888ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-60. Fixed a bug in ResourceManager which causes all NMs to get NPEs and thus causes all containers to be rejected. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1379550 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/12 12:11 PM",
      "commitName": "45a8e8c5a46535287de97fd6609c0743eef888ee",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/12 7:18 PM",
      "commitNameOld": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 6.7,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,74 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n-            request.setNodeStatus(nodeStatus);            \n+            request.setNodeStatus(nodeStatus);\n+            if (isSecurityEnabled()) {\n+              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n+                .getContainerTokenSecretManager().getCurrentKey());\n+            }\n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n \n             // See if the master-key has rolled over\n             if (isSecurityEnabled()) {\n               MasterKey updatedMasterKey \u003d response.getMasterKey();\n               if (updatedMasterKey !\u003d null) {\n                 // Will be non-null only on roll-over on RM side\n                 context.getContainerTokenSecretManager().setMasterKey(\n                   updatedMasterKey);\n               }\n             }\n \n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               NodeStatusUpdaterImpl.this.stop();\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               NodeStatusUpdaterImpl.this.reboot();\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);\n            if (isSecurityEnabled()) {\n              request.setLastKnownMasterKey(NodeStatusUpdaterImpl.this.context\n                .getContainerTokenSecretManager().getCurrentKey());\n            }\n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              NodeStatusUpdaterImpl.this.reboot();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.87,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,70 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);            \n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n+\n+            // See if the master-key has rolled over\n+            if (isSecurityEnabled()) {\n+              MasterKey updatedMasterKey \u003d response.getMasterKey();\n+              if (updatedMasterKey !\u003d null) {\n+                // Will be non-null only on roll-over on RM side\n+                context.getContainerTokenSecretManager().setMasterKey(\n+                  updatedMasterKey);\n+              }\n+            }\n+\n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               NodeStatusUpdaterImpl.this.stop();\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence rebooting.\");\n               NodeStatusUpdaterImpl.this.reboot();\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n\n            // See if the master-key has rolled over\n            if (isSecurityEnabled()) {\n              MasterKey updatedMasterKey \u003d response.getMasterKey();\n              if (updatedMasterKey !\u003d null) {\n                // Will be non-null only on roll-over on RM side\n                context.getContainerTokenSecretManager().setMasterKey(\n                  updatedMasterKey);\n              }\n            }\n\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              NodeStatusUpdaterImpl.this.reboot();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              NodeStatusUpdaterImpl.this.reboot();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java"
      }
    },
    "b9fd9e17598c606d0acd54a68b4693f482ffb3ac": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3034. Ensure NodeManager reboots itself on direction from ResourceManager. Contributed by Devaraj K \u0026 Eric Payne. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1297310 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/12 4:52 PM",
      "commitName": "b9fd9e17598c606d0acd54a68b4693f482ffb3ac",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "14/12/11 11:55 AM",
      "commitNameOld": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 82.21,
      "commitsBetweenForRepo": 591,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);            \n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               NodeStatusUpdaterImpl.this.stop();\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n-                  + \" hence shutting down.\");\n-              NodeStatusUpdaterImpl.this.stop();\n+                  + \" hence rebooting.\");\n+              NodeStatusUpdaterImpl.this.reboot();\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             //Only start tracking for keepAlive on FINISH_APP\n             trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence rebooting.\");\n              NodeStatusUpdaterImpl.this.reboot();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3398. Fixed log aggregation to work correctly in secure mode. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1214429 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/11 11:55 AM",
      "commitName": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/11/11 3:17 PM",
      "commitNameOld": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 14.86,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,59 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n+      @SuppressWarnings(\"unchecked\")\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory\n                 .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);            \n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n             if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n               LOG\n                   .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                   \t\t\" hence shutting down.\");\n               NodeStatusUpdaterImpl.this.stop();\n               break;\n             }\n             if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n               LOG.info(\"Node is out of sync with ResourceManager,\"\n                   + \" hence shutting down.\");\n               NodeStatusUpdaterImpl.this.stop();\n               break;\n             }\n \n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n+            //Only start tracking for keepAlive on FINISH_APP\n+            trackAppsForKeepAlive(appsToCleanup);\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      @SuppressWarnings(\"unchecked\")\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            //Only start tracking for keepAlive on FINISH_APP\n            trackAppsForKeepAlive(appsToCleanup);\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "cbdb07f4ca358b9507296868a913977ad82ed716": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2775. Fixed ResourceManager and NodeManager to force a decommissioned node to shutdown. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190467 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/11 10:31 AM",
      "commitName": "cbdb07f4ca358b9507296868a913977ad82ed716",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,56 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n-            NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n+            NodeHeartbeatRequest request \u003d recordFactory\n+                .newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);            \n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n+            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n+              LOG\n+                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n+                  \t\t\" hence shutting down.\");\n+              NodeStatusUpdaterImpl.this.stop();\n+              break;\n+            }\n+            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n+              LOG.info(\"Node is out of sync with ResourceManager,\"\n+                  + \" hence shutting down.\");\n+              NodeStatusUpdaterImpl.this.stop();\n+              break;\n+            }\n+\n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             // TODO Better error handling. Thread can die with the rest of the\n             // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n-            break;\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory\n                .newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            if (response.getNodeAction() \u003d\u003d NodeAction.SHUTDOWN) {\n              LOG\n                  .info(\"Recieved SHUTDOWN signal from Resourcemanager as part of heartbeat,\" +\n                  \t\t\" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n            if (response.getNodeAction() \u003d\u003d NodeAction.REBOOT) {\n              LOG.info(\"Node is out of sync with ResourceManager,\"\n                  + \" hence shutting down.\");\n              NodeStatusUpdaterImpl.this.stop();\n              break;\n            }\n\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/10/11 4:58 PM",
      "commitNameOld": "237154982bd5853c6a374cb265520e0602adc52f",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,42 @@\n   protected void startStatusUpdater() {\n \n     new Thread(\"Node Status Updater\") {\n       @Override\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);            \n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n+            // TODO Better error handling. Thread can die with the rest of the\n+            // NM still running.\n             LOG.error(\"Caught exception in status-updater\", e);\n             break;\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            // TODO Better error handling. Thread can die with the rest of the\n            // NM still running.\n            LOG.error(\"Caught exception in status-updater\", e);\n            break;\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "68328ae92632afc9cdd6e75b7a8d832723ddbe3b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3187. Add names for various unnamed threads in MR2. (Todd Lipcon and Siddharth Seth via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1184904 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/10/11 12:27 PM",
      "commitName": "68328ae92632afc9cdd6e75b7a8d832723ddbe3b",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "05/10/11 4:43 AM",
      "commitNameOld": "66137cf17cb4abccd6065819d97edc63c6510477",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.32,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   protected void startStatusUpdater() {\n \n-    new Thread() {\n+    new Thread(\"Node Status Updater\") {\n       @Override\n       public void run() {\n         int lastHeartBeatID \u003d 0;\n         while (!isStopped) {\n           // Send heartbeat\n           try {\n             synchronized (heartbeatMonitor) {\n               heartbeatMonitor.wait(heartBeatInterval);\n             }\n             NodeStatus nodeStatus \u003d getNodeStatus();\n             nodeStatus.setResponseId(lastHeartBeatID);\n             \n             NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n             request.setNodeStatus(nodeStatus);            \n             HeartbeatResponse response \u003d\n               resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n             lastHeartBeatID \u003d response.getResponseId();\n             List\u003cContainerId\u003e containersToCleanup \u003d response\n                 .getContainersToCleanupList();\n             if (containersToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedContainersEvent(containersToCleanup));\n             }\n             List\u003cApplicationId\u003e appsToCleanup \u003d\n                 response.getApplicationsToCleanupList();\n             if (appsToCleanup.size() !\u003d 0) {\n               dispatcher.getEventHandler().handle(\n                   new CMgrCompletedAppsEvent(appsToCleanup));\n             }\n           } catch (Throwable e) {\n             LOG.error(\"Caught exception in status-updater\", e);\n             break;\n           }\n         }\n       }\n     }.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread(\"Node Status Updater\") {\n      @Override\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Caught exception in status-updater\", e);\n            break;\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread() {\n      @Override\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Caught exception in status-updater\", e);\n            break;\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,40 @@\n+  protected void startStatusUpdater() {\n+\n+    new Thread() {\n+      @Override\n+      public void run() {\n+        int lastHeartBeatID \u003d 0;\n+        while (!isStopped) {\n+          // Send heartbeat\n+          try {\n+            synchronized (heartbeatMonitor) {\n+              heartbeatMonitor.wait(heartBeatInterval);\n+            }\n+            NodeStatus nodeStatus \u003d getNodeStatus();\n+            nodeStatus.setResponseId(lastHeartBeatID);\n+            \n+            NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n+            request.setNodeStatus(nodeStatus);            \n+            HeartbeatResponse response \u003d\n+              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n+            lastHeartBeatID \u003d response.getResponseId();\n+            List\u003cContainerId\u003e containersToCleanup \u003d response\n+                .getContainersToCleanupList();\n+            if (containersToCleanup.size() !\u003d 0) {\n+              dispatcher.getEventHandler().handle(\n+                  new CMgrCompletedContainersEvent(containersToCleanup));\n+            }\n+            List\u003cApplicationId\u003e appsToCleanup \u003d\n+                response.getApplicationsToCleanupList();\n+            if (appsToCleanup.size() !\u003d 0) {\n+              dispatcher.getEventHandler().handle(\n+                  new CMgrCompletedAppsEvent(appsToCleanup));\n+            }\n+          } catch (Throwable e) {\n+            LOG.error(\"Caught exception in status-updater\", e);\n+            break;\n+          }\n+        }\n+      }\n+    }.start();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startStatusUpdater() {\n\n    new Thread() {\n      @Override\n      public void run() {\n        int lastHeartBeatID \u003d 0;\n        while (!isStopped) {\n          // Send heartbeat\n          try {\n            synchronized (heartbeatMonitor) {\n              heartbeatMonitor.wait(heartBeatInterval);\n            }\n            NodeStatus nodeStatus \u003d getNodeStatus();\n            nodeStatus.setResponseId(lastHeartBeatID);\n            \n            NodeHeartbeatRequest request \u003d recordFactory.newRecordInstance(NodeHeartbeatRequest.class);\n            request.setNodeStatus(nodeStatus);            \n            HeartbeatResponse response \u003d\n              resourceTracker.nodeHeartbeat(request).getHeartbeatResponse();\n            lastHeartBeatID \u003d response.getResponseId();\n            List\u003cContainerId\u003e containersToCleanup \u003d response\n                .getContainersToCleanupList();\n            if (containersToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedContainersEvent(containersToCleanup));\n            }\n            List\u003cApplicationId\u003e appsToCleanup \u003d\n                response.getApplicationsToCleanupList();\n            if (appsToCleanup.size() !\u003d 0) {\n              dispatcher.getEventHandler().handle(\n                  new CMgrCompletedAppsEvent(appsToCleanup));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Caught exception in status-updater\", e);\n            break;\n          }\n        }\n      }\n    }.start();\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java"
    }
  }
}