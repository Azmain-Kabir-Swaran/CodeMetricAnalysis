{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NMWebServices.java",
  "functionName": "getLogs",
  "functionId": "getLogs___containerIdStr-String(annotations-@PathParam(YarnWebServiceParams.CONTAINER_ID)__modifiers-final)__filename-String(annotations-@PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME))__format-String(annotations-@QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT))__size-String(annotations-@QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE))",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
  "functionStartLine": 410,
  "functionEndLine": 535,
  "numCommitsSeen": 50,
  "timeTaken": 8927,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "91cc070d67533ebb3325b982eba2135e0d175a82",
    "ad45d19998c1b0da25754d0016854046731fa623",
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e",
    "464ff479ceec76609dca3539081de6b503b17325",
    "9dbfab1284015af6983b4a55b79c9e65bc0194e5",
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
    "5877f20f9c3f6f0afa505715e9a2ee312475af17",
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "9378d9428f127eff7acd6c13544016cdbf2d65fb",
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
    "9a31e5dfef42929951d305f31200ca4f80d86632",
    "e61d431275d7fe5641fe9da4903e285b10330fa0",
    "a759abcd898224c3481c55aa7e424bc286f60b15"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Ybodychange",
    "ad45d19998c1b0da25754d0016854046731fa623": "Ybodychange",
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e": "Ybodychange",
    "464ff479ceec76609dca3539081de6b503b17325": "Ybodychange",
    "9dbfab1284015af6983b4a55b79c9e65bc0194e5": "Yparametermetachange",
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c": "Ymultichange(Ybodychange,Yparametermetachange)",
    "5877f20f9c3f6f0afa505715e9a2ee312475af17": "Ybodychange",
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "9378d9428f127eff7acd6c13544016cdbf2d65fb": "Ymultichange(Yparameterchange,Ybodychange)",
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630": "Ybodychange",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": "Ymultichange(Yparameterchange,Ybodychange)",
    "9a31e5dfef42929951d305f31200ca4f80d86632": "Ybodychange",
    "e61d431275d7fe5641fe9da4903e285b10330fa0": "Ymultichange(Yparameterchange,Ybodychange)",
    "a759abcd898224c3481c55aa7e424bc286f60b15": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "25/01/19 4:05 PM",
      "commitNameOld": "1ab69a9543df555b878951e66e3da13485e7f6d5",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 48.97,
      "commitsBetweenForRepo": 401,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,126 @@\n   public Response getLogs(\n       @PathParam(YarnWebServiceParams.CONTAINER_ID)\n       final String containerIdStr,\n       @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n       String filename,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n       String format,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n       String size) {\n     ContainerId tempContainerId;\n     try {\n       tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     final ContainerId containerId \u003d tempContainerId;\n     boolean tempIsRunning \u003d false;\n     // check what is the status for container\n     try {\n       Container container \u003d nmContext.getContainers().get(containerId);\n       tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n     } catch (Exception ex) {\n       // This NM does not have this container any more. We\n       // assume the container has already finished.\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Can not find the container:\" + containerId\n-            + \" in this node.\");\n-      }\n+      LOG.debug(\"Can not find the container:{} in this node.\",\n+          containerId);\n     }\n     final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n         return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n             .build();\n       }\n       // redirect the request to the configured log server\n       String redirectURI \u003d \"/containers/\" + containerIdStr\n           + \"/logs/\" + filename;\n       return createRedirectResponse(request, redirectWSUrl, redirectURI);\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n     final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             LogToolUtils.outputContainerLogThroughZeroCopy(\n                 containerId.toString(), nmContext.getNodeId().toString(),\n                 outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                 ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n               ContainerLogsRequest logRequest \u003d new ContainerLogsRequest();\n               logRequest.setAppId(appId);\n               logRequest.setAppOwner(appOwner);\n               logRequest.setContainerId(containerId.toString());\n               logRequest.setNodeId(nmContext.getNodeId().toString());\n               logRequest.setBytes(bytes);\n               Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n               logTypes.add(outputFileName);\n               logRequest.setLogTypes(logTypes);\n               factory.getFileControllerForRead(appId, appOwner)\n                   .readAggregatedLogs(logRequest, os);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(\n      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n      final String containerIdStr,\n      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n      String filename,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n      String format,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n      String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      LOG.debug(\"Can not find the container:{} in this node.\",\n          containerId);\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n        return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n            .build();\n      }\n      // redirect the request to the configured log server\n      String redirectURI \u003d \"/containers/\" + containerIdStr\n          + \"/logs/\" + filename;\n      return createRedirectResponse(request, redirectWSUrl, redirectURI);\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            LogToolUtils.outputContainerLogThroughZeroCopy(\n                containerId.toString(), nmContext.getNodeId().toString(),\n                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              ContainerLogsRequest logRequest \u003d new ContainerLogsRequest();\n              logRequest.setAppId(appId);\n              logRequest.setAppOwner(appOwner);\n              logRequest.setContainerId(containerId.toString());\n              logRequest.setNodeId(nmContext.getNodeId().toString());\n              logRequest.setBytes(bytes);\n              Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n              logTypes.add(outputFileName);\n              logRequest.setLogTypes(logTypes);\n              factory.getFileControllerForRead(appId, appOwner)\n                  .readAggregatedLogs(logRequest, os);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "commitDateOld": "29/08/17 3:16 PM",
      "commitNameOld": "ad45d19998c1b0da25754d0016854046731fa623",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.06,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,128 @@\n   public Response getLogs(\n       @PathParam(YarnWebServiceParams.CONTAINER_ID)\n       final String containerIdStr,\n       @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n       String filename,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n       String format,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n       String size) {\n     ContainerId tempContainerId;\n     try {\n       tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     final ContainerId containerId \u003d tempContainerId;\n     boolean tempIsRunning \u003d false;\n     // check what is the status for container\n     try {\n       Container container \u003d nmContext.getContainers().get(containerId);\n       tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n     } catch (Exception ex) {\n       // This NM does not have this container any more. We\n       // assume the container has already finished.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Can not find the container:\" + containerId\n             + \" in this node.\");\n       }\n     }\n     final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n         return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n             .build();\n       }\n       // redirect the request to the configured log server\n       String redirectURI \u003d \"/containers/\" + containerIdStr\n           + \"/logs/\" + filename;\n       return createRedirectResponse(request, redirectWSUrl, redirectURI);\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n     final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             LogToolUtils.outputContainerLogThroughZeroCopy(\n                 containerId.toString(), nmContext.getNodeId().toString(),\n                 outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                 ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n-              int bufferSize \u003d 65536;\n-              byte[] buf \u003d new byte[bufferSize];\n-              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n-                  appId, appOwner, containerId.toString(),\n-                  nmContext.getNodeId().toString(), outputFileName, bytes,\n-                  os, buf);\n+              ContainerLogsRequest logRequest \u003d new ContainerLogsRequest();\n+              logRequest.setAppId(appId);\n+              logRequest.setAppOwner(appOwner);\n+              logRequest.setContainerId(containerId.toString());\n+              logRequest.setNodeId(nmContext.getNodeId().toString());\n+              logRequest.setBytes(bytes);\n+              Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n+              logTypes.add(outputFileName);\n+              logRequest.setLogTypes(logTypes);\n+              factory.getFileControllerForRead(appId, appOwner)\n+                  .readAggregatedLogs(logRequest, os);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(\n      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n      final String containerIdStr,\n      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n      String filename,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n      String format,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n      String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n        return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n            .build();\n      }\n      // redirect the request to the configured log server\n      String redirectURI \u003d \"/containers/\" + containerIdStr\n          + \"/logs/\" + filename;\n      return createRedirectResponse(request, redirectWSUrl, redirectURI);\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            LogToolUtils.outputContainerLogThroughZeroCopy(\n                containerId.toString(), nmContext.getNodeId().toString(),\n                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              ContainerLogsRequest logRequest \u003d new ContainerLogsRequest();\n              logRequest.setAppId(appId);\n              logRequest.setAppOwner(appOwner);\n              logRequest.setContainerId(containerId.toString());\n              logRequest.setNodeId(nmContext.getNodeId().toString());\n              logRequest.setBytes(bytes);\n              Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n              logTypes.add(outputFileName);\n              logRequest.setLogTypes(logTypes);\n              factory.getFileControllerForRead(appId, appOwner)\n                  .readAggregatedLogs(logRequest, os);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "ad45d19998c1b0da25754d0016854046731fa623": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7037. Optimize data transfer with zero-copy approach for containerlogs REST API in NMWebServices. Contributed by Tao Yang.\n",
      "commitDate": "29/08/17 3:16 PM",
      "commitName": "ad45d19998c1b0da25754d0016854046731fa623",
      "commitAuthor": "Junping Du",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 7.58,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,123 @@\n   public Response getLogs(\n       @PathParam(YarnWebServiceParams.CONTAINER_ID)\n       final String containerIdStr,\n       @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n       String filename,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n       String format,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n       String size) {\n     ContainerId tempContainerId;\n     try {\n       tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     final ContainerId containerId \u003d tempContainerId;\n     boolean tempIsRunning \u003d false;\n     // check what is the status for container\n     try {\n       Container container \u003d nmContext.getContainers().get(containerId);\n       tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n     } catch (Exception ex) {\n       // This NM does not have this container any more. We\n       // assume the container has already finished.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Can not find the container:\" + containerId\n             + \" in this node.\");\n       }\n     }\n     final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n         return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n             .build();\n       }\n       // redirect the request to the configured log server\n       String redirectURI \u003d \"/containers/\" + containerIdStr\n           + \"/logs/\" + filename;\n       return createRedirectResponse(request, redirectWSUrl, redirectURI);\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n     final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n-            int bufferSize \u003d 65536;\n-            byte[] buf \u003d new byte[bufferSize];\n-            LogToolUtils.outputContainerLog(containerId.toString(),\n-                nmContext.getNodeId().toString(), outputFileName, fileLength,\n-                bytes, lastModifiedTime, fis, os, buf,\n+            LogToolUtils.outputContainerLogThroughZeroCopy(\n+                containerId.toString(), nmContext.getNodeId().toString(),\n+                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                 ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n+              int bufferSize \u003d 65536;\n+              byte[] buf \u003d new byte[bufferSize];\n               LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                   appId, appOwner, containerId.toString(),\n                   nmContext.getNodeId().toString(), outputFileName, bytes,\n                   os, buf);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(\n      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n      final String containerIdStr,\n      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n      String filename,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n      String format,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n      String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n        return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n            .build();\n      }\n      // redirect the request to the configured log server\n      String redirectURI \u003d \"/containers/\" + containerIdStr\n          + \"/logs/\" + filename;\n      return createRedirectResponse(request, redirectWSUrl, redirectURI);\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            LogToolUtils.outputContainerLogThroughZeroCopy(\n                containerId.toString(), nmContext.getNodeId().toString(),\n                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              int bufferSize \u003d 65536;\n              byte[] buf \u003d new byte[bufferSize];\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6174. Log files pattern should be same for both running and finished container. Contributed by Xuan Gong.\n",
      "commitDate": "15/02/17 9:05 AM",
      "commitName": "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/02/17 6:12 AM",
      "commitNameOld": "464ff479ceec76609dca3539081de6b503b17325",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,123 @@\n   public Response getLogs(\n       @PathParam(YarnWebServiceParams.CONTAINER_ID)\n       final String containerIdStr,\n       @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n       String filename,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n       String format,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n       String size) {\n     ContainerId tempContainerId;\n     try {\n       tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     final ContainerId containerId \u003d tempContainerId;\n     boolean tempIsRunning \u003d false;\n     // check what is the status for container\n     try {\n       Container container \u003d nmContext.getContainers().get(containerId);\n       tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n     } catch (Exception ex) {\n       // This NM does not have this container any more. We\n       // assume the container has already finished.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Can not find the container:\" + containerId\n             + \" in this node.\");\n       }\n     }\n     final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n         return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n             .build();\n       }\n       // redirect the request to the configured log server\n       String redirectURI \u003d \"/containers/\" + containerIdStr\n           + \"/logs/\" + filename;\n       return createRedirectResponse(request, redirectWSUrl, redirectURI);\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n     final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             LogToolUtils.outputContainerLog(containerId.toString(),\n                 nmContext.getNodeId().toString(), outputFileName, fileLength,\n-                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n+                bytes, lastModifiedTime, fis, os, buf,\n+                ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n-            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n+            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n               LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                   appId, appOwner, containerId.toString(),\n                   nmContext.getNodeId().toString(), outputFileName, bytes,\n                   os, buf);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(\n      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n      final String containerIdStr,\n      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n      String filename,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n      String format,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n      String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n        return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n            .build();\n      }\n      // redirect the request to the configured log server\n      String redirectURI \u003d \"/containers/\" + containerIdStr\n          + \"/logs/\" + filename;\n      return createRedirectResponse(request, redirectWSUrl, redirectURI);\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "464ff479ceec76609dca3539081de6b503b17325": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6113. Re-direct NM Web Service to get container logs for finished applications. Contributed by Xuan Gong.\n",
      "commitDate": "13/02/17 6:12 AM",
      "commitName": "464ff479ceec76609dca3539081de6b503b17325",
      "commitAuthor": "Junping Du",
      "commitDateOld": "07/02/17 2:13 AM",
      "commitNameOld": "9dbfab1284015af6983b4a55b79c9e65bc0194e5",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 6.17,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,122 @@\n   public Response getLogs(\n       @PathParam(YarnWebServiceParams.CONTAINER_ID)\n       final String containerIdStr,\n       @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n       String filename,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n       String format,\n       @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n       String size) {\n     ContainerId tempContainerId;\n     try {\n       tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     final ContainerId containerId \u003d tempContainerId;\n     boolean tempIsRunning \u003d false;\n     // check what is the status for container\n     try {\n       Container container \u003d nmContext.getContainers().get(containerId);\n       tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n     } catch (Exception ex) {\n       // This NM does not have this container any more. We\n       // assume the container has already finished.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Can not find the container:\" + containerId\n             + \" in this node.\");\n       }\n     }\n     final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n-      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n+      if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n+        return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n+            .build();\n+      }\n+      // redirect the request to the configured log server\n+      String redirectURI \u003d \"/containers/\" + containerIdStr\n+          + \"/logs/\" + filename;\n+      return createRedirectResponse(request, redirectWSUrl, redirectURI);\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n     final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             LogToolUtils.outputContainerLog(containerId.toString(),\n                 nmContext.getNodeId().toString(), outputFileName, fileLength,\n                 bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n               LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                   appId, appOwner, containerId.toString(),\n                   nmContext.getNodeId().toString(), outputFileName, bytes,\n                   os, buf);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(\n      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n      final String containerIdStr,\n      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n      String filename,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n      String format,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n      String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      if (redirectWSUrl \u003d\u003d null || redirectWSUrl.isEmpty()) {\n        return Response.status(Status.NOT_FOUND).entity(ex.getMessage())\n            .build();\n      }\n      // redirect the request to the configured log server\n      String redirectURI \u003d \"/containers/\" + containerIdStr\n          + \"/logs/\" + filename;\n      return createRedirectResponse(request, redirectWSUrl, redirectURI);\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "9dbfab1284015af6983b4a55b79c9e65bc0194e5": {
      "type": "Yparametermetachange",
      "commitMessage": "YARN-6108. Improve AHS webservice to accept NM address as a parameter to get container logs. Contributed by Xuan Gong.\n",
      "commitDate": "07/02/17 2:13 AM",
      "commitName": "9dbfab1284015af6983b4a55b79c9e65bc0194e5",
      "commitAuthor": "Junping Du",
      "commitDateOld": "02/02/17 12:41 AM",
      "commitNameOld": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,115 @@\n   public Response getLogs(\n-      @PathParam(\"containerid\") final String containerIdStr,\n-      @PathParam(\"filename\") String filename,\n-      @QueryParam(\"format\") String format,\n-      @QueryParam(\"size\") String size) {\n+      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n+      final String containerIdStr,\n+      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n+      String filename,\n+      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n+      String format,\n+      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n+      String size) {\n     ContainerId tempContainerId;\n     try {\n       tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     final ContainerId containerId \u003d tempContainerId;\n     boolean tempIsRunning \u003d false;\n     // check what is the status for container\n     try {\n       Container container \u003d nmContext.getContainers().get(containerId);\n       tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n     } catch (Exception ex) {\n       // This NM does not have this container any more. We\n       // assume the container has already finished.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Can not find the container:\" + containerId\n             + \" in this node.\");\n       }\n     }\n     final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n     final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             LogToolUtils.outputContainerLog(containerId.toString(),\n                 nmContext.getNodeId().toString(), outputFileName, fileLength,\n                 bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n               LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                   appId, appOwner, containerId.toString(),\n                   nmContext.getNodeId().toString(), outputFileName, bytes,\n                   os, buf);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(\n      @PathParam(YarnWebServiceParams.CONTAINER_ID)\n      final String containerIdStr,\n      @PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)\n      String filename,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)\n      String format,\n      @QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE)\n      String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {
        "oldValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")__modifiers-final), filename-String(annotations-@PathParam(\"filename\")), format-String(annotations-@QueryParam(\"format\")), size-String(annotations-@QueryParam(\"size\"))]",
        "newValue": "[containerIdStr-String(annotations-@PathParam(YarnWebServiceParams.CONTAINER_ID)__modifiers-final), filename-String(annotations-@PathParam(YarnWebServiceParams.CONTAINER_LOG_FILE_NAME)), format-String(annotations-@QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_FORMAT)), size-String(annotations-@QueryParam(YarnWebServiceParams.RESPONSE_CONTENT_SIZE))]"
      }
    },
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "YARN-6100. Improve YARN webservice to output aggregated container logs. Contributed by Xuan Gong.\n",
      "commitDate": "02/02/17 12:41 AM",
      "commitName": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6100. Improve YARN webservice to output aggregated container logs. Contributed by Xuan Gong.\n",
          "commitDate": "02/02/17 12:41 AM",
          "commitName": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
          "commitAuthor": "Junping Du",
          "commitDateOld": "24/01/17 3:26 PM",
          "commitNameOld": "8528d85a68c0e6ea71026df4d3026e7edc206b2d",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 8.39,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,111 @@\n-  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n+  public Response getLogs(\n+      @PathParam(\"containerid\") final String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n-    ContainerId containerId;\n+    ContainerId tempContainerId;\n     try {\n-      containerId \u003d ContainerId.fromString(containerIdStr);\n+      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n-    \n+    final ContainerId containerId \u003d tempContainerId;\n+    boolean tempIsRunning \u003d false;\n+    // check what is the status for container\n+    try {\n+      Container container \u003d nmContext.getContainers().get(containerId);\n+      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n+    } catch (Exception ex) {\n+      // This NM does not have this container any more. We\n+      // assume the container has already finished.\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Can not find the container:\" + containerId\n+            + \" in this node.\");\n+      }\n+    }\n+    final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n+    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n+    final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n-            long toSkip \u003d 0;\n-            long totalBytesToRead \u003d fileLength;\n-            long skipAfterRead \u003d 0;\n-            if (bytes \u003c 0) {\n-              long absBytes \u003d Math.abs(bytes);\n-              if (absBytes \u003c fileLength) {\n-                toSkip \u003d fileLength - absBytes;\n-                totalBytesToRead \u003d absBytes;\n-              }\n-              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n+            LogToolUtils.outputContainerLog(containerId.toString(),\n+                nmContext.getNodeId().toString(), outputFileName, fileLength,\n+                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n+            StringBuilder sb \u003d new StringBuilder();\n+            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n+            sb.append(endOfFile + \".\");\n+            if (isRunning) {\n+              sb.append(\"This log file belongs to a running container (\"\n+                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n-              if (bytes \u003c fileLength) {\n-                totalBytesToRead \u003d bytes;\n-                skipAfterRead \u003d fileLength - bytes;\n+              sb.append(\"\\n\");\n+            }\n+            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n+                + \"\\n\\n\");\n+            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n+            // If we have aggregated logs for this container,\n+            // output the aggregation logs as well.\n+            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n+                .getApplicationId();\n+            Application app \u003d nmContext.getApplications().get(appId);\n+            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n+            try {\n+              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n+                  appId, appOwner, containerId.toString(),\n+                  nmContext.getNodeId().toString(), outputFileName, bytes,\n+                  os, buf);\n+            } catch (Exception ex) {\n+              // Something wrong when we try to access the aggregated log.\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Can not access the aggregated log for \"\n+                    + \"the container:\" + containerId);\n+                LOG.debug(ex.getMessage());\n               }\n             }\n-\n-            long curRead \u003d 0;\n-            long pendingRead \u003d totalBytesToRead - curRead;\n-            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                : (int) pendingRead;\n-            int len \u003d fis.read(buf, 0, toRead);\n-            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-              os.write(buf, 0, len);\n-              curRead +\u003d len;\n-\n-              pendingRead \u003d totalBytesToRead - curRead;\n-              toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                  : (int) pendingRead;\n-              len \u003d fis.read(buf, 0, toRead);\n-            }\n-            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n-            os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(\n      @PathParam(\"containerid\") final String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "YARN-6100. Improve YARN webservice to output aggregated container logs. Contributed by Xuan Gong.\n",
          "commitDate": "02/02/17 12:41 AM",
          "commitName": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
          "commitAuthor": "Junping Du",
          "commitDateOld": "24/01/17 3:26 PM",
          "commitNameOld": "8528d85a68c0e6ea71026df4d3026e7edc206b2d",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 8.39,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,111 @@\n-  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n+  public Response getLogs(\n+      @PathParam(\"containerid\") final String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n-    ContainerId containerId;\n+    ContainerId tempContainerId;\n     try {\n-      containerId \u003d ContainerId.fromString(containerIdStr);\n+      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n-    \n+    final ContainerId containerId \u003d tempContainerId;\n+    boolean tempIsRunning \u003d false;\n+    // check what is the status for container\n+    try {\n+      Container container \u003d nmContext.getContainers().get(containerId);\n+      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n+    } catch (Exception ex) {\n+      // This NM does not have this container any more. We\n+      // assume the container has already finished.\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Can not find the container:\" + containerId\n+            + \" in this node.\");\n+      }\n+    }\n+    final boolean isRunning \u003d tempIsRunning;\n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n+    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n+    final String outputFileName \u003d filename;\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n-            long toSkip \u003d 0;\n-            long totalBytesToRead \u003d fileLength;\n-            long skipAfterRead \u003d 0;\n-            if (bytes \u003c 0) {\n-              long absBytes \u003d Math.abs(bytes);\n-              if (absBytes \u003c fileLength) {\n-                toSkip \u003d fileLength - absBytes;\n-                totalBytesToRead \u003d absBytes;\n-              }\n-              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n+            LogToolUtils.outputContainerLog(containerId.toString(),\n+                nmContext.getNodeId().toString(), outputFileName, fileLength,\n+                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n+            StringBuilder sb \u003d new StringBuilder();\n+            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n+            sb.append(endOfFile + \".\");\n+            if (isRunning) {\n+              sb.append(\"This log file belongs to a running container (\"\n+                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n-              if (bytes \u003c fileLength) {\n-                totalBytesToRead \u003d bytes;\n-                skipAfterRead \u003d fileLength - bytes;\n+              sb.append(\"\\n\");\n+            }\n+            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n+                + \"\\n\\n\");\n+            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n+            // If we have aggregated logs for this container,\n+            // output the aggregation logs as well.\n+            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n+                .getApplicationId();\n+            Application app \u003d nmContext.getApplications().get(appId);\n+            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n+            try {\n+              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n+                  appId, appOwner, containerId.toString(),\n+                  nmContext.getNodeId().toString(), outputFileName, bytes,\n+                  os, buf);\n+            } catch (Exception ex) {\n+              // Something wrong when we try to access the aggregated log.\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Can not access the aggregated log for \"\n+                    + \"the container:\" + containerId);\n+                LOG.debug(ex.getMessage());\n               }\n             }\n-\n-            long curRead \u003d 0;\n-            long pendingRead \u003d totalBytesToRead - curRead;\n-            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                : (int) pendingRead;\n-            int len \u003d fis.read(buf, 0, toRead);\n-            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-              os.write(buf, 0, len);\n-              curRead +\u003d len;\n-\n-              pendingRead \u003d totalBytesToRead - curRead;\n-              toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                  : (int) pendingRead;\n-              len \u003d fis.read(buf, 0, toRead);\n-            }\n-            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n-            os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(\n      @PathParam(\"containerid\") final String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId tempContainerId;\n    try {\n      tempContainerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    final ContainerId containerId \u003d tempContainerId;\n    boolean tempIsRunning \u003d false;\n    // check what is the status for container\n    try {\n      Container container \u003d nmContext.getContainers().get(containerId);\n      tempIsRunning \u003d (container.getContainerState() \u003d\u003d ContainerState.RUNNING);\n    } catch (Exception ex) {\n      // This NM does not have this container any more. We\n      // assume the container has already finished.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Can not find the container:\" + containerId\n            + \" in this node.\");\n      }\n    }\n    final boolean isRunning \u003d tempIsRunning;\n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    final String lastModifiedTime \u003d Times.format(logFile.lastModified());\n    final String outputFileName \u003d filename;\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {
            "oldValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\")), format-String(annotations-@QueryParam(\"format\")), size-String(annotations-@QueryParam(\"size\"))]",
            "newValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")__modifiers-final), filename-String(annotations-@PathParam(\"filename\")), format-String(annotations-@QueryParam(\"format\")), size-String(annotations-@QueryParam(\"size\"))]"
          }
        }
      ]
    },
    "5877f20f9c3f6f0afa505715e9a2ee312475af17": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10075. Update jetty dependency to version 9 (rkanter)\n",
      "commitDate": "27/10/16 4:09 PM",
      "commitName": "5877f20f9c3f6f0afa505715e9a2ee312475af17",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "06/07/16 2:10 PM",
      "commitNameOld": "4c9e1aeb94247a6e97215e902bdc71a325244243",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 113.08,
      "commitsBetweenForRepo": 917,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,93 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             long toSkip \u003d 0;\n             long totalBytesToRead \u003d fileLength;\n             long skipAfterRead \u003d 0;\n             if (bytes \u003c 0) {\n               long absBytes \u003d Math.abs(bytes);\n               if (absBytes \u003c fileLength) {\n                 toSkip \u003d fileLength - absBytes;\n                 totalBytesToRead \u003d absBytes;\n               }\n               org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n             } else {\n               if (bytes \u003c fileLength) {\n                 totalBytesToRead \u003d bytes;\n                 skipAfterRead \u003d fileLength - bytes;\n               }\n             }\n \n             long curRead \u003d 0;\n             long pendingRead \u003d totalBytesToRead - curRead;\n             int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n             int len \u003d fis.read(buf, 0, toRead);\n             while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n               os.write(buf, 0, len);\n               curRead +\u003d len;\n \n               pendingRead \u003d totalBytesToRead - curRead;\n               toRead \u003d pendingRead \u003e buf.length ? buf.length\n                   : (int) pendingRead;\n               len \u003d fis.read(buf, 0, toRead);\n             }\n             org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n             os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n-      resp.header(\"Content-Type\", contentType);\n+      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            long skipAfterRead \u003d 0;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n                skipAfterRead \u003d fileLength - bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType + \"; \" + JettyUtils.UTF_8);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5251. Yarn CLI to obtain App logs for last \u0027n\u0027 bytes fails. Contributed by Xuan Gong.\n",
      "commitDate": "17/06/16 8:24 AM",
      "commitName": "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.72,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,93 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             long toSkip \u003d 0;\n             long totalBytesToRead \u003d fileLength;\n+            long skipAfterRead \u003d 0;\n             if (bytes \u003c 0) {\n               long absBytes \u003d Math.abs(bytes);\n               if (absBytes \u003c fileLength) {\n                 toSkip \u003d fileLength - absBytes;\n                 totalBytesToRead \u003d absBytes;\n               }\n-              long skippedBytes \u003d fis.skip(toSkip);\n-              if (skippedBytes !\u003d toSkip) {\n-                throw new IOException(\"The bytes were skipped are different \"\n-                    + \"from the caller requested\");\n-              }\n+              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n             } else {\n               if (bytes \u003c fileLength) {\n                 totalBytesToRead \u003d bytes;\n+                skipAfterRead \u003d fileLength - bytes;\n               }\n             }\n \n             long curRead \u003d 0;\n             long pendingRead \u003d totalBytesToRead - curRead;\n             int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n             int len \u003d fis.read(buf, 0, toRead);\n             while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n               os.write(buf, 0, len);\n               curRead +\u003d len;\n \n               pendingRead \u003d totalBytesToRead - curRead;\n               toRead \u003d pendingRead \u003e buf.length ? buf.length\n                   : (int) pendingRead;\n               len \u003d fis.read(buf, 0, toRead);\n             }\n+            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n             os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            long skipAfterRead \u003d 0;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n                skipAfterRead \u003d fileLength - bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/06/16 12:30 PM",
      "commitNameOld": "9378d9428f127eff7acd6c13544016cdbf2d65fb",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.11,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n-      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n+      containerId \u003d ContainerId.fromString(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     final long bytes \u003d parseLongParam(size);\n     String contentType \u003d WebAppUtils.getDefaultLogContentType();\n     if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n       contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n       if (contentType \u003d\u003d null) {\n         String errorMessage \u003d \"The valid values for the parameter : format \"\n             + \"are \" + WebAppUtils.listSupportedLogContentType();\n         return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n             .build();\n       }\n     }\n \n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             long toSkip \u003d 0;\n             long totalBytesToRead \u003d fileLength;\n             if (bytes \u003c 0) {\n               long absBytes \u003d Math.abs(bytes);\n               if (absBytes \u003c fileLength) {\n                 toSkip \u003d fileLength - absBytes;\n                 totalBytesToRead \u003d absBytes;\n               }\n               long skippedBytes \u003d fis.skip(toSkip);\n               if (skippedBytes !\u003d toSkip) {\n                 throw new IOException(\"The bytes were skipped are different \"\n                     + \"from the caller requested\");\n               }\n             } else {\n               if (bytes \u003c fileLength) {\n                 totalBytesToRead \u003d bytes;\n               }\n             }\n \n             long curRead \u003d 0;\n             long pendingRead \u003d totalBytesToRead - curRead;\n             int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n             int len \u003d fis.read(buf, 0, toRead);\n             while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n               os.write(buf, 0, len);\n               curRead +\u003d len;\n \n               pendingRead \u003d totalBytesToRead - curRead;\n               toRead \u003d pendingRead \u003e buf.length ? buf.length\n                   : (int) pendingRead;\n               len \u003d fis.read(buf, 0, toRead);\n             }\n             os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       resp.header(\"Content-Type\", contentType);\n       // Sending the X-Content-Type-Options response header with the value\n       // nosniff will prevent Internet Explorer from MIME-sniffing a response\n       // away from the declared content-type.\n       resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ContainerId.fromString(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              long skippedBytes \u003d fis.skip(toSkip);\n              if (skippedBytes !\u003d toSkip) {\n                throw new IOException(\"The bytes were skipped are different \"\n                    + \"from the caller requested\");\n              }\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "9378d9428f127eff7acd6c13544016cdbf2d65fb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5191. Renamed the newly added download\u003dtrue option for getting logs via NMWebServices and AHSWebServices to be a better \"format\" option. (Xuan Gong via vinodkv)\n",
      "commitDate": "09/06/16 12:30 PM",
      "commitName": "9378d9428f127eff7acd6c13544016cdbf2d65fb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5191. Renamed the newly added download\u003dtrue option for getting logs via NMWebServices and AHSWebServices to be a better \"format\" option. (Xuan Gong via vinodkv)\n",
          "commitDate": "09/06/16 12:30 PM",
          "commitName": "9378d9428f127eff7acd6c13544016cdbf2d65fb",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/06/16 4:07 PM",
          "commitNameOld": "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 1.85,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,94 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n-      @QueryParam(\"download\") String download,\n+      @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n-    boolean downloadFile \u003d parseBooleanParam(download);\n     final long bytes \u003d parseLongParam(size);\n+    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n+    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n+      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n+      if (contentType \u003d\u003d null) {\n+        String errorMessage \u003d \"The valid values for the parameter : format \"\n+            + \"are \" + WebAppUtils.listSupportedLogContentType();\n+        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n+            .build();\n+      }\n+    }\n+\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             long toSkip \u003d 0;\n             long totalBytesToRead \u003d fileLength;\n             if (bytes \u003c 0) {\n               long absBytes \u003d Math.abs(bytes);\n               if (absBytes \u003c fileLength) {\n                 toSkip \u003d fileLength - absBytes;\n                 totalBytesToRead \u003d absBytes;\n               }\n               long skippedBytes \u003d fis.skip(toSkip);\n               if (skippedBytes !\u003d toSkip) {\n                 throw new IOException(\"The bytes were skipped are different \"\n                     + \"from the caller requested\");\n               }\n             } else {\n               if (bytes \u003c fileLength) {\n                 totalBytesToRead \u003d bytes;\n               }\n             }\n \n             long curRead \u003d 0;\n             long pendingRead \u003d totalBytesToRead - curRead;\n             int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n             int len \u003d fis.read(buf, 0, toRead);\n             while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n               os.write(buf, 0, len);\n               curRead +\u003d len;\n \n               pendingRead \u003d totalBytesToRead - curRead;\n               toRead \u003d pendingRead \u003e buf.length ? buf.length\n                   : (int) pendingRead;\n               len \u003d fis.read(buf, 0, toRead);\n             }\n             os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n-      if (downloadFile) {\n-        resp.header(\"Content-Type\", \"application/octet-stream\");\n-      }\n+      resp.header(\"Content-Type\", contentType);\n+      // Sending the X-Content-Type-Options response header with the value\n+      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n+      // away from the declared content-type.\n+      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              long skippedBytes \u003d fis.skip(toSkip);\n              if (skippedBytes !\u003d toSkip) {\n                throw new IOException(\"The bytes were skipped are different \"\n                    + \"from the caller requested\");\n              }\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {
            "oldValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\")), download-String(annotations-@QueryParam(\"download\")), size-String(annotations-@QueryParam(\"size\"))]",
            "newValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\")), format-String(annotations-@QueryParam(\"format\")), size-String(annotations-@QueryParam(\"size\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5191. Renamed the newly added download\u003dtrue option for getting logs via NMWebServices and AHSWebServices to be a better \"format\" option. (Xuan Gong via vinodkv)\n",
          "commitDate": "09/06/16 12:30 PM",
          "commitName": "9378d9428f127eff7acd6c13544016cdbf2d65fb",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/06/16 4:07 PM",
          "commitNameOld": "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 1.85,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,94 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n-      @QueryParam(\"download\") String download,\n+      @QueryParam(\"format\") String format,\n       @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n-    boolean downloadFile \u003d parseBooleanParam(download);\n     final long bytes \u003d parseLongParam(size);\n+    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n+    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n+      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n+      if (contentType \u003d\u003d null) {\n+        String errorMessage \u003d \"The valid values for the parameter : format \"\n+            + \"are \" + WebAppUtils.listSupportedLogContentType();\n+        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n+            .build();\n+      }\n+    }\n+\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             long toSkip \u003d 0;\n             long totalBytesToRead \u003d fileLength;\n             if (bytes \u003c 0) {\n               long absBytes \u003d Math.abs(bytes);\n               if (absBytes \u003c fileLength) {\n                 toSkip \u003d fileLength - absBytes;\n                 totalBytesToRead \u003d absBytes;\n               }\n               long skippedBytes \u003d fis.skip(toSkip);\n               if (skippedBytes !\u003d toSkip) {\n                 throw new IOException(\"The bytes were skipped are different \"\n                     + \"from the caller requested\");\n               }\n             } else {\n               if (bytes \u003c fileLength) {\n                 totalBytesToRead \u003d bytes;\n               }\n             }\n \n             long curRead \u003d 0;\n             long pendingRead \u003d totalBytesToRead - curRead;\n             int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n             int len \u003d fis.read(buf, 0, toRead);\n             while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n               os.write(buf, 0, len);\n               curRead +\u003d len;\n \n               pendingRead \u003d totalBytesToRead - curRead;\n               toRead \u003d pendingRead \u003e buf.length ? buf.length\n                   : (int) pendingRead;\n               len \u003d fis.read(buf, 0, toRead);\n             }\n             os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n-      if (downloadFile) {\n-        resp.header(\"Content-Type\", \"application/octet-stream\");\n-      }\n+      resp.header(\"Content-Type\", contentType);\n+      // Sending the X-Content-Type-Options response header with the value\n+      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n+      // away from the declared content-type.\n+      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"format\") String format,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    final long bytes \u003d parseLongParam(size);\n    String contentType \u003d WebAppUtils.getDefaultLogContentType();\n    if (format !\u003d null \u0026\u0026 !format.isEmpty()) {\n      contentType \u003d WebAppUtils.getSupportedLogContentType(format);\n      if (contentType \u003d\u003d null) {\n        String errorMessage \u003d \"The valid values for the parameter : format \"\n            + \"are \" + WebAppUtils.listSupportedLogContentType();\n        return Response.status(Status.BAD_REQUEST).entity(errorMessage)\n            .build();\n      }\n    }\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              long skippedBytes \u003d fis.skip(toSkip);\n              if (skippedBytes !\u003d toSkip) {\n                throw new IOException(\"The bytes were skipped are different \"\n                    + \"from the caller requested\");\n              }\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      resp.header(\"Content-Type\", contentType);\n      // Sending the X-Content-Type-Options response header with the value\n      // nosniff will prevent Internet Explorer from MIME-sniffing a response\n      // away from the declared content-type.\n      resp.header(\"X-Content-Type-Options\", \"nosniff\");\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5199. Close LogReader in in AHSWebServices#getStreamingOutput and\nFileInputStream in NMWebServices#getLogs. Contributed by Xuan Gong\n",
      "commitDate": "07/06/16 4:07 PM",
      "commitName": "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
      "commitAuthor": "Xuan",
      "commitDateOld": "01/06/16 1:44 PM",
      "commitNameOld": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,82 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"download\") String download,\n       @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     boolean downloadFile \u003d parseBooleanParam(download);\n     final long bytes \u003d parseLongParam(size);\n-\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       final long fileLength \u003d logFile.length();\n \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n-          int bufferSize \u003d 65536;\n-          byte[] buf \u003d new byte[bufferSize];\n-          long toSkip \u003d 0;\n-          long totalBytesToRead \u003d fileLength;\n-          if (bytes \u003c 0) {\n-            long absBytes \u003d Math.abs(bytes);\n-            if (absBytes \u003c fileLength) {\n-              toSkip \u003d fileLength - absBytes;\n-              totalBytesToRead \u003d absBytes;\n+          try {\n+            int bufferSize \u003d 65536;\n+            byte[] buf \u003d new byte[bufferSize];\n+            long toSkip \u003d 0;\n+            long totalBytesToRead \u003d fileLength;\n+            if (bytes \u003c 0) {\n+              long absBytes \u003d Math.abs(bytes);\n+              if (absBytes \u003c fileLength) {\n+                toSkip \u003d fileLength - absBytes;\n+                totalBytesToRead \u003d absBytes;\n+              }\n+              long skippedBytes \u003d fis.skip(toSkip);\n+              if (skippedBytes !\u003d toSkip) {\n+                throw new IOException(\"The bytes were skipped are different \"\n+                    + \"from the caller requested\");\n+              }\n+            } else {\n+              if (bytes \u003c fileLength) {\n+                totalBytesToRead \u003d bytes;\n+              }\n             }\n-            long skippedBytes \u003d fis.skip(toSkip);\n-            if (skippedBytes !\u003d toSkip) {\n-              throw new IOException(\"The bytes were skipped are different \"\n-                  + \"from the caller requested\");\n-            }\n-          } else {\n-            if (bytes \u003c fileLength) {\n-              totalBytesToRead \u003d bytes;\n-            }\n-          }\n \n-          long curRead \u003d 0;\n-          long pendingRead \u003d totalBytesToRead - curRead;\n-          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-              : (int) pendingRead;\n-          int len \u003d fis.read(buf, 0, toRead);\n-          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-            os.write(buf, 0, len);\n-            curRead +\u003d len;\n-\n-            pendingRead \u003d totalBytesToRead - curRead;\n-            toRead \u003d pendingRead \u003e buf.length ? buf.length\n+            long curRead \u003d 0;\n+            long pendingRead \u003d totalBytesToRead - curRead;\n+            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n-            len \u003d fis.read(buf, 0, toRead);\n+            int len \u003d fis.read(buf, 0, toRead);\n+            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n+              os.write(buf, 0, len);\n+              curRead +\u003d len;\n+\n+              pendingRead \u003d totalBytesToRead - curRead;\n+              toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                  : (int) pendingRead;\n+              len \u003d fis.read(buf, 0, toRead);\n+            }\n+            os.flush();\n+          } finally {\n+            IOUtils.closeQuietly(fis);\n           }\n-          os.flush();\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       if (downloadFile) {\n         resp.header(\"Content-Type\", \"application/octet-stream\");\n       }\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"download\") String download,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    boolean downloadFile \u003d parseBooleanParam(download);\n    final long bytes \u003d parseLongParam(size);\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              long skippedBytes \u003d fis.skip(toSkip);\n              if (skippedBytes !\u003d toSkip) {\n                throw new IOException(\"The bytes were skipped are different \"\n                    + \"from the caller requested\");\n              }\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      if (downloadFile) {\n        resp.header(\"Content-Type\", \"application/octet-stream\");\n      }\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
      "commitDate": "01/06/16 1:44 PM",
      "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
          "commitDate": "01/06/16 1:44 PM",
          "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
          "commitAuthor": "Xuan",
          "commitDateOld": "25/05/16 6:31 AM",
          "commitNameOld": "9a31e5dfef42929951d305f31200ca4f80d86632",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 7.3,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,79 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n-      @QueryParam(\"download\") String download) {\n+      @QueryParam(\"download\") String download,\n+      @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     boolean downloadFile \u003d parseBooleanParam(download);\n+    final long bytes \u003d parseLongParam(size);\n+\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n-      \n+      final long fileLength \u003d logFile.length();\n+\n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           int bufferSize \u003d 65536;\n           byte[] buf \u003d new byte[bufferSize];\n-          int len;\n-          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n+          long toSkip \u003d 0;\n+          long totalBytesToRead \u003d fileLength;\n+          if (bytes \u003c 0) {\n+            long absBytes \u003d Math.abs(bytes);\n+            if (absBytes \u003c fileLength) {\n+              toSkip \u003d fileLength - absBytes;\n+              totalBytesToRead \u003d absBytes;\n+            }\n+            long skippedBytes \u003d fis.skip(toSkip);\n+            if (skippedBytes !\u003d toSkip) {\n+              throw new IOException(\"The bytes were skipped are different \"\n+                  + \"from the caller requested\");\n+            }\n+          } else {\n+            if (bytes \u003c fileLength) {\n+              totalBytesToRead \u003d bytes;\n+            }\n+          }\n+\n+          long curRead \u003d 0;\n+          long pendingRead \u003d totalBytesToRead - curRead;\n+          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n+              : (int) pendingRead;\n+          int len \u003d fis.read(buf, 0, toRead);\n+          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n             os.write(buf, 0, len);\n+            curRead +\u003d len;\n+\n+            pendingRead \u003d totalBytesToRead - curRead;\n+            toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                : (int) pendingRead;\n+            len \u003d fis.read(buf, 0, toRead);\n           }\n           os.flush();\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       if (downloadFile) {\n         resp.header(\"Content-Type\", \"application/octet-stream\");\n       }\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"download\") String download,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    boolean downloadFile \u003d parseBooleanParam(download);\n    final long bytes \u003d parseLongParam(size);\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          long toSkip \u003d 0;\n          long totalBytesToRead \u003d fileLength;\n          if (bytes \u003c 0) {\n            long absBytes \u003d Math.abs(bytes);\n            if (absBytes \u003c fileLength) {\n              toSkip \u003d fileLength - absBytes;\n              totalBytesToRead \u003d absBytes;\n            }\n            long skippedBytes \u003d fis.skip(toSkip);\n            if (skippedBytes !\u003d toSkip) {\n              throw new IOException(\"The bytes were skipped are different \"\n                  + \"from the caller requested\");\n            }\n          } else {\n            if (bytes \u003c fileLength) {\n              totalBytesToRead \u003d bytes;\n            }\n          }\n\n          long curRead \u003d 0;\n          long pendingRead \u003d totalBytesToRead - curRead;\n          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n              : (int) pendingRead;\n          int len \u003d fis.read(buf, 0, toRead);\n          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n            os.write(buf, 0, len);\n            curRead +\u003d len;\n\n            pendingRead \u003d totalBytesToRead - curRead;\n            toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            len \u003d fis.read(buf, 0, toRead);\n          }\n          os.flush();\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      if (downloadFile) {\n        resp.header(\"Content-Type\", \"application/octet-stream\");\n      }\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {
            "oldValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\")), download-String(annotations-@QueryParam(\"download\"))]",
            "newValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\")), download-String(annotations-@QueryParam(\"download\")), size-String(annotations-@QueryParam(\"size\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
          "commitDate": "01/06/16 1:44 PM",
          "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
          "commitAuthor": "Xuan",
          "commitDateOld": "25/05/16 6:31 AM",
          "commitNameOld": "9a31e5dfef42929951d305f31200ca4f80d86632",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 7.3,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,79 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n-      @QueryParam(\"download\") String download) {\n+      @QueryParam(\"download\") String download,\n+      @QueryParam(\"size\") String size) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     boolean downloadFile \u003d parseBooleanParam(download);\n+    final long bytes \u003d parseLongParam(size);\n+\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n-      \n+      final long fileLength \u003d logFile.length();\n+\n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           int bufferSize \u003d 65536;\n           byte[] buf \u003d new byte[bufferSize];\n-          int len;\n-          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n+          long toSkip \u003d 0;\n+          long totalBytesToRead \u003d fileLength;\n+          if (bytes \u003c 0) {\n+            long absBytes \u003d Math.abs(bytes);\n+            if (absBytes \u003c fileLength) {\n+              toSkip \u003d fileLength - absBytes;\n+              totalBytesToRead \u003d absBytes;\n+            }\n+            long skippedBytes \u003d fis.skip(toSkip);\n+            if (skippedBytes !\u003d toSkip) {\n+              throw new IOException(\"The bytes were skipped are different \"\n+                  + \"from the caller requested\");\n+            }\n+          } else {\n+            if (bytes \u003c fileLength) {\n+              totalBytesToRead \u003d bytes;\n+            }\n+          }\n+\n+          long curRead \u003d 0;\n+          long pendingRead \u003d totalBytesToRead - curRead;\n+          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n+              : (int) pendingRead;\n+          int len \u003d fis.read(buf, 0, toRead);\n+          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n             os.write(buf, 0, len);\n+            curRead +\u003d len;\n+\n+            pendingRead \u003d totalBytesToRead - curRead;\n+            toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                : (int) pendingRead;\n+            len \u003d fis.read(buf, 0, toRead);\n           }\n           os.flush();\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       if (downloadFile) {\n         resp.header(\"Content-Type\", \"application/octet-stream\");\n       }\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"download\") String download,\n      @QueryParam(\"size\") String size) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    boolean downloadFile \u003d parseBooleanParam(download);\n    final long bytes \u003d parseLongParam(size);\n\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      final long fileLength \u003d logFile.length();\n\n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          long toSkip \u003d 0;\n          long totalBytesToRead \u003d fileLength;\n          if (bytes \u003c 0) {\n            long absBytes \u003d Math.abs(bytes);\n            if (absBytes \u003c fileLength) {\n              toSkip \u003d fileLength - absBytes;\n              totalBytesToRead \u003d absBytes;\n            }\n            long skippedBytes \u003d fis.skip(toSkip);\n            if (skippedBytes !\u003d toSkip) {\n              throw new IOException(\"The bytes were skipped are different \"\n                  + \"from the caller requested\");\n            }\n          } else {\n            if (bytes \u003c fileLength) {\n              totalBytesToRead \u003d bytes;\n            }\n          }\n\n          long curRead \u003d 0;\n          long pendingRead \u003d totalBytesToRead - curRead;\n          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n              : (int) pendingRead;\n          int len \u003d fis.read(buf, 0, toRead);\n          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n            os.write(buf, 0, len);\n            curRead +\u003d len;\n\n            pendingRead \u003d totalBytesToRead - curRead;\n            toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            len \u003d fis.read(buf, 0, toRead);\n          }\n          os.flush();\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      if (downloadFile) {\n        resp.header(\"Content-Type\", \"application/octet-stream\");\n      }\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "9a31e5dfef42929951d305f31200ca4f80d86632": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5115. Avoid setting CONTENT-DISPOSITION header in the container-logs web-service. Contributed by Xuan Gong.\n",
      "commitDate": "25/05/16 6:31 AM",
      "commitName": "9a31e5dfef42929951d305f31200ca4f80d86632",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "04/05/16 10:35 AM",
      "commitNameOld": "e61d431275d7fe5641fe9da4903e285b10330fa0",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 20.83,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,46 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n       @PathParam(\"filename\") String filename,\n       @QueryParam(\"download\") String download) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n     boolean downloadFile \u003d parseBooleanParam(download);\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           int bufferSize \u003d 65536;\n           byte[] buf \u003d new byte[bufferSize];\n           int len;\n           while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n             os.write(buf, 0, len);\n           }\n           os.flush();\n         }\n       };\n       ResponseBuilder resp \u003d Response.ok(stream);\n       if (downloadFile) {\n         resp.header(\"Content-Type\", \"application/octet-stream\");\n-        resp.header(\"Content-Disposition\", \"attachment; filename\u003d\"\n-            + logFile.getName());\n       }\n       return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"download\") String download) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    boolean downloadFile \u003d parseBooleanParam(download);\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      \n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          int len;\n          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n            os.write(buf, 0, len);\n          }\n          os.flush();\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      if (downloadFile) {\n        resp.header(\"Content-Type\", \"application/octet-stream\");\n      }\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "e61d431275d7fe5641fe9da4903e285b10330fa0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4920. ATS/NM should support a link to dowload/get the logs in text format. Contributed by Xuan Gong.\n",
      "commitDate": "04/05/16 10:35 AM",
      "commitName": "e61d431275d7fe5641fe9da4903e285b10330fa0",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4920. ATS/NM should support a link to dowload/get the logs in text format. Contributed by Xuan Gong.\n",
          "commitDate": "04/05/16 10:35 AM",
          "commitName": "e61d431275d7fe5641fe9da4903e285b10330fa0",
          "commitAuthor": "Junping Du",
          "commitDateOld": "04/04/16 3:55 AM",
          "commitNameOld": "5092c94195a63bd2c3e36d5a74b4c061cea1b847",
          "commitAuthorOld": "naganarasimha",
          "daysBetweenCommits": 30.28,
          "commitsBetweenForRepo": 191,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,48 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n-      @PathParam(\"filename\") String filename) {\n+      @PathParam(\"filename\") String filename,\n+      @QueryParam(\"download\") String download) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n-    \n+    boolean downloadFile \u003d parseBooleanParam(download);\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           int bufferSize \u003d 65536;\n           byte[] buf \u003d new byte[bufferSize];\n           int len;\n           while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n             os.write(buf, 0, len);\n           }\n           os.flush();\n         }\n       };\n-      \n-      return Response.ok(stream).build();\n+      ResponseBuilder resp \u003d Response.ok(stream);\n+      if (downloadFile) {\n+        resp.header(\"Content-Type\", \"application/octet-stream\");\n+        resp.header(\"Content-Disposition\", \"attachment; filename\u003d\"\n+            + logFile.getName());\n+      }\n+      return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"download\") String download) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    boolean downloadFile \u003d parseBooleanParam(download);\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      \n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          int len;\n          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n            os.write(buf, 0, len);\n          }\n          os.flush();\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      if (downloadFile) {\n        resp.header(\"Content-Type\", \"application/octet-stream\");\n        resp.header(\"Content-Disposition\", \"attachment; filename\u003d\"\n            + logFile.getName());\n      }\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {
            "oldValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\"))]",
            "newValue": "[containerIdStr-String(annotations-@PathParam(\"containerid\")), filename-String(annotations-@PathParam(\"filename\")), download-String(annotations-@QueryParam(\"download\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4920. ATS/NM should support a link to dowload/get the logs in text format. Contributed by Xuan Gong.\n",
          "commitDate": "04/05/16 10:35 AM",
          "commitName": "e61d431275d7fe5641fe9da4903e285b10330fa0",
          "commitAuthor": "Junping Du",
          "commitDateOld": "04/04/16 3:55 AM",
          "commitNameOld": "5092c94195a63bd2c3e36d5a74b4c061cea1b847",
          "commitAuthorOld": "naganarasimha",
          "daysBetweenCommits": 30.28,
          "commitsBetweenForRepo": 191,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,48 @@\n   public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n-      @PathParam(\"filename\") String filename) {\n+      @PathParam(\"filename\") String filename,\n+      @QueryParam(\"download\") String download) {\n     ContainerId containerId;\n     try {\n       containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n     } catch (IllegalArgumentException ex) {\n       return Response.status(Status.BAD_REQUEST).build();\n     }\n     \n     File logFile \u003d null;\n     try {\n       logFile \u003d ContainerLogsUtils.getContainerLogFile(\n           containerId, filename, request.getRemoteUser(), nmContext);\n     } catch (NotFoundException ex) {\n       return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n     } catch (YarnException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n-    \n+    boolean downloadFile \u003d parseBooleanParam(download);\n     try {\n       final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n           containerIdStr, logFile, nmContext);\n       \n       StreamingOutput stream \u003d new StreamingOutput() {\n         @Override\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           int bufferSize \u003d 65536;\n           byte[] buf \u003d new byte[bufferSize];\n           int len;\n           while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n             os.write(buf, 0, len);\n           }\n           os.flush();\n         }\n       };\n-      \n-      return Response.ok(stream).build();\n+      ResponseBuilder resp \u003d Response.ok(stream);\n+      if (downloadFile) {\n+        resp.header(\"Content-Type\", \"application/octet-stream\");\n+        resp.header(\"Content-Disposition\", \"attachment; filename\u003d\"\n+            + logFile.getName());\n+      }\n+      return resp.build();\n     } catch (IOException ex) {\n       return Response.serverError().entity(ex.getMessage()).build();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename,\n      @QueryParam(\"download\") String download) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    boolean downloadFile \u003d parseBooleanParam(download);\n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      \n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          int len;\n          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n            os.write(buf, 0, len);\n          }\n          os.flush();\n        }\n      };\n      ResponseBuilder resp \u003d Response.ok(stream);\n      if (downloadFile) {\n        resp.header(\"Content-Type\", \"application/octet-stream\");\n        resp.header(\"Content-Disposition\", \"attachment; filename\u003d\"\n            + logFile.getName());\n      }\n      return resp.build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "a759abcd898224c3481c55aa7e424bc286f60b15": {
      "type": "Yintroduced",
      "commitMessage": "YARN-649. Added a new NM web-service to serve container logs in plain text over HTTP. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/09/13 5:09 PM",
      "commitName": "a759abcd898224c3481c55aa7e424bc286f60b15",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,42 @@\n+  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n+      @PathParam(\"filename\") String filename) {\n+    ContainerId containerId;\n+    try {\n+      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n+    } catch (IllegalArgumentException ex) {\n+      return Response.status(Status.BAD_REQUEST).build();\n+    }\n+    \n+    File logFile \u003d null;\n+    try {\n+      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n+          containerId, filename, request.getRemoteUser(), nmContext);\n+    } catch (NotFoundException ex) {\n+      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n+    } catch (YarnException ex) {\n+      return Response.serverError().entity(ex.getMessage()).build();\n+    }\n+    \n+    try {\n+      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n+          containerIdStr, logFile, nmContext);\n+      \n+      StreamingOutput stream \u003d new StreamingOutput() {\n+        @Override\n+        public void write(OutputStream os) throws IOException,\n+            WebApplicationException {\n+          int bufferSize \u003d 65536;\n+          byte[] buf \u003d new byte[bufferSize];\n+          int len;\n+          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n+            os.write(buf, 0, len);\n+          }\n+          os.flush();\n+        }\n+      };\n+      \n+      return Response.ok(stream).build();\n+    } catch (IOException ex) {\n+      return Response.serverError().entity(ex.getMessage()).build();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Response getLogs(@PathParam(\"containerid\") String containerIdStr,\n      @PathParam(\"filename\") String filename) {\n    ContainerId containerId;\n    try {\n      containerId \u003d ConverterUtils.toContainerId(containerIdStr);\n    } catch (IllegalArgumentException ex) {\n      return Response.status(Status.BAD_REQUEST).build();\n    }\n    \n    File logFile \u003d null;\n    try {\n      logFile \u003d ContainerLogsUtils.getContainerLogFile(\n          containerId, filename, request.getRemoteUser(), nmContext);\n    } catch (NotFoundException ex) {\n      return Response.status(Status.NOT_FOUND).entity(ex.getMessage()).build();\n    } catch (YarnException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n    \n    try {\n      final FileInputStream fis \u003d ContainerLogsUtils.openLogFileForRead(\n          containerIdStr, logFile, nmContext);\n      \n      StreamingOutput stream \u003d new StreamingOutput() {\n        @Override\n        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          int len;\n          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n            os.write(buf, 0, len);\n          }\n          os.flush();\n        }\n      };\n      \n      return Response.ok(stream).build();\n    } catch (IOException ex) {\n      return Response.serverError().entity(ex.getMessage()).build();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java"
    }
  }
}