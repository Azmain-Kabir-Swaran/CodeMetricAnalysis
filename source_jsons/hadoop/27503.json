{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AppLevelTimelineCollectorWithAgg.java",
  "functionName": "aggregate",
  "functionId": "aggregate",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollectorWithAgg.java",
  "functionStartLine": 118,
  "functionEndLine": 143,
  "numCommitsSeen": 25,
  "timeTaken": 3180,
  "changeHistory": [
    "dcd0bedcc8113dd5e1d852c242ae9511d1b3d58e",
    "3fb71b1393018e1001da55b794dda7d26491cf35",
    "793bbf216dc6d44ea57c778037bd461513fa6078",
    "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530",
    "a1b6d7456fa37b7b418dd08178ea73ed5c1de124",
    "39cce4e629aadb7fadf1fb14a23108f55b59eb21"
  ],
  "changeHistoryShort": {
    "dcd0bedcc8113dd5e1d852c242ae9511d1b3d58e": "Ybodychange",
    "3fb71b1393018e1001da55b794dda7d26491cf35": "Ymultichange(Ymovefromfile,Ybodychange)",
    "793bbf216dc6d44ea57c778037bd461513fa6078": "Ybodychange",
    "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530": "Ymultichange(Yrename,Ymodifierchange)",
    "a1b6d7456fa37b7b418dd08178ea73ed5c1de124": "Ybodychange",
    "39cce4e629aadb7fadf1fb14a23108f55b59eb21": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dcd0bedcc8113dd5e1d852c242ae9511d1b3d58e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7141. Move logging APIs to slf4j in timelineservice after ATSv2 merge. Contributed by Varun Saxena\n",
      "commitDate": "31/08/17 10:59 PM",
      "commitName": "dcd0bedcc8113dd5e1d852c242ae9511d1b3d58e",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "7594d1de7bbc34cd2e64202095a5e1757154d7d0",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,26 @@\n     private void aggregate() {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"App-level real-time aggregating\");\n-      }\n+      LOG.debug(\"App-level real-time aggregating\");\n       if (!isReadyToAggregate()) {\n         LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n         return;\n       }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n         Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n             \u003d getAggregationGroups();\n         if (aggregationGroups \u003d\u003d null\n             || aggregationGroups.isEmpty()) {\n           LOG.debug(\"App-level collector is empty, skip aggregation. \");\n           return;\n         }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n             aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n         putEntitiesAsync(entities, getCurrentUser());\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"App-level real-time aggregation complete\");\n-      }\n+      LOG.debug(\"App-level real-time aggregation complete\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void aggregate() {\n      LOG.debug(\"App-level real-time aggregating\");\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        putEntitiesAsync(entities, getCurrentUser());\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      LOG.debug(\"App-level real-time aggregation complete\");\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollectorWithAgg.java",
      "extendedDetails": {}
    },
    "3fb71b1393018e1001da55b794dda7d26491cf35": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-6888. Refactor AppLevelTimelineCollector such that RM does not have aggregator threads created. Contributed by Vrushali C.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "3fb71b1393018e1001da55b794dda7d26491cf35",
      "commitAuthor": "Rohith Sharma K S",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-6888. Refactor AppLevelTimelineCollector such that RM does not have aggregator threads created. Contributed by Vrushali C.\n",
          "commitDate": "29/08/17 10:59 PM",
          "commitName": "3fb71b1393018e1001da55b794dda7d26491cf35",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "29/08/17 10:59 PM",
          "commitNameOld": "a990ff70c25e2ab746578500720c531f23e0851e",
          "commitAuthorOld": "Rohith Sharma K S",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n     private void aggregate() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregating\");\n       }\n       if (!isReadyToAggregate()) {\n         LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n         return;\n       }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n         Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n             \u003d getAggregationGroups();\n         if (aggregationGroups \u003d\u003d null\n             || aggregationGroups.isEmpty()) {\n           LOG.debug(\"App-level collector is empty, skip aggregation. \");\n           return;\n         }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n             aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n-        putEntitiesAsync(entities, currentUser);\n+        putEntitiesAsync(entities, getCurrentUser());\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregation complete\");\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void aggregate() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        putEntitiesAsync(entities, getCurrentUser());\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollectorWithAgg.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollector.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollectorWithAgg.java",
            "oldMethodName": "aggregate",
            "newMethodName": "aggregate"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6888. Refactor AppLevelTimelineCollector such that RM does not have aggregator threads created. Contributed by Vrushali C.\n",
          "commitDate": "29/08/17 10:59 PM",
          "commitName": "3fb71b1393018e1001da55b794dda7d26491cf35",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "29/08/17 10:59 PM",
          "commitNameOld": "a990ff70c25e2ab746578500720c531f23e0851e",
          "commitAuthorOld": "Rohith Sharma K S",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n     private void aggregate() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregating\");\n       }\n       if (!isReadyToAggregate()) {\n         LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n         return;\n       }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n         Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n             \u003d getAggregationGroups();\n         if (aggregationGroups \u003d\u003d null\n             || aggregationGroups.isEmpty()) {\n           LOG.debug(\"App-level collector is empty, skip aggregation. \");\n           return;\n         }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n             aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n-        putEntitiesAsync(entities, currentUser);\n+        putEntitiesAsync(entities, getCurrentUser());\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregation complete\");\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void aggregate() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        putEntitiesAsync(entities, getCurrentUser());\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollectorWithAgg.java",
          "extendedDetails": {}
        }
      ]
    },
    "793bbf216dc6d44ea57c778037bd461513fa6078": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6455. Enhance the timelinewriter.flush() race condition fix (Haibo Chen via Varun Saxena)\n",
      "commitDate": "27/04/17 2:31 AM",
      "commitName": "793bbf216dc6d44ea57c778037bd461513fa6078",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "21/10/16 12:44 PM",
      "commitNameOld": "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 187.57,
      "commitsBetweenForRepo": 1126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,30 @@\n     private void aggregate() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregating\");\n       }\n       if (!isReadyToAggregate()) {\n         LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n         return;\n       }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n         Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n             \u003d getAggregationGroups();\n         if (aggregationGroups \u003d\u003d null\n             || aggregationGroups.isEmpty()) {\n           LOG.debug(\"App-level collector is empty, skip aggregation. \");\n           return;\n         }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n             aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n-        getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n-            currContext.getFlowName(), currContext.getFlowVersion(),\n-            currContext.getFlowRunId(), currContext.getAppId(), entities);\n+        putEntitiesAsync(entities, currentUser);\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregation complete\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void aggregate() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        putEntitiesAsync(entities, currentUser);\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollector.java",
      "extendedDetails": {}
    },
    "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "YARN-5747. Application timeline metric aggregation in timeline v2 will lose last round aggregation when an application finishes (Li Lu via Varun Saxena)\n",
      "commitDate": "21/10/16 12:44 PM",
      "commitName": "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530",
      "commitAuthor": "Varun Saxena",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-5747. Application timeline metric aggregation in timeline v2 will lose last round aggregation when an application finishes (Li Lu via Varun Saxena)\n",
          "commitDate": "21/10/16 12:44 PM",
          "commitName": "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530",
          "commitAuthor": "Varun Saxena",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "a1b6d7456fa37b7b418dd08178ea73ed5c1de124",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 103.17,
          "commitsBetweenForRepo": 711,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,32 @@\n-    public void run() {\n+    private void aggregate() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregating\");\n       }\n       if (!isReadyToAggregate()) {\n         LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n         return;\n       }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n         Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n             \u003d getAggregationGroups();\n         if (aggregationGroups \u003d\u003d null\n             || aggregationGroups.isEmpty()) {\n           LOG.debug(\"App-level collector is empty, skip aggregation. \");\n           return;\n         }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n             aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n         getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n             currContext.getFlowName(), currContext.getFlowVersion(),\n             currContext.getFlowRunId(), currContext.getAppId(), entities);\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregation complete\");\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void aggregate() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n            currContext.getFlowName(), currContext.getFlowVersion(),\n            currContext.getFlowRunId(), currContext.getAppId(), entities);\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollector.java",
          "extendedDetails": {
            "oldValue": "run",
            "newValue": "aggregate"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-5747. Application timeline metric aggregation in timeline v2 will lose last round aggregation when an application finishes (Li Lu via Varun Saxena)\n",
          "commitDate": "21/10/16 12:44 PM",
          "commitName": "44eb2bd7ae39cca77fc8c7ad493b52ea1bb43530",
          "commitAuthor": "Varun Saxena",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "a1b6d7456fa37b7b418dd08178ea73ed5c1de124",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 103.17,
          "commitsBetweenForRepo": 711,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,32 @@\n-    public void run() {\n+    private void aggregate() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregating\");\n       }\n       if (!isReadyToAggregate()) {\n         LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n         return;\n       }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n         Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n             \u003d getAggregationGroups();\n         if (aggregationGroups \u003d\u003d null\n             || aggregationGroups.isEmpty()) {\n           LOG.debug(\"App-level collector is empty, skip aggregation. \");\n           return;\n         }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n             aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n         getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n             currContext.getFlowName(), currContext.getFlowVersion(),\n             currContext.getFlowRunId(), currContext.getAppId(), entities);\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregation complete\");\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void aggregate() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n            currContext.getFlowName(), currContext.getFlowVersion(),\n            currContext.getFlowRunId(), currContext.getAppId(), entities);\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollector.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        }
      ]
    },
    "a1b6d7456fa37b7b418dd08178ea73ed5c1de124": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5018. Online aggregation logic should not run immediately after collectors got started (Li Lu via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "a1b6d7456fa37b7b418dd08178ea73ed5c1de124",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "39cce4e629aadb7fadf1fb14a23108f55b59eb21",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,32 @@\n     public void run() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregating\");\n       }\n+      if (!isReadyToAggregate()) {\n+        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n+        return;\n+      }\n       try {\n         TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n+        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n+            \u003d getAggregationGroups();\n+        if (aggregationGroups \u003d\u003d null\n+            || aggregationGroups.isEmpty()) {\n+          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n+          return;\n+        }\n         TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n-            getAggregationGroups(), currContext.getAppId(),\n+            aggregationGroups, currContext.getAppId(),\n             TimelineEntityType.YARN_APPLICATION.toString());\n         TimelineEntities entities \u003d new TimelineEntities();\n         entities.addEntity(resultEntity);\n         getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n             currContext.getFlowName(), currContext.getFlowVersion(),\n             currContext.getFlowRunId(), currContext.getAppId(), entities);\n       } catch (Exception e) {\n         LOG.error(\"Error aggregating timeline metrics\", e);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"App-level real-time aggregation complete\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      if (!isReadyToAggregate()) {\n        LOG.warn(\"App-level collector is not ready, skip aggregation. \");\n        return;\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        Map\u003cString, AggregationStatusTable\u003e aggregationGroups\n            \u003d getAggregationGroups();\n        if (aggregationGroups \u003d\u003d null\n            || aggregationGroups.isEmpty()) {\n          LOG.debug(\"App-level collector is empty, skip aggregation. \");\n          return;\n        }\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            aggregationGroups, currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n            currContext.getFlowName(), currContext.getFlowVersion(),\n            currContext.getFlowRunId(), currContext.getAppId(), entities);\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollector.java",
      "extendedDetails": {}
    },
    "39cce4e629aadb7fadf1fb14a23108f55b59eb21": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3816. [Aggregation] App-level aggregation and accumulation for YARN system metrics (Li Lu via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "39cce4e629aadb7fadf1fb14a23108f55b59eb21",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,21 @@\n+    public void run() {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"App-level real-time aggregating\");\n+      }\n+      try {\n+        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n+        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n+            getAggregationGroups(), currContext.getAppId(),\n+            TimelineEntityType.YARN_APPLICATION.toString());\n+        TimelineEntities entities \u003d new TimelineEntities();\n+        entities.addEntity(resultEntity);\n+        getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n+            currContext.getFlowName(), currContext.getFlowVersion(),\n+            currContext.getFlowRunId(), currContext.getAppId(), entities);\n+      } catch (Exception e) {\n+        LOG.error(\"Error aggregating timeline metrics\", e);\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"App-level real-time aggregation complete\");\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregating\");\n      }\n      try {\n        TimelineCollectorContext currContext \u003d getTimelineEntityContext();\n        TimelineEntity resultEntity \u003d TimelineCollector.aggregateWithoutGroupId(\n            getAggregationGroups(), currContext.getAppId(),\n            TimelineEntityType.YARN_APPLICATION.toString());\n        TimelineEntities entities \u003d new TimelineEntities();\n        entities.addEntity(resultEntity);\n        getWriter().write(currContext.getClusterId(), currContext.getUserId(),\n            currContext.getFlowName(), currContext.getFlowVersion(),\n            currContext.getFlowRunId(), currContext.getAppId(), entities);\n      } catch (Exception e) {\n        LOG.error(\"Error aggregating timeline metrics\", e);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"App-level real-time aggregation complete\");\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/AppLevelTimelineCollector.java"
    }
  }
}