{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WindowsSecureContainerExecutor.java",
  "functionName": "startLocalizer",
  "functionId": "startLocalizer___ctx-LocalizerStartContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
  "functionStartLine": 634,
  "functionEndLine": 716,
  "numCommitsSeen": 30,
  "timeTaken": 5341,
  "changeHistory": [
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
    "21ec4bdaef4b68adbbf4f33a6f74494c074f803c",
    "d8923cdbf1567aee10a54f144fef734d1465ebed",
    "72fe54684198b7df5c5fb2114616dff6d17a4402",
    "53fafcf061616516c24e2e2007a66a93d23d3e25",
    "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d",
    "41a548a916d4248164cb9495320f123ec215d70e",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
    "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a",
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769"
  ],
  "changeHistoryShort": {
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd": "Ybodychange",
    "21ec4bdaef4b68adbbf4f33a6f74494c074f803c": "Ybodychange",
    "d8923cdbf1567aee10a54f144fef734d1465ebed": "Ybodychange",
    "72fe54684198b7df5c5fb2114616dff6d17a4402": "Ybodychange",
    "53fafcf061616516c24e2e2007a66a93d23d3e25": "Ymultichange(Yparameterchange,Ybodychange)",
    "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d": "Ybodychange",
    "41a548a916d4248164cb9495320f123ec215d70e": "Ybodychange",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": "Ymultichange(Yparameterchange,Ybodychange)",
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5": "Ybodychange",
    "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a": "Ybodychange",
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9363.  Replaced debug logging with SLF4J parameterized log message.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "18/03/19 10:57 AM",
      "commitName": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "14/11/18 12:22 PM",
      "commitNameOld": "21ec4bdaef4b68adbbf4f33a6f74494c074f803c",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 123.9,
      "commitsBetweenForRepo": 900,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,83 @@\n   public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n       InterruptedException {\n     Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n     InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     String locId \u003d ctx.getLocId();\n     LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n \n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n     String tokenFn \u003d String.format(ContainerExecutor.TOKEN_FILE_NAME_FMT,\n         locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n \n     File cwdApp \u003d new File(appStorageDir.toString());\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n-    }\n+    LOG.debug(\"cwdApp: {}\", cwdApp);\n \n     List\u003cString\u003e command ;\n \n     command \u003d new ArrayList\u003cString\u003e();\n \n     //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n         tokenFn, localDirs, super.getConf());\n \n     String cmdLine \u003d StringUtils.join(command, \" \");\n \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(),\n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     } finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n             localizerPid,\n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n      InterruptedException {\n    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    String locId \u003d ctx.getLocId();\n    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n        ResourceLocalizationService.NM_PRIVATE_DIR);\n    createUserLocalDirs(localDirs, user);\n    createUserCacheDirs(localDirs, user);\n    createAppDirs(localDirs, user, appId);\n    createAppLogDirs(appId, logDirs, user);\n\n    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n    String tokenFn \u003d String.format(ContainerExecutor.TOKEN_FILE_NAME_FMT,\n        locId);\n    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n\n    File cwdApp \u003d new File(appStorageDir.toString());\n    LOG.debug(\"cwdApp: {}\", cwdApp);\n\n    List\u003cString\u003e command ;\n\n    command \u003d new ArrayList\u003cString\u003e();\n\n    //use same jvm as parent\n    File jvm \u003d new File(\n        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n    command.add(jvm.toString());\n\n    Path cwdPath \u003d new Path(cwdApp.getPath());\n\n    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n    // Passing CLASSPATH explicitly is *way* too long for command line.\n    String classPath \u003d System.getProperty(\"java.class.path\");\n    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n        classpathJarPrivateDir, cwdPath, env);\n    String classPathJar \u003d localizeClasspathJar(\n        new Path(jarCp[0]), cwdPath, user).toString();\n    command.add(\"-classpath\");\n    command.add(classPathJar + jarCp[1]);\n\n    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n    if (javaLibPath !\u003d null) {\n      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n    }\n    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n        tokenFn, localDirs, super.getConf());\n\n    String cmdLine \u003d StringUtils.join(command, \" \");\n\n    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n\n    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n        cwdApp.getAbsolutePath(),\n        localizerPid, user, \"nul:\", cmdLine);\n    try {\n      stubExecutor.execute();\n      stubExecutor.validateResult();\n    } finally {\n      stubExecutor.close();\n      try\n      {\n        killContainer(localizerPid, Signal.KILL);\n      }\n      catch(Throwable e) {\n        LOG.warn(String.format(\n            \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n            localizerPid,\n            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "21ec4bdaef4b68adbbf4f33a6f74494c074f803c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8672.  Improve token filename management for localization.\n            Contributed by Chandni Singh\n",
      "commitDate": "14/11/18 12:22 PM",
      "commitName": "21ec4bdaef4b68adbbf4f33a6f74494c074f803c",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 155.2,
      "commitsBetweenForRepo": 1266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n       InterruptedException {\n     Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n     InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     String locId \u003d ctx.getLocId();\n     LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n \n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n-    String tokenFn \u003d String.format(\n-        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n+    String tokenFn \u003d String.format(ContainerExecutor.TOKEN_FILE_NAME_FMT,\n+        locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n \n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n \n     List\u003cString\u003e command ;\n \n     command \u003d new ArrayList\u003cString\u003e();\n \n     //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n-        localDirs, super.getConf());\n+        tokenFn, localDirs, super.getConf());\n \n     String cmdLine \u003d StringUtils.join(command, \" \");\n \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(),\n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     } finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n             localizerPid,\n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n      InterruptedException {\n    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    String locId \u003d ctx.getLocId();\n    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n        ResourceLocalizationService.NM_PRIVATE_DIR);\n    createUserLocalDirs(localDirs, user);\n    createUserCacheDirs(localDirs, user);\n    createAppDirs(localDirs, user, appId);\n    createAppLogDirs(appId, logDirs, user);\n\n    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n    String tokenFn \u003d String.format(ContainerExecutor.TOKEN_FILE_NAME_FMT,\n        locId);\n    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n\n    File cwdApp \u003d new File(appStorageDir.toString());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n    }\n\n    List\u003cString\u003e command ;\n\n    command \u003d new ArrayList\u003cString\u003e();\n\n    //use same jvm as parent\n    File jvm \u003d new File(\n        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n    command.add(jvm.toString());\n\n    Path cwdPath \u003d new Path(cwdApp.getPath());\n\n    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n    // Passing CLASSPATH explicitly is *way* too long for command line.\n    String classPath \u003d System.getProperty(\"java.class.path\");\n    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n        classpathJarPrivateDir, cwdPath, env);\n    String classPathJar \u003d localizeClasspathJar(\n        new Path(jarCp[0]), cwdPath, user).toString();\n    command.add(\"-classpath\");\n    command.add(classPathJar + jarCp[1]);\n\n    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n    if (javaLibPath !\u003d null) {\n      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n    }\n    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n        tokenFn, localDirs, super.getConf());\n\n    String cmdLine \u003d StringUtils.join(command, \" \");\n\n    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n\n    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n        cwdApp.getAbsolutePath(),\n        localizerPid, user, \"nul:\", cmdLine);\n    try {\n      stubExecutor.execute();\n      stubExecutor.validateResult();\n    } finally {\n      stubExecutor.close();\n      try\n      {\n        killContainer(localizerPid, Signal.KILL);\n      }\n      catch(Throwable e) {\n        LOG.warn(String.format(\n            \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n            localizerPid,\n            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "d8923cdbf1567aee10a54f144fef734d1465ebed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7363. ContainerLocalizer don\u0027t have a valid log4j config in case of Linux container executor. (Contributed by Yufei Gu)\n",
      "commitDate": "27/11/17 2:31 PM",
      "commitName": "d8923cdbf1567aee10a54f144fef734d1465ebed",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "07/12/16 3:07 PM",
      "commitNameOld": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 354.98,
      "commitsBetweenForRepo": 2255,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n       InterruptedException {\n     Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n     InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     String locId \u003d ctx.getLocId();\n     LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n \n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n     String tokenFn \u003d String.format(\n         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n \n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n \n     List\u003cString\u003e command ;\n \n     command \u003d new ArrayList\u003cString\u003e();\n \n     //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n-        localDirs);\n+        localDirs, super.getConf());\n \n     String cmdLine \u003d StringUtils.join(command, \" \");\n \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(),\n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     } finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n             localizerPid,\n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n      InterruptedException {\n    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    String locId \u003d ctx.getLocId();\n    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n        ResourceLocalizationService.NM_PRIVATE_DIR);\n    createUserLocalDirs(localDirs, user);\n    createUserCacheDirs(localDirs, user);\n    createAppDirs(localDirs, user, appId);\n    createAppLogDirs(appId, logDirs, user);\n\n    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n    String tokenFn \u003d String.format(\n        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n\n    File cwdApp \u003d new File(appStorageDir.toString());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n    }\n\n    List\u003cString\u003e command ;\n\n    command \u003d new ArrayList\u003cString\u003e();\n\n    //use same jvm as parent\n    File jvm \u003d new File(\n        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n    command.add(jvm.toString());\n\n    Path cwdPath \u003d new Path(cwdApp.getPath());\n\n    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n    // Passing CLASSPATH explicitly is *way* too long for command line.\n    String classPath \u003d System.getProperty(\"java.class.path\");\n    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n        classpathJarPrivateDir, cwdPath, env);\n    String classPathJar \u003d localizeClasspathJar(\n        new Path(jarCp[0]), cwdPath, user).toString();\n    command.add(\"-classpath\");\n    command.add(classPathJar + jarCp[1]);\n\n    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n    if (javaLibPath !\u003d null) {\n      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n    }\n    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n        localDirs, super.getConf());\n\n    String cmdLine \u003d StringUtils.join(command, \" \");\n\n    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n\n    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n        cwdApp.getAbsolutePath(),\n        localizerPid, user, \"nul:\", cmdLine);\n    try {\n      stubExecutor.execute();\n      stubExecutor.validateResult();\n    } finally {\n      stubExecutor.close();\n      try\n      {\n        killContainer(localizerPid, Signal.KILL);\n      }\n      catch(Throwable e) {\n        LOG.warn(String.format(\n            \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n            localizerPid,\n            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "72fe54684198b7df5c5fb2114616dff6d17a4402": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5963. Spelling errors in logging and exceptions for node manager, client, web-proxy, common, and app history code (gsohn via rkanter)\n",
      "commitDate": "07/12/16 3:07 PM",
      "commitName": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "17/10/16 2:29 PM",
      "commitNameOld": "f5d92359145dfb820a9521e00e2d44c4ee96e67e",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 51.07,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n       InterruptedException {\n     Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n     InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     String locId \u003d ctx.getLocId();\n     LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n \n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n     String tokenFn \u003d String.format(\n         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n \n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n \n     List\u003cString\u003e command ;\n \n     command \u003d new ArrayList\u003cString\u003e();\n \n     //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n         localDirs);\n \n     String cmdLine \u003d StringUtils.join(command, \" \");\n \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(),\n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     } finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n-            \"An exception occured during the cleanup of localizer job %s:%n%s\",\n+            \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n             localizerPid,\n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n      InterruptedException {\n    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    String locId \u003d ctx.getLocId();\n    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n        ResourceLocalizationService.NM_PRIVATE_DIR);\n    createUserLocalDirs(localDirs, user);\n    createUserCacheDirs(localDirs, user);\n    createAppDirs(localDirs, user, appId);\n    createAppLogDirs(appId, logDirs, user);\n\n    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n    String tokenFn \u003d String.format(\n        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n\n    File cwdApp \u003d new File(appStorageDir.toString());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n    }\n\n    List\u003cString\u003e command ;\n\n    command \u003d new ArrayList\u003cString\u003e();\n\n    //use same jvm as parent\n    File jvm \u003d new File(\n        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n    command.add(jvm.toString());\n\n    Path cwdPath \u003d new Path(cwdApp.getPath());\n\n    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n    // Passing CLASSPATH explicitly is *way* too long for command line.\n    String classPath \u003d System.getProperty(\"java.class.path\");\n    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n        classpathJarPrivateDir, cwdPath, env);\n    String classPathJar \u003d localizeClasspathJar(\n        new Path(jarCp[0]), cwdPath, user).toString();\n    command.add(\"-classpath\");\n    command.add(classPathJar + jarCp[1]);\n\n    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n    if (javaLibPath !\u003d null) {\n      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n    }\n    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n        localDirs);\n\n    String cmdLine \u003d StringUtils.join(command, \" \");\n\n    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n\n    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n        cwdApp.getAbsolutePath(),\n        localizerPid, user, \"nul:\", cmdLine);\n    try {\n      stubExecutor.execute();\n      stubExecutor.validateResult();\n    } finally {\n      stubExecutor.close();\n      try\n      {\n        killContainer(localizerPid, Signal.KILL);\n      }\n      catch(Throwable e) {\n        LOG.warn(String.format(\n            \"An exception occurred during the cleanup of localizer job %s:%n%s\",\n            localizerPid,\n            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "53fafcf061616516c24e2e2007a66a93d23d3e25": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
      "commitDate": "21/05/15 3:50 PM",
      "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
          "commitDate": "21/05/15 3:50 PM",
          "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/05/15 8:01 PM",
          "commitNameOld": "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 12.83,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,85 @@\n- public void startLocalizer(Path nmPrivateContainerTokens,\n-     InetSocketAddress nmAddr, String user, String appId, String locId,\n-     LocalDirsHandlerService dirsHandler) throws IOException,\n-     InterruptedException {\n-   \n-     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n-     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n-     \n-     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n-         ResourceLocalizationService.NM_PRIVATE_DIR);\n-     createUserLocalDirs(localDirs, user);\n-     createUserCacheDirs(localDirs, user);\n-     createAppDirs(localDirs, user, appId);\n-     createAppLogDirs(appId, logDirs, user);\n+  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n+      InterruptedException {\n+    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n+    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n+    String user \u003d ctx.getUser();\n+    String appId \u003d ctx.getAppId();\n+    String locId \u003d ctx.getLocId();\n+    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n+    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n+    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n-     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n-     \n-     String tokenFn \u003d String.format(\n-         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n-     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n-     copyFile(nmPrivateContainerTokens, tokenDst, user);\n+    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n+        ResourceLocalizationService.NM_PRIVATE_DIR);\n+    createUserLocalDirs(localDirs, user);\n+    createUserCacheDirs(localDirs, user);\n+    createAppDirs(localDirs, user, appId);\n+    createAppLogDirs(appId, logDirs, user);\n \n-     File cwdApp \u003d new File(appStorageDir.toString());\n-     if (LOG.isDebugEnabled()) {\n-       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n-     }\n-     \n-     List\u003cString\u003e command ;\n+    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n-     command \u003d new ArrayList\u003cString\u003e();\n+    String tokenFn \u003d String.format(\n+        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n+    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n+    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n \n-   //use same jvm as parent\n-     File jvm \u003d new File(\n-         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n-     command.add(jvm.toString());\n-     \n-     Path cwdPath \u003d new Path(cwdApp.getPath());\n-     \n-     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n-     // Passing CLASSPATH explicitly is *way* too long for command line.\n-     String classPath \u003d System.getProperty(\"java.class.path\");\n-     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n-     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n-         classpathJarPrivateDir, cwdPath, env);\n-     String classPathJar \u003d localizeClasspathJar(\n-         new Path(jarCp[0]), cwdPath, user).toString();\n-     command.add(\"-classpath\");\n-     command.add(classPathJar + jarCp[1]);\n+    File cwdApp \u003d new File(appStorageDir.toString());\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n+    }\n \n-     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n-     if (javaLibPath !\u003d null) {\n-       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n-     }\n-     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n+    List\u003cString\u003e command ;\n \n-     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n-         localDirs);\n-     \n-     String cmdLine \u003d StringUtils.join(command, \" \");\n-     \n-     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n-     \n-     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n-         cwdApp.getAbsolutePath(), \n-         localizerPid, user, \"nul:\", cmdLine);\n-     try {\n-       stubExecutor.execute();\n-       stubExecutor.validateResult();\n-     }\n-     finally {\n-       stubExecutor.close();\n-       try\n-       {\n-         killContainer(localizerPid, Signal.KILL);\n-       }\n-       catch(Throwable e) {\n-         LOG.warn(String.format(\n-             \"An exception occured during the cleanup of localizer job %s:%n%s\", \n-             localizerPid, \n-             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n-       }\n-     }\n-   }\n\\ No newline at end of file\n+    command \u003d new ArrayList\u003cString\u003e();\n+\n+    //use same jvm as parent\n+    File jvm \u003d new File(\n+        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n+    command.add(jvm.toString());\n+\n+    Path cwdPath \u003d new Path(cwdApp.getPath());\n+\n+    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n+    // Passing CLASSPATH explicitly is *way* too long for command line.\n+    String classPath \u003d System.getProperty(\"java.class.path\");\n+    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n+    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n+        classpathJarPrivateDir, cwdPath, env);\n+    String classPathJar \u003d localizeClasspathJar(\n+        new Path(jarCp[0]), cwdPath, user).toString();\n+    command.add(\"-classpath\");\n+    command.add(classPathJar + jarCp[1]);\n+\n+    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n+    if (javaLibPath !\u003d null) {\n+      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n+    }\n+    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n+\n+    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n+        localDirs);\n+\n+    String cmdLine \u003d StringUtils.join(command, \" \");\n+\n+    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n+\n+    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n+        cwdApp.getAbsolutePath(),\n+        localizerPid, user, \"nul:\", cmdLine);\n+    try {\n+      stubExecutor.execute();\n+      stubExecutor.validateResult();\n+    } finally {\n+      stubExecutor.close();\n+      try\n+      {\n+        killContainer(localizerPid, Signal.KILL);\n+      }\n+      catch(Throwable e) {\n+        LOG.warn(String.format(\n+            \"An exception occured during the cleanup of localizer job %s:%n%s\",\n+            localizerPid,\n+            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n      InterruptedException {\n    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    String locId \u003d ctx.getLocId();\n    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n        ResourceLocalizationService.NM_PRIVATE_DIR);\n    createUserLocalDirs(localDirs, user);\n    createUserCacheDirs(localDirs, user);\n    createAppDirs(localDirs, user, appId);\n    createAppLogDirs(appId, logDirs, user);\n\n    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n    String tokenFn \u003d String.format(\n        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n\n    File cwdApp \u003d new File(appStorageDir.toString());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n    }\n\n    List\u003cString\u003e command ;\n\n    command \u003d new ArrayList\u003cString\u003e();\n\n    //use same jvm as parent\n    File jvm \u003d new File(\n        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n    command.add(jvm.toString());\n\n    Path cwdPath \u003d new Path(cwdApp.getPath());\n\n    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n    // Passing CLASSPATH explicitly is *way* too long for command line.\n    String classPath \u003d System.getProperty(\"java.class.path\");\n    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n        classpathJarPrivateDir, cwdPath, env);\n    String classPathJar \u003d localizeClasspathJar(\n        new Path(jarCp[0]), cwdPath, user).toString();\n    command.add(\"-classpath\");\n    command.add(classPathJar + jarCp[1]);\n\n    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n    if (javaLibPath !\u003d null) {\n      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n    }\n    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n        localDirs);\n\n    String cmdLine \u003d StringUtils.join(command, \" \");\n\n    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n\n    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n        cwdApp.getAbsolutePath(),\n        localizerPid, user, \"nul:\", cmdLine);\n    try {\n      stubExecutor.execute();\n      stubExecutor.validateResult();\n    } finally {\n      stubExecutor.close();\n      try\n      {\n        killContainer(localizerPid, Signal.KILL);\n      }\n      catch(Throwable e) {\n        LOG.warn(String.format(\n            \"An exception occured during the cleanup of localizer job %s:%n%s\",\n            localizerPid,\n            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[nmPrivateContainerTokens-Path, nmAddr-InetSocketAddress, user-String, appId-String, locId-String, dirsHandler-LocalDirsHandlerService]",
            "newValue": "[ctx-LocalizerStartContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
          "commitDate": "21/05/15 3:50 PM",
          "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/05/15 8:01 PM",
          "commitNameOld": "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 12.83,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,85 @@\n- public void startLocalizer(Path nmPrivateContainerTokens,\n-     InetSocketAddress nmAddr, String user, String appId, String locId,\n-     LocalDirsHandlerService dirsHandler) throws IOException,\n-     InterruptedException {\n-   \n-     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n-     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n-     \n-     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n-         ResourceLocalizationService.NM_PRIVATE_DIR);\n-     createUserLocalDirs(localDirs, user);\n-     createUserCacheDirs(localDirs, user);\n-     createAppDirs(localDirs, user, appId);\n-     createAppLogDirs(appId, logDirs, user);\n+  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n+      InterruptedException {\n+    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n+    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n+    String user \u003d ctx.getUser();\n+    String appId \u003d ctx.getAppId();\n+    String locId \u003d ctx.getLocId();\n+    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n+    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n+    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n-     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n-     \n-     String tokenFn \u003d String.format(\n-         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n-     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n-     copyFile(nmPrivateContainerTokens, tokenDst, user);\n+    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n+        ResourceLocalizationService.NM_PRIVATE_DIR);\n+    createUserLocalDirs(localDirs, user);\n+    createUserCacheDirs(localDirs, user);\n+    createAppDirs(localDirs, user, appId);\n+    createAppLogDirs(appId, logDirs, user);\n \n-     File cwdApp \u003d new File(appStorageDir.toString());\n-     if (LOG.isDebugEnabled()) {\n-       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n-     }\n-     \n-     List\u003cString\u003e command ;\n+    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n-     command \u003d new ArrayList\u003cString\u003e();\n+    String tokenFn \u003d String.format(\n+        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n+    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n+    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n \n-   //use same jvm as parent\n-     File jvm \u003d new File(\n-         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n-     command.add(jvm.toString());\n-     \n-     Path cwdPath \u003d new Path(cwdApp.getPath());\n-     \n-     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n-     // Passing CLASSPATH explicitly is *way* too long for command line.\n-     String classPath \u003d System.getProperty(\"java.class.path\");\n-     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n-     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n-         classpathJarPrivateDir, cwdPath, env);\n-     String classPathJar \u003d localizeClasspathJar(\n-         new Path(jarCp[0]), cwdPath, user).toString();\n-     command.add(\"-classpath\");\n-     command.add(classPathJar + jarCp[1]);\n+    File cwdApp \u003d new File(appStorageDir.toString());\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n+    }\n \n-     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n-     if (javaLibPath !\u003d null) {\n-       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n-     }\n-     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n+    List\u003cString\u003e command ;\n \n-     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n-         localDirs);\n-     \n-     String cmdLine \u003d StringUtils.join(command, \" \");\n-     \n-     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n-     \n-     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n-         cwdApp.getAbsolutePath(), \n-         localizerPid, user, \"nul:\", cmdLine);\n-     try {\n-       stubExecutor.execute();\n-       stubExecutor.validateResult();\n-     }\n-     finally {\n-       stubExecutor.close();\n-       try\n-       {\n-         killContainer(localizerPid, Signal.KILL);\n-       }\n-       catch(Throwable e) {\n-         LOG.warn(String.format(\n-             \"An exception occured during the cleanup of localizer job %s:%n%s\", \n-             localizerPid, \n-             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n-       }\n-     }\n-   }\n\\ No newline at end of file\n+    command \u003d new ArrayList\u003cString\u003e();\n+\n+    //use same jvm as parent\n+    File jvm \u003d new File(\n+        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n+    command.add(jvm.toString());\n+\n+    Path cwdPath \u003d new Path(cwdApp.getPath());\n+\n+    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n+    // Passing CLASSPATH explicitly is *way* too long for command line.\n+    String classPath \u003d System.getProperty(\"java.class.path\");\n+    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n+    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n+        classpathJarPrivateDir, cwdPath, env);\n+    String classPathJar \u003d localizeClasspathJar(\n+        new Path(jarCp[0]), cwdPath, user).toString();\n+    command.add(\"-classpath\");\n+    command.add(classPathJar + jarCp[1]);\n+\n+    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n+    if (javaLibPath !\u003d null) {\n+      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n+    }\n+    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n+\n+    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n+        localDirs);\n+\n+    String cmdLine \u003d StringUtils.join(command, \" \");\n+\n+    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n+\n+    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n+        cwdApp.getAbsolutePath(),\n+        localizerPid, user, \"nul:\", cmdLine);\n+    try {\n+      stubExecutor.execute();\n+      stubExecutor.validateResult();\n+    } finally {\n+      stubExecutor.close();\n+      try\n+      {\n+        killContainer(localizerPid, Signal.KILL);\n+      }\n+      catch(Throwable e) {\n+        LOG.warn(String.format(\n+            \"An exception occured during the cleanup of localizer job %s:%n%s\",\n+            localizerPid,\n+            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public void startLocalizer(LocalizerStartContext ctx) throws IOException,\n      InterruptedException {\n    Path nmPrivateContainerTokensPath \u003d ctx.getNmPrivateContainerTokens();\n    InetSocketAddress nmAddr \u003d ctx.getNmAddr();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    String locId \u003d ctx.getLocId();\n    LocalDirsHandlerService dirsHandler \u003d ctx.getDirsHandler();\n    List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n    Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n        ResourceLocalizationService.NM_PRIVATE_DIR);\n    createUserLocalDirs(localDirs, user);\n    createUserCacheDirs(localDirs, user);\n    createAppDirs(localDirs, user, appId);\n    createAppLogDirs(appId, logDirs, user);\n\n    Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n    String tokenFn \u003d String.format(\n        ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n    Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n    copyFile(nmPrivateContainerTokensPath, tokenDst, user);\n\n    File cwdApp \u003d new File(appStorageDir.toString());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n    }\n\n    List\u003cString\u003e command ;\n\n    command \u003d new ArrayList\u003cString\u003e();\n\n    //use same jvm as parent\n    File jvm \u003d new File(\n        new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n    command.add(jvm.toString());\n\n    Path cwdPath \u003d new Path(cwdApp.getPath());\n\n    // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n    // Passing CLASSPATH explicitly is *way* too long for command line.\n    String classPath \u003d System.getProperty(\"java.class.path\");\n    Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n    String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath,\n        classpathJarPrivateDir, cwdPath, env);\n    String classPathJar \u003d localizeClasspathJar(\n        new Path(jarCp[0]), cwdPath, user).toString();\n    command.add(\"-classpath\");\n    command.add(classPathJar + jarCp[1]);\n\n    String javaLibPath \u003d System.getProperty(\"java.library.path\");\n    if (javaLibPath !\u003d null) {\n      command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n    }\n    command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n    ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr,\n        localDirs);\n\n    String cmdLine \u003d StringUtils.join(command, \" \");\n\n    String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n\n    WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n        cwdApp.getAbsolutePath(),\n        localizerPid, user, \"nul:\", cmdLine);\n    try {\n      stubExecutor.execute();\n      stubExecutor.validateResult();\n    } finally {\n      stubExecutor.close();\n      try\n      {\n        killContainer(localizerPid, Signal.KILL);\n      }\n      catch(Throwable e) {\n        LOG.warn(String.format(\n            \"An exception occured during the cleanup of localizer job %s:%n%s\",\n            localizerPid,\n            org.apache.hadoop.util.StringUtils.stringifyException(e)));\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1912. ResourceLocalizer started without any jvm memory control.\nContributed by Masatake Iwasaki\n",
      "commitDate": "08/05/15 8:01 PM",
      "commitName": "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d",
      "commitAuthor": "Xuan",
      "commitDateOld": "06/03/15 2:18 PM",
      "commitNameOld": "21101c01f242439ec8ec40fb3a9ab1991ae0adc7",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 63.2,
      "commitsBetweenForRepo": 626,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,83 @@\n  public void startLocalizer(Path nmPrivateContainerTokens,\n      InetSocketAddress nmAddr, String user, String appId, String locId,\n      LocalDirsHandlerService dirsHandler) throws IOException,\n      InterruptedException {\n    \n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      \n      Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR);\n      createUserLocalDirs(localDirs, user);\n      createUserCacheDirs(localDirs, user);\n      createAppDirs(localDirs, user, appId);\n      createAppLogDirs(appId, logDirs, user);\n \n      Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n      \n      String tokenFn \u003d String.format(\n          ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n      Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n      copyFile(nmPrivateContainerTokens, tokenDst, user);\n \n      File cwdApp \u003d new File(appStorageDir.toString());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n      }\n      \n      List\u003cString\u003e command ;\n \n      command \u003d new ArrayList\u003cString\u003e();\n \n    //use same jvm as parent\n      File jvm \u003d new File(\n          new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n      command.add(jvm.toString());\n      \n      Path cwdPath \u003d new Path(cwdApp.getPath());\n      \n      // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n      // Passing CLASSPATH explicitly is *way* too long for command line.\n      String classPath \u003d System.getProperty(\"java.class.path\");\n      Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n      String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n          classpathJarPrivateDir, cwdPath, env);\n      String classPathJar \u003d localizeClasspathJar(\n          new Path(jarCp[0]), cwdPath, user).toString();\n      command.add(\"-classpath\");\n      command.add(classPathJar + jarCp[1]);\n \n      String javaLibPath \u003d System.getProperty(\"java.library.path\");\n      if (javaLibPath !\u003d null) {\n        command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n      }\n-     \n+     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n+\n      ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n          localDirs);\n      \n      String cmdLine \u003d StringUtils.join(command, \" \");\n      \n      String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n      \n      WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n          cwdApp.getAbsolutePath(), \n          localizerPid, user, \"nul:\", cmdLine);\n      try {\n        stubExecutor.execute();\n        stubExecutor.validateResult();\n      }\n      finally {\n        stubExecutor.close();\n        try\n        {\n          killContainer(localizerPid, Signal.KILL);\n        }\n        catch(Throwable e) {\n          LOG.warn(String.format(\n              \"An exception occured during the cleanup of localizer job %s:%n%s\", \n              localizerPid, \n              org.apache.hadoop.util.StringUtils.stringifyException(e)));\n        }\n      }\n    }\n\\ No newline at end of file\n",
      "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     LocalDirsHandlerService dirsHandler) throws IOException,\n     InterruptedException {\n   \n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n     \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n\n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n     \n     String tokenFn \u003d String.format(\n         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n     \n     List\u003cString\u003e command ;\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n   //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n\n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     command.addAll(ContainerLocalizer.getJavaOpts(getConf()));\n\n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n         localDirs);\n     \n     String cmdLine \u003d StringUtils.join(command, \" \");\n     \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n     \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(), \n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     }\n     finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occured during the cleanup of localizer job %s:%n%s\", \n             localizerPid, \n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "41a548a916d4248164cb9495320f123ec215d70e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2937. Fixed new findbugs warnings in hadoop-yarn-nodemanager. Contributed by Varun Saxena.\n",
      "commitDate": "23/12/14 8:32 PM",
      "commitName": "41a548a916d4248164cb9495320f123ec215d70e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "16/12/14 3:29 PM",
      "commitNameOld": "e996a1bfd4f3ada6cbd9633fe68fda1e0c910bdf",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 7.21,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n  public void startLocalizer(Path nmPrivateContainerTokens,\n      InetSocketAddress nmAddr, String user, String appId, String locId,\n      LocalDirsHandlerService dirsHandler) throws IOException,\n      InterruptedException {\n    \n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      \n      Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR);\n      createUserLocalDirs(localDirs, user);\n      createUserCacheDirs(localDirs, user);\n      createAppDirs(localDirs, user, appId);\n      createAppLogDirs(appId, logDirs, user);\n \n      Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n      \n      String tokenFn \u003d String.format(\n          ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n      Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n      copyFile(nmPrivateContainerTokens, tokenDst, user);\n \n      File cwdApp \u003d new File(appStorageDir.toString());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n      }\n      \n      List\u003cString\u003e command ;\n \n      command \u003d new ArrayList\u003cString\u003e();\n \n    //use same jvm as parent\n      File jvm \u003d new File(\n          new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n      command.add(jvm.toString());\n      \n      Path cwdPath \u003d new Path(cwdApp.getPath());\n      \n      // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n      // Passing CLASSPATH explicitly is *way* too long for command line.\n      String classPath \u003d System.getProperty(\"java.class.path\");\n      Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n      String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n          classpathJarPrivateDir, cwdPath, env);\n      String classPathJar \u003d localizeClasspathJar(\n          new Path(jarCp[0]), cwdPath, user).toString();\n      command.add(\"-classpath\");\n      command.add(classPathJar + jarCp[1]);\n \n      String javaLibPath \u003d System.getProperty(\"java.library.path\");\n      if (javaLibPath !\u003d null) {\n        command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n      }\n      \n      ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n          localDirs);\n      \n      String cmdLine \u003d StringUtils.join(command, \" \");\n      \n      String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n      \n      WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n          cwdApp.getAbsolutePath(), \n          localizerPid, user, \"nul:\", cmdLine);\n      try {\n        stubExecutor.execute();\n        stubExecutor.validateResult();\n      }\n      finally {\n        stubExecutor.close();\n        try\n        {\n          killContainer(localizerPid, Signal.KILL);\n        }\n        catch(Throwable e) {\n          LOG.warn(String.format(\n-             \"An exception occured during the cleanup of localizer job %s:\\n%s\", \n+             \"An exception occured during the cleanup of localizer job %s:%n%s\", \n              localizerPid, \n              org.apache.hadoop.util.StringUtils.stringifyException(e)));\n        }\n      }\n    }\n\\ No newline at end of file\n",
      "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     LocalDirsHandlerService dirsHandler) throws IOException,\n     InterruptedException {\n   \n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n     \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n\n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n     \n     String tokenFn \u003d String.format(\n         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n     \n     List\u003cString\u003e command ;\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n   //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n\n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n         localDirs);\n     \n     String cmdLine \u003d StringUtils.join(command, \" \");\n     \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n     \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(), \n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     }\n     finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occured during the cleanup of localizer job %s:%n%s\", \n             localizerPid, \n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
      "commitDate": "22/10/14 3:57 PM",
      "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "21/10/14 12:33 PM",
          "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.14,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,82 @@\n  public void startLocalizer(Path nmPrivateContainerTokens,\n      InetSocketAddress nmAddr, String user, String appId, String locId,\n-     List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n+     LocalDirsHandlerService dirsHandler) throws IOException,\n      InterruptedException {\n-\n+   \n+     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n+     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n+     \n+     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n+         ResourceLocalizationService.NM_PRIVATE_DIR);\n      createUserLocalDirs(localDirs, user);\n      createUserCacheDirs(localDirs, user);\n      createAppDirs(localDirs, user, appId);\n      createAppLogDirs(appId, logDirs, user);\n \n      Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n-\n-     String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n+     \n+     String tokenFn \u003d String.format(\n+         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n      Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n-     LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n      copyFile(nmPrivateContainerTokens, tokenDst, user);\n \n-     List\u003cString\u003e command ;\n-     String[] commandArray;\n-     ShellCommandExecutor shExec;\n-\n      File cwdApp \u003d new File(appStorageDir.toString());\n-     LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n+     if (LOG.isDebugEnabled()) {\n+       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n+     }\n+     \n+     List\u003cString\u003e command ;\n \n      command \u003d new ArrayList\u003cString\u003e();\n \n-     command.add(Shell.WINUTILS);\n-     command.add(\"task\");\n-     command.add(\"createAsUser\");\n-     command.add(\"START_LOCALIZER_\" + locId);\n-     command.add(user);\n-     command.add(\"nul:\"); // PID file    \n-   \n    //use same jvm as parent\n-     File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n+     File jvm \u003d new File(\n+         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n      command.add(jvm.toString());\n      \n+     Path cwdPath \u003d new Path(cwdApp.getPath());\n      \n      // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n      // Passing CLASSPATH explicitly is *way* too long for command line.\n      String classPath \u003d System.getProperty(\"java.class.path\");\n      Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n-     String[] jarCp \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n-     String classPathJar \u003d jarCp[0];\n-     localizeClasspathJar(new Path(classPathJar), user);\n-     String replacementClassPath \u003d classPathJar + jarCp[1];\n+     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n+         classpathJarPrivateDir, cwdPath, env);\n+     String classPathJar \u003d localizeClasspathJar(\n+         new Path(jarCp[0]), cwdPath, user).toString();\n      command.add(\"-classpath\");\n-     command.add(replacementClassPath);\n-     \n+     command.add(classPathJar + jarCp[1]);\n+\n      String javaLibPath \u003d System.getProperty(\"java.library.path\");\n      if (javaLibPath !\u003d null) {\n        command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n      }\n      \n-     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n-     commandArray \u003d command.toArray(new String[command.size()]);\n-\n-     shExec \u003d new ShellCommandExecutor(\n-         commandArray, cwdApp);\n-\n-     shExec.execute();\n+     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n+         localDirs);\n+     \n+     String cmdLine \u003d StringUtils.join(command, \" \");\n+     \n+     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n+     \n+     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n+         cwdApp.getAbsolutePath(), \n+         localizerPid, user, \"nul:\", cmdLine);\n+     try {\n+       stubExecutor.execute();\n+       stubExecutor.validateResult();\n+     }\n+     finally {\n+       stubExecutor.close();\n+       try\n+       {\n+         killContainer(localizerPid, Signal.KILL);\n+       }\n+       catch(Throwable e) {\n+         LOG.warn(String.format(\n+             \"An exception occured during the cleanup of localizer job %s:\\n%s\", \n+             localizerPid, \n+             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n+       }\n+     }\n    }\n\\ No newline at end of file\n",
          "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     LocalDirsHandlerService dirsHandler) throws IOException,\n     InterruptedException {\n   \n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n     \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n\n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n     \n     String tokenFn \u003d String.format(\n         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n     \n     List\u003cString\u003e command ;\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n   //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n\n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n         localDirs);\n     \n     String cmdLine \u003d StringUtils.join(command, \" \");\n     \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n     \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(), \n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     }\n     finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occured during the cleanup of localizer job %s:\\n%s\", \n             localizerPid, \n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[nmPrivateContainerTokens-Path, nmAddr-InetSocketAddress, user-String, appId-String, locId-String, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]",
            "newValue": "[nmPrivateContainerTokens-Path, nmAddr-InetSocketAddress, user-String, appId-String, locId-String, dirsHandler-LocalDirsHandlerService]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "21/10/14 12:33 PM",
          "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.14,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,82 @@\n  public void startLocalizer(Path nmPrivateContainerTokens,\n      InetSocketAddress nmAddr, String user, String appId, String locId,\n-     List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n+     LocalDirsHandlerService dirsHandler) throws IOException,\n      InterruptedException {\n-\n+   \n+     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n+     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n+     \n+     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n+         ResourceLocalizationService.NM_PRIVATE_DIR);\n      createUserLocalDirs(localDirs, user);\n      createUserCacheDirs(localDirs, user);\n      createAppDirs(localDirs, user, appId);\n      createAppLogDirs(appId, logDirs, user);\n \n      Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n-\n-     String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n+     \n+     String tokenFn \u003d String.format(\n+         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n      Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n-     LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n      copyFile(nmPrivateContainerTokens, tokenDst, user);\n \n-     List\u003cString\u003e command ;\n-     String[] commandArray;\n-     ShellCommandExecutor shExec;\n-\n      File cwdApp \u003d new File(appStorageDir.toString());\n-     LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n+     if (LOG.isDebugEnabled()) {\n+       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n+     }\n+     \n+     List\u003cString\u003e command ;\n \n      command \u003d new ArrayList\u003cString\u003e();\n \n-     command.add(Shell.WINUTILS);\n-     command.add(\"task\");\n-     command.add(\"createAsUser\");\n-     command.add(\"START_LOCALIZER_\" + locId);\n-     command.add(user);\n-     command.add(\"nul:\"); // PID file    \n-   \n    //use same jvm as parent\n-     File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n+     File jvm \u003d new File(\n+         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n      command.add(jvm.toString());\n      \n+     Path cwdPath \u003d new Path(cwdApp.getPath());\n      \n      // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n      // Passing CLASSPATH explicitly is *way* too long for command line.\n      String classPath \u003d System.getProperty(\"java.class.path\");\n      Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n-     String[] jarCp \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n-     String classPathJar \u003d jarCp[0];\n-     localizeClasspathJar(new Path(classPathJar), user);\n-     String replacementClassPath \u003d classPathJar + jarCp[1];\n+     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n+         classpathJarPrivateDir, cwdPath, env);\n+     String classPathJar \u003d localizeClasspathJar(\n+         new Path(jarCp[0]), cwdPath, user).toString();\n      command.add(\"-classpath\");\n-     command.add(replacementClassPath);\n-     \n+     command.add(classPathJar + jarCp[1]);\n+\n      String javaLibPath \u003d System.getProperty(\"java.library.path\");\n      if (javaLibPath !\u003d null) {\n        command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n      }\n      \n-     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n-     commandArray \u003d command.toArray(new String[command.size()]);\n-\n-     shExec \u003d new ShellCommandExecutor(\n-         commandArray, cwdApp);\n-\n-     shExec.execute();\n+     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n+         localDirs);\n+     \n+     String cmdLine \u003d StringUtils.join(command, \" \");\n+     \n+     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n+     \n+     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n+         cwdApp.getAbsolutePath(), \n+         localizerPid, user, \"nul:\", cmdLine);\n+     try {\n+       stubExecutor.execute();\n+       stubExecutor.validateResult();\n+     }\n+     finally {\n+       stubExecutor.close();\n+       try\n+       {\n+         killContainer(localizerPid, Signal.KILL);\n+       }\n+       catch(Throwable e) {\n+         LOG.warn(String.format(\n+             \"An exception occured during the cleanup of localizer job %s:\\n%s\", \n+             localizerPid, \n+             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n+       }\n+     }\n    }\n\\ No newline at end of file\n",
          "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     LocalDirsHandlerService dirsHandler) throws IOException,\n     InterruptedException {\n   \n     List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n     \n     Path classpathJarPrivateDir \u003d dirsHandler.getLocalPathForWrite(\n         ResourceLocalizationService.NM_PRIVATE_DIR);\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n\n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n     \n     String tokenFn \u003d String.format(\n         ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(String.format(\"cwdApp: %s\", cwdApp));\n     }\n     \n     List\u003cString\u003e command ;\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n   //use same jvm as parent\n     File jvm \u003d new File(\n         new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     Path cwdPath \u003d new Path(cwdApp.getPath());\n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String jarCp[] \u003d FileUtil.createJarWithClassPath(classPath, \n         classpathJarPrivateDir, cwdPath, env);\n     String classPathJar \u003d localizeClasspathJar(\n         new Path(jarCp[0]), cwdPath, user).toString();\n     command.add(\"-classpath\");\n     command.add(classPathJar + jarCp[1]);\n\n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, \n         localDirs);\n     \n     String cmdLine \u003d StringUtils.join(command, \" \");\n     \n     String localizerPid \u003d String.format(LOCALIZER_PID_FORMAT, locId);\n     \n     WintuilsProcessStubExecutor stubExecutor \u003d new WintuilsProcessStubExecutor(\n         cwdApp.getAbsolutePath(), \n         localizerPid, user, \"nul:\", cmdLine);\n     try {\n       stubExecutor.execute();\n       stubExecutor.validateResult();\n     }\n     finally {\n       stubExecutor.close();\n       try\n       {\n         killContainer(localizerPid, Signal.KILL);\n       }\n       catch(Throwable e) {\n         LOG.warn(String.format(\n             \"An exception occured during the cleanup of localizer job %s:\\n%s\", \n             localizerPid, \n             org.apache.hadoop.util.StringUtils.stringifyException(e)));\n       }\n     }\n   }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2720. Windows: Wildcard classpath variables not expanded against resources contained in archives. Contributed by Craig Welch.\n",
      "commitDate": "21/10/14 12:33 PM",
      "commitName": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "16/10/14 6:14 PM",
      "commitNameOld": "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 4.76,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,62 @@\n  public void startLocalizer(Path nmPrivateContainerTokens,\n      InetSocketAddress nmAddr, String user, String appId, String locId,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n      InterruptedException {\n \n      createUserLocalDirs(localDirs, user);\n      createUserCacheDirs(localDirs, user);\n      createAppDirs(localDirs, user, appId);\n      createAppLogDirs(appId, logDirs, user);\n \n      Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n      String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n      Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n      LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n      copyFile(nmPrivateContainerTokens, tokenDst, user);\n \n      List\u003cString\u003e command ;\n      String[] commandArray;\n      ShellCommandExecutor shExec;\n \n      File cwdApp \u003d new File(appStorageDir.toString());\n      LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n \n      command \u003d new ArrayList\u003cString\u003e();\n \n      command.add(Shell.WINUTILS);\n      command.add(\"task\");\n      command.add(\"createAsUser\");\n      command.add(\"START_LOCALIZER_\" + locId);\n      command.add(user);\n      command.add(\"nul:\"); // PID file    \n    \n    //use same jvm as parent\n      File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n      command.add(jvm.toString());\n      \n      \n      // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n      // Passing CLASSPATH explicitly is *way* too long for command line.\n      String classPath \u003d System.getProperty(\"java.class.path\");\n      Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n-     String classPathJar \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n+     String[] jarCp \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n+     String classPathJar \u003d jarCp[0];\n      localizeClasspathJar(new Path(classPathJar), user);\n+     String replacementClassPath \u003d classPathJar + jarCp[1];\n      command.add(\"-classpath\");\n-     command.add(classPathJar);\n+     command.add(replacementClassPath);\n      \n      String javaLibPath \u003d System.getProperty(\"java.library.path\");\n      if (javaLibPath !\u003d null) {\n        command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n      }\n      \n      ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n      commandArray \u003d command.toArray(new String[command.size()]);\n \n      shExec \u003d new ShellCommandExecutor(\n          commandArray, cwdApp);\n \n      shExec.execute();\n    }\n\\ No newline at end of file\n",
      "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n     InterruptedException {\n\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n\n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n     String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     List\u003cString\u003e command ;\n     String[] commandArray;\n     ShellCommandExecutor shExec;\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n     command.add(Shell.WINUTILS);\n     command.add(\"task\");\n     command.add(\"createAsUser\");\n     command.add(\"START_LOCALIZER_\" + locId);\n     command.add(user);\n     command.add(\"nul:\"); // PID file    \n   \n   //use same jvm as parent\n     File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String[] jarCp \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n     String classPathJar \u003d jarCp[0];\n     localizeClasspathJar(new Path(classPathJar), user);\n     String replacementClassPath \u003d classPathJar + jarCp[1];\n     command.add(\"-classpath\");\n     command.add(replacementClassPath);\n     \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n     commandArray \u003d command.toArray(new String[command.size()]);\n\n     shExec \u003d new ShellCommandExecutor(\n         commandArray, cwdApp);\n\n     shExec.execute();\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2682. Updated WindowsSecureContainerExecutor to not use DefaultContainerExecutor#getFirstApplicationDir and use getWorkingDir() instead. Contributed by Zhihai Xu\n",
      "commitDate": "16/10/14 6:14 PM",
      "commitName": "0fd0ebae645e671699f6a6a56a012ebe6dfb5b2a",
      "commitAuthor": "Jian He",
      "commitDateOld": "01/10/14 10:14 AM",
      "commitNameOld": "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.33,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,60 @@\n  public void startLocalizer(Path nmPrivateContainerTokens,\n      InetSocketAddress nmAddr, String user, String appId, String locId,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n      InterruptedException {\n \n      createUserLocalDirs(localDirs, user);\n      createUserCacheDirs(localDirs, user);\n      createAppDirs(localDirs, user, appId);\n      createAppLogDirs(appId, logDirs, user);\n-     \n-     // TODO: Why pick first app dir. The same in LCE why not random?\n-     Path appStorageDir \u003d getFirstApplicationDir(localDirs, user, appId);\n+\n+     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n \n      String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n      Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n      LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n      copyFile(nmPrivateContainerTokens, tokenDst, user);\n \n      List\u003cString\u003e command ;\n      String[] commandArray;\n      ShellCommandExecutor shExec;\n \n      File cwdApp \u003d new File(appStorageDir.toString());\n      LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n \n      command \u003d new ArrayList\u003cString\u003e();\n \n      command.add(Shell.WINUTILS);\n      command.add(\"task\");\n      command.add(\"createAsUser\");\n      command.add(\"START_LOCALIZER_\" + locId);\n      command.add(user);\n      command.add(\"nul:\"); // PID file    \n    \n    //use same jvm as parent\n      File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n      command.add(jvm.toString());\n      \n      \n      // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n      // Passing CLASSPATH explicitly is *way* too long for command line.\n      String classPath \u003d System.getProperty(\"java.class.path\");\n      Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n      String classPathJar \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n      localizeClasspathJar(new Path(classPathJar), user);\n      command.add(\"-classpath\");\n      command.add(classPathJar);\n      \n      String javaLibPath \u003d System.getProperty(\"java.library.path\");\n      if (javaLibPath !\u003d null) {\n        command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n      }\n      \n      ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n      commandArray \u003d command.toArray(new String[command.size()]);\n \n      shExec \u003d new ShellCommandExecutor(\n          commandArray, cwdApp);\n \n      shExec.execute();\n    }\n\\ No newline at end of file\n",
      "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n     InterruptedException {\n\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n\n     Path appStorageDir \u003d getWorkingDir(localDirs, user, appId);\n\n     String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     List\u003cString\u003e command ;\n     String[] commandArray;\n     ShellCommandExecutor shExec;\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n     command.add(Shell.WINUTILS);\n     command.add(\"task\");\n     command.add(\"createAsUser\");\n     command.add(\"START_LOCALIZER_\" + locId);\n     command.add(user);\n     command.add(\"nul:\"); // PID file    \n   \n   //use same jvm as parent\n     File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String classPathJar \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n     localizeClasspathJar(new Path(classPathJar), user);\n     command.add(\"-classpath\");\n     command.add(classPathJar);\n     \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n     commandArray \u003d command.toArray(new String[command.size()]);\n\n     shExec \u003d new ShellCommandExecutor(\n         commandArray, cwdApp);\n\n     shExec.execute();\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java",
      "extendedDetails": {}
    },
    "ba7f31c2ee8d23ecb183f88920ef06053c0b9769": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1972. Added a secure container-executor for Windows. Contributed by Remus Rusanu.\n",
      "commitDate": "01/10/14 10:14 AM",
      "commitName": "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,61 @@\n+ public void startLocalizer(Path nmPrivateContainerTokens,\n+     InetSocketAddress nmAddr, String user, String appId, String locId,\n+     List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n+     InterruptedException {\n+\n+     createUserLocalDirs(localDirs, user);\n+     createUserCacheDirs(localDirs, user);\n+     createAppDirs(localDirs, user, appId);\n+     createAppLogDirs(appId, logDirs, user);\n+     \n+     // TODO: Why pick first app dir. The same in LCE why not random?\n+     Path appStorageDir \u003d getFirstApplicationDir(localDirs, user, appId);\n+\n+     String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n+     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n+     LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n+     copyFile(nmPrivateContainerTokens, tokenDst, user);\n+\n+     List\u003cString\u003e command ;\n+     String[] commandArray;\n+     ShellCommandExecutor shExec;\n+\n+     File cwdApp \u003d new File(appStorageDir.toString());\n+     LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n+\n+     command \u003d new ArrayList\u003cString\u003e();\n+\n+     command.add(Shell.WINUTILS);\n+     command.add(\"task\");\n+     command.add(\"createAsUser\");\n+     command.add(\"START_LOCALIZER_\" + locId);\n+     command.add(user);\n+     command.add(\"nul:\"); // PID file    \n+   \n+   //use same jvm as parent\n+     File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n+     command.add(jvm.toString());\n+     \n+     \n+     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n+     // Passing CLASSPATH explicitly is *way* too long for command line.\n+     String classPath \u003d System.getProperty(\"java.class.path\");\n+     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n+     String classPathJar \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n+     localizeClasspathJar(new Path(classPathJar), user);\n+     command.add(\"-classpath\");\n+     command.add(classPathJar);\n+     \n+     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n+     if (javaLibPath !\u003d null) {\n+       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n+     }\n+     \n+     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n+     commandArray \u003d command.toArray(new String[command.size()]);\n+\n+     shExec \u003d new ShellCommandExecutor(\n+         commandArray, cwdApp);\n+\n+     shExec.execute();\n+   }\n\\ No newline at end of file\n",
      "actualSource": " public void startLocalizer(Path nmPrivateContainerTokens,\n     InetSocketAddress nmAddr, String user, String appId, String locId,\n     List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException,\n     InterruptedException {\n\n     createUserLocalDirs(localDirs, user);\n     createUserCacheDirs(localDirs, user);\n     createAppDirs(localDirs, user, appId);\n     createAppLogDirs(appId, logDirs, user);\n     \n     // TODO: Why pick first app dir. The same in LCE why not random?\n     Path appStorageDir \u003d getFirstApplicationDir(localDirs, user, appId);\n\n     String tokenFn \u003d String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);\n     Path tokenDst \u003d new Path(appStorageDir, tokenFn);\n     LOG.info(\"Copying from \" + nmPrivateContainerTokens + \" to \" + tokenDst);\n     copyFile(nmPrivateContainerTokens, tokenDst, user);\n\n     List\u003cString\u003e command ;\n     String[] commandArray;\n     ShellCommandExecutor shExec;\n\n     File cwdApp \u003d new File(appStorageDir.toString());\n     LOG.info(String.format(\"cwdApp: %s\", cwdApp));\n\n     command \u003d new ArrayList\u003cString\u003e();\n\n     command.add(Shell.WINUTILS);\n     command.add(\"task\");\n     command.add(\"createAsUser\");\n     command.add(\"START_LOCALIZER_\" + locId);\n     command.add(user);\n     command.add(\"nul:\"); // PID file    \n   \n   //use same jvm as parent\n     File jvm \u003d new File(new File(System.getProperty(\"java.home\"), \"bin\"), \"java.exe\");\n     command.add(jvm.toString());\n     \n     \n     // Build a temp classpath jar. See ContainerLaunch.sanitizeEnv().\n     // Passing CLASSPATH explicitly is *way* too long for command line.\n     String classPath \u003d System.getProperty(\"java.class.path\");\n     Map\u003cString, String\u003e env \u003d new HashMap\u003cString, String\u003e(System.getenv());\n     String classPathJar \u003d FileUtil.createJarWithClassPath(classPath, appStorageDir, env);\n     localizeClasspathJar(new Path(classPathJar), user);\n     command.add(\"-classpath\");\n     command.add(classPathJar);\n     \n     String javaLibPath \u003d System.getProperty(\"java.library.path\");\n     if (javaLibPath !\u003d null) {\n       command.add(\"-Djava.library.path\u003d\" + javaLibPath);\n     }\n     \n     ContainerLocalizer.buildMainArgs(command, user, appId, locId, nmAddr, localDirs);\n     commandArray \u003d command.toArray(new String[command.size()]);\n\n     shExec \u003d new ShellCommandExecutor(\n         commandArray, cwdApp);\n\n     shExec.execute();\n   }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/WindowsSecureContainerExecutor.java"
    }
  }
}