{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "processMisReplicatesAsync",
  "functionId": "processMisReplicatesAsync",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 3652,
  "functionEndLine": 3730,
  "numCommitsSeen": 477,
  "timeTaken": 14774,
  "changeHistory": [
    "a7f085d6bf499edf23e650a4f7211c53a442da0e",
    "4484b48498b2ab2a40a404c487c7a4e875df10dc",
    "32d043d9c5f4615058ea4f65a58ba271ba47fcb5",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "89b07490f8354bb83a67b7ffc917bfe99708e615"
  ],
  "changeHistoryShort": {
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": "Ybodychange",
    "4484b48498b2ab2a40a404c487c7a4e875df10dc": "Ybodychange",
    "32d043d9c5f4615058ea4f65a58ba271ba47fcb5": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "89b07490f8354bb83a67b7ffc917bfe99708e615": "Ybodychange"
  },
  "changeHistoryDetails": {
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11832. Switch leftover logs to slf4j format in BlockManager.java. Contributed by Hui Xu and Chen Liang.\n",
      "commitDate": "29/05/17 1:30 AM",
      "commitName": "a7f085d6bf499edf23e650a4f7211c53a442da0e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,79 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n     Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     reconstructionQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n           BlockInfo block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           switch (res) {\n           case UNDER_REPLICATED:\n             LOG.trace(\"under replicated block {}: {}\", block, res);\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             LOG.trace(\"over replicated block {}: {}\", block, res);\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             LOG.trace(\"invalid block {}: {}\", block, res);\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             LOG.trace(\"postpone block {}: {}\", block, res);\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             LOG.trace(\"under construction block {}: {}\", block, res);\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         reconstructionQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n-          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n-          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n-          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n-          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n-              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n-          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n+          LOG.info(\"Total number of blocks            \u003d {}\", blocksMap.size());\n+          LOG.info(\"Number of invalid blocks          \u003d {}\", nrInvalid);\n+          LOG.info(\"Number of under-replicated blocks \u003d {}\", nrUnderReplicated);\n+          LOG.info(\"Number of  over-replicated blocks \u003d {}{}\", nrOverReplicated,\n+              ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n+          LOG.info(\"Number of blocks being written    \u003d {}\",\n+                   nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \"\n                   + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    reconstructionQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfo block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          switch (res) {\n          case UNDER_REPLICATED:\n            LOG.trace(\"under replicated block {}: {}\", block, res);\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            LOG.trace(\"over replicated block {}: {}\", block, res);\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            LOG.trace(\"invalid block {}: {}\", block, res);\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            LOG.trace(\"postpone block {}: {}\", block, res);\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            LOG.trace(\"under construction block {}: {}\", block, res);\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        reconstructionQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d {}\", blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d {}\", nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d {}\", nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d {}{}\", nrOverReplicated,\n              ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d {}\",\n                   nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \"\n                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4484b48498b2ab2a40a404c487c7a4e875df10dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10941. Improve BlockManager#processMisReplicatesAsync log. Contributed by Chen Liang.\n",
      "commitDate": "11/11/16 2:31 PM",
      "commitName": "4484b48498b2ab2a40a404c487c7a4e875df10dc",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "17/10/16 5:45 PM",
      "commitNameOld": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 24.91,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,78 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n     Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     reconstructionQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n           BlockInfo block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"block \" + block + \": \" + res);\n-          }\n           switch (res) {\n           case UNDER_REPLICATED:\n+            LOG.trace(\"under replicated block {}: {}\", block, res);\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n+            LOG.trace(\"over replicated block {}: {}\", block, res);\n             nrOverReplicated++;\n             break;\n           case INVALID:\n+            LOG.trace(\"invalid block {}: {}\", block, res);\n             nrInvalid++;\n             break;\n           case POSTPONE:\n+            LOG.trace(\"postpone block {}: {}\", block, res);\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n+            LOG.trace(\"under construction block {}: {}\", block, res);\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         reconstructionQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \"\n                   + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    reconstructionQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfo block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          switch (res) {\n          case UNDER_REPLICATED:\n            LOG.trace(\"under replicated block {}: {}\", block, res);\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            LOG.trace(\"over replicated block {}: {}\", block, res);\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            LOG.trace(\"invalid block {}: {}\", block, res);\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            LOG.trace(\"postpone block {}: {}\", block, res);\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            LOG.trace(\"under construction block {}: {}\", block, res);\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        reconstructionQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \"\n                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "32d043d9c5f4615058ea4f65a58ba271ba47fcb5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9857. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-1]. Contributed by Rakesh R.\n",
      "commitDate": "16/03/16 4:53 PM",
      "commitName": "32d043d9c5f4615058ea4f65a58ba271ba47fcb5",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "10/03/16 7:03 PM",
      "commitNameOld": "e01c6ea688e62f25c4310e771a0cd85b53a5fb87",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 5.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n     Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n-    replicationQueuesInitProgress \u003d 0;\n+    reconstructionQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n           BlockInfo block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"block \" + block + \": \" + res);\n           }\n           switch (res) {\n           case UNDER_REPLICATED:\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n-        replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n+        reconstructionQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \"\n                   + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    reconstructionQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfo block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"block \" + block + \": \" + res);\n          }\n          switch (res) {\n          case UNDER_REPLICATED:\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        reconstructionQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \"\n                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n-    Iterator\u003cBlockInfoContiguous\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n+    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     replicationQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n-          BlockInfoContiguous block \u003d blocksItr.next();\n+          BlockInfo block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"block \" + block + \": \" + res);\n           }\n           switch (res) {\n           case UNDER_REPLICATED:\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \"\n                   + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    replicationQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfo block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"block \" + block + \": \" + res);\n          }\n          switch (res) {\n          case UNDER_REPLICATED:\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \"\n                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:03 AM",
      "commitNameOld": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n-    Iterator\u003cBlockInfoContiguous\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n+    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     replicationQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n-          BlockInfoContiguous block \u003d blocksItr.next();\n+          BlockInfo block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"block \" + block + \": \" + res);\n           }\n           switch (res) {\n           case UNDER_REPLICATED:\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \"\n                   + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    replicationQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfo block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"block \" + block + \": \" + res);\n          }\n          switch (res) {\n          case UNDER_REPLICATED:\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \"\n                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "19/03/15 2:29 PM",
      "commitNameOld": "978ef11f26794c22c7289582653b32268478e23e",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,76 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n-    long startTimeMisReplicatedScan \u003d Time.now();\n+    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n     Iterator\u003cBlockInfoContiguous\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     replicationQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n           BlockInfoContiguous block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"block \" + block + \": \" + res);\n           }\n           switch (res) {\n           case UNDER_REPLICATED:\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n-                  + \"completed in \" + (Time.now() - startTimeMisReplicatedScan)\n+                  + \"completed in \"\n+                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.monotonicNow();\n    Iterator\u003cBlockInfoContiguous\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    replicationQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfoContiguous block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"block \" + block + \": \" + res);\n          }\n          switch (res) {\n          case UNDER_REPLICATED:\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \"\n                  + (Time.monotonicNow() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/02/15 11:31 AM",
      "commitNameOld": "9175105eeaecf0a1d60b57989b73ce45cee4689b",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.now();\n-    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n+    Iterator\u003cBlockInfoContiguous\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     replicationQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n     long sleepDuration \u003d\n         Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n \n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n-          BlockInfo block \u003d blocksItr.next();\n+          BlockInfoContiguous block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"block \" + block + \": \" + res);\n           }\n           switch (res) {\n           case UNDER_REPLICATED:\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \" + (Time.now() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n         // Make sure it is out of the write lock for sufficiently long time.\n         Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.now();\n    Iterator\u003cBlockInfoContiguous\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    replicationQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfoContiguous block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"block \" + block + \": \" + res);\n          }\n          switch (res) {\n          case UNDER_REPLICATED:\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \" + (Time.now() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "89b07490f8354bb83a67b7ffc917bfe99708e615": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7603. The background replication queue initialization may not let others run. Contributed by Kihwal Lee.\n",
      "commitDate": "29/01/15 10:36 AM",
      "commitName": "89b07490f8354bb83a67b7ffc917bfe99708e615",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "13/01/15 4:10 PM",
      "commitNameOld": "85aec75ce53445e1abf840076d2e10f1e3c6d69b",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 15.77,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,75 @@\n   private void processMisReplicatesAsync() throws InterruptedException {\n     long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n     long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n     long startTimeMisReplicatedScan \u003d Time.now();\n     Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n     long totalBlocks \u003d blocksMap.size();\n     replicationQueuesInitProgress \u003d 0;\n     long totalProcessed \u003d 0;\n+    long sleepDuration \u003d\n+        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n+\n     while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n       int processed \u003d 0;\n       namesystem.writeLockInterruptibly();\n       try {\n         while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n           BlockInfo block \u003d blocksItr.next();\n           MisReplicationResult res \u003d processMisReplicatedBlock(block);\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"block \" + block + \": \" + res);\n           }\n           switch (res) {\n           case UNDER_REPLICATED:\n             nrUnderReplicated++;\n             break;\n           case OVER_REPLICATED:\n             nrOverReplicated++;\n             break;\n           case INVALID:\n             nrInvalid++;\n             break;\n           case POSTPONE:\n             nrPostponed++;\n             postponeBlock(block);\n             break;\n           case UNDER_CONSTRUCTION:\n             nrUnderConstruction++;\n             break;\n           case OK:\n             break;\n           default:\n             throw new AssertionError(\"Invalid enum value: \" + res);\n           }\n           processed++;\n         }\n         totalProcessed +\u003d processed;\n         // there is a possibility that if any of the blocks deleted/added during\n         // initialisation, then progress might be different.\n         replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n             / totalBlocks, 1.0);\n \n         if (!blocksItr.hasNext()) {\n           LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n           LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n           LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n           LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n               + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n           LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n           NameNode.stateChangeLog\n               .info(\"STATE* Replication Queue initialization \"\n                   + \"scan for invalid, over- and under-replicated blocks \"\n                   + \"completed in \" + (Time.now() - startTimeMisReplicatedScan)\n                   + \" msec\");\n           break;\n         }\n       } finally {\n         namesystem.writeUnlock();\n+        // Make sure it is out of the write lock for sufficiently long time.\n+        Thread.sleep(sleepDuration);\n       }\n     }\n     if (Thread.currentThread().isInterrupted()) {\n       LOG.info(\"Interrupted while processing replication queues.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processMisReplicatesAsync() throws InterruptedException {\n    long nrInvalid \u003d 0, nrOverReplicated \u003d 0;\n    long nrUnderReplicated \u003d 0, nrPostponed \u003d 0, nrUnderConstruction \u003d 0;\n    long startTimeMisReplicatedScan \u003d Time.now();\n    Iterator\u003cBlockInfo\u003e blocksItr \u003d blocksMap.getBlocks().iterator();\n    long totalBlocks \u003d blocksMap.size();\n    replicationQueuesInitProgress \u003d 0;\n    long totalProcessed \u003d 0;\n    long sleepDuration \u003d\n        Math.max(1, Math.min(numBlocksPerIteration/1000, 10000));\n\n    while (namesystem.isRunning() \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n      int processed \u003d 0;\n      namesystem.writeLockInterruptibly();\n      try {\n        while (processed \u003c numBlocksPerIteration \u0026\u0026 blocksItr.hasNext()) {\n          BlockInfo block \u003d blocksItr.next();\n          MisReplicationResult res \u003d processMisReplicatedBlock(block);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"block \" + block + \": \" + res);\n          }\n          switch (res) {\n          case UNDER_REPLICATED:\n            nrUnderReplicated++;\n            break;\n          case OVER_REPLICATED:\n            nrOverReplicated++;\n            break;\n          case INVALID:\n            nrInvalid++;\n            break;\n          case POSTPONE:\n            nrPostponed++;\n            postponeBlock(block);\n            break;\n          case UNDER_CONSTRUCTION:\n            nrUnderConstruction++;\n            break;\n          case OK:\n            break;\n          default:\n            throw new AssertionError(\"Invalid enum value: \" + res);\n          }\n          processed++;\n        }\n        totalProcessed +\u003d processed;\n        // there is a possibility that if any of the blocks deleted/added during\n        // initialisation, then progress might be different.\n        replicationQueuesInitProgress \u003d Math.min((double) totalProcessed\n            / totalBlocks, 1.0);\n\n        if (!blocksItr.hasNext()) {\n          LOG.info(\"Total number of blocks            \u003d \" + blocksMap.size());\n          LOG.info(\"Number of invalid blocks          \u003d \" + nrInvalid);\n          LOG.info(\"Number of under-replicated blocks \u003d \" + nrUnderReplicated);\n          LOG.info(\"Number of  over-replicated blocks \u003d \" + nrOverReplicated\n              + ((nrPostponed \u003e 0) ? (\" (\" + nrPostponed + \" postponed)\") : \"\"));\n          LOG.info(\"Number of blocks being written    \u003d \" + nrUnderConstruction);\n          NameNode.stateChangeLog\n              .info(\"STATE* Replication Queue initialization \"\n                  + \"scan for invalid, over- and under-replicated blocks \"\n                  + \"completed in \" + (Time.now() - startTimeMisReplicatedScan)\n                  + \" msec\");\n          break;\n        }\n      } finally {\n        namesystem.writeUnlock();\n        // Make sure it is out of the write lock for sufficiently long time.\n        Thread.sleep(sleepDuration);\n      }\n    }\n    if (Thread.currentThread().isInterrupted()) {\n      LOG.info(\"Interrupted while processing replication queues.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    }
  }
}