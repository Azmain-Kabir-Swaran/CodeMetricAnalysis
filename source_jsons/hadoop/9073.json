{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "internalReleaseLease",
  "functionId": "internalReleaseLease___lease-Lease__src-String__iip-INodesInPath__recoveryLeaseHolder-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 3612,
  "functionEndLine": 3751,
  "numCommitsSeen": 1383,
  "timeTaken": 64659,
  "changeHistory": [
    "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87",
    "42307e3c3abbfe0b83d9a2581deba327435b910f",
    "53bbef3802194b7a0a3ce5cd3c91def9e88856e3",
    "5304698dc8c5667c33e6ed9c4a827ef57172a723",
    "2b5ad48762587abbcd8bdb50d0ae98f8080d926c",
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "ae047655f4355288406cd5396fb4e3ea7c307b14",
    "bd909ed9f2d853f614f04a50e2230a7932732776",
    "c304890c8c7782d835896859f5b7f60b96c306c0",
    "164cbe643988f878f0f4100a4de51783e5b6738e",
    "bdd79388f39f4f35af7decd5703eff587b0ddfb7",
    "e535e0f05b5fbd087c93238deb888cc985254b4c",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
    "5137b388fc9d4d716f780daf6d04292feeb9df96",
    "e4f756260f16156179ba4adad974ec92279c2fac",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "146ce7a9784e52432b76164009336a4b2cf2860e",
    "abf833a7b228fff2bca4f69cd9df99d532380038",
    "1e1e93040748231dc913190aec1e031c379d8271",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f",
    "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "571e9c623241106dad5521a870fb8daef3f2b00a",
    "f36f0dde8866e2233dad26b38a8d432d2302a51a",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "ce68f410b05a58ad05965f32ad7f5b246b363a75",
    "f26d2adbf98890cfe350c17241f5049b89a11e3c",
    "3f070e83b1f4e0211ece8c0ab508a61188ad352a",
    "6770de7ec4f73e16740f1723f4e35d2fef2c22c8",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16",
    "9821af9ce8a56a2c583f1ed938902c20e897048f",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "ba2ee1d7fb91462c861169224d250d2d90bec3a6",
    "d69510a7f8b3a86cbf0175a6ff2e28ac82707924",
    "b7cd8c0f865e88e40eee75fd2690b1fdc4155071",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87": "Ybodychange",
    "42307e3c3abbfe0b83d9a2581deba327435b910f": "Ybodychange",
    "53bbef3802194b7a0a3ce5cd3c91def9e88856e3": "Ybodychange",
    "5304698dc8c5667c33e6ed9c4a827ef57172a723": "Ybodychange",
    "2b5ad48762587abbcd8bdb50d0ae98f8080d926c": "Ybodychange",
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "ae047655f4355288406cd5396fb4e3ea7c307b14": "Ybodychange",
    "bd909ed9f2d853f614f04a50e2230a7932732776": "Ybodychange",
    "c304890c8c7782d835896859f5b7f60b96c306c0": "Ybodychange",
    "164cbe643988f878f0f4100a4de51783e5b6738e": "Ybodychange",
    "bdd79388f39f4f35af7decd5703eff587b0ddfb7": "Ybodychange",
    "e535e0f05b5fbd087c93238deb888cc985254b4c": "Ybodychange",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": "Ybodychange",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": "Ybodychange",
    "5137b388fc9d4d716f780daf6d04292feeb9df96": "Ybodychange",
    "e4f756260f16156179ba4adad974ec92279c2fac": "Ybodychange",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": "Ybodychange",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "146ce7a9784e52432b76164009336a4b2cf2860e": "Ybodychange",
    "abf833a7b228fff2bca4f69cd9df99d532380038": "Ybodychange",
    "1e1e93040748231dc913190aec1e031c379d8271": "Ybodychange",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Ybodychange",
    "7e9358feb326d48b8c4f00249e7af5023cebd2e2": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "571e9c623241106dad5521a870fb8daef3f2b00a": "Ybodychange",
    "f36f0dde8866e2233dad26b38a8d432d2302a51a": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "ce68f410b05a58ad05965f32ad7f5b246b363a75": "Ybodychange",
    "f26d2adbf98890cfe350c17241f5049b89a11e3c": "Ybodychange",
    "3f070e83b1f4e0211ece8c0ab508a61188ad352a": "Ybodychange",
    "6770de7ec4f73e16740f1723f4e35d2fef2c22c8": "Ybodychange",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": "Ybodychange",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": "Ybodychange",
    "9821af9ce8a56a2c583f1ed938902c20e897048f": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "ba2ee1d7fb91462c861169224d250d2d90bec3a6": "Ybodychange",
    "d69510a7f8b3a86cbf0175a6ff2e28ac82707924": "Ybodychange",
    "b7cd8c0f865e88e40eee75fd2690b1fdc4155071": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12884. BlockUnderConstructionFeature.truncateBlock should be of type BlockInfo. Contributed by chencan.",
      "commitDate": "21/03/18 4:46 PM",
      "commitName": "8d898ab25f1c2032a07c9bbd96ba3d0c4eb5be87",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "13/03/18 4:39 PM",
      "commitNameOld": "9714fc1dd48edb1c40d96d69ae82ed3b0fab7748",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.0,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\" +\n           \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n           \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\" +\n             \" internalReleaseLease: Committed blocks are minimally\" +\n             \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n-      Block recoveryBlock \u003d uc.getTruncateBlock();\n+      BlockInfo recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.getBlockType());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n       // Start recovery of the last block for this file\n       // Only do so if there is no ongoing recovery for this block,\n       // or the previous recovery for this block timed out.\n       if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n         long blockRecoveryId \u003d nextGenerationStamp(\n             blockManager.isLegacyBlock(lastBlock));\n         if(copyOnTruncate) {\n           lastBlock.setGenerationStamp(blockRecoveryId);\n         } else if(truncateRecovery) {\n           recoveryBlock.setGenerationStamp(blockRecoveryId);\n         }\n         uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n \n         // Cannot close file right now, since the last block requires recovery.\n         // This may potentially cause infinite loop in lease recovery\n         // if there are no valid replicas on data-nodes.\n         NameNode.stateChangeLog.warn(\n             \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                 \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       }\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       leaseManager.renewLease(lease);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      BlockInfo recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.getBlockType());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // Start recovery of the last block for this file\n      // Only do so if there is no ongoing recovery for this block,\n      // or the previous recovery for this block timed out.\n      if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n        long blockRecoveryId \u003d nextGenerationStamp(\n            blockManager.isLegacyBlock(lastBlock));\n        if(copyOnTruncate) {\n          lastBlock.setGenerationStamp(blockRecoveryId);\n        } else if(truncateRecovery) {\n          recoveryBlock.setGenerationStamp(blockRecoveryId);\n        }\n        uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n\n        // Cannot close file right now, since the last block requires recovery.\n        // This may potentially cause infinite loop in lease recovery\n        // if there are no valid replicas on data-nodes.\n        NameNode.stateChangeLog.warn(\n            \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      }\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      leaseManager.renewLease(lease);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "42307e3c3abbfe0b83d9a2581deba327435b910f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11576. Block recovery will fail indefinitely if recovery time \u003e heartbeat interval. Contributed by Lukas Majercak\n",
      "commitDate": "01/12/17 10:34 PM",
      "commitName": "42307e3c3abbfe0b83d9a2581deba327435b910f",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "01/12/17 11:19 AM",
      "commitNameOld": "53bbef3802194b7a0a3ce5cd3c91def9e88856e3",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 0.47,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,140 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\" +\n           \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n           \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\" +\n             \" internalReleaseLease: Committed blocks are minimally\" +\n             \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.getBlockType());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n-      // start recovery of the last block for this file\n-      long blockRecoveryId \u003d nextGenerationStamp(\n-          blockManager.isLegacyBlock(lastBlock));\n-      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n-      if(copyOnTruncate) {\n-        lastBlock.setGenerationStamp(blockRecoveryId);\n-      } else if(truncateRecovery) {\n-        recoveryBlock.setGenerationStamp(blockRecoveryId);\n-      }\n-      uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n-      leaseManager.renewLease(lease);\n-      // Cannot close file right now, since the last block requires recovery.\n-      // This may potentially cause infinite loop in lease recovery\n-      // if there are no valid replicas on data-nodes.\n-      NameNode.stateChangeLog.warn(\n-                \"DIR* NameSystem.internalReleaseLease: \" +\n+      // Start recovery of the last block for this file\n+      // Only do so if there is no ongoing recovery for this block,\n+      // or the previous recovery for this block timed out.\n+      if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n+        long blockRecoveryId \u003d nextGenerationStamp(\n+            blockManager.isLegacyBlock(lastBlock));\n+        if(copyOnTruncate) {\n+          lastBlock.setGenerationStamp(blockRecoveryId);\n+        } else if(truncateRecovery) {\n+          recoveryBlock.setGenerationStamp(blockRecoveryId);\n+        }\n+        uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n+\n+        // Cannot close file right now, since the last block requires recovery.\n+        // This may potentially cause infinite loop in lease recovery\n+        // if there are no valid replicas on data-nodes.\n+        NameNode.stateChangeLog.warn(\n+            \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n-               \" Lease recovery is in progress. \" +\n+                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n+      }\n+      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n+      leaseManager.renewLease(lease);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.getBlockType());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // Start recovery of the last block for this file\n      // Only do so if there is no ongoing recovery for this block,\n      // or the previous recovery for this block timed out.\n      if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n        long blockRecoveryId \u003d nextGenerationStamp(\n            blockManager.isLegacyBlock(lastBlock));\n        if(copyOnTruncate) {\n          lastBlock.setGenerationStamp(blockRecoveryId);\n        } else if(truncateRecovery) {\n          recoveryBlock.setGenerationStamp(blockRecoveryId);\n        }\n        uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n\n        // Cannot close file right now, since the last block requires recovery.\n        // This may potentially cause infinite loop in lease recovery\n        // if there are no valid replicas on data-nodes.\n        NameNode.stateChangeLog.warn(\n            \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      }\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      leaseManager.renewLease(lease);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "53bbef3802194b7a0a3ce5cd3c91def9e88856e3": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11576. Block recovery will fail indefinitely if recovery time \u003e heartbeat interval. Contributed by Lukas Majercak\"\n\nThis reverts commit 5304698dc8c5667c33e6ed9c4a827ef57172a723.\n",
      "commitDate": "01/12/17 11:19 AM",
      "commitName": "53bbef3802194b7a0a3ce5cd3c91def9e88856e3",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "01/12/17 10:29 AM",
      "commitNameOld": "5304698dc8c5667c33e6ed9c4a827ef57172a723",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\" +\n           \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n           \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\" +\n             \" internalReleaseLease: Committed blocks are minimally\" +\n             \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.getBlockType());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n-      // Start recovery of the last block for this file\n-      // Only do so if there is no ongoing recovery for this block,\n-      // or the previous recovery for this block timed out.\n-      if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n-        long blockRecoveryId \u003d nextGenerationStamp(\n-            blockManager.isLegacyBlock(lastBlock));\n-        if(copyOnTruncate) {\n-          lastBlock.setGenerationStamp(blockRecoveryId);\n-        } else if(truncateRecovery) {\n-          recoveryBlock.setGenerationStamp(blockRecoveryId);\n-        }\n-        uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n-\n-        // Cannot close file right now, since the last block requires recovery.\n-        // This may potentially cause infinite loop in lease recovery\n-        // if there are no valid replicas on data-nodes.\n-        NameNode.stateChangeLog.warn(\n-            \"DIR* NameSystem.internalReleaseLease: \" +\n-                \"File \" + src + \" has not been closed.\" +\n-                \" Lease recovery is in progress. \" +\n-                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n-      }\n+      // start recovery of the last block for this file\n+      long blockRecoveryId \u003d nextGenerationStamp(\n+          blockManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n+      if(copyOnTruncate) {\n+        lastBlock.setGenerationStamp(blockRecoveryId);\n+      } else if(truncateRecovery) {\n+        recoveryBlock.setGenerationStamp(blockRecoveryId);\n+      }\n+      uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n       leaseManager.renewLease(lease);\n+      // Cannot close file right now, since the last block requires recovery.\n+      // This may potentially cause infinite loop in lease recovery\n+      // if there are no valid replicas on data-nodes.\n+      NameNode.stateChangeLog.warn(\n+                \"DIR* NameSystem.internalReleaseLease: \" +\n+                \"File \" + src + \" has not been closed.\" +\n+               \" Lease recovery is in progress. \" +\n+                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.getBlockType());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5304698dc8c5667c33e6ed9c4a827ef57172a723": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11576. Block recovery will fail indefinitely if recovery time \u003e heartbeat interval. Contributed by Lukas Majercak\n",
      "commitDate": "01/12/17 10:29 AM",
      "commitName": "5304698dc8c5667c33e6ed9c4a827ef57172a723",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "30/11/17 12:18 PM",
      "commitNameOld": "b1c7654ee40b372ed777525a42981c7cf55b5c72",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,140 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\" +\n           \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n           \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\" +\n             \" internalReleaseLease: Committed blocks are minimally\" +\n             \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.getBlockType());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n-      // start recovery of the last block for this file\n-      long blockRecoveryId \u003d nextGenerationStamp(\n-          blockManager.isLegacyBlock(lastBlock));\n-      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n-      if(copyOnTruncate) {\n-        lastBlock.setGenerationStamp(blockRecoveryId);\n-      } else if(truncateRecovery) {\n-        recoveryBlock.setGenerationStamp(blockRecoveryId);\n-      }\n-      uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n-      leaseManager.renewLease(lease);\n-      // Cannot close file right now, since the last block requires recovery.\n-      // This may potentially cause infinite loop in lease recovery\n-      // if there are no valid replicas on data-nodes.\n-      NameNode.stateChangeLog.warn(\n-                \"DIR* NameSystem.internalReleaseLease: \" +\n+      // Start recovery of the last block for this file\n+      // Only do so if there is no ongoing recovery for this block,\n+      // or the previous recovery for this block timed out.\n+      if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n+        long blockRecoveryId \u003d nextGenerationStamp(\n+            blockManager.isLegacyBlock(lastBlock));\n+        if(copyOnTruncate) {\n+          lastBlock.setGenerationStamp(blockRecoveryId);\n+        } else if(truncateRecovery) {\n+          recoveryBlock.setGenerationStamp(blockRecoveryId);\n+        }\n+        uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n+\n+        // Cannot close file right now, since the last block requires recovery.\n+        // This may potentially cause infinite loop in lease recovery\n+        // if there are no valid replicas on data-nodes.\n+        NameNode.stateChangeLog.warn(\n+            \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n-               \" Lease recovery is in progress. \" +\n+                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n+      }\n+      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n+      leaseManager.renewLease(lease);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.getBlockType());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // Start recovery of the last block for this file\n      // Only do so if there is no ongoing recovery for this block,\n      // or the previous recovery for this block timed out.\n      if (blockManager.addBlockRecoveryAttempt(lastBlock)) {\n        long blockRecoveryId \u003d nextGenerationStamp(\n            blockManager.isLegacyBlock(lastBlock));\n        if(copyOnTruncate) {\n          lastBlock.setGenerationStamp(blockRecoveryId);\n        } else if(truncateRecovery) {\n          recoveryBlock.setGenerationStamp(blockRecoveryId);\n        }\n        uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n\n        // Cannot close file right now, since the last block requires recovery.\n        // This may potentially cause infinite loop in lease recovery\n        // if there are no valid replicas on data-nodes.\n        NameNode.stateChangeLog.warn(\n            \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      }\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      leaseManager.renewLease(lease);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2b5ad48762587abbcd8bdb50d0ae98f8080d926c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11817. A faulty node can cause a lease leak and NPE on accessing data. Contributed by Kihwal Lee.\n",
      "commitDate": "25/05/17 3:17 PM",
      "commitName": "2b5ad48762587abbcd8bdb50d0ae98f8080d926c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\" +\n           \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n           \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\" +\n             \" internalReleaseLease: Committed blocks are minimally\" +\n             \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.getBlockType());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(\n           blockManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n-      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n+      uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.getBlockType());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId, true);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "10/01/17 8:12 PM",
      "commitNameOld": "467f5f1735494c5ef74e6591069884d3771c17e4",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 7.72,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\" +\n           \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n           \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\" +\n             \" internalReleaseLease: Committed blocks are minimally\" +\n             \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n-            lastBlock.isStriped());\n+            lastBlock.getBlockType());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(\n           blockManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.getBlockType());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ae047655f4355288406cd5396fb4e3ea7c307b14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10220. A large number of expired leases can make namenode unresponsive and cause failover (Nicolas Fraison via raviprak)\n",
      "commitDate": "08/06/16 1:44 PM",
      "commitName": "ae047655f4355288406cd5396fb4e3ea7c307b14",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "02/06/16 1:14 PM",
      "commitNameOld": "97e244947719d483c3f80521a00fec8e13dcb637",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 6.02,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId(), false);\n-      NameNode.stateChangeLog.warn(\"BLOCK*\"\n-        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n-        + \" lease removed, file closed.\");\n+      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n+          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n+          \" lease removed, file \" + src + \" closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n-        NameNode.stateChangeLog.warn(\"BLOCK*\"\n-          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n-          + \" lease removed, file closed.\");\n+        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n+            \" internalReleaseLease: Committed blocks are minimally\" +\n+            \" replicated, lease removed, file\" + src + \" closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.isStriped());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n-            + \"Removed empty last block and closed file.\");\n+            + \"Removed empty last block and closed file \" + src);\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(\n           blockManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\" +\n          \" internalReleaseLease: All existing blocks are COMPLETE,\" +\n          \" lease removed, file \" + src + \" closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\" +\n            \" internalReleaseLease: Committed blocks are minimally\" +\n            \" replicated, lease removed, file\" + src + \" closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.isStriped());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file \" + src);\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "bd909ed9f2d853f614f04a50e2230a7932732776": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8999. Allow a file to be closed with COMMITTED but not yet COMPLETE blocks.\n",
      "commitDate": "25/01/16 6:32 PM",
      "commitName": "bd909ed9f2d853f614f04a50e2230a7932732776",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "24/01/16 2:19 PM",
      "commitNameOld": "10a2bc0dffaece216eb9a6bac3236a086b9ece31",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 1.18,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n-          iip.getLatestSnapshotId());\n+          iip.getLatestSnapshotId(), false);\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n-            iip.getLatestSnapshotId());\n+            iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.isStriped());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n-            iip.getLatestSnapshotId());\n+            iip.getLatestSnapshotId(), false);\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(\n           blockManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId(), false);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.isStriped());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId(), false);\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c304890c8c7782d835896859f5b7f60b96c306c0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9542. Move BlockIdManager from FSNamesystem to BlockManager. Contributed by Jing Zhao.\n",
      "commitDate": "21/01/16 11:13 AM",
      "commitName": "c304890c8c7782d835896859f5b7f60b96c306c0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/01/16 10:30 AM",
      "commitNameOld": "67c9780609f707c11626f05028ddfd28f1b878f1",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 15.03,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       BlockUnderConstructionFeature uc \u003d\n           lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n             lastBlock.isStriped());\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(\n-          blockIdManager.isLegacyBlock(lastBlock));\n+          blockManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.isStriped());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "164cbe643988f878f0f4100a4de51783e5b6738e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8909. Erasure coding: update BlockInfoContiguousUC and BlockInfoStripedUC to use BlockUnderConstructionFeature. Contributed by Jing Zhao.\n",
      "commitDate": "27/08/15 1:02 AM",
      "commitName": "164cbe643988f878f0f4100a4de51783e5b6738e",
      "commitAuthor": "Walter Su",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.5,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,134 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      // TODO support truncate of striped blocks\n-      final BlockInfoUnderConstruction uc \u003d\n-          (BlockInfoUnderConstruction)lastBlock;\n+      final BlockUnderConstructionFeature uc \u003d lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n-          recoveryBlock.getBlockId() !\u003d uc.toBlock().getBlockId();\n+          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n-          recoveryBlock.getBlockId() \u003c uc.toBlock().getBlockId() \u0026\u0026\n-          recoveryBlock.getGenerationStamp() \u003c uc.toBlock().\n-              getGenerationStamp() \u0026\u0026\n-          recoveryBlock.getNumBytes() \u003e uc.toBlock().getNumBytes() :\n+          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n+          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n+          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n-        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n+        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n+            lastBlock.isStriped());\n       }\n \n-      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026\n-          uc.toBlock().getNumBytes() \u003d\u003d 0) {\n+      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d\n-          nextGenerationStamp(blockIdManager.isLegacyBlock(uc.toBlock()));\n+          nextGenerationStamp(blockIdManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n-        uc.toBlock().setGenerationStamp(blockRecoveryId);\n+        lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n-      uc.initializeBlockRecovery(blockRecoveryId);\n+      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockUnderConstructionFeature uc \u003d lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock, blockManager.getStorages(lastBlock),\n            lastBlock.isStriped());\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d\n          nextGenerationStamp(blockIdManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "bdd79388f39f4f35af7decd5703eff587b0ddfb7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8928. Improvements for BlockUnderConstructionFeature: ReplicaUnderConstruction as a separate class and replicas as an array. Contributed by Jing Zhao.\n",
      "commitDate": "24/08/15 3:53 PM",
      "commitName": "bdd79388f39f4f35af7decd5703eff587b0ddfb7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "19/08/15 11:28 AM",
      "commitNameOld": "3aac4758b007a56e3d66998d457b2156effca528",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.18,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,135 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null\n         || blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      BlockUnderConstructionFeature uc \u003d lastBlock.getUnderConstructionFeature();\n+      BlockUnderConstructionFeature uc \u003d\n+          lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n-        uc.setExpectedLocations(lastBlock.getGenerationStamp(),\n+        uc.setExpectedLocations(lastBlock,\n             blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(\n           blockIdManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null\n        || blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d\n          lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock,\n            blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockIdManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e535e0f05b5fbd087c93238deb888cc985254b4c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8801. Convert BlockInfoUnderConstruction as a feature. Contributed by Jing Zhao.\n",
      "commitDate": "17/08/15 11:28 AM",
      "commitName": "e535e0f05b5fbd087c93238deb888cc985254b4c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "17/08/15 10:15 AM",
      "commitNameOld": "a7862d5fe4c505f5d4b0c675438a971733f1f53a",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,134 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n-    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n-        blockManager.checkMinReplication(penultimateBlock);\n+    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null\n+        || blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n+      BlockUnderConstructionFeature uc \u003d lastBlock.getUnderConstructionFeature();\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n-          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n+          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n       assert !copyOnTruncate ||\n-          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n-          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n-          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n+          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n+          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n+          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n-        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n+        uc.setExpectedLocations(lastBlock.getGenerationStamp(),\n+            blockManager.getStorages(lastBlock));\n       }\n \n-      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n+      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n-      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n+      long blockRecoveryId \u003d nextGenerationStamp(\n+          blockIdManager.isLegacyBlock(lastBlock));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n-        uc.setGenerationStamp(blockRecoveryId);\n+        lastBlock.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n-      uc.initializeBlockRecovery(blockRecoveryId);\n+      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null\n        || blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      BlockUnderConstructionFeature uc \u003d lastBlock.getUnderConstructionFeature();\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d lastBlock.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c lastBlock.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c lastBlock.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e lastBlock.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(lastBlock.getGenerationStamp(),\n            blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 lastBlock.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(\n          blockIdManager.isLegacyBlock(lastBlock));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        lastBlock.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(lastBlock, blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\"\n\nThis reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/08/15 10:21 AM",
      "commitNameOld": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,132 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      final BlockInfoUnderConstruction uc \u003d\n-          (BlockInfoUnderConstruction)lastBlock;\n+      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\"\n\nThis reverts commit de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/08/15 10:40 PM",
      "commitNameOld": "cc71ad80e184fc6e5043729e8cfcf6a62ca3e71f",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n-      assert blockManager.hasMinStorage(curBlock) :\n+      assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n-        blockManager.hasMinStorage(penultimateBlock);\n+        blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n-          blockManager.hasMinStorage(lastBlock)) {\n+          blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d\n           (BlockInfoUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d\n          (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5137b388fc9d4d716f780daf6d04292feeb9df96": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8344. NameNode doesn\u0027t recover lease for files with missing blocks (raviprak)\"\n\nThis reverts commit e4f756260f16156179ba4adad974ec92279c2fac.\n\nConflicts:\n\thadoop-hdfs-project/hadoop-hdfs/CHANGES.txt\n",
      "commitDate": "21/07/15 11:29 AM",
      "commitName": "5137b388fc9d4d716f780daf6d04292feeb9df96",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "20/07/15 2:03 PM",
      "commitNameOld": "e4f756260f16156179ba4adad974ec92279c2fac",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,133 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d\n           (BlockInfoUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n-\n-      //If the block\u0027s recovery has been attempted enough times, mark the block\n-      //complete anyway and recover the lease\n-      if(uc.getNumRecoveryAttemptsLeft() \u003d\u003d 0) {\n-        blockManager.forceCompleteBlock(pendingFile, uc);\n-        finalizeINodeFileUnderConstruction(src, pendingFile,\n-            iip.getLatestSnapshotId());\n-        return true;\n-      }\n-\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d\n          (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e4f756260f16156179ba4adad974ec92279c2fac": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8344. NameNode doesn\u0027t recover lease for files with missing blocks (raviprak)\n",
      "commitDate": "20/07/15 2:03 PM",
      "commitName": "e4f756260f16156179ba4adad974ec92279c2fac",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "29/06/15 4:45 PM",
      "commitNameOld": "d3797f9f3cf502b7bfee3b64c641807b276c6faf",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 20.89,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,143 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d\n           (BlockInfoUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n+\n+      //If the block\u0027s recovery has been attempted enough times, mark the block\n+      //complete anyway and recover the lease\n+      if(uc.getNumRecoveryAttemptsLeft() \u003d\u003d 0) {\n+        blockManager.forceCompleteBlock(pendingFile, uc);\n+        finalizeINodeFileUnderConstruction(src, pendingFile,\n+            iip.getLatestSnapshotId());\n+        return true;\n+      }\n+\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d\n          (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n\n      //If the block\u0027s recovery has been attempted enough times, mark the block\n      //complete anyway and recover the lease\n      if(uc.getNumRecoveryAttemptsLeft() \u003d\u003d 0) {\n        blockManager.forceCompleteBlock(pendingFile, uc);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        return true;\n      }\n\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "26/06/15 10:49 AM",
      "commitName": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/06/15 2:42 PM",
      "commitNameOld": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n-      assert blockManager.checkMinReplication(curBlock) :\n+      assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n-        blockManager.checkMinReplication(penultimateBlock);\n+        blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n-          blockManager.checkMinReplication(lastBlock)) {\n+          blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d\n           (BlockInfoUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d\n          (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\n",
      "commitDate": "12/06/15 11:38 AM",
      "commitName": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "12/06/15 11:17 AM",
      "commitNameOld": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,133 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n+      final BlockInfoUnderConstruction uc \u003d\n+          (BlockInfoUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d\n          (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/05/15 8:08 AM",
      "commitNameOld": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,132 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n-    BlockInfoContiguous[] blocks \u003d pendingFile.getBlocks();\n+    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n-    BlockInfoContiguous curBlock \u003d null;\n+    BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n-    final BlockInfoContiguous lastBlock \u003d pendingFile.getLastBlock();\n+    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n-    BlockInfoContiguous penultimateBlock \u003d pendingFile.getPenultimateBlock();\n+    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "146ce7a9784e52432b76164009336a4b2cf2860e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7969. Erasure coding: NameNode support for lease recovery of striped block groups. Contributed by Zhe Zhang.\n",
      "commitDate": "26/05/15 11:55 AM",
      "commitName": "146ce7a9784e52432b76164009336a4b2cf2860e",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 11:55 AM",
      "commitNameOld": "1af8c148626effe1b41fc536019fd3349f485d59",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,137 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n           blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      // TODO support Striped block\u0027s recovery\n-      final BlockInfoContiguousUnderConstruction uc \u003d\n-          (BlockInfoContiguousUnderConstruction)lastBlock;\n+      // TODO support truncate of striped blocks\n+      final BlockInfoUnderConstruction uc \u003d\n+          (BlockInfoUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n-          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n+          recoveryBlock.getBlockId() !\u003d uc.toBlock().getBlockId();\n       assert !copyOnTruncate ||\n-          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n-          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n-          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n+          recoveryBlock.getBlockId() \u003c uc.toBlock().getBlockId() \u0026\u0026\n+          recoveryBlock.getGenerationStamp() \u003c uc.toBlock().\n+              getGenerationStamp() \u0026\u0026\n+          recoveryBlock.getNumBytes() \u003e uc.toBlock().getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n-      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n+      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026\n+          uc.toBlock().getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n-      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n+      long blockRecoveryId \u003d\n+          nextGenerationStamp(blockIdManager.isLegacyBlock(uc.toBlock()));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n-        uc.setGenerationStamp(blockRecoveryId);\n+        uc.toBlock().setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // TODO support truncate of striped blocks\n      final BlockInfoUnderConstruction uc \u003d\n          (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.toBlock().getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.toBlock().getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.toBlock().\n              getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.toBlock().getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026\n          uc.toBlock().getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d\n          nextGenerationStamp(blockIdManager.isLegacyBlock(uc.toBlock()));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.toBlock().setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "abf833a7b228fff2bca4f69cd9df99d532380038": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7907. Erasure Coding: track invalid, corrupt, and under-recovery striped blocks in NameNode. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:43 AM",
      "commitName": "abf833a7b228fff2bca4f69cd9df99d532380038",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:43 AM",
      "commitNameOld": "46dac3595fa2e2c14290154c3c12ea799ee5043d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n-      assert blockManager.checkMinStorage(curBlock) :\n+      assert blockManager.hasMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n-        blockManager.checkMinStorage(penultimateBlock);\n+        blockManager.hasMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinStorage \u0026\u0026\n-          blockManager.checkMinStorage(lastBlock)) {\n+          blockManager.hasMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       // TODO support Striped block\u0027s recovery\n       final BlockInfoContiguousUnderConstruction uc \u003d\n           (BlockInfoContiguousUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.hasMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.hasMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.hasMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // TODO support Striped block\u0027s recovery\n      final BlockInfoContiguousUnderConstruction uc \u003d\n          (BlockInfoContiguousUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1e1e93040748231dc913190aec1e031c379d8271": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7837. Erasure Coding: allocate and persist striped blocks in NameNode. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:32 AM",
      "commitName": "1e1e93040748231dc913190aec1e031c379d8271",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n-      assert blockManager.checkMinReplication(curBlock) :\n+      assert blockManager.checkMinStorage(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n-    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ||\n-        blockManager.checkMinReplication(penultimateBlock);\n+    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n+        blockManager.checkMinStorage(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n-      if(penultimateBlockMinReplication \u0026\u0026\n-          blockManager.checkMinReplication(lastBlock)) {\n+      if(penultimateBlockMinStorage \u0026\u0026\n+          blockManager.checkMinStorage(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       // TODO support Striped block\u0027s recovery\n       final BlockInfoContiguousUnderConstruction uc \u003d\n           (BlockInfoContiguousUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinStorage(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinStorage \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.checkMinStorage(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinStorage \u0026\u0026\n          blockManager.checkMinStorage(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // TODO support Striped block\u0027s recovery\n      final BlockInfoContiguousUnderConstruction uc \u003d\n          (BlockInfoContiguousUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7749. Erasure Coding: Add striped block support in INodeFile. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,134 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n-    BlockInfoContiguous[] blocks \u003d pendingFile.getBlocks();\n+    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n-    BlockInfoContiguous curBlock \u003d null;\n+    BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n-    final BlockInfoContiguous lastBlock \u003d pendingFile.getLastBlock();\n+    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n-    BlockInfoContiguous penultimateBlock \u003d pendingFile.getPenultimateBlock();\n+    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n-    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n+    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ||\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n+      // TODO support Striped block\u0027s recovery\n       final BlockInfoContiguousUnderConstruction uc \u003d\n           (BlockInfoContiguousUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ||\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // TODO support Striped block\u0027s recovery\n      final BlockInfoContiguousUnderConstruction uc \u003d\n          (BlockInfoContiguousUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/02/15 3:21 PM",
      "commitNameOld": "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,132 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n-    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n+    BlockInfoContiguous[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n-    BlockInfo curBlock \u003d null;\n+    BlockInfoContiguous curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n-    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n+    final BlockInfoContiguous lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n-    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n+    BlockInfoContiguous penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n+      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n       // determine if last block was intended to be truncated\n       Block recoveryBlock \u003d uc.getTruncateBlock();\n       boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n       boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n           recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n       assert !copyOnTruncate ||\n           recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n           recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n           recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n             \"wrong recoveryBlock\";\n \n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       if(copyOnTruncate) {\n         uc.setGenerationStamp(blockRecoveryId);\n       } else if(truncateRecovery) {\n         recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfoContiguous[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfoContiguous curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfoContiguous lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfoContiguous penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoContiguousUnderConstruction uc \u003d (BlockInfoContiguousUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "12/01/15 10:50 PM",
      "commitNameOld": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,132 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n-    case BEING_TRUNCATED:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n+      // determine if last block was intended to be truncated\n+      Block recoveryBlock \u003d uc.getTruncateBlock();\n+      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n+      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n+          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n+      assert !copyOnTruncate ||\n+          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n+          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n+          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n+            \"wrong recoveryBlock\";\n+\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n-      if (uc.getBlockUCState() !\u003d BlockUCState.BEING_TRUNCATED) {\n-        uc.initializeBlockRecovery(blockRecoveryId);\n+      if(copyOnTruncate) {\n+        uc.setGenerationStamp(blockRecoveryId);\n+      } else if(truncateRecovery) {\n+        recoveryBlock.setGenerationStamp(blockRecoveryId);\n       }\n+      uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // determine if last block was intended to be truncated\n      Block recoveryBlock \u003d uc.getTruncateBlock();\n      boolean truncateRecovery \u003d recoveryBlock !\u003d null;\n      boolean copyOnTruncate \u003d truncateRecovery \u0026\u0026\n          recoveryBlock.getBlockId() !\u003d uc.getBlockId();\n      assert !copyOnTruncate ||\n          recoveryBlock.getBlockId() \u003c uc.getBlockId() \u0026\u0026\n          recoveryBlock.getGenerationStamp() \u003c uc.getGenerationStamp() \u0026\u0026\n          recoveryBlock.getNumBytes() \u003e uc.getNumBytes() :\n            \"wrong recoveryBlock\";\n\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if(copyOnTruncate) {\n        uc.setGenerationStamp(blockRecoveryId);\n      } else if(truncateRecovery) {\n        recoveryBlock.setGenerationStamp(blockRecoveryId);\n      }\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "7e9358feb326d48b8c4f00249e7af5023cebd2e2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3107. Introduce truncate. Contributed by Plamen Jeliazkov.",
      "commitDate": "12/01/15 10:50 PM",
      "commitName": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "09/01/15 5:35 PM",
      "commitNameOld": "2a06101e61f2f7a08913c2367d9dbefb910e64a7",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.22,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,119 @@\n   boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n       String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n+    case BEING_TRUNCATED:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n-      uc.initializeBlockRecovery(blockRecoveryId);\n+      if (uc.getBlockUCState() !\u003d BlockUCState.BEING_TRUNCATED) {\n+        uc.initializeBlockRecovery(blockRecoveryId);\n+      }\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n    case BEING_TRUNCATED:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      if (uc.getBlockUCState() !\u003d BlockUCState.BEING_TRUNCATED) {\n        uc.initializeBlockRecovery(blockRecoveryId);\n      }\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "12/12/14 11:51 AM",
          "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,116 @@\n-  boolean internalReleaseLease(Lease lease, String src, \n-      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n-      IOException, UnresolvedLinkException {\n+  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n+      String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n-    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n-    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n+    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[lease-Lease, src-String, recoveryLeaseHolder-String]",
            "newValue": "[lease-Lease, src-String, iip-INodesInPath, recoveryLeaseHolder-String]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "12/12/14 11:51 AM",
          "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,116 @@\n-  boolean internalReleaseLease(Lease lease, String src, \n-      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n-      IOException, UnresolvedLinkException {\n+  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n+      String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n-    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n-    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n+    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[AlreadyBeingCreatedException, IOException, UnresolvedLinkException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "12/12/14 11:51 AM",
          "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,116 @@\n-  boolean internalReleaseLease(Lease lease, String src, \n-      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n-      IOException, UnresolvedLinkException {\n+  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n+      String recoveryLeaseHolder) throws IOException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n-    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n-    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n+    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean internalReleaseLease(Lease lease, String src, INodesInPath iip,\n      String recoveryLeaseHolder) throws IOException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFile pendingFile \u003d iip.getLastINode().asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "571e9c623241106dad5521a870fb8daef3f2b00a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7381. Decouple the management of block id and gen stamps from FSNamesystem. Contributed by Haohui Mai.\n",
      "commitDate": "11/11/14 12:42 PM",
      "commitName": "571e9c623241106dad5521a870fb8daef3f2b00a",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "05/11/14 10:14 AM",
      "commitNameOld": "18312804e9c86c0ea6a259e288994fea6fa366ef",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,118 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n \n     // If penultimate block doesn\u0027t exist then its minReplication is met\n     boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n-      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n+      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(blockIdManager.isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "f36f0dde8866e2233dad26b38a8d432d2302a51a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6276. Remove unnecessary conditions and null check. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1589586 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/14 10:05 PM",
      "commitName": "f36f0dde8866e2233dad26b38a8d432d2302a51a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "23/04/14 1:13 PM",
      "commitNameOld": "876fd8ab7913a259ff9f69c16cc2d9af46ad3f9b",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,118 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n-    boolean penultimateBlockMinReplication;\n-    BlockUCState penultimateBlockState;\n-    if (penultimateBlock \u003d\u003d null) {\n-      penultimateBlockState \u003d BlockUCState.COMPLETE;\n-      // If penultimate block doesn\u0027t exist then its minReplication is met\n-      penultimateBlockMinReplication \u003d true;\n-    } else {\n-      penultimateBlockState \u003d BlockUCState.COMMITTED;\n-      penultimateBlockMinReplication \u003d \n+\n+    // If penultimate block doesn\u0027t exist then its minReplication is met\n+    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n         blockManager.checkMinReplication(penultimateBlock);\n-    }\n-    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n-           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n-           \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n\n    // If penultimate block doesn\u0027t exist then its minReplication is met\n    boolean penultimateBlockMinReplication \u003d penultimateBlock \u003d\u003d null ? true :\n        blockManager.checkMinReplication(penultimateBlock);\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/01/14 6:45 PM",
      "commitNameOld": "d85c017d0488930d806f267141057fc73e68c728",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,128 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n-          iip.getLatestSnapshot());\n+          iip.getLatestSnapshotId());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n-            iip.getLatestSnapshot());\n+            iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n-            iip.getLatestSnapshot());\n+            iip.getLatestSnapshotId());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshotId());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshotId());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ce68f410b05a58ad05965f32ad7f5b246b363a75": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5285. Flatten INodeFile hierarchy: Replace INodeFileUnderConstruction and INodeFileUnderConstructionWithSnapshot with FileUnderContructionFeature.  Contributed by jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544389 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 5:39 PM",
      "commitName": "ce68f410b05a58ad05965f32ad7f5b246b363a75",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "21/11/13 9:12 AM",
      "commitNameOld": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,128 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n-    final INodeFileUnderConstruction pendingFile\n-        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n+    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshot());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n \n       if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n         // There is no datanode reported to this block.\n         // may be client have crashed before writing data to pipeline.\n         // This blocks doesn\u0027t need any recovery.\n         // We can remove this block and close the file.\n         pendingFile.removeLastBlock(lastBlock);\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n             + \"Removed empty last block and closed file.\");\n         return true;\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFile pendingFile \u003d iip.getINode(0).asFile();\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshot());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "f26d2adbf98890cfe350c17241f5049b89a11e3c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4516. Client crash after block allocation and NN switch before lease recovery for the same file can cause readers to fail forever. Contributed by Vinay.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543829 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/11/13 6:43 AM",
      "commitName": "f26d2adbf98890cfe350c17241f5049b89a11e3c",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "19/11/13 2:44 PM",
      "commitNameOld": "587f68b160411dd90d3215dab6a30126a0bd78a6",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,129 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFileUnderConstruction pendingFile\n         \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshot());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n+\n+      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n+        // There is no datanode reported to this block.\n+        // may be client have crashed before writing data to pipeline.\n+        // This blocks doesn\u0027t need any recovery.\n+        // We can remove this block and close the file.\n+        pendingFile.removeLastBlock(lastBlock);\n+        finalizeINodeFileUnderConstruction(src, pendingFile,\n+            iip.getLatestSnapshot());\n+        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n+            + \"Removed empty last block and closed file.\");\n+        return true;\n+      }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshot());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n\n      if (uc.getNumExpectedLocations() \u003d\u003d 0 \u0026\u0026 uc.getNumBytes() \u003d\u003d 0) {\n        // There is no datanode reported to this block.\n        // may be client have crashed before writing data to pipeline.\n        // This blocks doesn\u0027t need any recovery.\n        // We can remove this block and close the file.\n        pendingFile.removeLastBlock(lastBlock);\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK* internalReleaseLease: \"\n            + \"Removed empty last block and closed file.\");\n        return true;\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "3f070e83b1f4e0211ece8c0ab508a61188ad352a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5009. Include storage information in the LocatedBlock.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1519691 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/09/13 7:03 AM",
      "commitName": "3f070e83b1f4e0211ece8c0ab508a61188ad352a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/08/13 11:30 PM",
      "commitNameOld": "5d9d702607913685eab0d8ad077040ddc82bf085",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.31,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFileUnderConstruction pendingFile\n         \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshot());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n-        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n+        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshot());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getStorages(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "6770de7ec4f73e16740f1723f4e35d2fef2c22c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4645.  Move from randomly generated block ID to sequentially generated block ID.  Contributed by Arpit Agarwal\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500580 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/13 10:29 PM",
      "commitName": "6770de7ec4f73e16740f1723f4e35d2fef2c22c8",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "05/07/13 2:36 PM",
      "commitNameOld": "ed70fb1608e6c81314da83daddadd756394fb87e",
      "commitAuthorOld": "Konstantin Boudnik",
      "daysBetweenCommits": 2.33,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFileUnderConstruction pendingFile\n         \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshot());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n       // start recovery of the last block for this file\n-      long blockRecoveryId \u003d nextGenerationStamp();\n+      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshot());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp(isLegacyBlock(uc));\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4189. Renames the getMutableXxx methods to getXxx4Write and fix a bug that some getExistingPathINodes calls should be getINodesInPath4Write.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1441193 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/13 1:13 PM",
      "commitName": "2372e394dd99d69d396327d5a5e172953a8b8c6a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "29/01/13 1:31 PM",
      "commitNameOld": "66ea187228c899cadf23d10c7032c8efe1aa0df4",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 1.99,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n-    final INodesInPath iip \u003d dir.getINodesInPath(src);\n+    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n     final INodeFileUnderConstruction pendingFile\n         \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile,\n           iip.getLatestSnapshot());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile,\n             iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getLastINodeInPath(src);\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshot());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4103. Support O(1) snapshot creation.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/12 5:30 PM",
      "commitName": "b9f965de120b5278ac84a7e98aecb32aafde4c16",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/12/12 7:40 PM",
      "commitNameOld": "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,116 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n+    final INodesInPath iip \u003d dir.getINodesInPath(src);\n     final INodeFileUnderConstruction pendingFile\n-        \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n+        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n-      finalizeINodeFileUnderConstruction(src, pendingFile);\n+      finalizeINodeFileUnderConstruction(src, pendingFile,\n+          iip.getLatestSnapshot());\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n-        finalizeINodeFileUnderConstruction(src, pendingFile);\n+        finalizeINodeFileUnderConstruction(src, pendingFile,\n+            iip.getLatestSnapshot());\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d dir.getINodesInPath(src);\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(iip.getINode(0), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile,\n          iip.getLatestSnapshot());\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile,\n            iip.getLatestSnapshot());\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9821af9ce8a56a2c583f1ed938902c20e897048f": {
      "type": "Ybodychange",
      "commitMessage": "Reverting the previous merge r1416603 which committed some extra changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1416712 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/12/12 2:43 PM",
      "commitName": "9821af9ce8a56a2c583f1ed938902c20e897048f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "03/12/12 10:04 AM",
      "commitNameOld": "d500d59cbef51f1b0b0291995893b85a139bcec9",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,113 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n-    final INodesInPath inodesInPath \u003d dir.getINodesInPath(src);\n     final INodeFileUnderConstruction pendingFile\n-        \u003d INodeFileUnderConstruction.valueOf(inodesInPath.getINode(0), src);\n+        \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n-      finalizeINodeFileUnderConstruction(src, pendingFile,\n-          inodesInPath.getLatestSnapshot());\n+      finalizeINodeFileUnderConstruction(src, pendingFile);\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n-        finalizeINodeFileUnderConstruction(src, pendingFile,\n-            inodesInPath.getLatestSnapshot());\n+        finalizeINodeFileUnderConstruction(src, pendingFile);\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "26/10/12 11:08 AM",
      "commitNameOld": "0e796b61e829c4bf763caf13b0f53cb1bcefdeee",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.21,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,113 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n-    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n+    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n \n     final INodeFileUnderConstruction pendingFile\n         \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile);\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile);\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering \" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ba2ee1d7fb91462c861169224d250d2d90bec3a6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4107. Add utility methods for casting INode to INodeFile and INodeFileUnderConstruction.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1402265 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/12 11:44 AM",
      "commitName": "ba2ee1d7fb91462c861169224d250d2d90bec3a6",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/10/12 11:30 AM",
      "commitNameOld": "75cdb5bb4965161021df47376cccf058bf413f3b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,113 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n-    INodeFile iFile \u003d dir.getFileINode(src);\n-    if (iFile \u003d\u003d null) {\n-      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n-        + \"attempt to release a create lock on \"\n-        + src + \" file does not exist.\";\n-      NameNode.stateChangeLog.warn(message);\n-      throw new IOException(message);\n-    }\n-    if (!iFile.isUnderConstruction()) {\n-      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n-        + \"attempt to release a create lock on \"\n-        + src + \" but file is already closed.\";\n-      NameNode.stateChangeLog.warn(message);\n-      throw new IOException(message);\n-    }\n \n-    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n+    final INodeFileUnderConstruction pendingFile\n+        \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile);\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile);\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n       if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n         uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n       }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n\n    final INodeFileUnderConstruction pendingFile\n        \u003d INodeFileUnderConstruction.valueOf(dir.getINode(src), src);\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "d69510a7f8b3a86cbf0175a6ff2e28ac82707924": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3394. Do not use generic in INodeFile.getLastBlock(): the run-time ClassCastException check is useless since generic type information is only available in compile-time.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1341141 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/12 11:51 AM",
      "commitName": "d69510a7f8b3a86cbf0175a6ff2e28ac82707924",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "17/05/12 10:49 AM",
      "commitNameOld": "15ddb6634f8bdab37ce43f99f8338d84422c7232",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,127 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n     INodeFile iFile \u003d dir.getFileINode(src);\n     if (iFile \u003d\u003d null) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" file does not exist.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n     if (!iFile.isUnderConstruction()) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile);\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n          curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n-    // no we know that the last block is not COMPLETE, and\n+    // The last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n-    BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n+    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile);\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n+      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n       // setup the last block locations from the blockManager if not known\n-      if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n-        lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n+      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n+        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n+      }\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n-      lastBlock.initializeBlockRecovery(blockRecoveryId);\n+      uc.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n    INodeFile iFile \u003d dir.getFileINode(src);\n    if (iFile \u003d\u003d null) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" file does not exist.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n    if (!iFile.isUnderConstruction()) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // The last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    final BlockInfo lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)lastBlock;\n      // setup the last block locations from the blockManager if not known\n      if (uc.getNumExpectedLocations() \u003d\u003d 0) {\n        uc.setExpectedLocations(blockManager.getNodes(lastBlock));\n      }\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      uc.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "b7cd8c0f865e88e40eee75fd2690b1fdc4155071": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2564. Cleanup unnecessary exceptions thrown and unnecessary casts. Contributed by Hari Mankude\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203950 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 6:34 PM",
      "commitName": "b7cd8c0f865e88e40eee75fd2690b1fdc4155071",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "14/11/11 5:13 PM",
      "commitNameOld": "9a3f147fdd5421460889b266ead3a2300323cda2",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 4.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,125 @@\n   boolean internalReleaseLease(Lease lease, String src, \n       String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n       IOException, UnresolvedLinkException {\n     LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n     assert !isInSafeMode();\n     assert hasWriteLock();\n     INodeFile iFile \u003d dir.getFileINode(src);\n     if (iFile \u003d\u003d null) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" file does not exist.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n     if (!iFile.isUnderConstruction()) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n     int nrBlocks \u003d pendingFile.numBlocks();\n     BlockInfo[] blocks \u003d pendingFile.getBlocks();\n \n     int nrCompleteBlocks;\n     BlockInfo curBlock \u003d null;\n     for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n       curBlock \u003d blocks[nrCompleteBlocks];\n       if(!curBlock.isComplete())\n         break;\n       assert blockManager.checkMinReplication(curBlock) :\n               \"A COMPLETE block is not minimally replicated in \" + src;\n     }\n \n     // If there are no incomplete blocks associated with this file,\n     // then reap lease immediately and close the file.\n     if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n       finalizeINodeFileUnderConstruction(src, pendingFile);\n       NameNode.stateChangeLog.warn(\"BLOCK*\"\n         + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n         + \" lease removed, file closed.\");\n       return true;  // closed!\n     }\n \n     // Only the last and the penultimate blocks may be in non COMPLETE state.\n     // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n     if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n        nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n+         curBlock !\u003d null \u0026\u0026\n          curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n       final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n         + \"attempt to release a create lock on \"\n         + src + \" but file is already closed.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new IOException(message);\n     }\n \n     // no we know that the last block is not COMPLETE, and\n     // that the penultimate block if exists is either COMPLETE or COMMITTED\n     BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n     BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n     BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n     boolean penultimateBlockMinReplication;\n     BlockUCState penultimateBlockState;\n     if (penultimateBlock \u003d\u003d null) {\n       penultimateBlockState \u003d BlockUCState.COMPLETE;\n       // If penultimate block doesn\u0027t exist then its minReplication is met\n       penultimateBlockMinReplication \u003d true;\n     } else {\n       penultimateBlockState \u003d BlockUCState.COMMITTED;\n       penultimateBlockMinReplication \u003d \n         blockManager.checkMinReplication(penultimateBlock);\n     }\n     assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n            penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n            \"Unexpected state of penultimate block in \" + src;\n \n     switch(lastBlockState) {\n     case COMPLETE:\n       assert false : \"Already checked that the last block is incomplete\";\n       break;\n     case COMMITTED:\n       // Close file if committed blocks are minimally replicated\n       if(penultimateBlockMinReplication \u0026\u0026\n           blockManager.checkMinReplication(lastBlock)) {\n         finalizeINodeFileUnderConstruction(src, pendingFile);\n         NameNode.stateChangeLog.warn(\"BLOCK*\"\n           + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n           + \" lease removed, file closed.\");\n         return true;  // closed!\n       }\n       // Cannot close file right now, since some blocks \n       // are not yet minimally replicated.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n           \"Failed to release lease for file \" + src +\n           \". Committed blocks are waiting to be minimally replicated.\" +\n           \" Try again later.\";\n       NameNode.stateChangeLog.warn(message);\n       throw new AlreadyBeingCreatedException(message);\n     case UNDER_CONSTRUCTION:\n     case UNDER_RECOVERY:\n       // setup the last block locations from the blockManager if not known\n       if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n         lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n       // start recovery of the last block for this file\n       long blockRecoveryId \u003d nextGenerationStamp();\n       lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n       lastBlock.initializeBlockRecovery(blockRecoveryId);\n       leaseManager.renewLease(lease);\n       // Cannot close file right now, since the last block requires recovery.\n       // This may potentially cause infinite loop in lease recovery\n       // if there are no valid replicas on data-nodes.\n       NameNode.stateChangeLog.warn(\n                 \"DIR* NameSystem.internalReleaseLease: \" +\n                 \"File \" + src + \" has not been closed.\" +\n                \" Lease recovery is in progress. \" +\n                 \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n       break;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n    INodeFile iFile \u003d dir.getFileINode(src);\n    if (iFile \u003d\u003d null) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" file does not exist.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n    if (!iFile.isUnderConstruction()) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock !\u003d null \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // no we know that the last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // setup the last block locations from the blockManager if not known\n      if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n        lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      lastBlock.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n    INodeFile iFile \u003d dir.getFileINode(src);\n    if (iFile \u003d\u003d null) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" file does not exist.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n    if (!iFile.isUnderConstruction()) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // no we know that the last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // setup the last block locations from the blockManager if not known\n      if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n        lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      lastBlock.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n    INodeFile iFile \u003d dir.getFileINode(src);\n    if (iFile \u003d\u003d null) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" file does not exist.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n    if (!iFile.isUnderConstruction()) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // no we know that the last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // setup the last block locations from the blockManager if not known\n      if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n        lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      lastBlock.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,124 @@\n+  boolean internalReleaseLease(Lease lease, String src, \n+      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n+      IOException, UnresolvedLinkException {\n+    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n+    assert !isInSafeMode();\n+    assert hasWriteLock();\n+    INodeFile iFile \u003d dir.getFileINode(src);\n+    if (iFile \u003d\u003d null) {\n+      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n+        + \"attempt to release a create lock on \"\n+        + src + \" file does not exist.\";\n+      NameNode.stateChangeLog.warn(message);\n+      throw new IOException(message);\n+    }\n+    if (!iFile.isUnderConstruction()) {\n+      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n+        + \"attempt to release a create lock on \"\n+        + src + \" but file is already closed.\";\n+      NameNode.stateChangeLog.warn(message);\n+      throw new IOException(message);\n+    }\n+\n+    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n+    int nrBlocks \u003d pendingFile.numBlocks();\n+    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n+\n+    int nrCompleteBlocks;\n+    BlockInfo curBlock \u003d null;\n+    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n+      curBlock \u003d blocks[nrCompleteBlocks];\n+      if(!curBlock.isComplete())\n+        break;\n+      assert blockManager.checkMinReplication(curBlock) :\n+              \"A COMPLETE block is not minimally replicated in \" + src;\n+    }\n+\n+    // If there are no incomplete blocks associated with this file,\n+    // then reap lease immediately and close the file.\n+    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n+      finalizeINodeFileUnderConstruction(src, pendingFile);\n+      NameNode.stateChangeLog.warn(\"BLOCK*\"\n+        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n+        + \" lease removed, file closed.\");\n+      return true;  // closed!\n+    }\n+\n+    // Only the last and the penultimate blocks may be in non COMPLETE state.\n+    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n+    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n+       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n+         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n+      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n+        + \"attempt to release a create lock on \"\n+        + src + \" but file is already closed.\";\n+      NameNode.stateChangeLog.warn(message);\n+      throw new IOException(message);\n+    }\n+\n+    // no we know that the last block is not COMPLETE, and\n+    // that the penultimate block if exists is either COMPLETE or COMMITTED\n+    BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n+    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n+    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n+    boolean penultimateBlockMinReplication;\n+    BlockUCState penultimateBlockState;\n+    if (penultimateBlock \u003d\u003d null) {\n+      penultimateBlockState \u003d BlockUCState.COMPLETE;\n+      // If penultimate block doesn\u0027t exist then its minReplication is met\n+      penultimateBlockMinReplication \u003d true;\n+    } else {\n+      penultimateBlockState \u003d BlockUCState.COMMITTED;\n+      penultimateBlockMinReplication \u003d \n+        blockManager.checkMinReplication(penultimateBlock);\n+    }\n+    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n+           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n+           \"Unexpected state of penultimate block in \" + src;\n+\n+    switch(lastBlockState) {\n+    case COMPLETE:\n+      assert false : \"Already checked that the last block is incomplete\";\n+      break;\n+    case COMMITTED:\n+      // Close file if committed blocks are minimally replicated\n+      if(penultimateBlockMinReplication \u0026\u0026\n+          blockManager.checkMinReplication(lastBlock)) {\n+        finalizeINodeFileUnderConstruction(src, pendingFile);\n+        NameNode.stateChangeLog.warn(\"BLOCK*\"\n+          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n+          + \" lease removed, file closed.\");\n+        return true;  // closed!\n+      }\n+      // Cannot close file right now, since some blocks \n+      // are not yet minimally replicated.\n+      // This may potentially cause infinite loop in lease recovery\n+      // if there are no valid replicas on data-nodes.\n+      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n+          \"Failed to release lease for file \" + src +\n+          \". Committed blocks are waiting to be minimally replicated.\" +\n+          \" Try again later.\";\n+      NameNode.stateChangeLog.warn(message);\n+      throw new AlreadyBeingCreatedException(message);\n+    case UNDER_CONSTRUCTION:\n+    case UNDER_RECOVERY:\n+      // setup the last block locations from the blockManager if not known\n+      if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n+        lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n+      // start recovery of the last block for this file\n+      long blockRecoveryId \u003d nextGenerationStamp();\n+      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n+      lastBlock.initializeBlockRecovery(blockRecoveryId);\n+      leaseManager.renewLease(lease);\n+      // Cannot close file right now, since the last block requires recovery.\n+      // This may potentially cause infinite loop in lease recovery\n+      // if there are no valid replicas on data-nodes.\n+      NameNode.stateChangeLog.warn(\n+                \"DIR* NameSystem.internalReleaseLease: \" +\n+                \"File \" + src + \" has not been closed.\" +\n+               \" Lease recovery is in progress. \" +\n+                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n+      break;\n+    }\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean internalReleaseLease(Lease lease, String src, \n      String recoveryLeaseHolder) throws AlreadyBeingCreatedException, \n      IOException, UnresolvedLinkException {\n    LOG.info(\"Recovering lease\u003d\" + lease + \", src\u003d\" + src);\n    assert !isInSafeMode();\n    assert hasWriteLock();\n    INodeFile iFile \u003d dir.getFileINode(src);\n    if (iFile \u003d\u003d null) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" file does not exist.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n    if (!iFile.isUnderConstruction()) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    INodeFileUnderConstruction pendingFile \u003d (INodeFileUnderConstruction) iFile;\n    int nrBlocks \u003d pendingFile.numBlocks();\n    BlockInfo[] blocks \u003d pendingFile.getBlocks();\n\n    int nrCompleteBlocks;\n    BlockInfo curBlock \u003d null;\n    for(nrCompleteBlocks \u003d 0; nrCompleteBlocks \u003c nrBlocks; nrCompleteBlocks++) {\n      curBlock \u003d blocks[nrCompleteBlocks];\n      if(!curBlock.isComplete())\n        break;\n      assert blockManager.checkMinReplication(curBlock) :\n              \"A COMPLETE block is not minimally replicated in \" + src;\n    }\n\n    // If there are no incomplete blocks associated with this file,\n    // then reap lease immediately and close the file.\n    if(nrCompleteBlocks \u003d\u003d nrBlocks) {\n      finalizeINodeFileUnderConstruction(src, pendingFile);\n      NameNode.stateChangeLog.warn(\"BLOCK*\"\n        + \" internalReleaseLease: All existing blocks are COMPLETE,\"\n        + \" lease removed, file closed.\");\n      return true;  // closed!\n    }\n\n    // Only the last and the penultimate blocks may be in non COMPLETE state.\n    // If the penultimate block is not COMPLETE, then it must be COMMITTED.\n    if(nrCompleteBlocks \u003c nrBlocks - 2 ||\n       nrCompleteBlocks \u003d\u003d nrBlocks - 2 \u0026\u0026\n         curBlock.getBlockUCState() !\u003d BlockUCState.COMMITTED) {\n      final String message \u003d \"DIR* NameSystem.internalReleaseLease: \"\n        + \"attempt to release a create lock on \"\n        + src + \" but file is already closed.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new IOException(message);\n    }\n\n    // no we know that the last block is not COMPLETE, and\n    // that the penultimate block if exists is either COMPLETE or COMMITTED\n    BlockInfoUnderConstruction lastBlock \u003d pendingFile.getLastBlock();\n    BlockUCState lastBlockState \u003d lastBlock.getBlockUCState();\n    BlockInfo penultimateBlock \u003d pendingFile.getPenultimateBlock();\n    boolean penultimateBlockMinReplication;\n    BlockUCState penultimateBlockState;\n    if (penultimateBlock \u003d\u003d null) {\n      penultimateBlockState \u003d BlockUCState.COMPLETE;\n      // If penultimate block doesn\u0027t exist then its minReplication is met\n      penultimateBlockMinReplication \u003d true;\n    } else {\n      penultimateBlockState \u003d BlockUCState.COMMITTED;\n      penultimateBlockMinReplication \u003d \n        blockManager.checkMinReplication(penultimateBlock);\n    }\n    assert penultimateBlockState \u003d\u003d BlockUCState.COMPLETE ||\n           penultimateBlockState \u003d\u003d BlockUCState.COMMITTED :\n           \"Unexpected state of penultimate block in \" + src;\n\n    switch(lastBlockState) {\n    case COMPLETE:\n      assert false : \"Already checked that the last block is incomplete\";\n      break;\n    case COMMITTED:\n      // Close file if committed blocks are minimally replicated\n      if(penultimateBlockMinReplication \u0026\u0026\n          blockManager.checkMinReplication(lastBlock)) {\n        finalizeINodeFileUnderConstruction(src, pendingFile);\n        NameNode.stateChangeLog.warn(\"BLOCK*\"\n          + \" internalReleaseLease: Committed blocks are minimally replicated,\"\n          + \" lease removed, file closed.\");\n        return true;  // closed!\n      }\n      // Cannot close file right now, since some blocks \n      // are not yet minimally replicated.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      String message \u003d \"DIR* NameSystem.internalReleaseLease: \" +\n          \"Failed to release lease for file \" + src +\n          \". Committed blocks are waiting to be minimally replicated.\" +\n          \" Try again later.\";\n      NameNode.stateChangeLog.warn(message);\n      throw new AlreadyBeingCreatedException(message);\n    case UNDER_CONSTRUCTION:\n    case UNDER_RECOVERY:\n      // setup the last block locations from the blockManager if not known\n      if(lastBlock.getNumExpectedLocations() \u003d\u003d 0)\n        lastBlock.setExpectedLocations(blockManager.getNodes(lastBlock));\n      // start recovery of the last block for this file\n      long blockRecoveryId \u003d nextGenerationStamp();\n      lease \u003d reassignLease(lease, src, recoveryLeaseHolder, pendingFile);\n      lastBlock.initializeBlockRecovery(blockRecoveryId);\n      leaseManager.renewLease(lease);\n      // Cannot close file right now, since the last block requires recovery.\n      // This may potentially cause infinite loop in lease recovery\n      // if there are no valid replicas on data-nodes.\n      NameNode.stateChangeLog.warn(\n                \"DIR* NameSystem.internalReleaseLease: \" +\n                \"File \" + src + \" has not been closed.\" +\n               \" Lease recovery is in progress. \" +\n                \"RecoveryId \u003d \" + blockRecoveryId + \" for block \" + lastBlock);\n      break;\n    }\n    return false;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}