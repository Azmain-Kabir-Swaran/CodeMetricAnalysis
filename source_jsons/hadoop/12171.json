{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataNode.java",
  "functionName": "shutdown",
  "functionId": "shutdown",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
  "functionStartLine": 2030,
  "functionEndLine": 2200,
  "numCommitsSeen": 358,
  "timeTaken": 3718,
  "changeHistory": [
    "6e04b00df1bf4f0a45571c9fc4361e4e8a05f7ee",
    "15d38b1bf9fbd41658f6980c1a484dd28f746654",
    "39ed3a66dbb01383ed16b141183fc48bfd2e613d",
    "dfcb331ba3516264398121c9f23af3a79c0509cc"
  ],
  "changeHistoryShort": {
    "6e04b00df1bf4f0a45571c9fc4361e4e8a05f7ee": "Ybodychange",
    "15d38b1bf9fbd41658f6980c1a484dd28f746654": "Ybodychange",
    "39ed3a66dbb01383ed16b141183fc48bfd2e613d": "Ybodychange",
    "dfcb331ba3516264398121c9f23af3a79c0509cc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6e04b00df1bf4f0a45571c9fc4361e4e8a05f7ee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12288. Fix DataNode\u0027s xceiver count calculation. Contributed by Lisheng Sun.\n",
      "commitDate": "23/05/20 9:58 AM",
      "commitName": "6e04b00df1bf4f0a45571c9fc4361e4e8a05f7ee",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "13/05/20 11:47 AM",
      "commitNameOld": "3cacf1ce565ce151524d4f61ab7c01a718eb534d",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 9.92,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,171 @@\n   public void shutdown() {\n     stopMetricsLogger();\n     if (plugins !\u003d null) {\n       for (ServicePlugin p : plugins) {\n         try {\n           p.stop();\n           LOG.info(\"Stopped plug-in {}\", p);\n         } catch (Throwable t) {\n           LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n         }\n       }\n     }\n \n     List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n         ? new ArrayList\u003cBPOfferService\u003e()\n         : this.blockPoolManager.getAllNamenodeThreads();\n     // If shutdown is not for restart, set shouldRun to false early. \n     if (!shutdownForUpgrade) {\n       shouldRun \u003d false;\n     }\n \n     // When shutting down for restart, DataXceiverServer is interrupted\n     // in order to avoid any further acceptance of requests, but the peers\n     // for block writes are not closed until the clients are notified.\n     if (dataXceiverServer !\u003d null) {\n       try {\n         xserver.sendOOBToPeers();\n         ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n         this.dataXceiverServer.interrupt();\n       } catch (Exception e) {\n         // Ignore, since the out of band messaging is advisory.\n         LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n       }\n     }\n \n     // Record the time of initial notification\n     long timeNotified \u003d Time.monotonicNow();\n \n     if (localDataXceiverServer !\u003d null) {\n       ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n       this.localDataXceiverServer.interrupt();\n     }\n \n     // Terminate directory scanner and block scanner\n     shutdownPeriodicScanners();\n     shutdownDiskBalancer();\n \n     // Stop the web server\n     if (httpServer !\u003d null) {\n       try {\n         httpServer.close();\n       } catch (Exception e) {\n         LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n       }\n     }\n \n     volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n \n     if (storageLocationChecker !\u003d null) {\n       storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n     }\n \n     if (pauseMonitor !\u003d null) {\n       pauseMonitor.stop();\n     }\n \n     // shouldRun is set to false here to prevent certain threads from exiting\n     // before the restart prep is done.\n     this.shouldRun \u003d false;\n     \n     // wait reconfiguration thread, if any, to exit\n     shutdownReconfigurationTask();\n \n     LOG.info(\"Waiting up to 30 seconds for transfer threads to complete\");\n     HadoopExecutors.shutdown(this.xferService, LOG, 15L, TimeUnit.SECONDS);\n \n     // wait for all data receiver threads to exit\n     if (this.threadGroup !\u003d null) {\n       int sleepMs \u003d 2;\n       while (true) {\n         // When shutting down for restart, wait 2.5 seconds before forcing\n         // termination of receiver threads.\n         if (!this.shutdownForUpgrade ||\n             (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                 \u003e 1000))) {\n           this.threadGroup.interrupt();\n           break;\n         }\n         LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                  this.threadGroup.activeCount());\n         if (this.threadGroup.activeCount() \u003d\u003d 0) {\n           break;\n         }\n         try {\n           Thread.sleep(sleepMs);\n         } catch (InterruptedException e) {}\n         sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n         if (sleepMs \u003e 200) {\n           sleepMs \u003d 200;\n         }\n       }\n       this.threadGroup \u003d null;\n     }\n     if (this.dataXceiverServer !\u003d null) {\n       // wait for dataXceiverServer to terminate\n       try {\n         this.dataXceiverServer.join();\n       } catch (InterruptedException ie) {\n       }\n     }\n     if (this.localDataXceiverServer !\u003d null) {\n       // wait for localDataXceiverServer to terminate\n       try {\n         this.localDataXceiverServer.join();\n       } catch (InterruptedException ie) {\n       }\n     }\n     if (metrics !\u003d null) {\n       metrics.setDataNodeActiveXceiversCount(0);\n+      metrics.setDataNodePacketResponderCount(0);\n+      metrics.setDataNodeBlockRecoveryWorkerCount(0);\n     }\n \n    // IPC server needs to be shutdown late in the process, otherwise\n    // shutdown command response won\u0027t get sent.\n    if (ipcServer !\u003d null) {\n       ipcServer.stop();\n     }\n \n     if (ecWorker !\u003d null) {\n       ecWorker.shutDown();\n     }\n \n     if(blockPoolManager !\u003d null) {\n       try {\n         this.blockPoolManager.shutDownAll(bposArray);\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n       }\n     }\n     \n     if (storage !\u003d null) {\n       try {\n         this.storage.unlockAll();\n       } catch (IOException ie) {\n         LOG.warn(\"Exception when unlocking storage\", ie);\n       }\n     }\n     if (data !\u003d null) {\n       data.shutdown();\n     }\n     if (metrics !\u003d null) {\n       metrics.shutdown();\n     }\n     if (diskMetrics !\u003d null) {\n       diskMetrics.shutdownAndWait();\n     }\n     if (dataNodeInfoBeanName !\u003d null) {\n       MBeans.unregister(dataNodeInfoBeanName);\n       dataNodeInfoBeanName \u003d null;\n     }\n     if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n     LOG.info(\"Shutdown complete.\");\n     synchronized(this) {\n       // it is already false, but setting it again to avoid a findbug warning.\n       this.shouldRun \u003d false;\n       // Notify the main thread.\n       notifyAll();\n     }\n     tracer.close();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void shutdown() {\n    stopMetricsLogger();\n    if (plugins !\u003d null) {\n      for (ServicePlugin p : plugins) {\n        try {\n          p.stop();\n          LOG.info(\"Stopped plug-in {}\", p);\n        } catch (Throwable t) {\n          LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n        }\n      }\n    }\n\n    List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n        ? new ArrayList\u003cBPOfferService\u003e()\n        : this.blockPoolManager.getAllNamenodeThreads();\n    // If shutdown is not for restart, set shouldRun to false early. \n    if (!shutdownForUpgrade) {\n      shouldRun \u003d false;\n    }\n\n    // When shutting down for restart, DataXceiverServer is interrupted\n    // in order to avoid any further acceptance of requests, but the peers\n    // for block writes are not closed until the clients are notified.\n    if (dataXceiverServer !\u003d null) {\n      try {\n        xserver.sendOOBToPeers();\n        ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n        this.dataXceiverServer.interrupt();\n      } catch (Exception e) {\n        // Ignore, since the out of band messaging is advisory.\n        LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n      }\n    }\n\n    // Record the time of initial notification\n    long timeNotified \u003d Time.monotonicNow();\n\n    if (localDataXceiverServer !\u003d null) {\n      ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n      this.localDataXceiverServer.interrupt();\n    }\n\n    // Terminate directory scanner and block scanner\n    shutdownPeriodicScanners();\n    shutdownDiskBalancer();\n\n    // Stop the web server\n    if (httpServer !\u003d null) {\n      try {\n        httpServer.close();\n      } catch (Exception e) {\n        LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n      }\n    }\n\n    volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n\n    if (storageLocationChecker !\u003d null) {\n      storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n    }\n\n    if (pauseMonitor !\u003d null) {\n      pauseMonitor.stop();\n    }\n\n    // shouldRun is set to false here to prevent certain threads from exiting\n    // before the restart prep is done.\n    this.shouldRun \u003d false;\n    \n    // wait reconfiguration thread, if any, to exit\n    shutdownReconfigurationTask();\n\n    LOG.info(\"Waiting up to 30 seconds for transfer threads to complete\");\n    HadoopExecutors.shutdown(this.xferService, LOG, 15L, TimeUnit.SECONDS);\n\n    // wait for all data receiver threads to exit\n    if (this.threadGroup !\u003d null) {\n      int sleepMs \u003d 2;\n      while (true) {\n        // When shutting down for restart, wait 2.5 seconds before forcing\n        // termination of receiver threads.\n        if (!this.shutdownForUpgrade ||\n            (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                \u003e 1000))) {\n          this.threadGroup.interrupt();\n          break;\n        }\n        LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                 this.threadGroup.activeCount());\n        if (this.threadGroup.activeCount() \u003d\u003d 0) {\n          break;\n        }\n        try {\n          Thread.sleep(sleepMs);\n        } catch (InterruptedException e) {}\n        sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n        if (sleepMs \u003e 200) {\n          sleepMs \u003d 200;\n        }\n      }\n      this.threadGroup \u003d null;\n    }\n    if (this.dataXceiverServer !\u003d null) {\n      // wait for dataXceiverServer to terminate\n      try {\n        this.dataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (this.localDataXceiverServer !\u003d null) {\n      // wait for localDataXceiverServer to terminate\n      try {\n        this.localDataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (metrics !\u003d null) {\n      metrics.setDataNodeActiveXceiversCount(0);\n      metrics.setDataNodePacketResponderCount(0);\n      metrics.setDataNodeBlockRecoveryWorkerCount(0);\n    }\n\n   // IPC server needs to be shutdown late in the process, otherwise\n   // shutdown command response won\u0027t get sent.\n   if (ipcServer !\u003d null) {\n      ipcServer.stop();\n    }\n\n    if (ecWorker !\u003d null) {\n      ecWorker.shutDown();\n    }\n\n    if(blockPoolManager !\u003d null) {\n      try {\n        this.blockPoolManager.shutDownAll(bposArray);\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n      }\n    }\n    \n    if (storage !\u003d null) {\n      try {\n        this.storage.unlockAll();\n      } catch (IOException ie) {\n        LOG.warn(\"Exception when unlocking storage\", ie);\n      }\n    }\n    if (data !\u003d null) {\n      data.shutdown();\n    }\n    if (metrics !\u003d null) {\n      metrics.shutdown();\n    }\n    if (diskMetrics !\u003d null) {\n      diskMetrics.shutdownAndWait();\n    }\n    if (dataNodeInfoBeanName !\u003d null) {\n      MBeans.unregister(dataNodeInfoBeanName);\n      dataNodeInfoBeanName \u003d null;\n    }\n    if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n    LOG.info(\"Shutdown complete.\");\n    synchronized(this) {\n      // it is already false, but setting it again to avoid a findbug warning.\n      this.shouldRun \u003d false;\n      // Notify the main thread.\n      notifyAll();\n    }\n    tracer.close();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "15d38b1bf9fbd41658f6980c1a484dd28f746654": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14295. Add Threadpool for DataTransfers. Contributed by David Mollitor.\n",
      "commitDate": "28/03/19 3:37 AM",
      "commitName": "15d38b1bf9fbd41658f6980c1a484dd28f746654",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "12/03/19 10:17 AM",
      "commitNameOld": "34b14061b38dccab25058dff1b8743d8a3f82734",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 15.72,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,166 +1,169 @@\n   public void shutdown() {\n     stopMetricsLogger();\n     if (plugins !\u003d null) {\n       for (ServicePlugin p : plugins) {\n         try {\n           p.stop();\n           LOG.info(\"Stopped plug-in {}\", p);\n         } catch (Throwable t) {\n           LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n         }\n       }\n     }\n \n     List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n         ? new ArrayList\u003cBPOfferService\u003e()\n         : this.blockPoolManager.getAllNamenodeThreads();\n     // If shutdown is not for restart, set shouldRun to false early. \n     if (!shutdownForUpgrade) {\n       shouldRun \u003d false;\n     }\n \n     // When shutting down for restart, DataXceiverServer is interrupted\n     // in order to avoid any further acceptance of requests, but the peers\n     // for block writes are not closed until the clients are notified.\n     if (dataXceiverServer !\u003d null) {\n       try {\n         xserver.sendOOBToPeers();\n         ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n         this.dataXceiverServer.interrupt();\n       } catch (Exception e) {\n         // Ignore, since the out of band messaging is advisory.\n         LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n       }\n     }\n \n     // Record the time of initial notification\n     long timeNotified \u003d Time.monotonicNow();\n \n     if (localDataXceiverServer !\u003d null) {\n       ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n       this.localDataXceiverServer.interrupt();\n     }\n \n     // Terminate directory scanner and block scanner\n     shutdownPeriodicScanners();\n     shutdownDiskBalancer();\n \n     // Stop the web server\n     if (httpServer !\u003d null) {\n       try {\n         httpServer.close();\n       } catch (Exception e) {\n         LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n       }\n     }\n \n     volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n \n     if (storageLocationChecker !\u003d null) {\n       storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n     }\n \n     if (pauseMonitor !\u003d null) {\n       pauseMonitor.stop();\n     }\n \n     // shouldRun is set to false here to prevent certain threads from exiting\n     // before the restart prep is done.\n     this.shouldRun \u003d false;\n     \n     // wait reconfiguration thread, if any, to exit\n     shutdownReconfigurationTask();\n \n+    LOG.info(\"Waiting up to 30 seconds for transfer threads to complete\");\n+    HadoopExecutors.shutdown(this.xferService, LOG, 15L, TimeUnit.SECONDS);\n+\n     // wait for all data receiver threads to exit\n     if (this.threadGroup !\u003d null) {\n       int sleepMs \u003d 2;\n       while (true) {\n         // When shutting down for restart, wait 2.5 seconds before forcing\n         // termination of receiver threads.\n         if (!this.shutdownForUpgrade ||\n             (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                 \u003e 1000))) {\n           this.threadGroup.interrupt();\n           break;\n         }\n         LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                  this.threadGroup.activeCount());\n         if (this.threadGroup.activeCount() \u003d\u003d 0) {\n           break;\n         }\n         try {\n           Thread.sleep(sleepMs);\n         } catch (InterruptedException e) {}\n         sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n         if (sleepMs \u003e 200) {\n           sleepMs \u003d 200;\n         }\n       }\n       this.threadGroup \u003d null;\n     }\n     if (this.dataXceiverServer !\u003d null) {\n       // wait for dataXceiverServer to terminate\n       try {\n         this.dataXceiverServer.join();\n       } catch (InterruptedException ie) {\n       }\n     }\n     if (this.localDataXceiverServer !\u003d null) {\n       // wait for localDataXceiverServer to terminate\n       try {\n         this.localDataXceiverServer.join();\n       } catch (InterruptedException ie) {\n       }\n     }\n     if (metrics !\u003d null) {\n       metrics.setDataNodeActiveXceiversCount(0);\n     }\n \n    // IPC server needs to be shutdown late in the process, otherwise\n    // shutdown command response won\u0027t get sent.\n    if (ipcServer !\u003d null) {\n       ipcServer.stop();\n     }\n \n     if (ecWorker !\u003d null) {\n       ecWorker.shutDown();\n     }\n \n     if(blockPoolManager !\u003d null) {\n       try {\n         this.blockPoolManager.shutDownAll(bposArray);\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n       }\n     }\n     \n     if (storage !\u003d null) {\n       try {\n         this.storage.unlockAll();\n       } catch (IOException ie) {\n         LOG.warn(\"Exception when unlocking storage\", ie);\n       }\n     }\n     if (data !\u003d null) {\n       data.shutdown();\n     }\n     if (metrics !\u003d null) {\n       metrics.shutdown();\n     }\n     if (diskMetrics !\u003d null) {\n       diskMetrics.shutdownAndWait();\n     }\n     if (dataNodeInfoBeanName !\u003d null) {\n       MBeans.unregister(dataNodeInfoBeanName);\n       dataNodeInfoBeanName \u003d null;\n     }\n     if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n     LOG.info(\"Shutdown complete.\");\n     synchronized(this) {\n       // it is already false, but setting it again to avoid a findbug warning.\n       this.shouldRun \u003d false;\n       // Notify the main thread.\n       notifyAll();\n     }\n     tracer.close();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void shutdown() {\n    stopMetricsLogger();\n    if (plugins !\u003d null) {\n      for (ServicePlugin p : plugins) {\n        try {\n          p.stop();\n          LOG.info(\"Stopped plug-in {}\", p);\n        } catch (Throwable t) {\n          LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n        }\n      }\n    }\n\n    List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n        ? new ArrayList\u003cBPOfferService\u003e()\n        : this.blockPoolManager.getAllNamenodeThreads();\n    // If shutdown is not for restart, set shouldRun to false early. \n    if (!shutdownForUpgrade) {\n      shouldRun \u003d false;\n    }\n\n    // When shutting down for restart, DataXceiverServer is interrupted\n    // in order to avoid any further acceptance of requests, but the peers\n    // for block writes are not closed until the clients are notified.\n    if (dataXceiverServer !\u003d null) {\n      try {\n        xserver.sendOOBToPeers();\n        ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n        this.dataXceiverServer.interrupt();\n      } catch (Exception e) {\n        // Ignore, since the out of band messaging is advisory.\n        LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n      }\n    }\n\n    // Record the time of initial notification\n    long timeNotified \u003d Time.monotonicNow();\n\n    if (localDataXceiverServer !\u003d null) {\n      ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n      this.localDataXceiverServer.interrupt();\n    }\n\n    // Terminate directory scanner and block scanner\n    shutdownPeriodicScanners();\n    shutdownDiskBalancer();\n\n    // Stop the web server\n    if (httpServer !\u003d null) {\n      try {\n        httpServer.close();\n      } catch (Exception e) {\n        LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n      }\n    }\n\n    volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n\n    if (storageLocationChecker !\u003d null) {\n      storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n    }\n\n    if (pauseMonitor !\u003d null) {\n      pauseMonitor.stop();\n    }\n\n    // shouldRun is set to false here to prevent certain threads from exiting\n    // before the restart prep is done.\n    this.shouldRun \u003d false;\n    \n    // wait reconfiguration thread, if any, to exit\n    shutdownReconfigurationTask();\n\n    LOG.info(\"Waiting up to 30 seconds for transfer threads to complete\");\n    HadoopExecutors.shutdown(this.xferService, LOG, 15L, TimeUnit.SECONDS);\n\n    // wait for all data receiver threads to exit\n    if (this.threadGroup !\u003d null) {\n      int sleepMs \u003d 2;\n      while (true) {\n        // When shutting down for restart, wait 2.5 seconds before forcing\n        // termination of receiver threads.\n        if (!this.shutdownForUpgrade ||\n            (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                \u003e 1000))) {\n          this.threadGroup.interrupt();\n          break;\n        }\n        LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                 this.threadGroup.activeCount());\n        if (this.threadGroup.activeCount() \u003d\u003d 0) {\n          break;\n        }\n        try {\n          Thread.sleep(sleepMs);\n        } catch (InterruptedException e) {}\n        sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n        if (sleepMs \u003e 200) {\n          sleepMs \u003d 200;\n        }\n      }\n      this.threadGroup \u003d null;\n    }\n    if (this.dataXceiverServer !\u003d null) {\n      // wait for dataXceiverServer to terminate\n      try {\n        this.dataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (this.localDataXceiverServer !\u003d null) {\n      // wait for localDataXceiverServer to terminate\n      try {\n        this.localDataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (metrics !\u003d null) {\n      metrics.setDataNodeActiveXceiversCount(0);\n    }\n\n   // IPC server needs to be shutdown late in the process, otherwise\n   // shutdown command response won\u0027t get sent.\n   if (ipcServer !\u003d null) {\n      ipcServer.stop();\n    }\n\n    if (ecWorker !\u003d null) {\n      ecWorker.shutDown();\n    }\n\n    if(blockPoolManager !\u003d null) {\n      try {\n        this.blockPoolManager.shutDownAll(bposArray);\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n      }\n    }\n    \n    if (storage !\u003d null) {\n      try {\n        this.storage.unlockAll();\n      } catch (IOException ie) {\n        LOG.warn(\"Exception when unlocking storage\", ie);\n      }\n    }\n    if (data !\u003d null) {\n      data.shutdown();\n    }\n    if (metrics !\u003d null) {\n      metrics.shutdown();\n    }\n    if (diskMetrics !\u003d null) {\n      diskMetrics.shutdownAndWait();\n    }\n    if (dataNodeInfoBeanName !\u003d null) {\n      MBeans.unregister(dataNodeInfoBeanName);\n      dataNodeInfoBeanName \u003d null;\n    }\n    if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n    LOG.info(\"Shutdown complete.\");\n    synchronized(this) {\n      // it is already false, but setting it again to avoid a findbug warning.\n      this.shouldRun \u003d false;\n      // Notify the main thread.\n      notifyAll();\n    }\n    tracer.close();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "39ed3a66dbb01383ed16b141183fc48bfd2e613d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13076: [SPS]: Cleanup work for HDFS-10285 merge. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "39ed3a66dbb01383ed16b141183fc48bfd2e613d",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "dfcb331ba3516264398121c9f23af3a79c0509cc",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,170 +1,166 @@\n   public void shutdown() {\n     stopMetricsLogger();\n     if (plugins !\u003d null) {\n       for (ServicePlugin p : plugins) {\n         try {\n           p.stop();\n           LOG.info(\"Stopped plug-in {}\", p);\n         } catch (Throwable t) {\n           LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n         }\n       }\n     }\n \n-    // stop storagePolicySatisfyWorker\n-    if (storagePolicySatisfyWorker !\u003d null) {\n-      storagePolicySatisfyWorker.stop();\n-    }\n     List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n         ? new ArrayList\u003cBPOfferService\u003e()\n         : this.blockPoolManager.getAllNamenodeThreads();\n     // If shutdown is not for restart, set shouldRun to false early. \n     if (!shutdownForUpgrade) {\n       shouldRun \u003d false;\n     }\n \n     // When shutting down for restart, DataXceiverServer is interrupted\n     // in order to avoid any further acceptance of requests, but the peers\n     // for block writes are not closed until the clients are notified.\n     if (dataXceiverServer !\u003d null) {\n       try {\n         xserver.sendOOBToPeers();\n         ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n         this.dataXceiverServer.interrupt();\n       } catch (Exception e) {\n         // Ignore, since the out of band messaging is advisory.\n         LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n       }\n     }\n \n     // Record the time of initial notification\n     long timeNotified \u003d Time.monotonicNow();\n \n     if (localDataXceiverServer !\u003d null) {\n       ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n       this.localDataXceiverServer.interrupt();\n     }\n \n     // Terminate directory scanner and block scanner\n     shutdownPeriodicScanners();\n     shutdownDiskBalancer();\n \n     // Stop the web server\n     if (httpServer !\u003d null) {\n       try {\n         httpServer.close();\n       } catch (Exception e) {\n         LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n       }\n     }\n \n     volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n \n     if (storageLocationChecker !\u003d null) {\n       storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n     }\n \n     if (pauseMonitor !\u003d null) {\n       pauseMonitor.stop();\n     }\n \n     // shouldRun is set to false here to prevent certain threads from exiting\n     // before the restart prep is done.\n     this.shouldRun \u003d false;\n     \n     // wait reconfiguration thread, if any, to exit\n     shutdownReconfigurationTask();\n \n     // wait for all data receiver threads to exit\n     if (this.threadGroup !\u003d null) {\n       int sleepMs \u003d 2;\n       while (true) {\n         // When shutting down for restart, wait 2.5 seconds before forcing\n         // termination of receiver threads.\n         if (!this.shutdownForUpgrade ||\n             (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                 \u003e 1000))) {\n           this.threadGroup.interrupt();\n           break;\n         }\n         LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                  this.threadGroup.activeCount());\n         if (this.threadGroup.activeCount() \u003d\u003d 0) {\n           break;\n         }\n         try {\n           Thread.sleep(sleepMs);\n         } catch (InterruptedException e) {}\n         sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n         if (sleepMs \u003e 200) {\n           sleepMs \u003d 200;\n         }\n       }\n       this.threadGroup \u003d null;\n     }\n     if (this.dataXceiverServer !\u003d null) {\n       // wait for dataXceiverServer to terminate\n       try {\n         this.dataXceiverServer.join();\n       } catch (InterruptedException ie) {\n       }\n     }\n     if (this.localDataXceiverServer !\u003d null) {\n       // wait for localDataXceiverServer to terminate\n       try {\n         this.localDataXceiverServer.join();\n       } catch (InterruptedException ie) {\n       }\n     }\n     if (metrics !\u003d null) {\n       metrics.setDataNodeActiveXceiversCount(0);\n     }\n \n    // IPC server needs to be shutdown late in the process, otherwise\n    // shutdown command response won\u0027t get sent.\n    if (ipcServer !\u003d null) {\n       ipcServer.stop();\n     }\n \n     if (ecWorker !\u003d null) {\n       ecWorker.shutDown();\n     }\n \n     if(blockPoolManager !\u003d null) {\n       try {\n         this.blockPoolManager.shutDownAll(bposArray);\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n       }\n     }\n     \n     if (storage !\u003d null) {\n       try {\n         this.storage.unlockAll();\n       } catch (IOException ie) {\n         LOG.warn(\"Exception when unlocking storage\", ie);\n       }\n     }\n     if (data !\u003d null) {\n       data.shutdown();\n     }\n     if (metrics !\u003d null) {\n       metrics.shutdown();\n     }\n     if (diskMetrics !\u003d null) {\n       diskMetrics.shutdownAndWait();\n     }\n     if (dataNodeInfoBeanName !\u003d null) {\n       MBeans.unregister(dataNodeInfoBeanName);\n       dataNodeInfoBeanName \u003d null;\n     }\n     if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n     LOG.info(\"Shutdown complete.\");\n     synchronized(this) {\n       // it is already false, but setting it again to avoid a findbug warning.\n       this.shouldRun \u003d false;\n       // Notify the main thread.\n       notifyAll();\n     }\n     tracer.close();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void shutdown() {\n    stopMetricsLogger();\n    if (plugins !\u003d null) {\n      for (ServicePlugin p : plugins) {\n        try {\n          p.stop();\n          LOG.info(\"Stopped plug-in {}\", p);\n        } catch (Throwable t) {\n          LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n        }\n      }\n    }\n\n    List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n        ? new ArrayList\u003cBPOfferService\u003e()\n        : this.blockPoolManager.getAllNamenodeThreads();\n    // If shutdown is not for restart, set shouldRun to false early. \n    if (!shutdownForUpgrade) {\n      shouldRun \u003d false;\n    }\n\n    // When shutting down for restart, DataXceiverServer is interrupted\n    // in order to avoid any further acceptance of requests, but the peers\n    // for block writes are not closed until the clients are notified.\n    if (dataXceiverServer !\u003d null) {\n      try {\n        xserver.sendOOBToPeers();\n        ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n        this.dataXceiverServer.interrupt();\n      } catch (Exception e) {\n        // Ignore, since the out of band messaging is advisory.\n        LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n      }\n    }\n\n    // Record the time of initial notification\n    long timeNotified \u003d Time.monotonicNow();\n\n    if (localDataXceiverServer !\u003d null) {\n      ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n      this.localDataXceiverServer.interrupt();\n    }\n\n    // Terminate directory scanner and block scanner\n    shutdownPeriodicScanners();\n    shutdownDiskBalancer();\n\n    // Stop the web server\n    if (httpServer !\u003d null) {\n      try {\n        httpServer.close();\n      } catch (Exception e) {\n        LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n      }\n    }\n\n    volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n\n    if (storageLocationChecker !\u003d null) {\n      storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n    }\n\n    if (pauseMonitor !\u003d null) {\n      pauseMonitor.stop();\n    }\n\n    // shouldRun is set to false here to prevent certain threads from exiting\n    // before the restart prep is done.\n    this.shouldRun \u003d false;\n    \n    // wait reconfiguration thread, if any, to exit\n    shutdownReconfigurationTask();\n\n    // wait for all data receiver threads to exit\n    if (this.threadGroup !\u003d null) {\n      int sleepMs \u003d 2;\n      while (true) {\n        // When shutting down for restart, wait 2.5 seconds before forcing\n        // termination of receiver threads.\n        if (!this.shutdownForUpgrade ||\n            (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                \u003e 1000))) {\n          this.threadGroup.interrupt();\n          break;\n        }\n        LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                 this.threadGroup.activeCount());\n        if (this.threadGroup.activeCount() \u003d\u003d 0) {\n          break;\n        }\n        try {\n          Thread.sleep(sleepMs);\n        } catch (InterruptedException e) {}\n        sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n        if (sleepMs \u003e 200) {\n          sleepMs \u003d 200;\n        }\n      }\n      this.threadGroup \u003d null;\n    }\n    if (this.dataXceiverServer !\u003d null) {\n      // wait for dataXceiverServer to terminate\n      try {\n        this.dataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (this.localDataXceiverServer !\u003d null) {\n      // wait for localDataXceiverServer to terminate\n      try {\n        this.localDataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (metrics !\u003d null) {\n      metrics.setDataNodeActiveXceiversCount(0);\n    }\n\n   // IPC server needs to be shutdown late in the process, otherwise\n   // shutdown command response won\u0027t get sent.\n   if (ipcServer !\u003d null) {\n      ipcServer.stop();\n    }\n\n    if (ecWorker !\u003d null) {\n      ecWorker.shutDown();\n    }\n\n    if(blockPoolManager !\u003d null) {\n      try {\n        this.blockPoolManager.shutDownAll(bposArray);\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n      }\n    }\n    \n    if (storage !\u003d null) {\n      try {\n        this.storage.unlockAll();\n      } catch (IOException ie) {\n        LOG.warn(\"Exception when unlocking storage\", ie);\n      }\n    }\n    if (data !\u003d null) {\n      data.shutdown();\n    }\n    if (metrics !\u003d null) {\n      metrics.shutdown();\n    }\n    if (diskMetrics !\u003d null) {\n      diskMetrics.shutdownAndWait();\n    }\n    if (dataNodeInfoBeanName !\u003d null) {\n      MBeans.unregister(dataNodeInfoBeanName);\n      dataNodeInfoBeanName \u003d null;\n    }\n    if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n    LOG.info(\"Shutdown complete.\");\n    synchronized(this) {\n      // it is already false, but setting it again to avoid a findbug warning.\n      this.shouldRun \u003d false;\n      // Notify the main thread.\n      notifyAll();\n    }\n    tracer.close();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "dfcb331ba3516264398121c9f23af3a79c0509cc": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13076: [SPS]: Addendum. Resolve conflicts after rebasing branch to trunk. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "dfcb331ba3516264398121c9f23af3a79c0509cc",
      "commitAuthor": "Rakesh Radhakrishnan",
      "diff": "@@ -0,0 +1,170 @@\n+  public void shutdown() {\n+    stopMetricsLogger();\n+    if (plugins !\u003d null) {\n+      for (ServicePlugin p : plugins) {\n+        try {\n+          p.stop();\n+          LOG.info(\"Stopped plug-in {}\", p);\n+        } catch (Throwable t) {\n+          LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n+        }\n+      }\n+    }\n+\n+    // stop storagePolicySatisfyWorker\n+    if (storagePolicySatisfyWorker !\u003d null) {\n+      storagePolicySatisfyWorker.stop();\n+    }\n+    List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n+        ? new ArrayList\u003cBPOfferService\u003e()\n+        : this.blockPoolManager.getAllNamenodeThreads();\n+    // If shutdown is not for restart, set shouldRun to false early. \n+    if (!shutdownForUpgrade) {\n+      shouldRun \u003d false;\n+    }\n+\n+    // When shutting down for restart, DataXceiverServer is interrupted\n+    // in order to avoid any further acceptance of requests, but the peers\n+    // for block writes are not closed until the clients are notified.\n+    if (dataXceiverServer !\u003d null) {\n+      try {\n+        xserver.sendOOBToPeers();\n+        ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n+        this.dataXceiverServer.interrupt();\n+      } catch (Exception e) {\n+        // Ignore, since the out of band messaging is advisory.\n+        LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n+      }\n+    }\n+\n+    // Record the time of initial notification\n+    long timeNotified \u003d Time.monotonicNow();\n+\n+    if (localDataXceiverServer !\u003d null) {\n+      ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n+      this.localDataXceiverServer.interrupt();\n+    }\n+\n+    // Terminate directory scanner and block scanner\n+    shutdownPeriodicScanners();\n+    shutdownDiskBalancer();\n+\n+    // Stop the web server\n+    if (httpServer !\u003d null) {\n+      try {\n+        httpServer.close();\n+      } catch (Exception e) {\n+        LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n+      }\n+    }\n+\n+    volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n+\n+    if (storageLocationChecker !\u003d null) {\n+      storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n+    }\n+\n+    if (pauseMonitor !\u003d null) {\n+      pauseMonitor.stop();\n+    }\n+\n+    // shouldRun is set to false here to prevent certain threads from exiting\n+    // before the restart prep is done.\n+    this.shouldRun \u003d false;\n+    \n+    // wait reconfiguration thread, if any, to exit\n+    shutdownReconfigurationTask();\n+\n+    // wait for all data receiver threads to exit\n+    if (this.threadGroup !\u003d null) {\n+      int sleepMs \u003d 2;\n+      while (true) {\n+        // When shutting down for restart, wait 2.5 seconds before forcing\n+        // termination of receiver threads.\n+        if (!this.shutdownForUpgrade ||\n+            (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n+                \u003e 1000))) {\n+          this.threadGroup.interrupt();\n+          break;\n+        }\n+        LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n+                 this.threadGroup.activeCount());\n+        if (this.threadGroup.activeCount() \u003d\u003d 0) {\n+          break;\n+        }\n+        try {\n+          Thread.sleep(sleepMs);\n+        } catch (InterruptedException e) {}\n+        sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n+        if (sleepMs \u003e 200) {\n+          sleepMs \u003d 200;\n+        }\n+      }\n+      this.threadGroup \u003d null;\n+    }\n+    if (this.dataXceiverServer !\u003d null) {\n+      // wait for dataXceiverServer to terminate\n+      try {\n+        this.dataXceiverServer.join();\n+      } catch (InterruptedException ie) {\n+      }\n+    }\n+    if (this.localDataXceiverServer !\u003d null) {\n+      // wait for localDataXceiverServer to terminate\n+      try {\n+        this.localDataXceiverServer.join();\n+      } catch (InterruptedException ie) {\n+      }\n+    }\n+    if (metrics !\u003d null) {\n+      metrics.setDataNodeActiveXceiversCount(0);\n+    }\n+\n+   // IPC server needs to be shutdown late in the process, otherwise\n+   // shutdown command response won\u0027t get sent.\n+   if (ipcServer !\u003d null) {\n+      ipcServer.stop();\n+    }\n+\n+    if (ecWorker !\u003d null) {\n+      ecWorker.shutDown();\n+    }\n+\n+    if(blockPoolManager !\u003d null) {\n+      try {\n+        this.blockPoolManager.shutDownAll(bposArray);\n+      } catch (InterruptedException ie) {\n+        LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n+      }\n+    }\n+    \n+    if (storage !\u003d null) {\n+      try {\n+        this.storage.unlockAll();\n+      } catch (IOException ie) {\n+        LOG.warn(\"Exception when unlocking storage\", ie);\n+      }\n+    }\n+    if (data !\u003d null) {\n+      data.shutdown();\n+    }\n+    if (metrics !\u003d null) {\n+      metrics.shutdown();\n+    }\n+    if (diskMetrics !\u003d null) {\n+      diskMetrics.shutdownAndWait();\n+    }\n+    if (dataNodeInfoBeanName !\u003d null) {\n+      MBeans.unregister(dataNodeInfoBeanName);\n+      dataNodeInfoBeanName \u003d null;\n+    }\n+    if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n+    LOG.info(\"Shutdown complete.\");\n+    synchronized(this) {\n+      // it is already false, but setting it again to avoid a findbug warning.\n+      this.shouldRun \u003d false;\n+      // Notify the main thread.\n+      notifyAll();\n+    }\n+    tracer.close();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void shutdown() {\n    stopMetricsLogger();\n    if (plugins !\u003d null) {\n      for (ServicePlugin p : plugins) {\n        try {\n          p.stop();\n          LOG.info(\"Stopped plug-in {}\", p);\n        } catch (Throwable t) {\n          LOG.warn(\"ServicePlugin {} could not be stopped\", p, t);\n        }\n      }\n    }\n\n    // stop storagePolicySatisfyWorker\n    if (storagePolicySatisfyWorker !\u003d null) {\n      storagePolicySatisfyWorker.stop();\n    }\n    List\u003cBPOfferService\u003e bposArray \u003d (this.blockPoolManager \u003d\u003d null)\n        ? new ArrayList\u003cBPOfferService\u003e()\n        : this.blockPoolManager.getAllNamenodeThreads();\n    // If shutdown is not for restart, set shouldRun to false early. \n    if (!shutdownForUpgrade) {\n      shouldRun \u003d false;\n    }\n\n    // When shutting down for restart, DataXceiverServer is interrupted\n    // in order to avoid any further acceptance of requests, but the peers\n    // for block writes are not closed until the clients are notified.\n    if (dataXceiverServer !\u003d null) {\n      try {\n        xserver.sendOOBToPeers();\n        ((DataXceiverServer) this.dataXceiverServer.getRunnable()).kill();\n        this.dataXceiverServer.interrupt();\n      } catch (Exception e) {\n        // Ignore, since the out of band messaging is advisory.\n        LOG.trace(\"Exception interrupting DataXceiverServer\", e);\n      }\n    }\n\n    // Record the time of initial notification\n    long timeNotified \u003d Time.monotonicNow();\n\n    if (localDataXceiverServer !\u003d null) {\n      ((DataXceiverServer) this.localDataXceiverServer.getRunnable()).kill();\n      this.localDataXceiverServer.interrupt();\n    }\n\n    // Terminate directory scanner and block scanner\n    shutdownPeriodicScanners();\n    shutdownDiskBalancer();\n\n    // Stop the web server\n    if (httpServer !\u003d null) {\n      try {\n        httpServer.close();\n      } catch (Exception e) {\n        LOG.warn(\"Exception shutting down DataNode HttpServer\", e);\n      }\n    }\n\n    volumeChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n\n    if (storageLocationChecker !\u003d null) {\n      storageLocationChecker.shutdownAndWait(1, TimeUnit.SECONDS);\n    }\n\n    if (pauseMonitor !\u003d null) {\n      pauseMonitor.stop();\n    }\n\n    // shouldRun is set to false here to prevent certain threads from exiting\n    // before the restart prep is done.\n    this.shouldRun \u003d false;\n    \n    // wait reconfiguration thread, if any, to exit\n    shutdownReconfigurationTask();\n\n    // wait for all data receiver threads to exit\n    if (this.threadGroup !\u003d null) {\n      int sleepMs \u003d 2;\n      while (true) {\n        // When shutting down for restart, wait 2.5 seconds before forcing\n        // termination of receiver threads.\n        if (!this.shutdownForUpgrade ||\n            (this.shutdownForUpgrade \u0026\u0026 (Time.monotonicNow() - timeNotified\n                \u003e 1000))) {\n          this.threadGroup.interrupt();\n          break;\n        }\n        LOG.info(\"Waiting for threadgroup to exit, active threads is {}\",\n                 this.threadGroup.activeCount());\n        if (this.threadGroup.activeCount() \u003d\u003d 0) {\n          break;\n        }\n        try {\n          Thread.sleep(sleepMs);\n        } catch (InterruptedException e) {}\n        sleepMs \u003d sleepMs * 3 / 2; // exponential backoff\n        if (sleepMs \u003e 200) {\n          sleepMs \u003d 200;\n        }\n      }\n      this.threadGroup \u003d null;\n    }\n    if (this.dataXceiverServer !\u003d null) {\n      // wait for dataXceiverServer to terminate\n      try {\n        this.dataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (this.localDataXceiverServer !\u003d null) {\n      // wait for localDataXceiverServer to terminate\n      try {\n        this.localDataXceiverServer.join();\n      } catch (InterruptedException ie) {\n      }\n    }\n    if (metrics !\u003d null) {\n      metrics.setDataNodeActiveXceiversCount(0);\n    }\n\n   // IPC server needs to be shutdown late in the process, otherwise\n   // shutdown command response won\u0027t get sent.\n   if (ipcServer !\u003d null) {\n      ipcServer.stop();\n    }\n\n    if (ecWorker !\u003d null) {\n      ecWorker.shutDown();\n    }\n\n    if(blockPoolManager !\u003d null) {\n      try {\n        this.blockPoolManager.shutDownAll(bposArray);\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Received exception in BlockPoolManager#shutDownAll\", ie);\n      }\n    }\n    \n    if (storage !\u003d null) {\n      try {\n        this.storage.unlockAll();\n      } catch (IOException ie) {\n        LOG.warn(\"Exception when unlocking storage\", ie);\n      }\n    }\n    if (data !\u003d null) {\n      data.shutdown();\n    }\n    if (metrics !\u003d null) {\n      metrics.shutdown();\n    }\n    if (diskMetrics !\u003d null) {\n      diskMetrics.shutdownAndWait();\n    }\n    if (dataNodeInfoBeanName !\u003d null) {\n      MBeans.unregister(dataNodeInfoBeanName);\n      dataNodeInfoBeanName \u003d null;\n    }\n    if (shortCircuitRegistry !\u003d null) shortCircuitRegistry.shutdown();\n    LOG.info(\"Shutdown complete.\");\n    synchronized(this) {\n      // it is already false, but setting it again to avoid a findbug warning.\n      this.shouldRun \u003d false;\n      // Notify the main thread.\n      notifyAll();\n    }\n    tracer.close();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}