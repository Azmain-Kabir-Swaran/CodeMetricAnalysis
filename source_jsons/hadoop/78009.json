{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Find.java",
  "functionName": "processOptions",
  "functionId": "processOptions___args-LinkedList__String__",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/find/Find.java",
  "functionStartLine": 167,
  "functionEndLine": 212,
  "numCommitsSeen": 3,
  "timeTaken": 677,
  "changeHistory": [
    "ba879a5dadbb0f33bba7e05ebc329a9942f34276"
  ],
  "changeHistoryShort": {
    "ba879a5dadbb0f33bba7e05ebc329a9942f34276": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ba879a5dadbb0f33bba7e05ebc329a9942f34276": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8989. hadoop fs -find feature (Jonathan Allen via aw)\n",
      "commitDate": "13/11/14 11:52 AM",
      "commitName": "ba879a5dadbb0f33bba7e05ebc329a9942f34276",
      "commitAuthor": "Allen Wittenauer",
      "diff": "@@ -0,0 +1,46 @@\n+  protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n+    CommandFormat cf \u003d\n+        new CommandFormat(1, Integer.MAX_VALUE, OPTION_FOLLOW_LINK,\n+            OPTION_FOLLOW_ARG_LINK, null);\n+    cf.parse(args);\n+\n+    if (cf.getOpt(OPTION_FOLLOW_LINK)) {\n+      getOptions().setFollowLink(true);\n+    } else if (cf.getOpt(OPTION_FOLLOW_ARG_LINK)) {\n+      getOptions().setFollowArgLink(true);\n+    }\n+\n+    // search for first non-path argument (ie starts with a \"-\") and capture and\n+    // remove the remaining arguments as expressions\n+    LinkedList\u003cString\u003e expressionArgs \u003d new LinkedList\u003cString\u003e();\n+    Iterator\u003cString\u003e it \u003d args.iterator();\n+    boolean isPath \u003d true;\n+    while (it.hasNext()) {\n+      String arg \u003d it.next();\n+      if (isPath) {\n+        if (arg.startsWith(\"-\")) {\n+          isPath \u003d false;\n+        }\n+      }\n+      if (!isPath) {\n+        expressionArgs.add(arg);\n+        it.remove();\n+      }\n+    }\n+\n+    if (args.isEmpty()) {\n+      args.add(Path.CUR_DIR);\n+    }\n+\n+    Expression expression \u003d parseExpression(expressionArgs);\n+    if (!expression.isAction()) {\n+      Expression and \u003d getExpression(And.class);\n+      Deque\u003cExpression\u003e children \u003d new LinkedList\u003cExpression\u003e();\n+      children.add(getExpression(Print.class));\n+      children.add(expression);\n+      and.addChildren(children);\n+      expression \u003d and;\n+    }\n+\n+    setRootExpression(expression);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n    CommandFormat cf \u003d\n        new CommandFormat(1, Integer.MAX_VALUE, OPTION_FOLLOW_LINK,\n            OPTION_FOLLOW_ARG_LINK, null);\n    cf.parse(args);\n\n    if (cf.getOpt(OPTION_FOLLOW_LINK)) {\n      getOptions().setFollowLink(true);\n    } else if (cf.getOpt(OPTION_FOLLOW_ARG_LINK)) {\n      getOptions().setFollowArgLink(true);\n    }\n\n    // search for first non-path argument (ie starts with a \"-\") and capture and\n    // remove the remaining arguments as expressions\n    LinkedList\u003cString\u003e expressionArgs \u003d new LinkedList\u003cString\u003e();\n    Iterator\u003cString\u003e it \u003d args.iterator();\n    boolean isPath \u003d true;\n    while (it.hasNext()) {\n      String arg \u003d it.next();\n      if (isPath) {\n        if (arg.startsWith(\"-\")) {\n          isPath \u003d false;\n        }\n      }\n      if (!isPath) {\n        expressionArgs.add(arg);\n        it.remove();\n      }\n    }\n\n    if (args.isEmpty()) {\n      args.add(Path.CUR_DIR);\n    }\n\n    Expression expression \u003d parseExpression(expressionArgs);\n    if (!expression.isAction()) {\n      Expression and \u003d getExpression(And.class);\n      Deque\u003cExpression\u003e children \u003d new LinkedList\u003cExpression\u003e();\n      children.add(getExpression(Print.class));\n      children.add(expression);\n      and.addChildren(children);\n      expression \u003d and;\n    }\n\n    setRootExpression(expression);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/find/Find.java"
    }
  }
}