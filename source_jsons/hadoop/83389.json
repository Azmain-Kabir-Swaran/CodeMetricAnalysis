{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ServiceLauncher.java",
  "functionName": "parseCommandArgs",
  "functionId": "parseCommandArgs___conf-Configuration__args-List__String__",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java",
  "functionStartLine": 914,
  "functionEndLine": 967,
  "numCommitsSeen": 3,
  "timeTaken": 1241,
  "changeHistory": [
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "373bb4931fb392e3ca6bfd78992887e5a405e186"
  ],
  "changeHistoryShort": {
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ybodychange",
    "373bb4931fb392e3ca6bfd78992887e5a405e186": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 274.3,
      "commitsBetweenForRepo": 2016,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   protected List\u003cString\u003e parseCommandArgs(Configuration conf,\n       List\u003cString\u003e args) {\n     Preconditions.checkNotNull(commandOptions,\n         \"Command options have not been created\");\n     StringBuilder argString \u003d new StringBuilder(args.size() * 32);\n     for (String arg : args) {\n       argString.append(\"\\\"\").append(arg).append(\"\\\" \");\n     }\n     LOG.debug(\"Command line: {}\", argString);\n     try {\n       String[] argArray \u003d args.toArray(new String[args.size()]);\n       // parse this the standard way. This will\n       // update the configuration in the parser, and potentially\n       // patch the user credentials\n       GenericOptionsParser parser \u003d createGenericOptionsParser(conf, argArray);\n       if (!parser.isParseSuccessful()) {\n         throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n             E_PARSE_FAILED + \" %s\", argString);\n       }\n       CommandLine line \u003d parser.getCommandLine();\n       List\u003cString\u003e remainingArgs \u003d Arrays.asList(parser.getRemainingArgs());\n       LOG.debug(\"Remaining arguments {}\", remainingArgs);\n \n       // Scan the list of configuration files\n       // and bail out if they don\u0027t exist\n       if (line.hasOption(ARG_CONF)) {\n         String[] filenames \u003d line.getOptionValues(ARG_CONF);\n         verifyConfigurationFilesExist(filenames);\n         // Add URLs of files as list of URLs to load\n         for (String filename : filenames) {\n           File file \u003d new File(filename);\n           LOG.debug(\"Configuration files {}\", file);\n           confResourceUrls.add(file.toURI().toURL());\n         }\n       }\n       if (line.hasOption(ARG_CONFCLASS)) {\n         // new resources to instantiate as configurations\n         List\u003cString\u003e classnameList \u003d Arrays.asList(\n             line.getOptionValues(ARG_CONFCLASS));\n         LOG.debug(\"Configuration classes {}\", classnameList);\n         confClassnames.addAll(classnameList);\n       }\n       // return the remainder\n       return remainingArgs;\n     } catch (IOException e) {\n       // parsing problem: convert to a command argument error with\n       // the original text\n       throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e);\n     } catch (RuntimeException e) {\n       // lower level issue such as XML parse failure\n-      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n+      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e,\n           E_PARSE_FAILED + \" %s : %s\", argString, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cString\u003e parseCommandArgs(Configuration conf,\n      List\u003cString\u003e args) {\n    Preconditions.checkNotNull(commandOptions,\n        \"Command options have not been created\");\n    StringBuilder argString \u003d new StringBuilder(args.size() * 32);\n    for (String arg : args) {\n      argString.append(\"\\\"\").append(arg).append(\"\\\" \");\n    }\n    LOG.debug(\"Command line: {}\", argString);\n    try {\n      String[] argArray \u003d args.toArray(new String[args.size()]);\n      // parse this the standard way. This will\n      // update the configuration in the parser, and potentially\n      // patch the user credentials\n      GenericOptionsParser parser \u003d createGenericOptionsParser(conf, argArray);\n      if (!parser.isParseSuccessful()) {\n        throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n            E_PARSE_FAILED + \" %s\", argString);\n      }\n      CommandLine line \u003d parser.getCommandLine();\n      List\u003cString\u003e remainingArgs \u003d Arrays.asList(parser.getRemainingArgs());\n      LOG.debug(\"Remaining arguments {}\", remainingArgs);\n\n      // Scan the list of configuration files\n      // and bail out if they don\u0027t exist\n      if (line.hasOption(ARG_CONF)) {\n        String[] filenames \u003d line.getOptionValues(ARG_CONF);\n        verifyConfigurationFilesExist(filenames);\n        // Add URLs of files as list of URLs to load\n        for (String filename : filenames) {\n          File file \u003d new File(filename);\n          LOG.debug(\"Configuration files {}\", file);\n          confResourceUrls.add(file.toURI().toURL());\n        }\n      }\n      if (line.hasOption(ARG_CONFCLASS)) {\n        // new resources to instantiate as configurations\n        List\u003cString\u003e classnameList \u003d Arrays.asList(\n            line.getOptionValues(ARG_CONFCLASS));\n        LOG.debug(\"Configuration classes {}\", classnameList);\n        confClassnames.addAll(classnameList);\n      }\n      // return the remainder\n      return remainingArgs;\n    } catch (IOException e) {\n      // parsing problem: convert to a command argument error with\n      // the original text\n      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e);\n    } catch (RuntimeException e) {\n      // lower level issue such as XML parse failure\n      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e,\n          E_PARSE_FAILED + \" %s : %s\", argString, e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java",
      "extendedDetails": {}
    },
    "373bb4931fb392e3ca6bfd78992887e5a405e186": {
      "type": "Yintroduced",
      "commitMessage": "YARN-679. Add an entry point that can start any Yarn service. Contributed by Steve Loughran.\n",
      "commitDate": "28/04/17 10:45 AM",
      "commitName": "373bb4931fb392e3ca6bfd78992887e5a405e186",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,54 @@\n+  protected List\u003cString\u003e parseCommandArgs(Configuration conf,\n+      List\u003cString\u003e args) {\n+    Preconditions.checkNotNull(commandOptions,\n+        \"Command options have not been created\");\n+    StringBuilder argString \u003d new StringBuilder(args.size() * 32);\n+    for (String arg : args) {\n+      argString.append(\"\\\"\").append(arg).append(\"\\\" \");\n+    }\n+    LOG.debug(\"Command line: {}\", argString);\n+    try {\n+      String[] argArray \u003d args.toArray(new String[args.size()]);\n+      // parse this the standard way. This will\n+      // update the configuration in the parser, and potentially\n+      // patch the user credentials\n+      GenericOptionsParser parser \u003d createGenericOptionsParser(conf, argArray);\n+      if (!parser.isParseSuccessful()) {\n+        throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n+            E_PARSE_FAILED + \" %s\", argString);\n+      }\n+      CommandLine line \u003d parser.getCommandLine();\n+      List\u003cString\u003e remainingArgs \u003d Arrays.asList(parser.getRemainingArgs());\n+      LOG.debug(\"Remaining arguments {}\", remainingArgs);\n+\n+      // Scan the list of configuration files\n+      // and bail out if they don\u0027t exist\n+      if (line.hasOption(ARG_CONF)) {\n+        String[] filenames \u003d line.getOptionValues(ARG_CONF);\n+        verifyConfigurationFilesExist(filenames);\n+        // Add URLs of files as list of URLs to load\n+        for (String filename : filenames) {\n+          File file \u003d new File(filename);\n+          LOG.debug(\"Configuration files {}\", file);\n+          confResourceUrls.add(file.toURI().toURL());\n+        }\n+      }\n+      if (line.hasOption(ARG_CONFCLASS)) {\n+        // new resources to instantiate as configurations\n+        List\u003cString\u003e classnameList \u003d Arrays.asList(\n+            line.getOptionValues(ARG_CONFCLASS));\n+        LOG.debug(\"Configuration classes {}\", classnameList);\n+        confClassnames.addAll(classnameList);\n+      }\n+      // return the remainder\n+      return remainingArgs;\n+    } catch (IOException e) {\n+      // parsing problem: convert to a command argument error with\n+      // the original text\n+      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e);\n+    } catch (RuntimeException e) {\n+      // lower level issue such as XML parse failure\n+      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n+          E_PARSE_FAILED + \" %s : %s\", argString, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cString\u003e parseCommandArgs(Configuration conf,\n      List\u003cString\u003e args) {\n    Preconditions.checkNotNull(commandOptions,\n        \"Command options have not been created\");\n    StringBuilder argString \u003d new StringBuilder(args.size() * 32);\n    for (String arg : args) {\n      argString.append(\"\\\"\").append(arg).append(\"\\\" \");\n    }\n    LOG.debug(\"Command line: {}\", argString);\n    try {\n      String[] argArray \u003d args.toArray(new String[args.size()]);\n      // parse this the standard way. This will\n      // update the configuration in the parser, and potentially\n      // patch the user credentials\n      GenericOptionsParser parser \u003d createGenericOptionsParser(conf, argArray);\n      if (!parser.isParseSuccessful()) {\n        throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n            E_PARSE_FAILED + \" %s\", argString);\n      }\n      CommandLine line \u003d parser.getCommandLine();\n      List\u003cString\u003e remainingArgs \u003d Arrays.asList(parser.getRemainingArgs());\n      LOG.debug(\"Remaining arguments {}\", remainingArgs);\n\n      // Scan the list of configuration files\n      // and bail out if they don\u0027t exist\n      if (line.hasOption(ARG_CONF)) {\n        String[] filenames \u003d line.getOptionValues(ARG_CONF);\n        verifyConfigurationFilesExist(filenames);\n        // Add URLs of files as list of URLs to load\n        for (String filename : filenames) {\n          File file \u003d new File(filename);\n          LOG.debug(\"Configuration files {}\", file);\n          confResourceUrls.add(file.toURI().toURL());\n        }\n      }\n      if (line.hasOption(ARG_CONFCLASS)) {\n        // new resources to instantiate as configurations\n        List\u003cString\u003e classnameList \u003d Arrays.asList(\n            line.getOptionValues(ARG_CONFCLASS));\n        LOG.debug(\"Configuration classes {}\", classnameList);\n        confClassnames.addAll(classnameList);\n      }\n      // return the remainder\n      return remainingArgs;\n    } catch (IOException e) {\n      // parsing problem: convert to a command argument error with\n      // the original text\n      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e);\n    } catch (RuntimeException e) {\n      // lower level issue such as XML parse failure\n      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,\n          E_PARSE_FAILED + \" %s : %s\", argString, e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java"
    }
  }
}