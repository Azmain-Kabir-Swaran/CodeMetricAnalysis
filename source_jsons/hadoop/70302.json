{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "redo",
  "functionId": "redo",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 517,
  "functionEndLine": 598,
  "numCommitsSeen": 66,
  "timeTaken": 3555,
  "changeHistory": [
    "9288206cb3c1a39044a8e106436987185ef43ddf",
    "c571cda5c7d929477961dfff4176d7de4944d874",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40"
  ],
  "changeHistoryShort": {
    "9288206cb3c1a39044a8e106436987185ef43ddf": "Ybodychange",
    "c571cda5c7d929477961dfff4176d7de4944d874": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9288206cb3c1a39044a8e106436987185ef43ddf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14845. Azure wasb: getFileStatus not making any auth check.\nContributed by Sivaguru Sankaridurg\n",
      "commitDate": "05/10/17 7:05 AM",
      "commitName": "9288206cb3c1a39044a8e106436987185ef43ddf",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "28/09/17 11:52 AM",
      "commitNameOld": "a530e7ab3b3f5bd71143a91266b46787962ac532",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n     public void redo() throws IOException {\n \n       if (!committed) {\n \n         // Nothing to do. The -RedoPending.json file should have already been\n         // deleted.\n         return;\n       }\n \n       // Try to get a lease on source folder to block concurrent access to it.\n       // It may fail if the folder is already gone. We don\u0027t check if the\n       // source exists explicitly because that could recursively trigger redo\n       // and give an infinite recursion.\n       SelfRenewingLease lease \u003d null;\n       boolean sourceFolderGone \u003d false;\n       try {\n         lease \u003d fs.leaseSourceFolder(srcKey);\n       } catch (AzureException e) {\n \n         // If the source folder was not found then somebody probably\n         // raced with us and finished the rename first, or the\n         // first rename failed right before deleting the rename pending\n         // file.\n         String errorCode \u003d \"\";\n         try {\n           StorageException se \u003d (StorageException) e.getCause();\n           errorCode \u003d se.getErrorCode();\n         } catch (Exception e2) {\n           ; // do nothing -- could not get errorCode\n         }\n         if (errorCode.equals(\"BlobNotFound\")) {\n           sourceFolderGone \u003d true;\n         } else {\n           throw new IOException(\n               \"Unexpected error when trying to lease source folder name during \"\n               + \"folder rename redo\",\n               e);\n         }\n       }\n \n       if (!sourceFolderGone) {\n         // Make sure the target folder exists.\n         Path dst \u003d fullPath(dstKey);\n-        if (!fs.exists(dst)) {\n+        if (!fs.existsInternal(dst)) {\n           fs.mkdirs(dst);\n         }\n \n         // For each file inside the folder to be renamed,\n         // make sure it has been renamed.\n         for(String fileName : fileStrings) {\n           finishSingleFileRename(fileName);\n         }\n \n         // Remove the source folder. Don\u0027t check explicitly if it exists,\n         // to avoid triggering redo recursively.\n         try {\n           // Rename the source folder 0-byte root file\n           // as destination folder 0-byte root file.\n           FileMetadata srcMetaData \u003d this.getSourceMetadata();\n           if (srcMetaData.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n             // We already have a lease. So let\u0027s just rename the source blob\n             // as destination blob under same lease.\n             fs.getStoreInterface().rename(this.getSrcKey(), this.getDstKey(), false, lease);\n           }\n \n           // Now we can safely delete the source folder.\n           fs.getStoreInterface().delete(srcKey, lease);\n         } catch (Exception e) {\n           LOG.info(\"Unable to delete source folder during folder rename redo. \"\n               + \"If the source folder is already gone, this is not an error \"\n               + \"condition. Continuing with redo.\", e);\n         }\n \n         // Update the last-modified time of the parent folders of both source\n         // and destination.\n         fs.updateParentFolderLastModifiedTime(srcKey);\n         fs.updateParentFolderLastModifiedTime(dstKey);\n       }\n \n       // Remove the -RenamePending.json file.\n       fs.delete(getRenamePendingFilePath(), false);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void redo() throws IOException {\n\n      if (!committed) {\n\n        // Nothing to do. The -RedoPending.json file should have already been\n        // deleted.\n        return;\n      }\n\n      // Try to get a lease on source folder to block concurrent access to it.\n      // It may fail if the folder is already gone. We don\u0027t check if the\n      // source exists explicitly because that could recursively trigger redo\n      // and give an infinite recursion.\n      SelfRenewingLease lease \u003d null;\n      boolean sourceFolderGone \u003d false;\n      try {\n        lease \u003d fs.leaseSourceFolder(srcKey);\n      } catch (AzureException e) {\n\n        // If the source folder was not found then somebody probably\n        // raced with us and finished the rename first, or the\n        // first rename failed right before deleting the rename pending\n        // file.\n        String errorCode \u003d \"\";\n        try {\n          StorageException se \u003d (StorageException) e.getCause();\n          errorCode \u003d se.getErrorCode();\n        } catch (Exception e2) {\n          ; // do nothing -- could not get errorCode\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          sourceFolderGone \u003d true;\n        } else {\n          throw new IOException(\n              \"Unexpected error when trying to lease source folder name during \"\n              + \"folder rename redo\",\n              e);\n        }\n      }\n\n      if (!sourceFolderGone) {\n        // Make sure the target folder exists.\n        Path dst \u003d fullPath(dstKey);\n        if (!fs.existsInternal(dst)) {\n          fs.mkdirs(dst);\n        }\n\n        // For each file inside the folder to be renamed,\n        // make sure it has been renamed.\n        for(String fileName : fileStrings) {\n          finishSingleFileRename(fileName);\n        }\n\n        // Remove the source folder. Don\u0027t check explicitly if it exists,\n        // to avoid triggering redo recursively.\n        try {\n          // Rename the source folder 0-byte root file\n          // as destination folder 0-byte root file.\n          FileMetadata srcMetaData \u003d this.getSourceMetadata();\n          if (srcMetaData.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n            // We already have a lease. So let\u0027s just rename the source blob\n            // as destination blob under same lease.\n            fs.getStoreInterface().rename(this.getSrcKey(), this.getDstKey(), false, lease);\n          }\n\n          // Now we can safely delete the source folder.\n          fs.getStoreInterface().delete(srcKey, lease);\n        } catch (Exception e) {\n          LOG.info(\"Unable to delete source folder during folder rename redo. \"\n              + \"If the source folder is already gone, this is not an error \"\n              + \"condition. Continuing with redo.\", e);\n        }\n\n        // Update the last-modified time of the parent folders of both source\n        // and destination.\n        fs.updateParentFolderLastModifiedTime(srcKey);\n        fs.updateParentFolderLastModifiedTime(dstKey);\n      }\n\n      // Remove the -RenamePending.json file.\n      fs.delete(getRenamePendingFilePath(), false);\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "c571cda5c7d929477961dfff4176d7de4944d874": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14048. REDO operation of WASB#AtomicRename should create placeholder blob for destination folder. Contributed by NITIN VERMA\n",
      "commitDate": "06/03/17 5:00 PM",
      "commitName": "c571cda5c7d929477961dfff4176d7de4944d874",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "03/03/17 5:09 PM",
      "commitNameOld": "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,82 @@\n     public void redo() throws IOException {\n \n       if (!committed) {\n \n         // Nothing to do. The -RedoPending.json file should have already been\n         // deleted.\n         return;\n       }\n \n       // Try to get a lease on source folder to block concurrent access to it.\n       // It may fail if the folder is already gone. We don\u0027t check if the\n       // source exists explicitly because that could recursively trigger redo\n       // and give an infinite recursion.\n       SelfRenewingLease lease \u003d null;\n       boolean sourceFolderGone \u003d false;\n       try {\n         lease \u003d fs.leaseSourceFolder(srcKey);\n       } catch (AzureException e) {\n \n         // If the source folder was not found then somebody probably\n         // raced with us and finished the rename first, or the\n         // first rename failed right before deleting the rename pending\n         // file.\n         String errorCode \u003d \"\";\n         try {\n           StorageException se \u003d (StorageException) e.getCause();\n           errorCode \u003d se.getErrorCode();\n         } catch (Exception e2) {\n           ; // do nothing -- could not get errorCode\n         }\n         if (errorCode.equals(\"BlobNotFound\")) {\n           sourceFolderGone \u003d true;\n         } else {\n           throw new IOException(\n               \"Unexpected error when trying to lease source folder name during \"\n               + \"folder rename redo\",\n               e);\n         }\n       }\n \n       if (!sourceFolderGone) {\n         // Make sure the target folder exists.\n         Path dst \u003d fullPath(dstKey);\n         if (!fs.exists(dst)) {\n           fs.mkdirs(dst);\n         }\n \n         // For each file inside the folder to be renamed,\n         // make sure it has been renamed.\n         for(String fileName : fileStrings) {\n           finishSingleFileRename(fileName);\n         }\n \n         // Remove the source folder. Don\u0027t check explicitly if it exists,\n         // to avoid triggering redo recursively.\n         try {\n+          // Rename the source folder 0-byte root file\n+          // as destination folder 0-byte root file.\n+          FileMetadata srcMetaData \u003d this.getSourceMetadata();\n+          if (srcMetaData.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+            // We already have a lease. So let\u0027s just rename the source blob\n+            // as destination blob under same lease.\n+            fs.getStoreInterface().rename(this.getSrcKey(), this.getDstKey(), false, lease);\n+          }\n+\n+          // Now we can safely delete the source folder.\n           fs.getStoreInterface().delete(srcKey, lease);\n         } catch (Exception e) {\n           LOG.info(\"Unable to delete source folder during folder rename redo. \"\n               + \"If the source folder is already gone, this is not an error \"\n               + \"condition. Continuing with redo.\", e);\n         }\n \n         // Update the last-modified time of the parent folders of both source\n         // and destination.\n         fs.updateParentFolderLastModifiedTime(srcKey);\n         fs.updateParentFolderLastModifiedTime(dstKey);\n       }\n \n       // Remove the -RenamePending.json file.\n       fs.delete(getRenamePendingFilePath(), false);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void redo() throws IOException {\n\n      if (!committed) {\n\n        // Nothing to do. The -RedoPending.json file should have already been\n        // deleted.\n        return;\n      }\n\n      // Try to get a lease on source folder to block concurrent access to it.\n      // It may fail if the folder is already gone. We don\u0027t check if the\n      // source exists explicitly because that could recursively trigger redo\n      // and give an infinite recursion.\n      SelfRenewingLease lease \u003d null;\n      boolean sourceFolderGone \u003d false;\n      try {\n        lease \u003d fs.leaseSourceFolder(srcKey);\n      } catch (AzureException e) {\n\n        // If the source folder was not found then somebody probably\n        // raced with us and finished the rename first, or the\n        // first rename failed right before deleting the rename pending\n        // file.\n        String errorCode \u003d \"\";\n        try {\n          StorageException se \u003d (StorageException) e.getCause();\n          errorCode \u003d se.getErrorCode();\n        } catch (Exception e2) {\n          ; // do nothing -- could not get errorCode\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          sourceFolderGone \u003d true;\n        } else {\n          throw new IOException(\n              \"Unexpected error when trying to lease source folder name during \"\n              + \"folder rename redo\",\n              e);\n        }\n      }\n\n      if (!sourceFolderGone) {\n        // Make sure the target folder exists.\n        Path dst \u003d fullPath(dstKey);\n        if (!fs.exists(dst)) {\n          fs.mkdirs(dst);\n        }\n\n        // For each file inside the folder to be renamed,\n        // make sure it has been renamed.\n        for(String fileName : fileStrings) {\n          finishSingleFileRename(fileName);\n        }\n\n        // Remove the source folder. Don\u0027t check explicitly if it exists,\n        // to avoid triggering redo recursively.\n        try {\n          // Rename the source folder 0-byte root file\n          // as destination folder 0-byte root file.\n          FileMetadata srcMetaData \u003d this.getSourceMetadata();\n          if (srcMetaData.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n            // We already have a lease. So let\u0027s just rename the source blob\n            // as destination blob under same lease.\n            fs.getStoreInterface().rename(this.getSrcKey(), this.getDstKey(), false, lease);\n          }\n\n          // Now we can safely delete the source folder.\n          fs.getStoreInterface().delete(srcKey, lease);\n        } catch (Exception e) {\n          LOG.info(\"Unable to delete source folder during folder rename redo. \"\n              + \"If the source folder is already gone, this is not an error \"\n              + \"condition. Continuing with redo.\", e);\n        }\n\n        // Update the last-modified time of the parent folders of both source\n        // and destination.\n        fs.updateParentFolderLastModifiedTime(srcKey);\n        fs.updateParentFolderLastModifiedTime(dstKey);\n      }\n\n      // Remove the -RenamePending.json file.\n      fs.delete(getRenamePendingFilePath(), false);\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,72 @@\n+    public void redo() throws IOException {\n+\n+      if (!committed) {\n+\n+        // Nothing to do. The -RedoPending.json file should have already been\n+        // deleted.\n+        return;\n+      }\n+\n+      // Try to get a lease on source folder to block concurrent access to it.\n+      // It may fail if the folder is already gone. We don\u0027t check if the\n+      // source exists explicitly because that could recursively trigger redo\n+      // and give an infinite recursion.\n+      SelfRenewingLease lease \u003d null;\n+      boolean sourceFolderGone \u003d false;\n+      try {\n+        lease \u003d fs.leaseSourceFolder(srcKey);\n+      } catch (AzureException e) {\n+\n+        // If the source folder was not found then somebody probably\n+        // raced with us and finished the rename first, or the\n+        // first rename failed right before deleting the rename pending\n+        // file.\n+        String errorCode \u003d \"\";\n+        try {\n+          StorageException se \u003d (StorageException) e.getCause();\n+          errorCode \u003d se.getErrorCode();\n+        } catch (Exception e2) {\n+          ; // do nothing -- could not get errorCode\n+        }\n+        if (errorCode.equals(\"BlobNotFound\")) {\n+          sourceFolderGone \u003d true;\n+        } else {\n+          throw new IOException(\n+              \"Unexpected error when trying to lease source folder name during \"\n+              + \"folder rename redo\",\n+              e);\n+        }\n+      }\n+\n+      if (!sourceFolderGone) {\n+        // Make sure the target folder exists.\n+        Path dst \u003d fullPath(dstKey);\n+        if (!fs.exists(dst)) {\n+          fs.mkdirs(dst);\n+        }\n+\n+        // For each file inside the folder to be renamed,\n+        // make sure it has been renamed.\n+        for(String fileName : fileStrings) {\n+          finishSingleFileRename(fileName);\n+        }\n+\n+        // Remove the source folder. Don\u0027t check explicitly if it exists,\n+        // to avoid triggering redo recursively.\n+        try {\n+          fs.getStoreInterface().delete(srcKey, lease);\n+        } catch (Exception e) {\n+          LOG.info(\"Unable to delete source folder during folder rename redo. \"\n+              + \"If the source folder is already gone, this is not an error \"\n+              + \"condition. Continuing with redo.\", e);\n+        }\n+\n+        // Update the last-modified time of the parent folders of both source\n+        // and destination.\n+        fs.updateParentFolderLastModifiedTime(srcKey);\n+        fs.updateParentFolderLastModifiedTime(dstKey);\n+      }\n+\n+      // Remove the -RenamePending.json file.\n+      fs.delete(getRenamePendingFilePath(), false);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void redo() throws IOException {\n\n      if (!committed) {\n\n        // Nothing to do. The -RedoPending.json file should have already been\n        // deleted.\n        return;\n      }\n\n      // Try to get a lease on source folder to block concurrent access to it.\n      // It may fail if the folder is already gone. We don\u0027t check if the\n      // source exists explicitly because that could recursively trigger redo\n      // and give an infinite recursion.\n      SelfRenewingLease lease \u003d null;\n      boolean sourceFolderGone \u003d false;\n      try {\n        lease \u003d fs.leaseSourceFolder(srcKey);\n      } catch (AzureException e) {\n\n        // If the source folder was not found then somebody probably\n        // raced with us and finished the rename first, or the\n        // first rename failed right before deleting the rename pending\n        // file.\n        String errorCode \u003d \"\";\n        try {\n          StorageException se \u003d (StorageException) e.getCause();\n          errorCode \u003d se.getErrorCode();\n        } catch (Exception e2) {\n          ; // do nothing -- could not get errorCode\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          sourceFolderGone \u003d true;\n        } else {\n          throw new IOException(\n              \"Unexpected error when trying to lease source folder name during \"\n              + \"folder rename redo\",\n              e);\n        }\n      }\n\n      if (!sourceFolderGone) {\n        // Make sure the target folder exists.\n        Path dst \u003d fullPath(dstKey);\n        if (!fs.exists(dst)) {\n          fs.mkdirs(dst);\n        }\n\n        // For each file inside the folder to be renamed,\n        // make sure it has been renamed.\n        for(String fileName : fileStrings) {\n          finishSingleFileRename(fileName);\n        }\n\n        // Remove the source folder. Don\u0027t check explicitly if it exists,\n        // to avoid triggering redo recursively.\n        try {\n          fs.getStoreInterface().delete(srcKey, lease);\n        } catch (Exception e) {\n          LOG.info(\"Unable to delete source folder during folder rename redo. \"\n              + \"If the source folder is already gone, this is not an error \"\n              + \"condition. Continuing with redo.\", e);\n        }\n\n        // Update the last-modified time of the parent folders of both source\n        // and destination.\n        fs.updateParentFolderLastModifiedTime(srcKey);\n        fs.updateParentFolderLastModifiedTime(dstKey);\n      }\n\n      // Remove the -RenamePending.json file.\n      fs.delete(getRenamePendingFilePath(), false);\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}