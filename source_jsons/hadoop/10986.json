{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataXceiverServer.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
  "functionStartLine": 222,
  "functionEndLine": 294,
  "numCommitsSeen": 39,
  "timeTaken": 8957,
  "changeHistory": [
    "0b855b9f3570f98ff2f2802114241e10520aded8",
    "235e3da90a4212d0c204afaef09db3408abfab82",
    "dde0ab55aadcf7c9cf71dbe36d90e97da6bc9498",
    "b3d8a642a938da9de680b479585a7c2014b8965c",
    "1c6b5d2b5841e5219a98937088cde4ae63869f80",
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
    "837e17b2eac1471d93e2eff395272063b265fee7",
    "239b2742d0e80d13c970fd062af4930e672fe903",
    "a701c792f880c43ba807f00a92a99dadf89eab0c",
    "0663dbaac0a19719ddf9cd4290ba893bfca69da2",
    "8e8bb50afd823a26d9a7ed1311ad050ef059fb5d",
    "6e0991704ffda5cf4cff758f0e7086523fa7bcb4",
    "7cf49f5d9ccef7e42415003435184e05d5dabb23",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
    "3af51887b40df8de7482040cf8a90600a2c4305f",
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
    "58dc1381e0f2582e91da13cc67a5ca9d9657d78c",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "0b855b9f3570f98ff2f2802114241e10520aded8": "Ybodychange",
    "235e3da90a4212d0c204afaef09db3408abfab82": "Ybodychange",
    "dde0ab55aadcf7c9cf71dbe36d90e97da6bc9498": "Ybodychange",
    "b3d8a642a938da9de680b479585a7c2014b8965c": "Ybodychange",
    "1c6b5d2b5841e5219a98937088cde4ae63869f80": "Ybodychange",
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7": "Ybodychange",
    "837e17b2eac1471d93e2eff395272063b265fee7": "Ybodychange",
    "239b2742d0e80d13c970fd062af4930e672fe903": "Ybodychange",
    "a701c792f880c43ba807f00a92a99dadf89eab0c": "Ybodychange",
    "0663dbaac0a19719ddf9cd4290ba893bfca69da2": "Ybodychange",
    "8e8bb50afd823a26d9a7ed1311ad050ef059fb5d": "Ybodychange",
    "6e0991704ffda5cf4cff758f0e7086523fa7bcb4": "Ybodychange",
    "7cf49f5d9ccef7e42415003435184e05d5dabb23": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": "Ybodychange",
    "3af51887b40df8de7482040cf8a90600a2c4305f": "Ybodychange",
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2": "Ybodychange",
    "58dc1381e0f2582e91da13cc67a5ca9d9657d78c": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0b855b9f3570f98ff2f2802114241e10520aded8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15256. Fix typo in DataXceiverServer#run(). Contributed by Lisheng Sun.\n",
      "commitDate": "06/04/20 1:05 PM",
      "commitName": "0b855b9f3570f98ff2f2802114241e10520aded8",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "17/09/19 2:55 PM",
      "commitNameOld": "f580a87079bb47bf92d254677745d067b6bc8fde",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 201.92,
      "commitsBetweenForRepo": 827,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public void run() {\n     Peer peer \u003d null;\n     while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n       try {\n         peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n-              + \" exceeds the limit of concurrent xcievers: \"\n+              + \" exceeds the limit of concurrent xceivers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n             DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n           LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.closeQuietly(peer);\n         LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.closeQuietly(peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(TimeUnit.SECONDS.toMillis(30L));\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(\"{}:DataXceiverServer: Exiting.\", datanode.getDisplayName(),\n             te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n \n     // Close the server to stop reception of more requests.\n     lock.lock();\n     try {\n       if (!closed) {\n         peerServer.close();\n         closed \u003d true;\n       }\n     } catch (IOException ie) {\n       LOG.warn(\"{}:DataXceiverServer: close exception\",\n           datanode.getDisplayName(), ie);\n     } finally {\n       lock.unlock();\n     }\n \n     // if in restart prep stage, notify peers before closing them.\n     if (datanode.shutdownForUpgrade) {\n       restartNotifyPeers();\n       // Each thread needs some time to process it. If a thread needs\n       // to send an OOB message to the client, but blocked on network for\n       // long time, we need to force its termination.\n       LOG.info(\"Shutting down DataXceiverServer before restart\");\n \n       waitAllPeers(2L, TimeUnit.SECONDS);\n     }\n \n     closeAllPeers();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xceivers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n          LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeQuietly(peer);\n        LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeQuietly(peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(TimeUnit.SECONDS.toMillis(30L));\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(\"{}:DataXceiverServer: Exiting.\", datanode.getDisplayName(),\n            te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n\n    // Close the server to stop reception of more requests.\n    lock.lock();\n    try {\n      if (!closed) {\n        peerServer.close();\n        closed \u003d true;\n      }\n    } catch (IOException ie) {\n      LOG.warn(\"{}:DataXceiverServer: close exception\",\n          datanode.getDisplayName(), ie);\n    } finally {\n      lock.unlock();\n    }\n\n    // if in restart prep stage, notify peers before closing them.\n    if (datanode.shutdownForUpgrade) {\n      restartNotifyPeers();\n      // Each thread needs some time to process it. If a thread needs\n      // to send an OOB message to the client, but blocked on network for\n      // long time, we need to force its termination.\n      LOG.info(\"Shutting down DataXceiverServer before restart\");\n\n      waitAllPeers(2L, TimeUnit.SECONDS);\n    }\n\n    closeAllPeers();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "235e3da90a4212d0c204afaef09db3408abfab82": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14287. DataXceiverServer May Double-Close PeerServer. Contributed by BELUGA BEHR.\n",
      "commitDate": "18/02/19 11:00 AM",
      "commitName": "235e3da90a4212d0c204afaef09db3408abfab82",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "15/02/19 4:32 PM",
      "commitNameOld": "dde0ab55aadcf7c9cf71dbe36d90e97da6bc9498",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,73 @@\n   public void run() {\n     Peer peer \u003d null;\n     while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n       try {\n         peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n             DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n           LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.closeQuietly(peer);\n         LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.closeQuietly(peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(TimeUnit.SECONDS.toMillis(30L));\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(\"{}:DataXceiverServer: Exiting.\", datanode.getDisplayName(),\n             te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n \n     // Close the server to stop reception of more requests.\n+    lock.lock();\n     try {\n-      peerServer.close();\n-      closed \u003d true;\n+      if (!closed) {\n+        peerServer.close();\n+        closed \u003d true;\n+      }\n     } catch (IOException ie) {\n       LOG.warn(\"{}:DataXceiverServer: close exception\",\n           datanode.getDisplayName(), ie);\n+    } finally {\n+      lock.unlock();\n     }\n \n     // if in restart prep stage, notify peers before closing them.\n     if (datanode.shutdownForUpgrade) {\n       restartNotifyPeers();\n       // Each thread needs some time to process it. If a thread needs\n       // to send an OOB message to the client, but blocked on network for\n       // long time, we need to force its termination.\n       LOG.info(\"Shutting down DataXceiverServer before restart\");\n \n       waitAllPeers(2L, TimeUnit.SECONDS);\n     }\n \n     closeAllPeers();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n          LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeQuietly(peer);\n        LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeQuietly(peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(TimeUnit.SECONDS.toMillis(30L));\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(\"{}:DataXceiverServer: Exiting.\", datanode.getDisplayName(),\n            te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n\n    // Close the server to stop reception of more requests.\n    lock.lock();\n    try {\n      if (!closed) {\n        peerServer.close();\n        closed \u003d true;\n      }\n    } catch (IOException ie) {\n      LOG.warn(\"{}:DataXceiverServer: close exception\",\n          datanode.getDisplayName(), ie);\n    } finally {\n      lock.unlock();\n    }\n\n    // if in restart prep stage, notify peers before closing them.\n    if (datanode.shutdownForUpgrade) {\n      restartNotifyPeers();\n      // Each thread needs some time to process it. If a thread needs\n      // to send an OOB message to the client, but blocked on network for\n      // long time, we need to force its termination.\n      LOG.info(\"Shutting down DataXceiverServer before restart\");\n\n      waitAllPeers(2L, TimeUnit.SECONDS);\n    }\n\n    closeAllPeers();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "dde0ab55aadcf7c9cf71dbe36d90e97da6bc9498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14258. Introduce Java Concurrent Package To DataXceiverServer Class. Contributed by BELUGA BEHR.\n",
      "commitDate": "15/02/19 4:32 PM",
      "commitName": "dde0ab55aadcf7c9cf71dbe36d90e97da6bc9498",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "23/06/16 2:13 PM",
      "commitNameOld": "dca298d79e46e27bdf008be53dd77448d7a9c0c6",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 967.14,
      "commitsBetweenForRepo": 7428,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,68 @@\n   public void run() {\n     Peer peer \u003d null;\n     while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n       try {\n         peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n             DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n-          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n+          LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ace);\n         }\n       } catch (IOException ie) {\n-        IOUtils.cleanup(null, peer);\n-        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n+        IOUtils.closeQuietly(peer);\n+        LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ie);\n       } catch (OutOfMemoryError ie) {\n-        IOUtils.cleanup(null, peer);\n+        IOUtils.closeQuietly(peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n-          Thread.sleep(30 * 1000);\n+          Thread.sleep(TimeUnit.SECONDS.toMillis(30L));\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n-        LOG.error(datanode.getDisplayName()\n-            + \":DataXceiverServer: Exiting due to: \", te);\n+        LOG.error(\"{}:DataXceiverServer: Exiting.\", datanode.getDisplayName(),\n+            te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n \n     // Close the server to stop reception of more requests.\n     try {\n       peerServer.close();\n       closed \u003d true;\n     } catch (IOException ie) {\n-      LOG.warn(datanode.getDisplayName()\n-          + \" :DataXceiverServer: close exception\", ie);\n+      LOG.warn(\"{}:DataXceiverServer: close exception\",\n+          datanode.getDisplayName(), ie);\n     }\n \n     // if in restart prep stage, notify peers before closing them.\n     if (datanode.shutdownForUpgrade) {\n       restartNotifyPeers();\n       // Each thread needs some time to process it. If a thread needs\n       // to send an OOB message to the client, but blocked on network for\n       // long time, we need to force its termination.\n       LOG.info(\"Shutting down DataXceiverServer before restart\");\n-      // Allow roughly up to 2 seconds.\n-      for (int i \u003d 0; getNumPeers() \u003e 0 \u0026\u0026 i \u003c 10; i++) {\n-        try {\n-          Thread.sleep(200);\n-        } catch (InterruptedException e) {\n-          // ignore\n-        }\n-      }\n+\n+      waitAllPeers(2L, TimeUnit.SECONDS);\n     }\n-    // Close all peers.\n+\n     closeAllPeers();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n          LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeQuietly(peer);\n        LOG.warn(\"{}:DataXceiverServer\", datanode.getDisplayName(), ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeQuietly(peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(TimeUnit.SECONDS.toMillis(30L));\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(\"{}:DataXceiverServer: Exiting.\", datanode.getDisplayName(),\n            te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n\n    // Close the server to stop reception of more requests.\n    try {\n      peerServer.close();\n      closed \u003d true;\n    } catch (IOException ie) {\n      LOG.warn(\"{}:DataXceiverServer: close exception\",\n          datanode.getDisplayName(), ie);\n    }\n\n    // if in restart prep stage, notify peers before closing them.\n    if (datanode.shutdownForUpgrade) {\n      restartNotifyPeers();\n      // Each thread needs some time to process it. If a thread needs\n      // to send an OOB message to the client, but blocked on network for\n      // long time, we need to force its termination.\n      LOG.info(\"Shutting down DataXceiverServer before restart\");\n\n      waitAllPeers(2L, TimeUnit.SECONDS);\n    }\n\n    closeAllPeers();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "b3d8a642a938da9de680b479585a7c2014b8965c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7283. Bump DataNode OOM log from WARN to ERROR. Contributed by Stephen Chu.\n",
      "commitDate": "24/10/14 10:50 AM",
      "commitName": "b3d8a642a938da9de680b479585a7c2014b8965c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/08/14 6:13 PM",
      "commitNameOld": "6824abc19e12ed142d9f32b8706ef73d97edd1cc",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 64.69,
      "commitsBetweenForRepo": 633,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public void run() {\n     Peer peer \u003d null;\n     while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n       try {\n         peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n             DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n           LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.cleanup(null, peer);\n         LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.cleanup(null, peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n-        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n+        LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n \n     // Close the server to stop reception of more requests.\n     try {\n       peerServer.close();\n       closed \u003d true;\n     } catch (IOException ie) {\n       LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n \n     // if in restart prep stage, notify peers before closing them.\n     if (datanode.shutdownForUpgrade) {\n       restartNotifyPeers();\n       // Each thread needs some time to process it. If a thread needs\n       // to send an OOB message to the client, but blocked on network for\n       // long time, we need to force its termination.\n       LOG.info(\"Shutting down DataXceiverServer before restart\");\n       // Allow roughly up to 2 seconds.\n       for (int i \u003d 0; getNumPeers() \u003e 0 \u0026\u0026 i \u003c 10; i++) {\n         try {\n           Thread.sleep(200);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       }\n     }\n     // Close all peers.\n     closeAllPeers();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.cleanup(null, peer);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.cleanup(null, peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.error(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n\n    // Close the server to stop reception of more requests.\n    try {\n      peerServer.close();\n      closed \u003d true;\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n\n    // if in restart prep stage, notify peers before closing them.\n    if (datanode.shutdownForUpgrade) {\n      restartNotifyPeers();\n      // Each thread needs some time to process it. If a thread needs\n      // to send an OOB message to the client, but blocked on network for\n      // long time, we need to force its termination.\n      LOG.info(\"Shutting down DataXceiverServer before restart\");\n      // Allow roughly up to 2 seconds.\n      for (int i \u003d 0; getNumPeers() \u003e 0 \u0026\u0026 i \u003c 10; i++) {\n        try {\n          Thread.sleep(200);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      }\n    }\n    // Close all peers.\n    closeAllPeers();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "1c6b5d2b5841e5219a98937088cde4ae63869f80": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5583. Make DN send an OOB Ack on shutdown before restarting. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571491 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/14 3:38 PM",
      "commitName": "1c6b5d2b5841e5219a98937088cde4ae63869f80",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "09/01/13 1:34 PM",
      "commitNameOld": "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 411.09,
      "commitsBetweenForRepo": 2591,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,74 @@\n   public void run() {\n     Peer peer \u003d null;\n-    while (datanode.shouldRun) {\n+    while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n       try {\n         peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n             DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n-        if (datanode.shouldRun) {\n+        if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n           LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.cleanup(null, peer);\n         LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.cleanup(null, peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n-    synchronized (this) {\n-      for (Peer p : peers) {\n-        IOUtils.cleanup(LOG, p);\n-      }\n-    }\n+\n+    // Close the server to stop reception of more requests.\n     try {\n       peerServer.close();\n+      closed \u003d true;\n     } catch (IOException ie) {\n       LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n+\n+    // if in restart prep stage, notify peers before closing them.\n+    if (datanode.shutdownForUpgrade) {\n+      restartNotifyPeers();\n+      // Each thread needs some time to process it. If a thread needs\n+      // to send an OOB message to the client, but blocked on network for\n+      // long time, we need to force its termination.\n+      LOG.info(\"Shutting down DataXceiverServer before restart\");\n+      // Allow roughly up to 2 seconds.\n+      for (int i \u003d 0; getNumPeers() \u003e 0 \u0026\u0026 i \u003c 10; i++) {\n+        try {\n+          Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+          // ignore\n+        }\n+      }\n+    }\n+    // Close all peers.\n+    closeAllPeers();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun \u0026\u0026 !datanode.shutdownForUpgrade) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.cleanup(null, peer);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.cleanup(null, peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n\n    // Close the server to stop reception of more requests.\n    try {\n      peerServer.close();\n      closed \u003d true;\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n\n    // if in restart prep stage, notify peers before closing them.\n    if (datanode.shutdownForUpgrade) {\n      restartNotifyPeers();\n      // Each thread needs some time to process it. If a thread needs\n      // to send an OOB message to the client, but blocked on network for\n      // long time, we need to force its termination.\n      LOG.info(\"Shutting down DataXceiverServer before restart\");\n      // Allow roughly up to 2 seconds.\n      for (int i \u003d 0; getNumPeers() \u003e 0 \u0026\u0026 i \u003c 10; i++) {\n        try {\n          Thread.sleep(200);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      }\n    }\n    // Close all peers.\n    closeAllPeers();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1431097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 1:34 PM",
      "commitName": "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "08/01/13 6:39 PM",
      "commitNameOld": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,57 @@\n   public void run() {\n+    Peer peer \u003d null;\n     while (datanode.shouldRun) {\n-      Socket s \u003d null;\n       try {\n-        s \u003d ss.accept();\n-        s.setTcpNoDelay(true);\n-        // Timeouts are set within DataXceiver.run()\n+        peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n-            DataXceiver.create(s, datanode, this))\n+            DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n           LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n-        IOUtils.closeSocket(s);\n+        IOUtils.cleanup(null, peer);\n         LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n-        IOUtils.closeSocket(s);\n+        IOUtils.cleanup(null, peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n+    synchronized (this) {\n+      for (Peer p : peers) {\n+        IOUtils.cleanup(LOG, p);\n+      }\n+    }\n     try {\n-      ss.close();\n+      peerServer.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.cleanup(null, peer);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.cleanup(null, peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    synchronized (this) {\n      for (Peer p : peers) {\n        IOUtils.cleanup(LOG, p);\n      }\n    }\n    try {\n      peerServer.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "837e17b2eac1471d93e2eff395272063b265fee7": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c -1430507 . for reverting HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430662 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 6:39 PM",
      "commitName": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/01/13 12:44 PM",
      "commitNameOld": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,54 @@\n   public void run() {\n-    Peer peer \u003d null;\n     while (datanode.shouldRun) {\n+      Socket s \u003d null;\n       try {\n-        peer \u003d peerServer.accept();\n+        s \u003d ss.accept();\n+        s.setTcpNoDelay(true);\n+        // Timeouts are set within DataXceiver.run()\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n-            DataXceiver.create(peer, datanode, this))\n+            DataXceiver.create(s, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n           LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n-        IOUtils.cleanup(null, peer);\n+        IOUtils.closeSocket(s);\n         LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n-        IOUtils.cleanup(null, peer);\n+        IOUtils.closeSocket(s);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n-    synchronized (this) {\n-      for (Peer p : peers) {\n-        IOUtils.cleanup(LOG, p);\n-      }\n-    }\n     try {\n-      peerServer.close();\n+      ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      Socket s \u003d null;\n      try {\n        s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        // Timeouts are set within DataXceiver.run()\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(s, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeSocket(s);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeSocket(s);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "239b2742d0e80d13c970fd062af4930e672fe903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430507 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 12:44 PM",
      "commitName": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/05/12 11:50 AM",
      "commitNameOld": "a701c792f880c43ba807f00a92a99dadf89eab0c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 249.08,
      "commitsBetweenForRepo": 1300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,57 @@\n   public void run() {\n+    Peer peer \u003d null;\n     while (datanode.shouldRun) {\n-      Socket s \u003d null;\n       try {\n-        s \u003d ss.accept();\n-        s.setTcpNoDelay(true);\n-        // Timeouts are set within DataXceiver.run()\n+        peer \u003d peerServer.accept();\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup,\n-            DataXceiver.create(s, datanode, this))\n+            DataXceiver.create(peer, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n           LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n-        IOUtils.closeSocket(s);\n+        IOUtils.cleanup(null, peer);\n         LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n-        IOUtils.closeSocket(s);\n+        IOUtils.cleanup(null, peer);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n+    synchronized (this) {\n+      for (Peer p : peers) {\n+        IOUtils.cleanup(LOG, p);\n+      }\n+    }\n     try {\n-      ss.close();\n+      peerServer.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    Peer peer \u003d null;\n    while (datanode.shouldRun) {\n      try {\n        peer \u003d peerServer.accept();\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(peer, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.cleanup(null, peer);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.cleanup(null, peer);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    synchronized (this) {\n      for (Peer p : peers) {\n        IOUtils.cleanup(LOG, p);\n      }\n    }\n    try {\n      peerServer.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "a701c792f880c43ba807f00a92a99dadf89eab0c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3357. DataXceiver reads from client socket with incorrect/no timeout. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1334116 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/12 11:50 AM",
      "commitName": "a701c792f880c43ba807f00a92a99dadf89eab0c",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/03/12 8:41 PM",
      "commitNameOld": "0663dbaac0a19719ddf9cd4290ba893bfca69da2",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 33.63,
      "commitsBetweenForRepo": 270,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       Socket s \u003d null;\n       try {\n         s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n+        // Timeouts are set within DataXceiver.run()\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n-        new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n+        new Daemon(datanode.threadGroup,\n+            DataXceiver.create(s, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n           LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.closeSocket(s);\n         LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.closeSocket(s);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      Socket s \u003d null;\n      try {\n        s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        // Timeouts are set within DataXceiver.run()\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup,\n            DataXceiver.create(s, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeSocket(s);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeSocket(s);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "0663dbaac0a19719ddf9cd4290ba893bfca69da2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3171. The DatanodeID \"name\" field is overloaded. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308014 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/03/12 8:41 PM",
      "commitName": "0663dbaac0a19719ddf9cd4290ba893bfca69da2",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "04/01/12 6:15 AM",
      "commitNameOld": "075122690c5c17ac443a8eb3fb7387001e4907c0",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 87.56,
      "commitsBetweenForRepo": 658,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       Socket s \u003d null;\n       try {\n         s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n \n         // Make sure the xceiver count is not exceeded\n         int curXceiverCount \u003d datanode.getXceiverCount();\n         if (curXceiverCount \u003e maxXceiverCount) {\n           throw new IOException(\"Xceiver count \" + curXceiverCount\n               + \" exceeds the limit of concurrent xcievers: \"\n               + maxXceiverCount);\n         }\n \n         new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n-          LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n+          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.closeSocket(s);\n-        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n+        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.closeSocket(s);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n-        LOG.error(datanode.getMachineName()\n+        LOG.error(datanode.getDisplayName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n-      LOG.warn(datanode.getMachineName()\n+      LOG.warn(datanode.getDisplayName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      Socket s \u003d null;\n      try {\n        s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeSocket(s);\n        LOG.warn(datanode.getDisplayName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeSocket(s);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getDisplayName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getDisplayName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "8e8bb50afd823a26d9a7ed1311ad050ef059fb5d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2454. Move maxXceiverCount check to before starting the thread in dataXceiver. Contributed by Harsh J\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204124 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/11 8:27 PM",
      "commitName": "8e8bb50afd823a26d9a7ed1311ad050ef059fb5d",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "19/11/11 8:13 PM",
      "commitNameOld": "513718f92dc572da22a995830fe203b969f23493",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,52 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       Socket s \u003d null;\n       try {\n         s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n+\n+        // Make sure the xceiver count is not exceeded\n+        int curXceiverCount \u003d datanode.getXceiverCount();\n+        if (curXceiverCount \u003e maxXceiverCount) {\n+          throw new IOException(\"Xceiver count \" + curXceiverCount\n+              + \" exceeds the limit of concurrent xcievers: \"\n+              + maxXceiverCount);\n+        }\n+\n         new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n             .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n           LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n         IOUtils.closeSocket(s);\n         LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n       } catch (OutOfMemoryError ie) {\n         IOUtils.closeSocket(s);\n         // DataNode can run out of memory if there is too many transfers.\n         // Log the event, Sleep for 30 seconds, other transfers may complete by\n         // then.\n         LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n         try {\n           Thread.sleep(30 * 1000);\n         } catch (InterruptedException e) {\n           // ignore\n         }\n       } catch (Throwable te) {\n         LOG.error(datanode.getMachineName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getMachineName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      Socket s \u003d null;\n      try {\n        s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n\n        // Make sure the xceiver count is not exceeded\n        int curXceiverCount \u003d datanode.getXceiverCount();\n        if (curXceiverCount \u003e maxXceiverCount) {\n          throw new IOException(\"Xceiver count \" + curXceiverCount\n              + \" exceeds the limit of concurrent xcievers: \"\n              + maxXceiverCount);\n        }\n\n        new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeSocket(s);\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeSocket(s);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "6e0991704ffda5cf4cff758f0e7086523fa7bcb4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2452. OutOfMemoryError in DataXceiverServer takes down the DataNode. Contributed by Uma Maheswara Rao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1187965 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/10/11 1:17 PM",
      "commitName": "6e0991704ffda5cf4cff758f0e7086523fa7bcb4",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "04/09/11 12:30 PM",
      "commitNameOld": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 49.03,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,43 @@\n   public void run() {\n     while (datanode.shouldRun) {\n+      Socket s \u003d null;\n       try {\n-        Socket s \u003d ss.accept();\n+        s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n-        final DataXceiver exciver;\n-        try {\n-          exciver \u003d new DataXceiver(s, datanode, this);\n-        } catch(IOException e) {\n-          IOUtils.closeSocket(s);\n-          throw e;\n-        }\n-        new Daemon(datanode.threadGroup, exciver).start();\n+        new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n+            .start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (AsynchronousCloseException ace) {\n         // another thread closed our listener socket - that\u0027s expected during shutdown,\n         // but not in other circumstances\n         if (datanode.shouldRun) {\n           LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n         }\n       } catch (IOException ie) {\n+        IOUtils.closeSocket(s);\n         LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n+      } catch (OutOfMemoryError ie) {\n+        IOUtils.closeSocket(s);\n+        // DataNode can run out of memory if there is too many transfers.\n+        // Log the event, Sleep for 30 seconds, other transfers may complete by\n+        // then.\n+        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n+        try {\n+          Thread.sleep(30 * 1000);\n+        } catch (InterruptedException e) {\n+          // ignore\n+        }\n       } catch (Throwable te) {\n         LOG.error(datanode.getMachineName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getMachineName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      Socket s \u003d null;\n      try {\n        s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        new Daemon(datanode.threadGroup, new DataXceiver(s, datanode, this))\n            .start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        IOUtils.closeSocket(s);\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (OutOfMemoryError ie) {\n        IOUtils.closeSocket(s);\n        // DataNode can run out of memory if there is too many transfers.\n        // Log the event, Sleep for 30 seconds, other transfers may complete by\n        // then.\n        LOG.warn(\"DataNode is out of memory. Will retry in 30 seconds.\", ie);\n        try {\n          Thread.sleep(30 * 1000);\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "7cf49f5d9ccef7e42415003435184e05d5dabb23": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2286. DataXceiverServer logs AsynchronousCloseException at shutdown. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1162003 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/08/11 11:44 PM",
      "commitName": "7cf49f5d9ccef7e42415003435184e05d5dabb23",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,36 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       try {\n         Socket s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n         final DataXceiver exciver;\n         try {\n           exciver \u003d new DataXceiver(s, datanode, this);\n         } catch(IOException e) {\n           IOUtils.closeSocket(s);\n           throw e;\n         }\n         new Daemon(datanode.threadGroup, exciver).start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n+      } catch (AsynchronousCloseException ace) {\n+        // another thread closed our listener socket - that\u0027s expected during shutdown,\n+        // but not in other circumstances\n+        if (datanode.shouldRun) {\n+          LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n+        }\n       } catch (IOException ie) {\n         LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n       } catch (Throwable te) {\n         LOG.error(datanode.getMachineName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getMachineName()\n           + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        final DataXceiver exciver;\n        try {\n          exciver \u003d new DataXceiver(s, datanode, this);\n        } catch(IOException e) {\n          IOUtils.closeSocket(s);\n          throw e;\n        }\n        new Daemon(datanode.threadGroup, exciver).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (AsynchronousCloseException ace) {\n        // another thread closed our listener socket - that\u0027s expected during shutdown,\n        // but not in other circumstances\n        if (datanode.shouldRun) {\n          LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ace);\n        }\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        final DataXceiver exciver;\n        try {\n          exciver \u003d new DataXceiver(s, datanode, this);\n        } catch(IOException e) {\n          IOUtils.closeSocket(s);\n          throw e;\n        }\n        new Daemon(datanode.threadGroup, exciver).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        final DataXceiver exciver;\n        try {\n          exciver \u003d new DataXceiver(s, datanode, this);\n        } catch(IOException e) {\n          IOUtils.closeSocket(s);\n          throw e;\n        }\n        new Daemon(datanode.threadGroup, exciver).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java"
      }
    },
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1977. Stop using StringUtils.stringifyException(). Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1145834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/11 6:11 PM",
      "commitName": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "30/06/11 1:56 PM",
      "commitNameOld": "3af51887b40df8de7482040cf8a90600a2c4305f",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 12.18,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       try {\n         Socket s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n         final DataXceiver exciver;\n         try {\n           exciver \u003d new DataXceiver(s, datanode, this);\n         } catch(IOException e) {\n           IOUtils.closeSocket(s);\n           throw e;\n         }\n         new Daemon(datanode.threadGroup, exciver).start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (IOException ie) {\n         LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n       } catch (Throwable te) {\n         LOG.error(datanode.getMachineName()\n             + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getMachineName()\n-          + \":DataXceiverServer: Close exception due to: \", ie);\n+          + \" :DataXceiverServer: close exception\", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        final DataXceiver exciver;\n        try {\n          exciver \u003d new DataXceiver(s, datanode, this);\n        } catch(IOException e) {\n          IOUtils.closeSocket(s);\n          throw e;\n        }\n        new Daemon(datanode.threadGroup, exciver).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \" :DataXceiverServer: close exception\", ie);\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "3af51887b40df8de7482040cf8a90600a2c4305f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2118. Couple dfs data dir improvements. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1141713 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/06/11 1:56 PM",
      "commitName": "3af51887b40df8de7482040cf8a90600a2c4305f",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "23/06/11 4:57 PM",
      "commitNameOld": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       try {\n         Socket s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n         final DataXceiver exciver;\n         try {\n           exciver \u003d new DataXceiver(s, datanode, this);\n         } catch(IOException e) {\n           IOUtils.closeSocket(s);\n           throw e;\n         }\n         new Daemon(datanode.threadGroup, exciver).start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (IOException ie) {\n-        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \", ie);\n+        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n       } catch (Throwable te) {\n         LOG.error(datanode.getMachineName()\n-            + \":DataXceiveServer: Exiting due to: \", te);\n+            + \":DataXceiverServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getMachineName()\n-          + \":DataXceiveServer: Close exception due to: \", ie);\n+          + \":DataXceiverServer: Close exception due to: \", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        final DataXceiver exciver;\n        try {\n          exciver \u003d new DataXceiver(s, datanode, this);\n        } catch(IOException e) {\n          IOUtils.closeSocket(s);\n          throw e;\n        }\n        new Daemon(datanode.threadGroup, exciver).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiverServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiverServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \":DataXceiverServer: Close exception due to: \", ie);\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/11 4:57 PM",
      "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/06/11 4:35 PM",
      "commitNameOld": "58dc1381e0f2582e91da13cc67a5ca9d9657d78c",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 7.02,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,30 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       try {\n         Socket s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n-        new Daemon(datanode.threadGroup, \n-            new DataXceiver(s, datanode, this)).start();\n+        final DataXceiver exciver;\n+        try {\n+          exciver \u003d new DataXceiver(s, datanode, this);\n+        } catch(IOException e) {\n+          IOUtils.closeSocket(s);\n+          throw e;\n+        }\n+        new Daemon(datanode.threadGroup, exciver).start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (IOException ie) {\n         LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \", ie);\n       } catch (Throwable te) {\n         LOG.error(datanode.getMachineName()\n             + \":DataXceiveServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n       LOG.warn(datanode.getMachineName()\n           + \":DataXceiveServer: Close exception due to: \", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        final DataXceiver exciver;\n        try {\n          exciver \u003d new DataXceiver(s, datanode, this);\n        } catch(IOException e) {\n          IOUtils.closeSocket(s);\n          throw e;\n        }\n        new Daemon(datanode.threadGroup, exciver).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiveServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \":DataXceiveServer: Close exception due to: \", ie);\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "58dc1381e0f2582e91da13cc67a5ca9d9657d78c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1692. In secure mode, Datanode process doesn\u0027t exit when disks fail. Contributed by Bharath Mundlapudi.\n        \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1136741 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/06/11 4:35 PM",
      "commitName": "58dc1381e0f2582e91da13cc67a5ca9d9657d78c",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "12/06/11 3:00 PM",
      "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 4.07,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,24 @@\n   public void run() {\n     while (datanode.shouldRun) {\n       try {\n         Socket s \u003d ss.accept();\n         s.setTcpNoDelay(true);\n         new Daemon(datanode.threadGroup, \n             new DataXceiver(s, datanode, this)).start();\n       } catch (SocketTimeoutException ignored) {\n         // wake up to see if should continue to run\n       } catch (IOException ie) {\n-        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \" \n-                                + StringUtils.stringifyException(ie));\n+        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \", ie);\n       } catch (Throwable te) {\n-        LOG.error(datanode.getMachineName() + \":DataXceiveServer: Exiting due to:\" \n-                                 + StringUtils.stringifyException(te));\n+        LOG.error(datanode.getMachineName()\n+            + \":DataXceiveServer: Exiting due to: \", te);\n         datanode.shouldRun \u003d false;\n       }\n     }\n     try {\n       ss.close();\n     } catch (IOException ie) {\n-      LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \" \n-                              + StringUtils.stringifyException(ie));\n+      LOG.warn(datanode.getMachineName()\n+          + \":DataXceiveServer: Close exception due to: \", ie);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        new Daemon(datanode.threadGroup, \n            new DataXceiver(s, datanode, this)).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \", ie);\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName()\n            + \":DataXceiveServer: Exiting due to: \", te);\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName()\n          + \":DataXceiveServer: Close exception due to: \", ie);\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,25 @@\n+  public void run() {\n+    while (datanode.shouldRun) {\n+      try {\n+        Socket s \u003d ss.accept();\n+        s.setTcpNoDelay(true);\n+        new Daemon(datanode.threadGroup, \n+            new DataXceiver(s, datanode, this)).start();\n+      } catch (SocketTimeoutException ignored) {\n+        // wake up to see if should continue to run\n+      } catch (IOException ie) {\n+        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \" \n+                                + StringUtils.stringifyException(ie));\n+      } catch (Throwable te) {\n+        LOG.error(datanode.getMachineName() + \":DataXceiveServer: Exiting due to:\" \n+                                 + StringUtils.stringifyException(te));\n+        datanode.shouldRun \u003d false;\n+      }\n+    }\n+    try {\n+      ss.close();\n+    } catch (IOException ie) {\n+      LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \" \n+                              + StringUtils.stringifyException(ie));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (datanode.shouldRun) {\n      try {\n        Socket s \u003d ss.accept();\n        s.setTcpNoDelay(true);\n        new Daemon(datanode.threadGroup, \n            new DataXceiver(s, datanode, this)).start();\n      } catch (SocketTimeoutException ignored) {\n        // wake up to see if should continue to run\n      } catch (IOException ie) {\n        LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \" \n                                + StringUtils.stringifyException(ie));\n      } catch (Throwable te) {\n        LOG.error(datanode.getMachineName() + \":DataXceiveServer: Exiting due to:\" \n                                 + StringUtils.stringifyException(te));\n        datanode.shouldRun \u003d false;\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException ie) {\n      LOG.warn(datanode.getMachineName() + \":DataXceiveServer: \" \n                              + StringUtils.stringifyException(ie));\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiverServer.java"
    }
  }
}