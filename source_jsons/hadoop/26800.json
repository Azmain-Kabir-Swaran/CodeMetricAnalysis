{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProtocRunner.java",
  "functionName": "execute",
  "functionId": "execute",
  "sourceFilePath": "hadoop-maven-plugins/src/main/java/org/apache/hadoop/maven/plugin/protoc/ProtocRunner.java",
  "functionStartLine": 183,
  "functionEndLine": 282,
  "numCommitsSeen": 2,
  "timeTaken": 409,
  "changeHistory": [
    "e1c6ef2efa9d87fdfc7474ca63998a13a3929874"
  ],
  "changeHistoryShort": {
    "e1c6ef2efa9d87fdfc7474ca63998a13a3929874": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e1c6ef2efa9d87fdfc7474ca63998a13a3929874": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13789. Hadoop Common includes generated test protos in both jar and test-jar. Contributed by Sean Busbey.\n",
      "commitDate": "08/11/16 4:33 PM",
      "commitName": "e1c6ef2efa9d87fdfc7474ca63998a13a3929874",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,100 @@\n+  public void execute() throws MojoExecutionException {\n+    try {\n+      List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n+      command.add(protocCommand);\n+      command.add(\"--version\");\n+      Exec exec \u003d new Exec(mojo);\n+      List\u003cString\u003e out \u003d new ArrayList\u003cString\u003e();\n+      if (exec.run(command, out) \u003d\u003d 127) {\n+        mojo.getLog().error(\"protoc, not found at: \" + protocCommand);\n+        throw new MojoExecutionException(\"protoc failure\");\n+      } else {\n+        if (out.isEmpty()) {\n+          mojo.getLog().error(\"stdout: \" + out);\n+          throw new MojoExecutionException(\n+              \"\u0027protoc --version\u0027 did not return a version\");\n+        } else {\n+          if (!out.get(0).endsWith(protocVersion)) {\n+            throw new MojoExecutionException(\n+                \"protoc version is \u0027\" + out.get(0) + \"\u0027, expected version is \u0027\"\n+                    + protocVersion + \"\u0027\");\n+          }\n+        }\n+      }\n+      if (!output.mkdirs()) {\n+        if (!output.exists()) {\n+          throw new MojoExecutionException(\n+              \"Could not create directory: \" + output);\n+        }\n+      }\n+\n+      // Whether the import or source protoc files have changed.\n+      ChecksumComparator comparator \u003d new ChecksumComparator(checksumPath);\n+      boolean importsChanged \u003d false;\n+\n+      command \u003d new ArrayList\u003cString\u003e();\n+      command.add(protocCommand);\n+      command.add(\"--java_out\u003d\" + output.getCanonicalPath());\n+      if (imports !\u003d null) {\n+        for (File i : imports) {\n+          if (comparator.hasChanged(i)) {\n+            importsChanged \u003d true;\n+          }\n+          command.add(\"-I\" + i.getCanonicalPath());\n+        }\n+      }\n+      // Filter to generate classes for just the changed source files.\n+      List\u003cFile\u003e changedSources \u003d new ArrayList\u003c\u003e();\n+      boolean sourcesChanged \u003d false;\n+      for (File f : FileSetUtils.convertFileSetToFiles(source)) {\n+        // Need to recompile if the source has changed, or if any import has\n+        // changed.\n+        if (comparator.hasChanged(f) || importsChanged) {\n+          sourcesChanged \u003d true;\n+          changedSources.add(f);\n+          command.add(f.getCanonicalPath());\n+        }\n+      }\n+\n+      if (!sourcesChanged \u0026\u0026 !importsChanged) {\n+        mojo.getLog().info(\"No changes detected in protoc files, skipping \"\n+            + \"generation.\");\n+      } else {\n+        if (mojo.getLog().isDebugEnabled()) {\n+          StringBuilder b \u003d new StringBuilder();\n+          b.append(\"Generating classes for the following protoc files: [\");\n+          String prefix \u003d \"\";\n+          for (File f : changedSources) {\n+            b.append(prefix);\n+            b.append(f.toString());\n+            prefix \u003d \", \";\n+          }\n+          b.append(\"]\");\n+          mojo.getLog().debug(b.toString());\n+        }\n+\n+        exec \u003d new Exec(mojo);\n+        out \u003d new ArrayList\u003cString\u003e();\n+        List\u003cString\u003e err \u003d new ArrayList\u003c\u003e();\n+        if (exec.run(command, out, err) !\u003d 0) {\n+          mojo.getLog().error(\"protoc compiler error\");\n+          for (String s : out) {\n+            mojo.getLog().error(s);\n+          }\n+          for (String s : err) {\n+            mojo.getLog().error(s);\n+          }\n+          throw new MojoExecutionException(\"protoc failure\");\n+        }\n+        // Write the new checksum file on success.\n+        comparator.writeChecksums();\n+      }\n+    } catch (Throwable ex) {\n+      throw new MojoExecutionException(ex.toString(), ex);\n+    }\n+    if(test) {\n+      project.addTestCompileSourceRoot(output.getAbsolutePath());\n+    } else {\n+      project.addCompileSourceRoot(output.getAbsolutePath());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void execute() throws MojoExecutionException {\n    try {\n      List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n      command.add(protocCommand);\n      command.add(\"--version\");\n      Exec exec \u003d new Exec(mojo);\n      List\u003cString\u003e out \u003d new ArrayList\u003cString\u003e();\n      if (exec.run(command, out) \u003d\u003d 127) {\n        mojo.getLog().error(\"protoc, not found at: \" + protocCommand);\n        throw new MojoExecutionException(\"protoc failure\");\n      } else {\n        if (out.isEmpty()) {\n          mojo.getLog().error(\"stdout: \" + out);\n          throw new MojoExecutionException(\n              \"\u0027protoc --version\u0027 did not return a version\");\n        } else {\n          if (!out.get(0).endsWith(protocVersion)) {\n            throw new MojoExecutionException(\n                \"protoc version is \u0027\" + out.get(0) + \"\u0027, expected version is \u0027\"\n                    + protocVersion + \"\u0027\");\n          }\n        }\n      }\n      if (!output.mkdirs()) {\n        if (!output.exists()) {\n          throw new MojoExecutionException(\n              \"Could not create directory: \" + output);\n        }\n      }\n\n      // Whether the import or source protoc files have changed.\n      ChecksumComparator comparator \u003d new ChecksumComparator(checksumPath);\n      boolean importsChanged \u003d false;\n\n      command \u003d new ArrayList\u003cString\u003e();\n      command.add(protocCommand);\n      command.add(\"--java_out\u003d\" + output.getCanonicalPath());\n      if (imports !\u003d null) {\n        for (File i : imports) {\n          if (comparator.hasChanged(i)) {\n            importsChanged \u003d true;\n          }\n          command.add(\"-I\" + i.getCanonicalPath());\n        }\n      }\n      // Filter to generate classes for just the changed source files.\n      List\u003cFile\u003e changedSources \u003d new ArrayList\u003c\u003e();\n      boolean sourcesChanged \u003d false;\n      for (File f : FileSetUtils.convertFileSetToFiles(source)) {\n        // Need to recompile if the source has changed, or if any import has\n        // changed.\n        if (comparator.hasChanged(f) || importsChanged) {\n          sourcesChanged \u003d true;\n          changedSources.add(f);\n          command.add(f.getCanonicalPath());\n        }\n      }\n\n      if (!sourcesChanged \u0026\u0026 !importsChanged) {\n        mojo.getLog().info(\"No changes detected in protoc files, skipping \"\n            + \"generation.\");\n      } else {\n        if (mojo.getLog().isDebugEnabled()) {\n          StringBuilder b \u003d new StringBuilder();\n          b.append(\"Generating classes for the following protoc files: [\");\n          String prefix \u003d \"\";\n          for (File f : changedSources) {\n            b.append(prefix);\n            b.append(f.toString());\n            prefix \u003d \", \";\n          }\n          b.append(\"]\");\n          mojo.getLog().debug(b.toString());\n        }\n\n        exec \u003d new Exec(mojo);\n        out \u003d new ArrayList\u003cString\u003e();\n        List\u003cString\u003e err \u003d new ArrayList\u003c\u003e();\n        if (exec.run(command, out, err) !\u003d 0) {\n          mojo.getLog().error(\"protoc compiler error\");\n          for (String s : out) {\n            mojo.getLog().error(s);\n          }\n          for (String s : err) {\n            mojo.getLog().error(s);\n          }\n          throw new MojoExecutionException(\"protoc failure\");\n        }\n        // Write the new checksum file on success.\n        comparator.writeChecksums();\n      }\n    } catch (Throwable ex) {\n      throw new MojoExecutionException(ex.toString(), ex);\n    }\n    if(test) {\n      project.addTestCompileSourceRoot(output.getAbsolutePath());\n    } else {\n      project.addCompileSourceRoot(output.getAbsolutePath());\n    }\n  }",
      "path": "hadoop-maven-plugins/src/main/java/org/apache/hadoop/maven/plugin/protoc/ProtocRunner.java"
    }
  }
}