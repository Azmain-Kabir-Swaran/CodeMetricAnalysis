{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Configuration.java",
  "functionName": "loadResource",
  "functionId": "loadResource___properties-Properties__wrapper-Resource__quiet-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
  "functionStartLine": 3012,
  "functionEndLine": 3057,
  "numCommitsSeen": 188,
  "timeTaken": 8468,
  "changeHistory": [
    "3961690037fa4274a3640104b3c344e8626caa10",
    "f51da9c4d1423c2ac92eb4f40e973264e7e968cc",
    "b07e68b02a34d272114dda4194992a847928aef8",
    "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1",
    "0889e5a8b7102ca1b64af6806537ad99c2018dfd",
    "a4cd101934ae5a5cad9663de872fb4ecee0d7560",
    "ccaf036662e22da14583942054898c99fa51dae5",
    "1ba9704eec22c75f8aec653ee15eb6767b5a7f4b",
    "1309c585fb9f632f7c649464ecbe358c5130b142",
    "523f467d939d80e2bc162e1f47be497109783061",
    "af3aadf04f0d6aff19fff99fe18c9b3feae2c529",
    "a126a01fa197beebe955837c8f2efbd3257f7aa5",
    "7abf7e81512918d780e05070c29ee2ba8736f41e",
    "3ab7f86c16c0c3df89f5157aab0bb5d66fbcc2d5",
    "aac5c149c7ca500b8eb810b7d4b561ff1e38ea02",
    "11312adedb09886e94241aabd973064764b6d857",
    "bbf1f55bee92976b101956fe30467619ca274ac8",
    "58a8826fb5a0c2d70aabf2a9a99f0b8906124155",
    "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "97c38f94f57544cdd24fb581fef10d61c7263654",
    "889528e387680f18472b45e63f7857dbd0117eb9",
    "75103dc925dc8db6c65e2281c96998c965c5e3f9",
    "280ab0cf7d71882cd3af8cf4e77a1af96844e0c6",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "3961690037fa4274a3640104b3c344e8626caa10": "Ybodychange",
    "f51da9c4d1423c2ac92eb4f40e973264e7e968cc": "Ybodychange",
    "b07e68b02a34d272114dda4194992a847928aef8": "Ybodychange",
    "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1": "Ybodychange",
    "0889e5a8b7102ca1b64af6806537ad99c2018dfd": "Ybodychange",
    "a4cd101934ae5a5cad9663de872fb4ecee0d7560": "Ybodychange",
    "ccaf036662e22da14583942054898c99fa51dae5": "Ybodychange",
    "1ba9704eec22c75f8aec653ee15eb6767b5a7f4b": "Ybodychange",
    "1309c585fb9f632f7c649464ecbe358c5130b142": "Ybodychange",
    "523f467d939d80e2bc162e1f47be497109783061": "Ybodychange",
    "af3aadf04f0d6aff19fff99fe18c9b3feae2c529": "Ybodychange",
    "a126a01fa197beebe955837c8f2efbd3257f7aa5": "Ybodychange",
    "7abf7e81512918d780e05070c29ee2ba8736f41e": "Ybodychange",
    "3ab7f86c16c0c3df89f5157aab0bb5d66fbcc2d5": "Ybodychange",
    "aac5c149c7ca500b8eb810b7d4b561ff1e38ea02": "Ybodychange",
    "11312adedb09886e94241aabd973064764b6d857": "Ybodychange",
    "bbf1f55bee92976b101956fe30467619ca274ac8": "Ybodychange",
    "58a8826fb5a0c2d70aabf2a9a99f0b8906124155": "Ymultichange(Yreturntypechange,Ybodychange)",
    "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "97c38f94f57544cdd24fb581fef10d61c7263654": "Ybodychange",
    "889528e387680f18472b45e63f7857dbd0117eb9": "Ybodychange",
    "75103dc925dc8db6c65e2281c96998c965c5e3f9": "Ybodychange",
    "280ab0cf7d71882cd3af8cf4e77a1af96844e0c6": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3961690037fa4274a3640104b3c344e8626caa10": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15973. Configuration: Included properties are not cached if resource is a stream. Contributed by Eric Payne\n",
      "commitDate": "20/12/18 7:29 AM",
      "commitName": "3961690037fa4274a3640104b3c344e8626caa10",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 70.44,
      "commitsBetweenForRepo": 544,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,46 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n-      XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n-      boolean isRestricted \u003d wrapper.isParserRestricted();\n \n-      if (resource instanceof URL) {                  // an URL resource\n-        reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n-      } else if (resource instanceof String) {        // a CLASSPATH resource\n-        URL url \u003d getResource((String)resource);\n-        reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n-      } else if (resource instanceof Path) {          // a file resource\n-        // Can\u0027t use FileSystem API or we get an infinite loop\n-        // since FileSystem uses Configuration API.  Use java.io.File instead.\n-        File file \u003d new File(((Path)resource).toUri().getPath())\n-          .getAbsoluteFile();\n-        if (file.exists()) {\n-          if (!quiet) {\n-            LOG.debug(\"parsing File \" + file);\n-          }\n-          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n-              new FileInputStream(file)), ((Path)resource).toString(),\n-              isRestricted);\n-        }\n-      } else if (resource instanceof InputStream) {\n-        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n-            isRestricted);\n+      if (resource instanceof InputStream) {\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n+      XMLStreamReader2 reader \u003d getStreamReader(wrapper, quiet);\n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n \n       List\u003cParsedItem\u003e items \u003d new Parser(reader, wrapper, quiet).parse();\n       for (ParsedItem item : items) {\n         loadProperty(toAddTo, item.name, item.key, item.value,\n             item.isFinal, item.sources);\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name, wrapper.isParserRestricted());\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof InputStream) {\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      XMLStreamReader2 reader \u003d getStreamReader(wrapper, quiet);\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n\n      List\u003cParsedItem\u003e items \u003d new Parser(reader, wrapper, quiet).parse();\n      for (ParsedItem item : items) {\n        loadProperty(toAddTo, item.name, item.key, item.value,\n            item.isFinal, item.sources);\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name, wrapper.isParserRestricted());\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "f51da9c4d1423c2ac92eb4f40e973264e7e968cc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15554. Improve JIT performance for Configuration parsing. Contributed by Todd Lipcon.\n",
      "commitDate": "02/07/18 9:31 AM",
      "commitName": "f51da9c4d1423c2ac92eb4f40e973264e7e968cc",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "20/06/18 4:43 PM",
      "commitNameOld": "43541a18907d2303b708ae27a9a2cb5df891da4f",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.7,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,243 +1,67 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n       boolean isRestricted \u003d wrapper.isParserRestricted();\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString(),\n               isRestricted);\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n             isRestricted);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n-      DeprecationContext deprecations \u003d deprecationContext.get();\n \n-      StringBuilder token \u003d new StringBuilder();\n-      String confName \u003d null;\n-      String confValue \u003d null;\n-      String confInclude \u003d null;\n-      String confTag \u003d null;\n-      boolean confFinal \u003d false;\n-      boolean fallbackAllowed \u003d false;\n-      boolean fallbackEntered \u003d false;\n-      boolean parseToken \u003d false;\n-      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n-\n-      while (reader.hasNext()) {\n-        switch (reader.next()) {\n-        case XMLStreamConstants.START_ELEMENT:\n-          switch (reader.getLocalName()) {\n-          case \"property\":\n-            confName \u003d null;\n-            confValue \u003d null;\n-            confFinal \u003d false;\n-            confTag \u003d null;\n-            confSource.clear();\n-\n-            // First test for short format configuration\n-            int attrCount \u003d reader.getAttributeCount();\n-            for (int i \u003d 0; i \u003c attrCount; i++) {\n-              String propertyAttr \u003d reader.getAttributeLocalName(i);\n-              if (\"name\".equals(propertyAttr)) {\n-                confName \u003d StringInterner.weakIntern(\n-                    reader.getAttributeValue(i));\n-              } else if (\"value\".equals(propertyAttr)) {\n-                confValue \u003d StringInterner.weakIntern(\n-                    reader.getAttributeValue(i));\n-              } else if (\"final\".equals(propertyAttr)) {\n-                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n-              } else if (\"source\".equals(propertyAttr)) {\n-                confSource.add(StringInterner.weakIntern(\n-                    reader.getAttributeValue(i)));\n-              } else if (\"tag\".equals(propertyAttr)) {\n-                confTag \u003d StringInterner\n-                    .weakIntern(reader.getAttributeValue(i));\n-              }\n-            }\n-            break;\n-          case \"name\":\n-          case \"value\":\n-          case \"final\":\n-          case \"source\":\n-          case \"tag\":\n-            parseToken \u003d true;\n-            token.setLength(0);\n-            break;\n-          case \"include\":\n-            // Determine href for xi:include\n-            confInclude \u003d null;\n-            attrCount \u003d reader.getAttributeCount();\n-            for (int i \u003d 0; i \u003c attrCount; i++) {\n-              String attrName \u003d reader.getAttributeLocalName(i);\n-              if (\"href\".equals(attrName)) {\n-                confInclude \u003d reader.getAttributeValue(i);\n-              }\n-            }\n-            if (confInclude \u003d\u003d null) {\n-              break;\n-            }\n-            if (isRestricted) {\n-              throw new RuntimeException(\"Error parsing resource \" + wrapper\n-                  + \": XInclude is not supported for restricted resources\");\n-            }\n-            // Determine if the included resource is a classpath resource\n-            // otherwise fallback to a file resource\n-            // xi:include are treated as inline and retain current source\n-            URL include \u003d getResource(confInclude);\n-            if (include !\u003d null) {\n-              Resource classpathResource \u003d new Resource(include, name,\n-                  wrapper.isParserRestricted());\n-              loadResource(properties, classpathResource, quiet);\n-            } else {\n-              URL url;\n-              try {\n-                url \u003d new URL(confInclude);\n-                url.openConnection().connect();\n-              } catch (IOException ioe) {\n-                File href \u003d new File(confInclude);\n-                if (!href.isAbsolute()) {\n-                  // Included resources are relative to the current resource\n-                  File baseFile \u003d new File(name).getParentFile();\n-                  href \u003d new File(baseFile, href.getPath());\n-                }\n-                if (!href.exists()) {\n-                  // Resource errors are non-fatal iff there is 1 xi:fallback\n-                  fallbackAllowed \u003d true;\n-                  break;\n-                }\n-                url \u003d href.toURI().toURL();\n-              }\n-              Resource uriResource \u003d new Resource(url, name,\n-                  wrapper.isParserRestricted());\n-              loadResource(properties, uriResource, quiet);\n-            }\n-            break;\n-          case \"fallback\":\n-            fallbackEntered \u003d true;\n-            break;\n-          case \"configuration\":\n-            break;\n-          default:\n-            break;\n-          }\n-          break;\n-\n-        case XMLStreamConstants.CHARACTERS:\n-          if (parseToken) {\n-            char[] text \u003d reader.getTextCharacters();\n-            token.append(text, reader.getTextStart(), reader.getTextLength());\n-          }\n-          break;\n-\n-        case XMLStreamConstants.END_ELEMENT:\n-          switch (reader.getLocalName()) {\n-          case \"name\":\n-            if (token.length() \u003e 0) {\n-              confName \u003d StringInterner.weakIntern(token.toString().trim());\n-            }\n-            break;\n-          case \"value\":\n-            if (token.length() \u003e 0) {\n-              confValue \u003d StringInterner.weakIntern(token.toString());\n-            }\n-            break;\n-          case \"final\":\n-            confFinal \u003d \"true\".equals(token.toString());\n-            break;\n-          case \"source\":\n-            confSource.add(StringInterner.weakIntern(token.toString()));\n-            break;\n-          case \"tag\":\n-            if (token.length() \u003e 0) {\n-              confTag \u003d StringInterner.weakIntern(token.toString());\n-            }\n-            break;\n-          case \"include\":\n-            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n-              throw new IOException(\"Fetch fail on include for \u0027\"\n-                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n-                  + name + \"\u0027\");\n-            }\n-            fallbackAllowed \u003d false;\n-            fallbackEntered \u003d false;\n-            break;\n-          case \"property\":\n-            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n-              break;\n-            }\n-            confSource.add(name);\n-            // Read tags and put them in propertyTagsMap\n-            if (confTag !\u003d null) {\n-              readTagFromConfig(confTag, confName, confValue, confSource);\n-            }\n-\n-            DeprecatedKeyInfo keyInfo \u003d\n-                deprecations.getDeprecatedKeyMap().get(confName);\n-            if (keyInfo !\u003d null) {\n-              keyInfo.clearAccessed();\n-              for (String key : keyInfo.newKeys) {\n-                // update new keys with deprecated key\u0027s value\n-                loadProperty(toAddTo, name, key, confValue, confFinal,\n-                    confSource.toArray(new String[confSource.size()]));\n-              }\n-            } else {\n-              loadProperty(toAddTo, name, confName, confValue, confFinal,\n-                  confSource.toArray(new String[confSource.size()]));\n-            }\n-            break;\n-          default:\n-            break;\n-          }\n-        default:\n-          break;\n-        }\n+      List\u003cParsedItem\u003e items \u003d new Parser(reader, wrapper, quiet).parse();\n+      for (ParsedItem item : items) {\n+        loadProperty(toAddTo, item.name, item.key, item.value,\n+            item.isFinal, item.sources);\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name, wrapper.isParserRestricted());\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n      boolean isRestricted \u003d wrapper.isParserRestricted();\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString(),\n              isRestricted);\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n            isRestricted);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n\n      List\u003cParsedItem\u003e items \u003d new Parser(reader, wrapper, quiet).parse();\n      for (ParsedItem item : items) {\n        loadProperty(toAddTo, item.name, item.key, item.value,\n            item.isFinal, item.sources);\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name, wrapper.isParserRestricted());\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "b07e68b02a34d272114dda4194992a847928aef8": {
      "type": "Ybodychange",
      "commitMessage": "Addendum patch for Configuration fix. (Jason Lowe via asuresh)\n",
      "commitDate": "13/11/17 2:03 PM",
      "commitName": "b07e68b02a34d272114dda4194992a847928aef8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "09/11/17 3:15 PM",
      "commitNameOld": "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 3.95,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,241 +1,243 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n       boolean isRestricted \u003d wrapper.isParserRestricted();\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString(),\n               isRestricted);\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n             isRestricted);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n       String confInclude \u003d null;\n       String confTag \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n             confTag \u003d null;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n               } else if (\"tag\".equals(propertyAttr)) {\n                 confTag \u003d StringInterner\n                     .weakIntern(reader.getAttributeValue(i));\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n           case \"tag\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n             // Determine href for xi:include\n             confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n             if (isRestricted) {\n               throw new RuntimeException(\"Error parsing resource \" + wrapper\n                   + \": XInclude is not supported for restricted resources\");\n             }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n-              Resource classpathResource \u003d new Resource(include, name);\n+              Resource classpathResource \u003d new Resource(include, name,\n+                  wrapper.isParserRestricted());\n               loadResource(properties, classpathResource, quiet);\n             } else {\n               URL url;\n               try {\n                 url \u003d new URL(confInclude);\n                 url.openConnection().connect();\n               } catch (IOException ioe) {\n                 File href \u003d new File(confInclude);\n                 if (!href.isAbsolute()) {\n                   // Included resources are relative to the current resource\n                   File baseFile \u003d new File(name).getParentFile();\n                   href \u003d new File(baseFile, href.getPath());\n                 }\n                 if (!href.exists()) {\n                   // Resource errors are non-fatal iff there is 1 xi:fallback\n                   fallbackAllowed \u003d true;\n                   break;\n                 }\n                 url \u003d href.toURI().toURL();\n               }\n-              Resource uriResource \u003d new Resource(url, name);\n+              Resource uriResource \u003d new Resource(url, name,\n+                  wrapper.isParserRestricted());\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n           case \"tag\":\n             if (token.length() \u003e 0) {\n               confTag \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"include\":\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n               throw new IOException(\"Fetch fail on include for \u0027\"\n                   + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                   + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n             //Read tags and put them in propertyTagsMap\n             if (confTag !\u003d null) {\n               readTagFromConfig(confTag, confName, confValue, confSource);\n             }\n \n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name, wrapper.isParserRestricted());\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n      boolean isRestricted \u003d wrapper.isParserRestricted();\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString(),\n              isRestricted);\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n            isRestricted);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      String confInclude \u003d null;\n      String confTag \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confTag \u003d null;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              } else if (\"tag\".equals(propertyAttr)) {\n                confTag \u003d StringInterner\n                    .weakIntern(reader.getAttributeValue(i));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n          case \"tag\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            if (isRestricted) {\n              throw new RuntimeException(\"Error parsing resource \" + wrapper\n                  + \": XInclude is not supported for restricted resources\");\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name,\n                  wrapper.isParserRestricted());\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              URL url;\n              try {\n                url \u003d new URL(confInclude);\n                url.openConnection().connect();\n              } catch (IOException ioe) {\n                File href \u003d new File(confInclude);\n                if (!href.isAbsolute()) {\n                  // Included resources are relative to the current resource\n                  File baseFile \u003d new File(name).getParentFile();\n                  href \u003d new File(baseFile, href.getPath());\n                }\n                if (!href.exists()) {\n                  // Resource errors are non-fatal iff there is 1 xi:fallback\n                  fallbackAllowed \u003d true;\n                  break;\n                }\n                url \u003d href.toURI().toURL();\n              }\n              Resource uriResource \u003d new Resource(url, name,\n                  wrapper.isParserRestricted());\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"tag\":\n            if (token.length() \u003e 0) {\n              confTag \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include for \u0027\"\n                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                  + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            //Read tags and put them in propertyTagsMap\n            if (confTag !\u003d null) {\n              readTagFromConfig(confTag, confName, confValue, confSource);\n            }\n\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name, wrapper.isParserRestricted());\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1": {
      "type": "Ybodychange",
      "commitMessage": "Fixing Job History Server Configuration parsing. (Jason Lowe via asuresh)\n",
      "commitDate": "09/11/17 3:15 PM",
      "commitName": "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "13/10/17 1:52 PM",
      "commitNameOld": "e163f41850bd09a17d3102a3af0af2e3cd831ab0",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 27.1,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,234 +1,241 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n+      boolean isRestricted \u003d wrapper.isParserRestricted();\n \n       if (resource instanceof URL) {                  // an URL resource\n-        reader \u003d (XMLStreamReader2)parse((URL)resource);\n+        reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n-        reader \u003d (XMLStreamReader2)parse(url);\n+        reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n-              new FileInputStream(file)), ((Path)resource).toString());\n+              new FileInputStream(file)), ((Path)resource).toString(),\n+              isRestricted);\n         }\n       } else if (resource instanceof InputStream) {\n-        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n+        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n+            isRestricted);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n       String confInclude \u003d null;\n       String confTag \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n             confTag \u003d null;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n               } else if (\"tag\".equals(propertyAttr)) {\n                 confTag \u003d StringInterner\n                     .weakIntern(reader.getAttributeValue(i));\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n           case \"tag\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n             // Determine href for xi:include\n             confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n+            if (isRestricted) {\n+              throw new RuntimeException(\"Error parsing resource \" + wrapper\n+                  + \": XInclude is not supported for restricted resources\");\n+            }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n               Resource classpathResource \u003d new Resource(include, name);\n               loadResource(properties, classpathResource, quiet);\n             } else {\n               URL url;\n               try {\n                 url \u003d new URL(confInclude);\n                 url.openConnection().connect();\n               } catch (IOException ioe) {\n                 File href \u003d new File(confInclude);\n                 if (!href.isAbsolute()) {\n                   // Included resources are relative to the current resource\n                   File baseFile \u003d new File(name).getParentFile();\n                   href \u003d new File(baseFile, href.getPath());\n                 }\n                 if (!href.exists()) {\n                   // Resource errors are non-fatal iff there is 1 xi:fallback\n                   fallbackAllowed \u003d true;\n                   break;\n                 }\n                 url \u003d href.toURI().toURL();\n               }\n               Resource uriResource \u003d new Resource(url, name);\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n           case \"tag\":\n             if (token.length() \u003e 0) {\n               confTag \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"include\":\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n               throw new IOException(\"Fetch fail on include for \u0027\"\n                   + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                   + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n             //Read tags and put them in propertyTagsMap\n             if (confTag !\u003d null) {\n               readTagFromConfig(confTag, confName, confValue, confSource);\n             }\n \n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n-        return new Resource(toAddTo, name);\n+        return new Resource(toAddTo, name, wrapper.isParserRestricted());\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n      boolean isRestricted \u003d wrapper.isParserRestricted();\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource, isRestricted);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url, isRestricted);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString(),\n              isRestricted);\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null,\n            isRestricted);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      String confInclude \u003d null;\n      String confTag \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confTag \u003d null;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              } else if (\"tag\".equals(propertyAttr)) {\n                confTag \u003d StringInterner\n                    .weakIntern(reader.getAttributeValue(i));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n          case \"tag\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            if (isRestricted) {\n              throw new RuntimeException(\"Error parsing resource \" + wrapper\n                  + \": XInclude is not supported for restricted resources\");\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              URL url;\n              try {\n                url \u003d new URL(confInclude);\n                url.openConnection().connect();\n              } catch (IOException ioe) {\n                File href \u003d new File(confInclude);\n                if (!href.isAbsolute()) {\n                  // Included resources are relative to the current resource\n                  File baseFile \u003d new File(name).getParentFile();\n                  href \u003d new File(baseFile, href.getPath());\n                }\n                if (!href.exists()) {\n                  // Resource errors are non-fatal iff there is 1 xi:fallback\n                  fallbackAllowed \u003d true;\n                  break;\n                }\n                url \u003d href.toURI().toURL();\n              }\n              Resource uriResource \u003d new Resource(url, name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"tag\":\n            if (token.length() \u003e 0) {\n              confTag \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include for \u0027\"\n                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                  + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            //Read tags and put them in propertyTagsMap\n            if (confTag !\u003d null) {\n              readTagFromConfig(confTag, confName, confValue, confSource);\n            }\n\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name, wrapper.isParserRestricted());\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "0889e5a8b7102ca1b64af6806537ad99c2018dfd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12529. Get source for config tags from file name. Contributed by Ajay Kumar.\n",
      "commitDate": "25/09/17 1:55 PM",
      "commitName": "0889e5a8b7102ca1b64af6806537ad99c2018dfd",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "07/09/17 12:40 PM",
      "commitNameOld": "a4cd101934ae5a5cad9663de872fb4ecee0d7560",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 18.05,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,230 +1,234 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n       String confInclude \u003d null;\n+      String confTag \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n+            confTag \u003d null;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n               } else if (\"tag\".equals(propertyAttr)) {\n-                //Read tags and put them in propertyTagsMap\n-                readTagFromConfig(reader.getAttributeValue(i), confName,\n-                    confValue, confSource);\n+                confTag \u003d StringInterner\n+                    .weakIntern(reader.getAttributeValue(i));\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n           case \"tag\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n             // Determine href for xi:include\n             confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n               Resource classpathResource \u003d new Resource(include, name);\n               loadResource(properties, classpathResource, quiet);\n             } else {\n               URL url;\n               try {\n                 url \u003d new URL(confInclude);\n                 url.openConnection().connect();\n               } catch (IOException ioe) {\n                 File href \u003d new File(confInclude);\n                 if (!href.isAbsolute()) {\n                   // Included resources are relative to the current resource\n                   File baseFile \u003d new File(name).getParentFile();\n                   href \u003d new File(baseFile, href.getPath());\n                 }\n                 if (!href.exists()) {\n                   // Resource errors are non-fatal iff there is 1 xi:fallback\n                   fallbackAllowed \u003d true;\n                   break;\n                 }\n                 url \u003d href.toURI().toURL();\n               }\n               Resource uriResource \u003d new Resource(url, name);\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n           case \"tag\":\n             if (token.length() \u003e 0) {\n-              //Read tags and put them in propertyTagsMap\n-              readTagFromConfig(token.toString(), confName,\n-                  confValue, confSource);\n+              confTag \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"include\":\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n               throw new IOException(\"Fetch fail on include for \u0027\"\n                   + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                   + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n+            //Read tags and put them in propertyTagsMap\n+            if (confTag !\u003d null) {\n+              readTagFromConfig(confTag, confName, confValue, confSource);\n+            }\n+\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      String confInclude \u003d null;\n      String confTag \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confTag \u003d null;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              } else if (\"tag\".equals(propertyAttr)) {\n                confTag \u003d StringInterner\n                    .weakIntern(reader.getAttributeValue(i));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n          case \"tag\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              URL url;\n              try {\n                url \u003d new URL(confInclude);\n                url.openConnection().connect();\n              } catch (IOException ioe) {\n                File href \u003d new File(confInclude);\n                if (!href.isAbsolute()) {\n                  // Included resources are relative to the current resource\n                  File baseFile \u003d new File(name).getParentFile();\n                  href \u003d new File(baseFile, href.getPath());\n                }\n                if (!href.exists()) {\n                  // Resource errors are non-fatal iff there is 1 xi:fallback\n                  fallbackAllowed \u003d true;\n                  break;\n                }\n                url \u003d href.toURI().toURL();\n              }\n              Resource uriResource \u003d new Resource(url, name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"tag\":\n            if (token.length() \u003e 0) {\n              confTag \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include for \u0027\"\n                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                  + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            //Read tags and put them in propertyTagsMap\n            if (confTag !\u003d null) {\n              readTagFromConfig(confTag, confName, confValue, confSource);\n            }\n\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "a4cd101934ae5a5cad9663de872fb4ecee0d7560": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12350. Support meta tags in configs. Contributed by Ajay Kumar.\n",
      "commitDate": "07/09/17 12:40 PM",
      "commitName": "a4cd101934ae5a5cad9663de872fb4ecee0d7560",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "23/08/17 11:37 AM",
      "commitNameOld": "7e6463d2fb5f9383d88baec290461868cf476e4c",
      "commitAuthorOld": "John Zhuge",
      "daysBetweenCommits": 15.04,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,218 +1,230 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n       String confInclude \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n+              } else if (\"tag\".equals(propertyAttr)) {\n+                //Read tags and put them in propertyTagsMap\n+                readTagFromConfig(reader.getAttributeValue(i), confName,\n+                    confValue, confSource);\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n+          case \"tag\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n             // Determine href for xi:include\n             confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n               Resource classpathResource \u003d new Resource(include, name);\n               loadResource(properties, classpathResource, quiet);\n             } else {\n               URL url;\n               try {\n                 url \u003d new URL(confInclude);\n                 url.openConnection().connect();\n               } catch (IOException ioe) {\n                 File href \u003d new File(confInclude);\n                 if (!href.isAbsolute()) {\n                   // Included resources are relative to the current resource\n                   File baseFile \u003d new File(name).getParentFile();\n                   href \u003d new File(baseFile, href.getPath());\n                 }\n                 if (!href.exists()) {\n                   // Resource errors are non-fatal iff there is 1 xi:fallback\n                   fallbackAllowed \u003d true;\n                   break;\n                 }\n                 url \u003d href.toURI().toURL();\n               }\n               Resource uriResource \u003d new Resource(url, name);\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n+          case \"tag\":\n+            if (token.length() \u003e 0) {\n+              //Read tags and put them in propertyTagsMap\n+              readTagFromConfig(token.toString(), confName,\n+                  confValue, confSource);\n+            }\n+            break;\n           case \"include\":\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n               throw new IOException(\"Fetch fail on include for \u0027\"\n                   + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                   + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      String confInclude \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              } else if (\"tag\".equals(propertyAttr)) {\n                //Read tags and put them in propertyTagsMap\n                readTagFromConfig(reader.getAttributeValue(i), confName,\n                    confValue, confSource);\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n          case \"tag\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              URL url;\n              try {\n                url \u003d new URL(confInclude);\n                url.openConnection().connect();\n              } catch (IOException ioe) {\n                File href \u003d new File(confInclude);\n                if (!href.isAbsolute()) {\n                  // Included resources are relative to the current resource\n                  File baseFile \u003d new File(name).getParentFile();\n                  href \u003d new File(baseFile, href.getPath());\n                }\n                if (!href.exists()) {\n                  // Resource errors are non-fatal iff there is 1 xi:fallback\n                  fallbackAllowed \u003d true;\n                  break;\n                }\n                url \u003d href.toURI().toURL();\n              }\n              Resource uriResource \u003d new Resource(url, name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"tag\":\n            if (token.length() \u003e 0) {\n              //Read tags and put them in propertyTagsMap\n              readTagFromConfig(token.toString(), confName,\n                  confValue, confSource);\n            }\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include for \u0027\"\n                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                  + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "ccaf036662e22da14583942054898c99fa51dae5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14539. Move commons logging APIs over to slf4j in hadoop-common. Contributed by Wenxin He.\n",
      "commitDate": "17/07/17 9:32 PM",
      "commitName": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "11/07/17 5:40 AM",
      "commitNameOld": "3a7f02b81520ad4d3eebf92e9dbca662beec0302",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 6.66,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,218 +1,218 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n       String confInclude \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n             // Determine href for xi:include\n             confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n               Resource classpathResource \u003d new Resource(include, name);\n               loadResource(properties, classpathResource, quiet);\n             } else {\n               URL url;\n               try {\n                 url \u003d new URL(confInclude);\n                 url.openConnection().connect();\n               } catch (IOException ioe) {\n                 File href \u003d new File(confInclude);\n                 if (!href.isAbsolute()) {\n                   // Included resources are relative to the current resource\n                   File baseFile \u003d new File(name).getParentFile();\n                   href \u003d new File(baseFile, href.getPath());\n                 }\n                 if (!href.exists()) {\n                   // Resource errors are non-fatal iff there is 1 xi:fallback\n                   fallbackAllowed \u003d true;\n                   break;\n                 }\n                 url \u003d href.toURI().toURL();\n               }\n               Resource uriResource \u003d new Resource(url, name);\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n           case \"include\":\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n               throw new IOException(\"Fetch fail on include for \u0027\"\n                   + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                   + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n-      LOG.fatal(\"error parsing conf \" + name, e);\n+      LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n-      LOG.fatal(\"error parsing conf \" + name, e);\n+      LOG.error(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      String confInclude \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              URL url;\n              try {\n                url \u003d new URL(confInclude);\n                url.openConnection().connect();\n              } catch (IOException ioe) {\n                File href \u003d new File(confInclude);\n                if (!href.isAbsolute()) {\n                  // Included resources are relative to the current resource\n                  File baseFile \u003d new File(name).getParentFile();\n                  href \u003d new File(baseFile, href.getPath());\n                }\n                if (!href.exists()) {\n                  // Resource errors are non-fatal iff there is 1 xi:fallback\n                  fallbackAllowed \u003d true;\n                  break;\n                }\n                url \u003d href.toURI().toURL();\n              }\n              Resource uriResource \u003d new Resource(url, name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include for \u0027\"\n                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                  + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.error(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "1ba9704eec22c75f8aec653ee15eb6767b5a7f4b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14399. Configuration does not correctly XInclude absolute file URIs.\nContributed by Jonathan Eagles\n",
      "commitDate": "25/05/17 6:59 AM",
      "commitName": "1ba9704eec22c75f8aec653ee15eb6767b5a7f4b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "30/03/17 12:14 PM",
      "commitNameOld": "1309c585fb9f632f7c649464ecbe358c5130b142",
      "commitAuthorOld": "Jonathan Eagles",
      "daysBetweenCommits": 55.78,
      "commitsBetweenForRepo": 305,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,218 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n+      String confInclude \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n             // Determine href for xi:include\n-            String confInclude \u003d null;\n+            confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n               Resource classpathResource \u003d new Resource(include, name);\n               loadResource(properties, classpathResource, quiet);\n             } else {\n-              File href \u003d new File(confInclude);\n-              if (!href.isAbsolute()) {\n-                // Included resources are relative to the current resource\n-                File baseFile \u003d new File(name).getParentFile();\n-                href \u003d new File(baseFile, href.getPath());\n+              URL url;\n+              try {\n+                url \u003d new URL(confInclude);\n+                url.openConnection().connect();\n+              } catch (IOException ioe) {\n+                File href \u003d new File(confInclude);\n+                if (!href.isAbsolute()) {\n+                  // Included resources are relative to the current resource\n+                  File baseFile \u003d new File(name).getParentFile();\n+                  href \u003d new File(baseFile, href.getPath());\n+                }\n+                if (!href.exists()) {\n+                  // Resource errors are non-fatal iff there is 1 xi:fallback\n+                  fallbackAllowed \u003d true;\n+                  break;\n+                }\n+                url \u003d href.toURI().toURL();\n               }\n-              if (!href.exists()) {\n-                // Resource errors are non-fatal iff there is 1 xi:fallback\n-                fallbackAllowed \u003d true;\n-                break;\n-              }\n-              Resource uriResource \u003d new Resource(href.toURI().toURL(), name);\n+              Resource uriResource \u003d new Resource(url, name);\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n           case \"include\":\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n-              throw new IOException(\"Fetch fail on include with no \"\n-                  + \"fallback while loading \u0027\" + name + \"\u0027\");\n+              throw new IOException(\"Fetch fail on include for \u0027\"\n+                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n+                  + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      String confInclude \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              URL url;\n              try {\n                url \u003d new URL(confInclude);\n                url.openConnection().connect();\n              } catch (IOException ioe) {\n                File href \u003d new File(confInclude);\n                if (!href.isAbsolute()) {\n                  // Included resources are relative to the current resource\n                  File baseFile \u003d new File(name).getParentFile();\n                  href \u003d new File(baseFile, href.getPath());\n                }\n                if (!href.exists()) {\n                  // Resource errors are non-fatal iff there is 1 xi:fallback\n                  fallbackAllowed \u003d true;\n                  break;\n                }\n                url \u003d href.toURI().toURL();\n              }\n              Resource uriResource \u003d new Resource(url, name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include for \u0027\"\n                  + confInclude + \"\u0027 with no fallback while loading \u0027\"\n                  + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "1309c585fb9f632f7c649464ecbe358c5130b142": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14216. Addendum to Improve Configuration XML Parsing Performance (jeagles)\n",
      "commitDate": "30/03/17 12:14 PM",
      "commitName": "1309c585fb9f632f7c649464ecbe358c5130b142",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "29/03/17 8:12 AM",
      "commitNameOld": "523f467d939d80e2bc162e1f47be497109783061",
      "commitAuthorOld": "Jonathan Eagles",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,218 +1,209 @@\n   private Resource loadResource(Properties properties,\n                                 Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n \n       if (resource instanceof URL) {                  // an URL resource\n         reader \u003d (XMLStreamReader2)parse((URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         reader \u003d (XMLStreamReader2)parse(url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       }\n \n       if (reader \u003d\u003d null) {\n         if (quiet) {\n           return null;\n         }\n         throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       DeprecationContext deprecations \u003d deprecationContext.get();\n \n       StringBuilder token \u003d new StringBuilder();\n       String confName \u003d null;\n       String confValue \u003d null;\n       boolean confFinal \u003d false;\n       boolean fallbackAllowed \u003d false;\n       boolean fallbackEntered \u003d false;\n       boolean parseToken \u003d false;\n       LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n       while (reader.hasNext()) {\n         switch (reader.next()) {\n         case XMLStreamConstants.START_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"property\":\n             confName \u003d null;\n             confValue \u003d null;\n             confFinal \u003d false;\n             confSource.clear();\n \n             // First test for short format configuration\n             int attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String propertyAttr \u003d reader.getAttributeLocalName(i);\n               if (\"name\".equals(propertyAttr)) {\n                 confName \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"value\".equals(propertyAttr)) {\n                 confValue \u003d StringInterner.weakIntern(\n                     reader.getAttributeValue(i));\n               } else if (\"final\".equals(propertyAttr)) {\n                 confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n               } else if (\"source\".equals(propertyAttr)) {\n                 confSource.add(StringInterner.weakIntern(\n                     reader.getAttributeValue(i)));\n               }\n             }\n             break;\n           case \"name\":\n           case \"value\":\n           case \"final\":\n           case \"source\":\n             parseToken \u003d true;\n             token.setLength(0);\n             break;\n           case \"include\":\n-            if (!\"xi\".equals(reader.getPrefix())) {\n-              break;\n-            }\n             // Determine href for xi:include\n             String confInclude \u003d null;\n             attrCount \u003d reader.getAttributeCount();\n             for (int i \u003d 0; i \u003c attrCount; i++) {\n               String attrName \u003d reader.getAttributeLocalName(i);\n               if (\"href\".equals(attrName)) {\n                 confInclude \u003d reader.getAttributeValue(i);\n               }\n             }\n             if (confInclude \u003d\u003d null) {\n               break;\n             }\n             // Determine if the included resource is a classpath resource\n             // otherwise fallback to a file resource\n             // xi:include are treated as inline and retain current source\n             URL include \u003d getResource(confInclude);\n             if (include !\u003d null) {\n               Resource classpathResource \u003d new Resource(include, name);\n               loadResource(properties, classpathResource, quiet);\n             } else {\n               File href \u003d new File(confInclude);\n               if (!href.isAbsolute()) {\n                 // Included resources are relative to the current resource\n                 File baseFile \u003d new File(name).getParentFile();\n                 href \u003d new File(baseFile, href.getPath());\n               }\n               if (!href.exists()) {\n                 // Resource errors are non-fatal iff there is 1 xi:fallback\n                 fallbackAllowed \u003d true;\n                 break;\n               }\n               Resource uriResource \u003d new Resource(href.toURI().toURL(), name);\n               loadResource(properties, uriResource, quiet);\n             }\n             break;\n           case \"fallback\":\n-            if (!\"xi\".equals(reader.getPrefix())) {\n-              break;\n-            }\n             fallbackEntered \u003d true;\n             break;\n           case \"configuration\":\n             break;\n           default:\n             break;\n           }\n           break;\n \n         case XMLStreamConstants.CHARACTERS:\n           if (parseToken) {\n             char[] text \u003d reader.getTextCharacters();\n             token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n           break;\n \n         case XMLStreamConstants.END_ELEMENT:\n           switch (reader.getLocalName()) {\n           case \"name\":\n             if (token.length() \u003e 0) {\n               confName \u003d StringInterner.weakIntern(token.toString().trim());\n             }\n             break;\n           case \"value\":\n             if (token.length() \u003e 0) {\n               confValue \u003d StringInterner.weakIntern(token.toString());\n             }\n             break;\n           case \"final\":\n             confFinal \u003d \"true\".equals(token.toString());\n             break;\n           case \"source\":\n             confSource.add(StringInterner.weakIntern(token.toString()));\n             break;\n           case \"include\":\n-            if (!\"xi\".equals(reader.getPrefix())) {\n-              break;\n-            }\n             if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n               throw new IOException(\"Fetch fail on include with no \"\n                   + \"fallback while loading \u0027\" + name + \"\u0027\");\n             }\n             fallbackAllowed \u003d false;\n             fallbackEntered \u003d false;\n             break;\n           case \"property\":\n             if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n               break;\n             }\n             confSource.add(name);\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(confName);\n             if (keyInfo !\u003d null) {\n               keyInfo.clearAccessed();\n               for (String key : keyInfo.newKeys) {\n                 // update new keys with deprecated key\u0027s value\n                 loadProperty(toAddTo, name, key, confValue, confFinal,\n                     confSource.toArray(new String[confSource.size()]));\n               }\n             } else {\n               loadProperty(toAddTo, name, confName, confValue, confFinal,\n                   confSource.toArray(new String[confSource.size()]));\n             }\n             break;\n           default:\n             break;\n           }\n         default:\n           break;\n         }\n       }\n       reader.close();\n \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (XMLStreamException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            // Determine href for xi:include\n            String confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              File href \u003d new File(confInclude);\n              if (!href.isAbsolute()) {\n                // Included resources are relative to the current resource\n                File baseFile \u003d new File(name).getParentFile();\n                href \u003d new File(baseFile, href.getPath());\n              }\n              if (!href.exists()) {\n                // Resource errors are non-fatal iff there is 1 xi:fallback\n                fallbackAllowed \u003d true;\n                break;\n              }\n              Resource uriResource \u003d new Resource(href.toURI().toURL(), name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"include\":\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include with no \"\n                  + \"fallback while loading \u0027\" + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "523f467d939d80e2bc162e1f47be497109783061": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14216. Improve Configuration XML Parsing Performance (jeagles)\n",
      "commitDate": "29/03/17 8:12 AM",
      "commitName": "523f467d939d80e2bc162e1f47be497109783061",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "27/03/17 11:05 PM",
      "commitNameOld": "253e3e78abb9ebe0e8103d25538ff07875b33c84",
      "commitAuthorOld": "John Zhuge",
      "daysBetweenCommits": 1.38,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,218 @@\n-  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n+  private Resource loadResource(Properties properties,\n+                                Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n-      \n-      DocumentBuilderFactory docBuilderFactory \n-        \u003d DocumentBuilderFactory.newInstance();\n-      //ignore all comments inside the xml file\n-      docBuilderFactory.setIgnoringComments(true);\n-\n-      //allow includes in the xml file\n-      docBuilderFactory.setNamespaceAware(true);\n-      try {\n-          docBuilderFactory.setXIncludeAware(true);\n-      } catch (UnsupportedOperationException e) {\n-        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n-                + docBuilderFactory\n-                + \":\" + e,\n-                e);\n-      }\n-      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n-      Document doc \u003d null;\n-      Element root \u003d null;\n+      XMLStreamReader2 reader \u003d null;\n       boolean returnCachedProperties \u003d false;\n-      \n+\n       if (resource instanceof URL) {                  // an URL resource\n-        doc \u003d parse(builder, (URL)resource);\n+        reader \u003d (XMLStreamReader2)parse((URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n-        doc \u003d parse(builder, url);\n+        reader \u003d (XMLStreamReader2)parse(url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n-          doc \u003d parse(builder, new BufferedInputStream(\n+          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n-        doc \u003d parse(builder, (InputStream) resource, null);\n+        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n-      } else if (resource instanceof Element) {\n-        root \u003d (Element)resource;\n       }\n \n-      if (root \u003d\u003d null) {\n-        if (doc \u003d\u003d null) {\n-          if (quiet) {\n-            return null;\n-          }\n-          throw new RuntimeException(resource + \" not found\");\n+      if (reader \u003d\u003d null) {\n+        if (quiet) {\n+          return null;\n         }\n-        root \u003d doc.getDocumentElement();\n+        throw new RuntimeException(resource + \" not found\");\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n-      if (!\"configuration\".equals(root.getTagName()))\n-        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n-      NodeList props \u003d root.getChildNodes();\n       DeprecationContext deprecations \u003d deprecationContext.get();\n-      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n-        Node propNode \u003d props.item(i);\n-        if (!(propNode instanceof Element))\n-          continue;\n-        Element prop \u003d (Element)propNode;\n-        if (\"configuration\".equals(prop.getTagName())) {\n-          loadResource(toAddTo, new Resource(prop, name), quiet);\n-          continue;\n-        }\n-        if (!\"property\".equals(prop.getTagName()))\n-          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n \n-        String attr \u003d null;\n-        String value \u003d null;\n-        boolean finalParameter \u003d false;\n-        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n+      StringBuilder token \u003d new StringBuilder();\n+      String confName \u003d null;\n+      String confValue \u003d null;\n+      boolean confFinal \u003d false;\n+      boolean fallbackAllowed \u003d false;\n+      boolean fallbackEntered \u003d false;\n+      boolean parseToken \u003d false;\n+      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n \n-        Attr propAttr \u003d prop.getAttributeNode(\"name\");\n-        if (propAttr !\u003d null)\n-          attr \u003d StringInterner.weakIntern(propAttr.getValue());\n-        propAttr \u003d prop.getAttributeNode(\"value\");\n-        if (propAttr !\u003d null)\n-          value \u003d StringInterner.weakIntern(propAttr.getValue());\n-        propAttr \u003d prop.getAttributeNode(\"final\");\n-        if (propAttr !\u003d null)\n-          finalParameter \u003d \"true\".equals(propAttr.getValue());\n-        propAttr \u003d prop.getAttributeNode(\"source\");\n-        if (propAttr !\u003d null)\n-          source.add(StringInterner.weakIntern(propAttr.getValue()));\n+      while (reader.hasNext()) {\n+        switch (reader.next()) {\n+        case XMLStreamConstants.START_ELEMENT:\n+          switch (reader.getLocalName()) {\n+          case \"property\":\n+            confName \u003d null;\n+            confValue \u003d null;\n+            confFinal \u003d false;\n+            confSource.clear();\n \n-        NodeList fields \u003d prop.getChildNodes();\n-        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n-          Node fieldNode \u003d fields.item(j);\n-          if (!(fieldNode instanceof Element))\n-            continue;\n-          Element field \u003d (Element)fieldNode;\n-          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            attr \u003d StringInterner.weakIntern(\n-                ((Text)field.getFirstChild()).getData().trim());\n-          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            value \u003d StringInterner.weakIntern(\n-                ((Text)field.getFirstChild()).getData());\n-          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n-          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            source.add(StringInterner.weakIntern(\n-                ((Text)field.getFirstChild()).getData()));\n-        }\n-        source.add(name);\n-        \n-        // Ignore this parameter if it has already been marked as \u0027final\u0027\n-        if (attr !\u003d null) {\n-          if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n-            DeprecatedKeyInfo keyInfo \u003d\n-                deprecations.getDeprecatedKeyMap().get(attr);\n-            keyInfo.clearAccessed();\n-            for (String key:keyInfo.newKeys) {\n-              // update new keys with deprecated key\u0027s value \n-              loadProperty(toAddTo, name, key, value, finalParameter, \n-                  source.toArray(new String[source.size()]));\n+            // First test for short format configuration\n+            int attrCount \u003d reader.getAttributeCount();\n+            for (int i \u003d 0; i \u003c attrCount; i++) {\n+              String propertyAttr \u003d reader.getAttributeLocalName(i);\n+              if (\"name\".equals(propertyAttr)) {\n+                confName \u003d StringInterner.weakIntern(\n+                    reader.getAttributeValue(i));\n+              } else if (\"value\".equals(propertyAttr)) {\n+                confValue \u003d StringInterner.weakIntern(\n+                    reader.getAttributeValue(i));\n+              } else if (\"final\".equals(propertyAttr)) {\n+                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n+              } else if (\"source\".equals(propertyAttr)) {\n+                confSource.add(StringInterner.weakIntern(\n+                    reader.getAttributeValue(i)));\n+              }\n             }\n+            break;\n+          case \"name\":\n+          case \"value\":\n+          case \"final\":\n+          case \"source\":\n+            parseToken \u003d true;\n+            token.setLength(0);\n+            break;\n+          case \"include\":\n+            if (!\"xi\".equals(reader.getPrefix())) {\n+              break;\n+            }\n+            // Determine href for xi:include\n+            String confInclude \u003d null;\n+            attrCount \u003d reader.getAttributeCount();\n+            for (int i \u003d 0; i \u003c attrCount; i++) {\n+              String attrName \u003d reader.getAttributeLocalName(i);\n+              if (\"href\".equals(attrName)) {\n+                confInclude \u003d reader.getAttributeValue(i);\n+              }\n+            }\n+            if (confInclude \u003d\u003d null) {\n+              break;\n+            }\n+            // Determine if the included resource is a classpath resource\n+            // otherwise fallback to a file resource\n+            // xi:include are treated as inline and retain current source\n+            URL include \u003d getResource(confInclude);\n+            if (include !\u003d null) {\n+              Resource classpathResource \u003d new Resource(include, name);\n+              loadResource(properties, classpathResource, quiet);\n+            } else {\n+              File href \u003d new File(confInclude);\n+              if (!href.isAbsolute()) {\n+                // Included resources are relative to the current resource\n+                File baseFile \u003d new File(name).getParentFile();\n+                href \u003d new File(baseFile, href.getPath());\n+              }\n+              if (!href.exists()) {\n+                // Resource errors are non-fatal iff there is 1 xi:fallback\n+                fallbackAllowed \u003d true;\n+                break;\n+              }\n+              Resource uriResource \u003d new Resource(href.toURI().toURL(), name);\n+              loadResource(properties, uriResource, quiet);\n+            }\n+            break;\n+          case \"fallback\":\n+            if (!\"xi\".equals(reader.getPrefix())) {\n+              break;\n+            }\n+            fallbackEntered \u003d true;\n+            break;\n+          case \"configuration\":\n+            break;\n+          default:\n+            break;\n           }\n-          else {\n-            loadProperty(toAddTo, name, attr, value, finalParameter, \n-                source.toArray(new String[source.size()]));\n+          break;\n+\n+        case XMLStreamConstants.CHARACTERS:\n+          if (parseToken) {\n+            char[] text \u003d reader.getTextCharacters();\n+            token.append(text, reader.getTextStart(), reader.getTextLength());\n           }\n+          break;\n+\n+        case XMLStreamConstants.END_ELEMENT:\n+          switch (reader.getLocalName()) {\n+          case \"name\":\n+            if (token.length() \u003e 0) {\n+              confName \u003d StringInterner.weakIntern(token.toString().trim());\n+            }\n+            break;\n+          case \"value\":\n+            if (token.length() \u003e 0) {\n+              confValue \u003d StringInterner.weakIntern(token.toString());\n+            }\n+            break;\n+          case \"final\":\n+            confFinal \u003d \"true\".equals(token.toString());\n+            break;\n+          case \"source\":\n+            confSource.add(StringInterner.weakIntern(token.toString()));\n+            break;\n+          case \"include\":\n+            if (!\"xi\".equals(reader.getPrefix())) {\n+              break;\n+            }\n+            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n+              throw new IOException(\"Fetch fail on include with no \"\n+                  + \"fallback while loading \u0027\" + name + \"\u0027\");\n+            }\n+            fallbackAllowed \u003d false;\n+            fallbackEntered \u003d false;\n+            break;\n+          case \"property\":\n+            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n+              break;\n+            }\n+            confSource.add(name);\n+            DeprecatedKeyInfo keyInfo \u003d\n+                deprecations.getDeprecatedKeyMap().get(confName);\n+            if (keyInfo !\u003d null) {\n+              keyInfo.clearAccessed();\n+              for (String key : keyInfo.newKeys) {\n+                // update new keys with deprecated key\u0027s value\n+                loadProperty(toAddTo, name, key, confValue, confFinal,\n+                    confSource.toArray(new String[confSource.size()]));\n+              }\n+            } else {\n+              loadProperty(toAddTo, name, confName, confValue, confFinal,\n+                  confSource.toArray(new String[confSource.size()]));\n+            }\n+            break;\n+          default:\n+            break;\n+          }\n+        default:\n+          break;\n         }\n       }\n-      \n+      reader.close();\n+\n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n-    } catch (DOMException e) {\n+    } catch (XMLStreamException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n-    } catch (SAXException e) {\n-      LOG.fatal(\"error parsing conf \" + name, e);\n-      throw new RuntimeException(e);\n-    } catch (ParserConfigurationException e) {\n-      LOG.fatal(\"error parsing conf \" + name , e);\n-      throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties,\n                                Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      XMLStreamReader2 reader \u003d null;\n      boolean returnCachedProperties \u003d false;\n\n      if (resource instanceof URL) {                  // an URL resource\n        reader \u003d (XMLStreamReader2)parse((URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        reader \u003d (XMLStreamReader2)parse(url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          reader \u003d (XMLStreamReader2)parse(new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        reader \u003d (XMLStreamReader2)parse((InputStream)resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      }\n\n      if (reader \u003d\u003d null) {\n        if (quiet) {\n          return null;\n        }\n        throw new RuntimeException(resource + \" not found\");\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      DeprecationContext deprecations \u003d deprecationContext.get();\n\n      StringBuilder token \u003d new StringBuilder();\n      String confName \u003d null;\n      String confValue \u003d null;\n      boolean confFinal \u003d false;\n      boolean fallbackAllowed \u003d false;\n      boolean fallbackEntered \u003d false;\n      boolean parseToken \u003d false;\n      LinkedList\u003cString\u003e confSource \u003d new LinkedList\u003cString\u003e();\n\n      while (reader.hasNext()) {\n        switch (reader.next()) {\n        case XMLStreamConstants.START_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"property\":\n            confName \u003d null;\n            confValue \u003d null;\n            confFinal \u003d false;\n            confSource.clear();\n\n            // First test for short format configuration\n            int attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String propertyAttr \u003d reader.getAttributeLocalName(i);\n              if (\"name\".equals(propertyAttr)) {\n                confName \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"value\".equals(propertyAttr)) {\n                confValue \u003d StringInterner.weakIntern(\n                    reader.getAttributeValue(i));\n              } else if (\"final\".equals(propertyAttr)) {\n                confFinal \u003d \"true\".equals(reader.getAttributeValue(i));\n              } else if (\"source\".equals(propertyAttr)) {\n                confSource.add(StringInterner.weakIntern(\n                    reader.getAttributeValue(i)));\n              }\n            }\n            break;\n          case \"name\":\n          case \"value\":\n          case \"final\":\n          case \"source\":\n            parseToken \u003d true;\n            token.setLength(0);\n            break;\n          case \"include\":\n            if (!\"xi\".equals(reader.getPrefix())) {\n              break;\n            }\n            // Determine href for xi:include\n            String confInclude \u003d null;\n            attrCount \u003d reader.getAttributeCount();\n            for (int i \u003d 0; i \u003c attrCount; i++) {\n              String attrName \u003d reader.getAttributeLocalName(i);\n              if (\"href\".equals(attrName)) {\n                confInclude \u003d reader.getAttributeValue(i);\n              }\n            }\n            if (confInclude \u003d\u003d null) {\n              break;\n            }\n            // Determine if the included resource is a classpath resource\n            // otherwise fallback to a file resource\n            // xi:include are treated as inline and retain current source\n            URL include \u003d getResource(confInclude);\n            if (include !\u003d null) {\n              Resource classpathResource \u003d new Resource(include, name);\n              loadResource(properties, classpathResource, quiet);\n            } else {\n              File href \u003d new File(confInclude);\n              if (!href.isAbsolute()) {\n                // Included resources are relative to the current resource\n                File baseFile \u003d new File(name).getParentFile();\n                href \u003d new File(baseFile, href.getPath());\n              }\n              if (!href.exists()) {\n                // Resource errors are non-fatal iff there is 1 xi:fallback\n                fallbackAllowed \u003d true;\n                break;\n              }\n              Resource uriResource \u003d new Resource(href.toURI().toURL(), name);\n              loadResource(properties, uriResource, quiet);\n            }\n            break;\n          case \"fallback\":\n            if (!\"xi\".equals(reader.getPrefix())) {\n              break;\n            }\n            fallbackEntered \u003d true;\n            break;\n          case \"configuration\":\n            break;\n          default:\n            break;\n          }\n          break;\n\n        case XMLStreamConstants.CHARACTERS:\n          if (parseToken) {\n            char[] text \u003d reader.getTextCharacters();\n            token.append(text, reader.getTextStart(), reader.getTextLength());\n          }\n          break;\n\n        case XMLStreamConstants.END_ELEMENT:\n          switch (reader.getLocalName()) {\n          case \"name\":\n            if (token.length() \u003e 0) {\n              confName \u003d StringInterner.weakIntern(token.toString().trim());\n            }\n            break;\n          case \"value\":\n            if (token.length() \u003e 0) {\n              confValue \u003d StringInterner.weakIntern(token.toString());\n            }\n            break;\n          case \"final\":\n            confFinal \u003d \"true\".equals(token.toString());\n            break;\n          case \"source\":\n            confSource.add(StringInterner.weakIntern(token.toString()));\n            break;\n          case \"include\":\n            if (!\"xi\".equals(reader.getPrefix())) {\n              break;\n            }\n            if (fallbackAllowed \u0026\u0026 !fallbackEntered) {\n              throw new IOException(\"Fetch fail on include with no \"\n                  + \"fallback while loading \u0027\" + name + \"\u0027\");\n            }\n            fallbackAllowed \u003d false;\n            fallbackEntered \u003d false;\n            break;\n          case \"property\":\n            if (confName \u003d\u003d null || (!fallbackAllowed \u0026\u0026 fallbackEntered)) {\n              break;\n            }\n            confSource.add(name);\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(confName);\n            if (keyInfo !\u003d null) {\n              keyInfo.clearAccessed();\n              for (String key : keyInfo.newKeys) {\n                // update new keys with deprecated key\u0027s value\n                loadProperty(toAddTo, name, key, confValue, confFinal,\n                    confSource.toArray(new String[confSource.size()]));\n              }\n            } else {\n              loadProperty(toAddTo, name, confName, confValue, confFinal,\n                  confSource.toArray(new String[confSource.size()]));\n            }\n            break;\n          default:\n            break;\n          }\n        default:\n          break;\n        }\n      }\n      reader.close();\n\n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (XMLStreamException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "af3aadf04f0d6aff19fff99fe18c9b3feae2c529": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6964. Allow compact property description in xml (Kengo Seki via aw)\n",
      "commitDate": "05/02/15 7:09 PM",
      "commitName": "af3aadf04f0d6aff19fff99fe18c9b3feae2c529",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "21/01/15 9:15 PM",
      "commitNameOld": "786dbdfad8991a99d71bdd861e0b5014669a422c",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 14.91,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,157 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           doc \u003d parse(builder, new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         doc \u003d parse(builder, (InputStream) resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (root \u003d\u003d null) {\n         if (doc \u003d\u003d null) {\n           if (quiet) {\n             return null;\n           }\n           throw new RuntimeException(resource + \" not found\");\n         }\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       DeprecationContext deprecations \u003d deprecationContext.get();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n-        NodeList fields \u003d prop.getChildNodes();\n+\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n+\n+        Attr propAttr \u003d prop.getAttributeNode(\"name\");\n+        if (propAttr !\u003d null)\n+          attr \u003d StringInterner.weakIntern(propAttr.getValue());\n+        propAttr \u003d prop.getAttributeNode(\"value\");\n+        if (propAttr !\u003d null)\n+          value \u003d StringInterner.weakIntern(propAttr.getValue());\n+        propAttr \u003d prop.getAttributeNode(\"final\");\n+        if (propAttr !\u003d null)\n+          finalParameter \u003d \"true\".equals(propAttr.getValue());\n+        propAttr \u003d prop.getAttributeNode(\"source\");\n+        if (propAttr !\u003d null)\n+          source.add(StringInterner.weakIntern(propAttr.getValue()));\n+\n+        NodeList fields \u003d prop.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData().trim());\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData());\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData()));\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(attr);\n             keyInfo.clearAccessed();\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (root \u003d\u003d null) {\n        if (doc \u003d\u003d null) {\n          if (quiet) {\n            return null;\n          }\n          throw new RuntimeException(resource + \" not found\");\n        }\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      DeprecationContext deprecations \u003d deprecationContext.get();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n\n        Attr propAttr \u003d prop.getAttributeNode(\"name\");\n        if (propAttr !\u003d null)\n          attr \u003d StringInterner.weakIntern(propAttr.getValue());\n        propAttr \u003d prop.getAttributeNode(\"value\");\n        if (propAttr !\u003d null)\n          value \u003d StringInterner.weakIntern(propAttr.getValue());\n        propAttr \u003d prop.getAttributeNode(\"final\");\n        if (propAttr !\u003d null)\n          finalParameter \u003d \"true\".equals(propAttr.getValue());\n        propAttr \u003d prop.getAttributeNode(\"source\");\n        if (propAttr !\u003d null)\n          source.add(StringInterner.weakIntern(propAttr.getValue()));\n\n        NodeList fields \u003d prop.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData().trim());\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData());\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData()));\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(attr);\n            keyInfo.clearAccessed();\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "a126a01fa197beebe955837c8f2efbd3257f7aa5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10437. Fix the javac warnings in the conf and the util package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1582015 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/14 12:03 PM",
      "commitName": "a126a01fa197beebe955837c8f2efbd3257f7aa5",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/02/14 2:59 PM",
      "commitNameOld": "2f341414dd4a052bee3907ff4a6db283a15f9d53",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 34.84,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,142 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           doc \u003d parse(builder, new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         doc \u003d parse(builder, (InputStream) resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n-      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n-        if (quiet)\n-          return null;\n-        throw new RuntimeException(resource + \" not found\");\n-      }\n-\n       if (root \u003d\u003d null) {\n+        if (doc \u003d\u003d null) {\n+          if (quiet) {\n+            return null;\n+          }\n+          throw new RuntimeException(resource + \" not found\");\n+        }\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       DeprecationContext deprecations \u003d deprecationContext.get();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData().trim());\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData());\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData()));\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d\n                 deprecations.getDeprecatedKeyMap().get(attr);\n             keyInfo.clearAccessed();\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (root \u003d\u003d null) {\n        if (doc \u003d\u003d null) {\n          if (quiet) {\n            return null;\n          }\n          throw new RuntimeException(resource + \" not found\");\n        }\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      DeprecationContext deprecations \u003d deprecationContext.get();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData().trim());\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData());\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData()));\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(attr);\n            keyInfo.clearAccessed();\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "7abf7e81512918d780e05070c29ee2ba8736f41e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9478. Fix race conditions during the initialization of Configuration related to deprecatedKeyMap (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1538248 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/11/13 11:42 AM",
      "commitName": "7abf7e81512918d780e05070c29ee2ba8736f41e",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "20/08/13 2:53 PM",
      "commitNameOld": "2cd6064195da817d2c34b64f19d4c6d630efbc4a",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 73.87,
      "commitsBetweenForRepo": 472,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,142 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.debug(\"parsing File \" + file);\n           }\n           doc \u003d parse(builder, new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         doc \u003d parse(builder, (InputStream) resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n+      DeprecationContext deprecations \u003d deprecationContext.get();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData().trim());\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData());\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData()));\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n-          if (deprecatedKeyMap.containsKey(attr)) {\n-            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n-            keyInfo.accessed \u003d false;\n+          if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n+            DeprecatedKeyInfo keyInfo \u003d\n+                deprecations.getDeprecatedKeyMap().get(attr);\n+            keyInfo.clearAccessed();\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      DeprecationContext deprecations \u003d deprecationContext.get();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData().trim());\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData());\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData()));\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecations.getDeprecatedKeyMap().containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d\n                deprecations.getDeprecatedKeyMap().get(attr);\n            keyInfo.clearAccessed();\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "3ab7f86c16c0c3df89f5157aab0bb5d66fbcc2d5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9582. Non-existent file to \"hadoop fs -conf\" doesn\u0027t throw error. Contributed by Ashwin Shankar\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494331 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/13 2:56 PM",
      "commitName": "3ab7f86c16c0c3df89f5157aab0bb5d66fbcc2d5",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "30/04/13 4:07 PM",
      "commitNameOld": "0728f00282559e1ef6a46991ab630101045ff755",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 48.95,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n-            LOG.info(\"parsing File \" + file);\n+            LOG.debug(\"parsing File \" + file);\n           }\n           doc \u003d parse(builder, new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         doc \u003d parse(builder, (InputStream) resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData().trim());\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData());\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(StringInterner.weakIntern(\n                 ((Text)field.getFirstChild()).getData()));\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.debug(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData().trim());\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData());\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData()));\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "aac5c149c7ca500b8eb810b7d4b561ff1e38ea02": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4752. Reduce MR AM memory usage through String Interning (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1404177 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/12 7:57 AM",
      "commitName": "aac5c149c7ca500b8eb810b7d4b561ff1e38ea02",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "19/09/12 9:06 PM",
      "commitNameOld": "4c56bccf5ee1d6ec1fcef0804eacae785c4d7c18",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 41.45,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,140 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing File \" + file);\n           }\n           doc \u003d parse(builder, new BufferedInputStream(\n               new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n         doc \u003d parse(builder, (InputStream) resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n+            attr \u003d StringInterner.weakIntern(\n+                ((Text)field.getFirstChild()).getData().trim());\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            value \u003d ((Text)field.getFirstChild()).getData();\n+            value \u003d StringInterner.weakIntern(\n+                ((Text)field.getFirstChild()).getData());\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n-            source.add(((Text)field.getFirstChild()).getData());\n+            source.add(StringInterner.weakIntern(\n+                ((Text)field.getFirstChild()).getData()));\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData().trim());\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData());\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(StringInterner.weakIntern(\n                ((Text)field.getFirstChild()).getData()));\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "11312adedb09886e94241aabd973064764b6d857": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8749. HADOOP-8031 changed the way in which relative xincludes are handled in Configuration. (ahmed via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1381703 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/12 11:15 AM",
      "commitName": "11312adedb09886e94241aabd973064764b6d857",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "31/08/12 11:27 AM",
      "commitNameOld": "38d003a6db26307cd6544e1ca303c5a521299fb4",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing File \" + file);\n           }\n-          doc \u003d parse(builder, new BufferedInputStream(new FileInputStream(file)));\n+          doc \u003d parse(builder, new BufferedInputStream(\n+              new FileInputStream(file)), ((Path)resource).toString());\n         }\n       } else if (resource instanceof InputStream) {\n-        doc \u003d parse(builder, (InputStream) resource);\n+        doc \u003d parse(builder, (InputStream) resource, null);\n         returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(((Text)field.getFirstChild()).getData());\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(\n              new FileInputStream(file)), ((Path)resource).toString());\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource, null);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(((Text)field.getFirstChild()).getData());\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "bbf1f55bee92976b101956fe30467619ca274ac8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8031. Configuration class fails to find embedded .jar resources; should use URL.openStream() (genman via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1376772 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/08/12 4:24 PM",
      "commitName": "bbf1f55bee92976b101956fe30467619ca274ac8",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "23/08/12 8:24 AM",
      "commitNameOld": "42beb56a2ed0176bf0c47fe1b844f01d459130d1",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,156 +1,136 @@\n   private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     String name \u003d UNKNOWN_RESOURCE;\n     try {\n       Object resource \u003d wrapper.getResource();\n       name \u003d wrapper.getName();\n       \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n       boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n-        URL url \u003d (URL)resource;\n-        if (url !\u003d null) {\n-          if (!quiet) {\n-            LOG.info(\"parsing \" + url);\n-          }\n-          doc \u003d builder.parse(url.toString());\n-        }\n+        doc \u003d parse(builder, (URL)resource);\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n-        if (url !\u003d null) {\n-          if (!quiet) {\n-            LOG.info(\"parsing \" + url);\n-          }\n-          doc \u003d builder.parse(url.toString());\n-        }\n+        doc \u003d parse(builder, url);\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n-            LOG.info(\"parsing \" + file);\n+            LOG.info(\"parsing File \" + file);\n           }\n-          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n-          try {\n-            doc \u003d builder.parse(in);\n-          } finally {\n-            in.close();\n-          }\n+          doc \u003d parse(builder, new BufferedInputStream(new FileInputStream(file)));\n         }\n       } else if (resource instanceof InputStream) {\n-        try {\n-          doc \u003d builder.parse((InputStream)resource);\n-          returnCachedProperties \u003d true;\n-        } finally {\n-          ((InputStream)resource).close();\n-        }\n+        doc \u003d parse(builder, (InputStream) resource);\n+        returnCachedProperties \u003d true;\n       } else if (resource instanceof Properties) {\n         overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       Properties toAddTo \u003d properties;\n       if(returnCachedProperties) {\n         toAddTo \u003d new Properties();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(((Text)field.getFirstChild()).getData());\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n               loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n             loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n       \n       if (returnCachedProperties) {\n         overlay(properties, toAddTo);\n         return new Resource(toAddTo, name);\n       }\n       return null;\n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        doc \u003d parse(builder, (URL)resource);\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        doc \u003d parse(builder, url);\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing File \" + file);\n          }\n          doc \u003d parse(builder, new BufferedInputStream(new FileInputStream(file)));\n        }\n      } else if (resource instanceof InputStream) {\n        doc \u003d parse(builder, (InputStream) resource);\n        returnCachedProperties \u003d true;\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(((Text)field.getFirstChild()).getData());\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "58a8826fb5a0c2d70aabf2a9a99f0b8906124155": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-8573. Configuration tries to read from an inputstream resource multiple times (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359891 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/12 1:50 PM",
      "commitName": "58a8826fb5a0c2d70aabf2a9a99f0b8906124155",
      "commitAuthor": "Thomas Graves",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-8573. Configuration tries to read from an inputstream resource multiple times (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359891 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/07/12 1:50 PM",
          "commitName": "58a8826fb5a0c2d70aabf2a9a99f0b8906124155",
          "commitAuthor": "Thomas Graves",
          "commitDateOld": "10/07/12 9:49 AM",
          "commitNameOld": "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,156 @@\n-  private void loadResource(Properties properties, Resource wrapper, boolean quiet) {\n+  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n+    String name \u003d UNKNOWN_RESOURCE;\n     try {\n+      Object resource \u003d wrapper.getResource();\n+      name \u003d wrapper.getName();\n+      \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n-\n-      Object resource \u003d wrapper.getResource();\n-      String name \u003d wrapper.getName();\n+      boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         URL url \u003d (URL)resource;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n       } else if (resource instanceof InputStream) {\n         try {\n           doc \u003d builder.parse((InputStream)resource);\n+          returnCachedProperties \u003d true;\n         } finally {\n           ((InputStream)resource).close();\n         }\n+      } else if (resource instanceof Properties) {\n+        overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n-          return;\n+          return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n+      Properties toAddTo \u003d properties;\n+      if(returnCachedProperties) {\n+        toAddTo \u003d new Properties();\n+      }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n-          loadResource(properties, new Resource(prop, name), quiet);\n+          loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(((Text)field.getFirstChild()).getData());\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n-              loadProperty(properties, name, key, value, finalParameter, \n+              loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n-            loadProperty(properties, name, attr, value, finalParameter, \n+            loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n-        \n+      \n+      if (returnCachedProperties) {\n+        overlay(properties, toAddTo);\n+        return new Resource(toAddTo, name);\n+      }\n+      return null;\n     } catch (IOException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)resource;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (resource instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)resource);\n          returnCachedProperties \u003d true;\n        } finally {\n          ((InputStream)resource).close();\n        }\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(((Text)field.getFirstChild()).getData());\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Resource"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-8573. Configuration tries to read from an inputstream resource multiple times (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359891 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/07/12 1:50 PM",
          "commitName": "58a8826fb5a0c2d70aabf2a9a99f0b8906124155",
          "commitAuthor": "Thomas Graves",
          "commitDateOld": "10/07/12 9:49 AM",
          "commitNameOld": "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,156 @@\n-  private void loadResource(Properties properties, Resource wrapper, boolean quiet) {\n+  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n+    String name \u003d UNKNOWN_RESOURCE;\n     try {\n+      Object resource \u003d wrapper.getResource();\n+      name \u003d wrapper.getName();\n+      \n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n-\n-      Object resource \u003d wrapper.getResource();\n-      String name \u003d wrapper.getName();\n+      boolean returnCachedProperties \u003d false;\n       \n       if (resource instanceof URL) {                  // an URL resource\n         URL url \u003d (URL)resource;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (resource instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)resource);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n       } else if (resource instanceof InputStream) {\n         try {\n           doc \u003d builder.parse((InputStream)resource);\n+          returnCachedProperties \u003d true;\n         } finally {\n           ((InputStream)resource).close();\n         }\n+      } else if (resource instanceof Properties) {\n+        overlay(properties, (Properties)resource);\n       } else if (resource instanceof Element) {\n         root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n-          return;\n+          return null;\n         throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n+      Properties toAddTo \u003d properties;\n+      if(returnCachedProperties) {\n+        toAddTo \u003d new Properties();\n+      }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n-          loadResource(properties, new Resource(prop, name), quiet);\n+          loadResource(toAddTo, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n           if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             source.add(((Text)field.getFirstChild()).getData());\n         }\n         source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n-              loadProperty(properties, name, key, value, finalParameter, \n+              loadProperty(toAddTo, name, key, value, finalParameter, \n                   source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n-            loadProperty(properties, name, attr, value, finalParameter, \n+            loadProperty(toAddTo, name, attr, value, finalParameter, \n                 source.toArray(new String[source.size()]));\n           }\n         }\n       }\n-        \n+      \n+      if (returnCachedProperties) {\n+        overlay(properties, toAddTo);\n+        return new Resource(toAddTo, name);\n+      }\n+      return null;\n     } catch (IOException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name, e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n-      LOG.fatal(\"error parsing conf file: \" + e);\n+      LOG.fatal(\"error parsing conf \" + name , e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    String name \u003d UNKNOWN_RESOURCE;\n    try {\n      Object resource \u003d wrapper.getResource();\n      name \u003d wrapper.getName();\n      \n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n      boolean returnCachedProperties \u003d false;\n      \n      if (resource instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)resource;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (resource instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)resource);\n          returnCachedProperties \u003d true;\n        } finally {\n          ((InputStream)resource).close();\n        }\n      } else if (resource instanceof Properties) {\n        overlay(properties, (Properties)resource);\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return null;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      Properties toAddTo \u003d properties;\n      if(returnCachedProperties) {\n        toAddTo \u003d new Properties();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(toAddTo, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(((Text)field.getFirstChild()).getData());\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(toAddTo, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(toAddTo, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n      \n      if (returnCachedProperties) {\n        overlay(properties, toAddTo);\n        return new Resource(toAddTo, name);\n      }\n      return null;\n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf \" + name, e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf \" + name , e);\n      throw new RuntimeException(e);\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
          "extendedDetails": {}
        }
      ]
    },
    "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-8525. Provide Improved Traceability for Configuration (bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359775 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/12 9:49 AM",
      "commitName": "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36",
      "commitAuthor": "Robert Joseph Evans",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-8525. Provide Improved Traceability for Configuration (bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359775 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/07/12 9:49 AM",
          "commitName": "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36",
          "commitAuthor": "Robert Joseph Evans",
          "commitDateOld": "30/06/12 11:40 AM",
          "commitNameOld": "cb5867573e8fd5bf1c5fed793aa554ccb5549661",
          "commitAuthorOld": "Harsh J",
          "daysBetweenCommits": 9.92,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,133 +1,142 @@\n-  private void loadResource(Properties properties, Object name, boolean quiet) {\n+  private void loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     try {\n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n \n-      if (name instanceof URL) {                  // an URL resource\n-        URL url \u003d (URL)name;\n+      Object resource \u003d wrapper.getResource();\n+      String name \u003d wrapper.getName();\n+      \n+      if (resource instanceof URL) {                  // an URL resource\n+        URL url \u003d (URL)resource;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n-      } else if (name instanceof String) {        // a CLASSPATH resource\n-        URL url \u003d getResource((String)name);\n+      } else if (resource instanceof String) {        // a CLASSPATH resource\n+        URL url \u003d getResource((String)resource);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n-      } else if (name instanceof Path) {          // a file resource\n+      } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n-        File file \u003d new File(((Path)name).toUri().getPath())\n+        File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n-      } else if (name instanceof InputStream) {\n+      } else if (resource instanceof InputStream) {\n         try {\n-          doc \u003d builder.parse((InputStream)name);\n+          doc \u003d builder.parse((InputStream)resource);\n         } finally {\n-          ((InputStream)name).close();\n+          ((InputStream)resource).close();\n         }\n-      } else if (name instanceof Element) {\n-        root \u003d (Element)name;\n+      } else if (resource instanceof Element) {\n+        root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return;\n-        throw new RuntimeException(name + \" not found\");\n+        throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n-          loadResource(properties, prop, quiet);\n+          loadResource(properties, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n+        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n+          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n+            source.add(((Text)field.getFirstChild()).getData());\n         }\n+        source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n-              loadProperty(properties, name, key, value, finalParameter);\n+              loadProperty(properties, name, key, value, finalParameter, \n+                  source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n-            loadProperty(properties, name, attr, value, finalParameter);\n+            loadProperty(properties, name, attr, value, finalParameter, \n+                source.toArray(new String[source.size()]));\n           }\n         }\n       }\n         \n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      Object resource \u003d wrapper.getResource();\n      String name \u003d wrapper.getName();\n      \n      if (resource instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)resource;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (resource instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)resource);\n        } finally {\n          ((InputStream)resource).close();\n        }\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(((Text)field.getFirstChild()).getData());\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(properties, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(properties, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
          "extendedDetails": {
            "oldValue": "[properties-Properties, name-Object, quiet-boolean]",
            "newValue": "[properties-Properties, wrapper-Resource, quiet-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-8525. Provide Improved Traceability for Configuration (bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359775 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/07/12 9:49 AM",
          "commitName": "0b7139d6bcfe6a4860c98b3703ee163b2f4bdb36",
          "commitAuthor": "Robert Joseph Evans",
          "commitDateOld": "30/06/12 11:40 AM",
          "commitNameOld": "cb5867573e8fd5bf1c5fed793aa554ccb5549661",
          "commitAuthorOld": "Harsh J",
          "daysBetweenCommits": 9.92,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,133 +1,142 @@\n-  private void loadResource(Properties properties, Object name, boolean quiet) {\n+  private void loadResource(Properties properties, Resource wrapper, boolean quiet) {\n     try {\n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n \n-      if (name instanceof URL) {                  // an URL resource\n-        URL url \u003d (URL)name;\n+      Object resource \u003d wrapper.getResource();\n+      String name \u003d wrapper.getName();\n+      \n+      if (resource instanceof URL) {                  // an URL resource\n+        URL url \u003d (URL)resource;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n-      } else if (name instanceof String) {        // a CLASSPATH resource\n-        URL url \u003d getResource((String)name);\n+      } else if (resource instanceof String) {        // a CLASSPATH resource\n+        URL url \u003d getResource((String)resource);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n-      } else if (name instanceof Path) {          // a file resource\n+      } else if (resource instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n-        File file \u003d new File(((Path)name).toUri().getPath())\n+        File file \u003d new File(((Path)resource).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n-      } else if (name instanceof InputStream) {\n+      } else if (resource instanceof InputStream) {\n         try {\n-          doc \u003d builder.parse((InputStream)name);\n+          doc \u003d builder.parse((InputStream)resource);\n         } finally {\n-          ((InputStream)name).close();\n+          ((InputStream)resource).close();\n         }\n-      } else if (name instanceof Element) {\n-        root \u003d (Element)name;\n+      } else if (resource instanceof Element) {\n+        root \u003d (Element)resource;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return;\n-        throw new RuntimeException(name + \" not found\");\n+        throw new RuntimeException(resource + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n-          loadResource(properties, prop, quiet);\n+          loadResource(properties, new Resource(prop, name), quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n+        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n+          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n+            source.add(((Text)field.getFirstChild()).getData());\n         }\n+        source.add(name);\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (deprecatedKeyMap.containsKey(attr)) {\n             DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n             keyInfo.accessed \u003d false;\n             for (String key:keyInfo.newKeys) {\n               // update new keys with deprecated key\u0027s value \n-              loadProperty(properties, name, key, value, finalParameter);\n+              loadProperty(properties, name, key, value, finalParameter, \n+                  source.toArray(new String[source.size()]));\n             }\n           }\n           else {\n-            loadProperty(properties, name, attr, value, finalParameter);\n+            loadProperty(properties, name, attr, value, finalParameter, \n+                source.toArray(new String[source.size()]));\n           }\n         }\n       }\n         \n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadResource(Properties properties, Resource wrapper, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      Object resource \u003d wrapper.getResource();\n      String name \u003d wrapper.getName();\n      \n      if (resource instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)resource;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)resource);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (resource instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)resource).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (resource instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)resource);\n        } finally {\n          ((InputStream)resource).close();\n        }\n      } else if (resource instanceof Element) {\n        root \u003d (Element)resource;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(resource + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, new Resource(prop, name), quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        LinkedList\u003cString\u003e source \u003d new LinkedList\u003cString\u003e();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n          if (\"source\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            source.add(((Text)field.getFirstChild()).getData());\n        }\n        source.add(name);\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(properties, name, key, value, finalParameter, \n                  source.toArray(new String[source.size()]));\n            }\n          }\n          else {\n            loadProperty(properties, name, attr, value, finalParameter, \n                source.toArray(new String[source.size()]));\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(properties, name, key, value, finalParameter);\n            }\n          }\n          else {\n            loadProperty(properties, name, attr, value, finalParameter);\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(properties, name, key, value, finalParameter);\n            }\n          }\n          else {\n            loadProperty(properties, name, attr, value, finalParameter);\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/conf/Configuration.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(properties, name, key, value, finalParameter);\n            }\n          }\n          else {\n            loadProperty(properties, name, attr, value, finalParameter);\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/conf/Configuration.java",
        "newPath": "common/src/java/org/apache/hadoop/conf/Configuration.java"
      }
    },
    "97c38f94f57544cdd24fb581fef10d61c7263654": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6439. Fixes handling of deprecated keys to follow order in which keys are defined. Contributed by V.V.Chaitanya Krishna.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@936463 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/04/10 12:32 PM",
      "commitName": "97c38f94f57544cdd24fb581fef10d61c7263654",
      "commitAuthor": "Hemanth Yamijala",
      "commitDateOld": "22/03/10 12:08 PM",
      "commitNameOld": "0485fe23ba76f7d96a198aed00f392fd571124bc",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 30.02,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,133 @@\n   private void loadResource(Properties properties, Object name, boolean quiet) {\n     try {\n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n \n       if (name instanceof URL) {                  // an URL resource\n         URL url \u003d (URL)name;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)name);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)name).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n       } else if (name instanceof InputStream) {\n         try {\n           doc \u003d builder.parse((InputStream)name);\n         } finally {\n           ((InputStream)name).close();\n         }\n       } else if (name instanceof Element) {\n         root \u003d (Element)name;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return;\n         throw new RuntimeException(name + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(properties, prop, quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n         }\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n-          if (value !\u003d null) {\n-            if (!finalParameters.contains(attr)) {\n-              properties.setProperty(attr, value);\n-              updatingResource.put(attr, name.toString());\n-            } else {\n-              LOG.warn(name+\":a attempt to override final parameter: \"+attr\n-                     +\";  Ignoring.\");\n+          if (deprecatedKeyMap.containsKey(attr)) {\n+            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n+            keyInfo.accessed \u003d false;\n+            for (String key:keyInfo.newKeys) {\n+              // update new keys with deprecated key\u0027s value \n+              loadProperty(properties, name, key, value, finalParameter);\n             }\n           }\n-          if (finalParameter) {\n-            finalParameters.add(attr);\n+          else {\n+            loadProperty(properties, name, attr, value, finalParameter);\n           }\n         }\n       }\n         \n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (deprecatedKeyMap.containsKey(attr)) {\n            DeprecatedKeyInfo keyInfo \u003d deprecatedKeyMap.get(attr);\n            keyInfo.accessed \u003d false;\n            for (String key:keyInfo.newKeys) {\n              // update new keys with deprecated key\u0027s value \n              loadProperty(properties, name, key, value, finalParameter);\n            }\n          }\n          else {\n            loadProperty(properties, name, attr, value, finalParameter);\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "889528e387680f18472b45e63f7857dbd0117eb9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6408. Add a /conf servlet to dump running configuration. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@896641 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/10 11:44 AM",
      "commitName": "889528e387680f18472b45e63f7857dbd0117eb9",
      "commitAuthor": "Thomas White",
      "commitDateOld": "09/12/09 3:25 PM",
      "commitNameOld": "a473f3773342695cdb47e3ae4fe432b81e7787fd",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 27.85,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,134 @@\n   private void loadResource(Properties properties, Object name, boolean quiet) {\n     try {\n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n \n       if (name instanceof URL) {                  // an URL resource\n         URL url \u003d (URL)name;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)name);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)name).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n       } else if (name instanceof InputStream) {\n         try {\n           doc \u003d builder.parse((InputStream)name);\n         } finally {\n           ((InputStream)name).close();\n         }\n       } else if (name instanceof Element) {\n         root \u003d (Element)name;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return;\n         throw new RuntimeException(name + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(properties, prop, quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n         }\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null) {\n           if (value !\u003d null) {\n             if (!finalParameters.contains(attr)) {\n               properties.setProperty(attr, value);\n-              if (storeResource) {\n-                updatingResource.put(attr, name.toString());\n-              }\n+              updatingResource.put(attr, name.toString());\n             } else {\n               LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                      +\";  Ignoring.\");\n             }\n           }\n           if (finalParameter) {\n             finalParameters.add(attr);\n           }\n         }\n       }\n         \n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (value !\u003d null) {\n            if (!finalParameters.contains(attr)) {\n              properties.setProperty(attr, value);\n              updatingResource.put(attr, name.toString());\n            } else {\n              LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                     +\";  Ignoring.\");\n            }\n          }\n          if (finalParameter) {\n            finalParameters.add(attr);\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "75103dc925dc8db6c65e2281c96998c965c5e3f9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6227. Fix Configuration to allow final parameters to be set to null and prevent them from being overridden. Contributed by Amareshwari Sriramadasu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@810097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/09/09 8:24 AM",
      "commitName": "75103dc925dc8db6c65e2281c96998c965c5e3f9",
      "commitAuthor": "Hemanth Yamijala",
      "commitDateOld": "24/08/09 4:21 AM",
      "commitNameOld": "280ab0cf7d71882cd3af8cf4e77a1af96844e0c6",
      "commitAuthorOld": "Hemanth Yamijala",
      "daysBetweenCommits": 8.17,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,136 @@\n   private void loadResource(Properties properties, Object name, boolean quiet) {\n     try {\n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n \n       if (name instanceof URL) {                  // an URL resource\n         URL url \u003d (URL)name;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)name);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)name).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n       } else if (name instanceof InputStream) {\n         try {\n           doc \u003d builder.parse((InputStream)name);\n         } finally {\n           ((InputStream)name).close();\n         }\n       } else if (name instanceof Element) {\n         root \u003d (Element)name;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return;\n         throw new RuntimeException(name + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(properties, prop, quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n         }\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n-        if (attr !\u003d null \u0026\u0026 value !\u003d null) {\n-          if (!finalParameters.contains(attr)) {\n-            properties.setProperty(attr, value);\n-            if (storeResource) {\n-              updatingResource.put(attr, name.toString());\n-            }\n-            if (finalParameter)\n-              finalParameters.add(attr);\n-          } else {\n-            LOG.warn(name+\":a attempt to override final parameter: \"+attr\n+        if (attr !\u003d null) {\n+          if (value !\u003d null) {\n+            if (!finalParameters.contains(attr)) {\n+              properties.setProperty(attr, value);\n+              if (storeResource) {\n+                updatingResource.put(attr, name.toString());\n+              }\n+            } else {\n+              LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                      +\";  Ignoring.\");\n+            }\n+          }\n+          if (finalParameter) {\n+            finalParameters.add(attr);\n           }\n         }\n       }\n         \n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null) {\n          if (value !\u003d null) {\n            if (!finalParameters.contains(attr)) {\n              properties.setProperty(attr, value);\n              if (storeResource) {\n                updatingResource.put(attr, name.toString());\n              }\n            } else {\n              LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                     +\";  Ignoring.\");\n            }\n          }\n          if (finalParameter) {\n            finalParameters.add(attr);\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "280ab0cf7d71882cd3af8cf4e77a1af96844e0c6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6184. Provide an API to dump Configuration in a JSON format. Contributed by V.V.Chaitanya Krishna.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@807149 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/09 4:21 AM",
      "commitName": "280ab0cf7d71882cd3af8cf4e77a1af96844e0c6",
      "commitAuthor": "Hemanth Yamijala",
      "commitDateOld": "20/08/09 11:59 PM",
      "commitNameOld": "0a8e65c23b1a8380b4246f18755ebb5d3f376111",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,133 @@\n   private void loadResource(Properties properties, Object name, boolean quiet) {\n     try {\n       DocumentBuilderFactory docBuilderFactory \n         \u003d DocumentBuilderFactory.newInstance();\n       //ignore all comments inside the xml file\n       docBuilderFactory.setIgnoringComments(true);\n \n       //allow includes in the xml file\n       docBuilderFactory.setNamespaceAware(true);\n       try {\n           docBuilderFactory.setXIncludeAware(true);\n       } catch (UnsupportedOperationException e) {\n         LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                 + docBuilderFactory\n                 + \":\" + e,\n                 e);\n       }\n       DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n       Document doc \u003d null;\n       Element root \u003d null;\n \n       if (name instanceof URL) {                  // an URL resource\n         URL url \u003d (URL)name;\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof String) {        // a CLASSPATH resource\n         URL url \u003d getResource((String)name);\n         if (url !\u003d null) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + url);\n           }\n           doc \u003d builder.parse(url.toString());\n         }\n       } else if (name instanceof Path) {          // a file resource\n         // Can\u0027t use FileSystem API or we get an infinite loop\n         // since FileSystem uses Configuration API.  Use java.io.File instead.\n         File file \u003d new File(((Path)name).toUri().getPath())\n           .getAbsoluteFile();\n         if (file.exists()) {\n           if (!quiet) {\n             LOG.info(\"parsing \" + file);\n           }\n           InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n           try {\n             doc \u003d builder.parse(in);\n           } finally {\n             in.close();\n           }\n         }\n       } else if (name instanceof InputStream) {\n         try {\n           doc \u003d builder.parse((InputStream)name);\n         } finally {\n           ((InputStream)name).close();\n         }\n       } else if (name instanceof Element) {\n         root \u003d (Element)name;\n       }\n \n       if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n         if (quiet)\n           return;\n         throw new RuntimeException(name + \" not found\");\n       }\n \n       if (root \u003d\u003d null) {\n         root \u003d doc.getDocumentElement();\n       }\n       if (!\"configuration\".equals(root.getTagName()))\n         LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n       NodeList props \u003d root.getChildNodes();\n       for (int i \u003d 0; i \u003c props.getLength(); i++) {\n         Node propNode \u003d props.item(i);\n         if (!(propNode instanceof Element))\n           continue;\n         Element prop \u003d (Element)propNode;\n         if (\"configuration\".equals(prop.getTagName())) {\n           loadResource(properties, prop, quiet);\n           continue;\n         }\n         if (!\"property\".equals(prop.getTagName()))\n           LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n         NodeList fields \u003d prop.getChildNodes();\n         String attr \u003d null;\n         String value \u003d null;\n         boolean finalParameter \u003d false;\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element)fieldNode;\n           if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             attr \u003d ((Text)field.getFirstChild()).getData().trim();\n           if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             value \u003d ((Text)field.getFirstChild()).getData();\n           if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n             finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n         }\n         \n         // Ignore this parameter if it has already been marked as \u0027final\u0027\n         if (attr !\u003d null \u0026\u0026 value !\u003d null) {\n           if (!finalParameters.contains(attr)) {\n             properties.setProperty(attr, value);\n+            if (storeResource) {\n+              updatingResource.put(attr, name.toString());\n+            }\n             if (finalParameter)\n               finalParameters.add(attr);\n           } else {\n             LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                      +\";  Ignoring.\");\n           }\n         }\n       }\n         \n     } catch (IOException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (DOMException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (SAXException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     } catch (ParserConfigurationException e) {\n       LOG.fatal(\"error parsing conf file: \" + e);\n       throw new RuntimeException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null \u0026\u0026 value !\u003d null) {\n          if (!finalParameters.contains(attr)) {\n            properties.setProperty(attr, value);\n            if (storeResource) {\n              updatingResource.put(attr, name.toString());\n            }\n            if (finalParameter)\n              finalParameters.add(attr);\n          } else {\n            LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                     +\";  Ignoring.\");\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,130 @@\n+  private void loadResource(Properties properties, Object name, boolean quiet) {\n+    try {\n+      DocumentBuilderFactory docBuilderFactory \n+        \u003d DocumentBuilderFactory.newInstance();\n+      //ignore all comments inside the xml file\n+      docBuilderFactory.setIgnoringComments(true);\n+\n+      //allow includes in the xml file\n+      docBuilderFactory.setNamespaceAware(true);\n+      try {\n+          docBuilderFactory.setXIncludeAware(true);\n+      } catch (UnsupportedOperationException e) {\n+        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n+                + docBuilderFactory\n+                + \":\" + e,\n+                e);\n+      }\n+      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n+      Document doc \u003d null;\n+      Element root \u003d null;\n+\n+      if (name instanceof URL) {                  // an URL resource\n+        URL url \u003d (URL)name;\n+        if (url !\u003d null) {\n+          if (!quiet) {\n+            LOG.info(\"parsing \" + url);\n+          }\n+          doc \u003d builder.parse(url.toString());\n+        }\n+      } else if (name instanceof String) {        // a CLASSPATH resource\n+        URL url \u003d getResource((String)name);\n+        if (url !\u003d null) {\n+          if (!quiet) {\n+            LOG.info(\"parsing \" + url);\n+          }\n+          doc \u003d builder.parse(url.toString());\n+        }\n+      } else if (name instanceof Path) {          // a file resource\n+        // Can\u0027t use FileSystem API or we get an infinite loop\n+        // since FileSystem uses Configuration API.  Use java.io.File instead.\n+        File file \u003d new File(((Path)name).toUri().getPath())\n+          .getAbsoluteFile();\n+        if (file.exists()) {\n+          if (!quiet) {\n+            LOG.info(\"parsing \" + file);\n+          }\n+          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n+          try {\n+            doc \u003d builder.parse(in);\n+          } finally {\n+            in.close();\n+          }\n+        }\n+      } else if (name instanceof InputStream) {\n+        try {\n+          doc \u003d builder.parse((InputStream)name);\n+        } finally {\n+          ((InputStream)name).close();\n+        }\n+      } else if (name instanceof Element) {\n+        root \u003d (Element)name;\n+      }\n+\n+      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n+        if (quiet)\n+          return;\n+        throw new RuntimeException(name + \" not found\");\n+      }\n+\n+      if (root \u003d\u003d null) {\n+        root \u003d doc.getDocumentElement();\n+      }\n+      if (!\"configuration\".equals(root.getTagName()))\n+        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n+      NodeList props \u003d root.getChildNodes();\n+      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n+        Node propNode \u003d props.item(i);\n+        if (!(propNode instanceof Element))\n+          continue;\n+        Element prop \u003d (Element)propNode;\n+        if (\"configuration\".equals(prop.getTagName())) {\n+          loadResource(properties, prop, quiet);\n+          continue;\n+        }\n+        if (!\"property\".equals(prop.getTagName()))\n+          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n+        NodeList fields \u003d prop.getChildNodes();\n+        String attr \u003d null;\n+        String value \u003d null;\n+        boolean finalParameter \u003d false;\n+        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n+          Node fieldNode \u003d fields.item(j);\n+          if (!(fieldNode instanceof Element))\n+            continue;\n+          Element field \u003d (Element)fieldNode;\n+          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n+            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n+          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n+            value \u003d ((Text)field.getFirstChild()).getData();\n+          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n+            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n+        }\n+        \n+        // Ignore this parameter if it has already been marked as \u0027final\u0027\n+        if (attr !\u003d null \u0026\u0026 value !\u003d null) {\n+          if (!finalParameters.contains(attr)) {\n+            properties.setProperty(attr, value);\n+            if (finalParameter)\n+              finalParameters.add(attr);\n+          } else {\n+            LOG.warn(name+\":a attempt to override final parameter: \"+attr\n+                     +\";  Ignoring.\");\n+          }\n+        }\n+      }\n+        \n+    } catch (IOException e) {\n+      LOG.fatal(\"error parsing conf file: \" + e);\n+      throw new RuntimeException(e);\n+    } catch (DOMException e) {\n+      LOG.fatal(\"error parsing conf file: \" + e);\n+      throw new RuntimeException(e);\n+    } catch (SAXException e) {\n+      LOG.fatal(\"error parsing conf file: \" + e);\n+      throw new RuntimeException(e);\n+    } catch (ParserConfigurationException e) {\n+      LOG.fatal(\"error parsing conf file: \" + e);\n+      throw new RuntimeException(e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadResource(Properties properties, Object name, boolean quiet) {\n    try {\n      DocumentBuilderFactory docBuilderFactory \n        \u003d DocumentBuilderFactory.newInstance();\n      //ignore all comments inside the xml file\n      docBuilderFactory.setIgnoringComments(true);\n\n      //allow includes in the xml file\n      docBuilderFactory.setNamespaceAware(true);\n      try {\n          docBuilderFactory.setXIncludeAware(true);\n      } catch (UnsupportedOperationException e) {\n        LOG.error(\"Failed to set setXIncludeAware(true) for parser \"\n                + docBuilderFactory\n                + \":\" + e,\n                e);\n      }\n      DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n      Document doc \u003d null;\n      Element root \u003d null;\n\n      if (name instanceof URL) {                  // an URL resource\n        URL url \u003d (URL)name;\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof String) {        // a CLASSPATH resource\n        URL url \u003d getResource((String)name);\n        if (url !\u003d null) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + url);\n          }\n          doc \u003d builder.parse(url.toString());\n        }\n      } else if (name instanceof Path) {          // a file resource\n        // Can\u0027t use FileSystem API or we get an infinite loop\n        // since FileSystem uses Configuration API.  Use java.io.File instead.\n        File file \u003d new File(((Path)name).toUri().getPath())\n          .getAbsoluteFile();\n        if (file.exists()) {\n          if (!quiet) {\n            LOG.info(\"parsing \" + file);\n          }\n          InputStream in \u003d new BufferedInputStream(new FileInputStream(file));\n          try {\n            doc \u003d builder.parse(in);\n          } finally {\n            in.close();\n          }\n        }\n      } else if (name instanceof InputStream) {\n        try {\n          doc \u003d builder.parse((InputStream)name);\n        } finally {\n          ((InputStream)name).close();\n        }\n      } else if (name instanceof Element) {\n        root \u003d (Element)name;\n      }\n\n      if (doc \u003d\u003d null \u0026\u0026 root \u003d\u003d null) {\n        if (quiet)\n          return;\n        throw new RuntimeException(name + \" not found\");\n      }\n\n      if (root \u003d\u003d null) {\n        root \u003d doc.getDocumentElement();\n      }\n      if (!\"configuration\".equals(root.getTagName()))\n        LOG.fatal(\"bad conf file: top-level element not \u003cconfiguration\u003e\");\n      NodeList props \u003d root.getChildNodes();\n      for (int i \u003d 0; i \u003c props.getLength(); i++) {\n        Node propNode \u003d props.item(i);\n        if (!(propNode instanceof Element))\n          continue;\n        Element prop \u003d (Element)propNode;\n        if (\"configuration\".equals(prop.getTagName())) {\n          loadResource(properties, prop, quiet);\n          continue;\n        }\n        if (!\"property\".equals(prop.getTagName()))\n          LOG.warn(\"bad conf file: element not \u003cproperty\u003e\");\n        NodeList fields \u003d prop.getChildNodes();\n        String attr \u003d null;\n        String value \u003d null;\n        boolean finalParameter \u003d false;\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element)fieldNode;\n          if (\"name\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            attr \u003d ((Text)field.getFirstChild()).getData().trim();\n          if (\"value\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            value \u003d ((Text)field.getFirstChild()).getData();\n          if (\"final\".equals(field.getTagName()) \u0026\u0026 field.hasChildNodes())\n            finalParameter \u003d \"true\".equals(((Text)field.getFirstChild()).getData());\n        }\n        \n        // Ignore this parameter if it has already been marked as \u0027final\u0027\n        if (attr !\u003d null \u0026\u0026 value !\u003d null) {\n          if (!finalParameters.contains(attr)) {\n            properties.setProperty(attr, value);\n            if (finalParameter)\n              finalParameters.add(attr);\n          } else {\n            LOG.warn(name+\":a attempt to override final parameter: \"+attr\n                     +\";  Ignoring.\");\n          }\n        }\n      }\n        \n    } catch (IOException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (DOMException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (SAXException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    } catch (ParserConfigurationException e) {\n      LOG.fatal(\"error parsing conf file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/conf/Configuration.java"
    }
  }
}