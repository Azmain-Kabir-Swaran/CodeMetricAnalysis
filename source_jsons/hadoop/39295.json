{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "allocateFromReservedContainer",
  "functionId": "allocateFromReservedContainer___node-FiCaSchedulerNode__withNodeHeartbeat-boolean__reservedContainer-RMContainer",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 1604,
  "functionEndLine": 1658,
  "numCommitsSeen": 239,
  "timeTaken": 3516,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
    "09763925025a3709e6098186348e1afd80cb9f71",
    "c336af3847add969303c95ea5af2fb76e0c086ab"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": "Ybodychange",
    "09763925025a3709e6098186348e1afd80cb9f71": "Ybodychange",
    "c336af3847add969303c95ea5af2fb76e0c086ab": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/03/20 12:25 AM",
      "commitNameOld": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 6.16,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private void allocateFromReservedContainer(FiCaSchedulerNode node,\n       boolean withNodeHeartbeat, RMContainer reservedContainer) {\n     FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n         reservedContainer.getContainerId());\n     if (reservedApplication \u003d\u003d null) {\n       LOG.error(\n           \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n               + node.getNodeID() + \" container\u003d\" + reservedContainer\n               .getContainerId());\n       return;\n     }\n \n     // Try to fulfill the reservation\n     LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n         reservedApplication.getApplicationId(), node.getNodeID());\n \n     LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n     CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n         new SimpleCandidateNodeSet\u003c\u003e(node),\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     if (assignment.isFulfilledReservation()) {\n       if (withNodeHeartbeat) {\n         // Only update SchedulerHealth in sync scheduling, existing\n         // Data structure of SchedulerHealth need to be updated for\n         // Async mode\n         updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n             assignment);\n       }\n \n       schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          queue.getParent().getQueueName(), queue.getQueueName(),\n+          queue.getParent().getQueuePath(), queue.getQueuePath(),\n           ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n       ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n           node, reservedContainer.getContainerId(),\n           AllocationState.ALLOCATED_FROM_RESERVED);\n     } else if (assignment.getAssignmentInformation().getNumReservations() \u003e 0) {\n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n-          queue.getParent().getQueueName(), queue.getQueueName(),\n+          queue.getParent().getQueuePath(), queue.getQueuePath(),\n           ActivityState.RE_RESERVED, ActivityDiagnosticConstant.EMPTY);\n       ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n           node, reservedContainer.getContainerId(), AllocationState.RESERVED);\n     }\n \n     assignment.setSchedulingMode(\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void allocateFromReservedContainer(FiCaSchedulerNode node,\n      boolean withNodeHeartbeat, RMContainer reservedContainer) {\n    FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n        reservedContainer.getContainerId());\n    if (reservedApplication \u003d\u003d null) {\n      LOG.error(\n          \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n              + node.getNodeID() + \" container\u003d\" + reservedContainer\n              .getContainerId());\n      return;\n    }\n\n    // Try to fulfill the reservation\n    LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n        reservedApplication.getApplicationId(), node.getNodeID());\n\n    LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n    CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n        new SimpleCandidateNodeSet\u003c\u003e(node),\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    if (assignment.isFulfilledReservation()) {\n      if (withNodeHeartbeat) {\n        // Only update SchedulerHealth in sync scheduling, existing\n        // Data structure of SchedulerHealth need to be updated for\n        // Async mode\n        updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n            assignment);\n      }\n\n      schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueuePath(), queue.getQueuePath(),\n          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(),\n          AllocationState.ALLOCATED_FROM_RESERVED);\n    } else if (assignment.getAssignmentInformation().getNumReservations() \u003e 0) {\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueuePath(), queue.getQueuePath(),\n          ActivityState.RE_RESERVED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(), AllocationState.RESERVED);\n    }\n\n    assignment.setSchedulingMode(\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9664. Improve response of scheduler/app activities for better understanding. Contributed by Tao Yang.\n",
      "commitDate": "29/08/19 3:14 AM",
      "commitName": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "27/08/19 3:53 PM",
      "commitNameOld": "8ef46595da6aefe4458aa7181670c3d9b13e7ec6",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 1.47,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private void allocateFromReservedContainer(FiCaSchedulerNode node,\n       boolean withNodeHeartbeat, RMContainer reservedContainer) {\n     FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n         reservedContainer.getContainerId());\n     if (reservedApplication \u003d\u003d null) {\n       LOG.error(\n           \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n               + node.getNodeID() + \" container\u003d\" + reservedContainer\n               .getContainerId());\n       return;\n     }\n \n     // Try to fulfill the reservation\n     LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n         reservedApplication.getApplicationId(), node.getNodeID());\n \n     LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n     CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n         new SimpleCandidateNodeSet\u003c\u003e(node),\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     if (assignment.isFulfilledReservation()) {\n       if (withNodeHeartbeat) {\n         // Only update SchedulerHealth in sync scheduling, existing\n         // Data structure of SchedulerHealth need to be updated for\n         // Async mode\n         updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n             assignment);\n       }\n \n       schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           queue.getParent().getQueueName(), queue.getQueueName(),\n           ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n       ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n           node, reservedContainer.getContainerId(),\n           AllocationState.ALLOCATED_FROM_RESERVED);\n-    } else{\n+    } else if (assignment.getAssignmentInformation().getNumReservations() \u003e 0) {\n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           queue.getParent().getQueueName(), queue.getQueueName(),\n-          ActivityState.SKIPPED, ActivityDiagnosticConstant.EMPTY);\n+          ActivityState.RE_RESERVED, ActivityDiagnosticConstant.EMPTY);\n       ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n-          node, reservedContainer.getContainerId(), AllocationState.SKIPPED);\n+          node, reservedContainer.getContainerId(), AllocationState.RESERVED);\n     }\n \n     assignment.setSchedulingMode(\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void allocateFromReservedContainer(FiCaSchedulerNode node,\n      boolean withNodeHeartbeat, RMContainer reservedContainer) {\n    FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n        reservedContainer.getContainerId());\n    if (reservedApplication \u003d\u003d null) {\n      LOG.error(\n          \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n              + node.getNodeID() + \" container\u003d\" + reservedContainer\n              .getContainerId());\n      return;\n    }\n\n    // Try to fulfill the reservation\n    LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n        reservedApplication.getApplicationId(), node.getNodeID());\n\n    LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n    CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n        new SimpleCandidateNodeSet\u003c\u003e(node),\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    if (assignment.isFulfilledReservation()) {\n      if (withNodeHeartbeat) {\n        // Only update SchedulerHealth in sync scheduling, existing\n        // Data structure of SchedulerHealth need to be updated for\n        // Async mode\n        updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n            assignment);\n      }\n\n      schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueueName(), queue.getQueueName(),\n          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(),\n          AllocationState.ALLOCATED_FROM_RESERVED);\n    } else if (assignment.getAssignmentInformation().getNumReservations() \u003e 0) {\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueueName(), queue.getQueueName(),\n          ActivityState.RE_RESERVED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(), AllocationState.RESERVED);\n    }\n\n    assignment.setSchedulingMode(\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "09763925025a3709e6098186348e1afd80cb9f71": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9590. Correct incompatible, incomplete and redundant activities. Contributed by Tao Yang.\n",
      "commitDate": "06/06/19 6:59 AM",
      "commitName": "09763925025a3709e6098186348e1afd80cb9f71",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "07/05/19 6:54 PM",
      "commitNameOld": "c336af3847add969303c95ea5af2fb76e0c086ab",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 29.5,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private void allocateFromReservedContainer(FiCaSchedulerNode node,\n       boolean withNodeHeartbeat, RMContainer reservedContainer) {\n     FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n         reservedContainer.getContainerId());\n     if (reservedApplication \u003d\u003d null) {\n       LOG.error(\n           \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n               + node.getNodeID() + \" container\u003d\" + reservedContainer\n               .getContainerId());\n       return;\n     }\n \n     // Try to fulfill the reservation\n     LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n         reservedApplication.getApplicationId(), node.getNodeID());\n \n     LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n     CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n         new SimpleCandidateNodeSet\u003c\u003e(node),\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     if (assignment.isFulfilledReservation()) {\n       if (withNodeHeartbeat) {\n         // Only update SchedulerHealth in sync scheduling, existing\n         // Data structure of SchedulerHealth need to be updated for\n         // Async mode\n         updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n             assignment);\n       }\n \n       schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n \n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           queue.getParent().getQueueName(), queue.getQueueName(),\n           ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n       ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n           node, reservedContainer.getContainerId(),\n           AllocationState.ALLOCATED_FROM_RESERVED);\n     } else{\n       ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n           queue.getParent().getQueueName(), queue.getQueueName(),\n-          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n+          ActivityState.SKIPPED, ActivityDiagnosticConstant.EMPTY);\n       ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n           node, reservedContainer.getContainerId(), AllocationState.SKIPPED);\n     }\n \n     assignment.setSchedulingMode(\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void allocateFromReservedContainer(FiCaSchedulerNode node,\n      boolean withNodeHeartbeat, RMContainer reservedContainer) {\n    FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n        reservedContainer.getContainerId());\n    if (reservedApplication \u003d\u003d null) {\n      LOG.error(\n          \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n              + node.getNodeID() + \" container\u003d\" + reservedContainer\n              .getContainerId());\n      return;\n    }\n\n    // Try to fulfill the reservation\n    LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n        reservedApplication.getApplicationId(), node.getNodeID());\n\n    LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n    CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n        new SimpleCandidateNodeSet\u003c\u003e(node),\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    if (assignment.isFulfilledReservation()) {\n      if (withNodeHeartbeat) {\n        // Only update SchedulerHealth in sync scheduling, existing\n        // Data structure of SchedulerHealth need to be updated for\n        // Async mode\n        updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n            assignment);\n      }\n\n      schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueueName(), queue.getQueueName(),\n          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(),\n          AllocationState.ALLOCATED_FROM_RESERVED);\n    } else{\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueueName(), queue.getQueueName(),\n          ActivityState.SKIPPED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(), AllocationState.SKIPPED);\n    }\n\n    assignment.setSchedulingMode(\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c336af3847add969303c95ea5af2fb76e0c086ab": {
      "type": "Yintroduced",
      "commitMessage": "YARN-9432. Reserved containers leak after its request has been cancelled or satisfied when multi-nodes enabled. Contributed by Tao Yang.\n",
      "commitDate": "07/05/19 6:54 PM",
      "commitName": "c336af3847add969303c95ea5af2fb76e0c086ab",
      "commitAuthor": "Weiwei Yang",
      "diff": "@@ -0,0 +1,55 @@\n+  private void allocateFromReservedContainer(FiCaSchedulerNode node,\n+      boolean withNodeHeartbeat, RMContainer reservedContainer) {\n+    FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n+        reservedContainer.getContainerId());\n+    if (reservedApplication \u003d\u003d null) {\n+      LOG.error(\n+          \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n+              + node.getNodeID() + \" container\u003d\" + reservedContainer\n+              .getContainerId());\n+      return;\n+    }\n+\n+    // Try to fulfill the reservation\n+    LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n+        reservedApplication.getApplicationId(), node.getNodeID());\n+\n+    LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n+    CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n+        new SimpleCandidateNodeSet\u003c\u003e(node),\n+        // TODO, now we only consider limits for parent for non-labeled\n+        // resources, should consider labeled resources as well.\n+        new ResourceLimits(labelManager\n+            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n+                getClusterResource())),\n+        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n+\n+    if (assignment.isFulfilledReservation()) {\n+      if (withNodeHeartbeat) {\n+        // Only update SchedulerHealth in sync scheduling, existing\n+        // Data structure of SchedulerHealth need to be updated for\n+        // Async mode\n+        updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n+            assignment);\n+      }\n+\n+      schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n+\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          queue.getParent().getQueueName(), queue.getQueueName(),\n+          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n+      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n+          node, reservedContainer.getContainerId(),\n+          AllocationState.ALLOCATED_FROM_RESERVED);\n+    } else{\n+      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n+          queue.getParent().getQueueName(), queue.getQueueName(),\n+          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n+      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n+          node, reservedContainer.getContainerId(), AllocationState.SKIPPED);\n+    }\n+\n+    assignment.setSchedulingMode(\n+        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n+    submitResourceCommitRequest(getClusterResource(), assignment);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void allocateFromReservedContainer(FiCaSchedulerNode node,\n      boolean withNodeHeartbeat, RMContainer reservedContainer) {\n    FiCaSchedulerApp reservedApplication \u003d getCurrentAttemptForContainer(\n        reservedContainer.getContainerId());\n    if (reservedApplication \u003d\u003d null) {\n      LOG.error(\n          \"Trying to schedule for a finished app, please double check. nodeId\u003d\"\n              + node.getNodeID() + \" container\u003d\" + reservedContainer\n              .getContainerId());\n      return;\n    }\n\n    // Try to fulfill the reservation\n    LOG.debug(\"Trying to fulfill reservation for application {} on node: {}\",\n        reservedApplication.getApplicationId(), node.getNodeID());\n\n    LeafQueue queue \u003d ((LeafQueue) reservedApplication.getQueue());\n    CSAssignment assignment \u003d queue.assignContainers(getClusterResource(),\n        new SimpleCandidateNodeSet\u003c\u003e(node),\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    if (assignment.isFulfilledReservation()) {\n      if (withNodeHeartbeat) {\n        // Only update SchedulerHealth in sync scheduling, existing\n        // Data structure of SchedulerHealth need to be updated for\n        // Async mode\n        updateSchedulerHealth(lastNodeUpdateTime, node.getNodeID(),\n            assignment);\n      }\n\n      schedulerHealth.updateSchedulerFulfilledReservationCounts(1);\n\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueueName(), queue.getQueueName(),\n          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(),\n          AllocationState.ALLOCATED_FROM_RESERVED);\n    } else{\n      ActivitiesLogger.QUEUE.recordQueueActivity(activitiesManager, node,\n          queue.getParent().getQueueName(), queue.getQueueName(),\n          ActivityState.ACCEPTED, ActivityDiagnosticConstant.EMPTY);\n      ActivitiesLogger.NODE.finishAllocatedNodeAllocation(activitiesManager,\n          node, reservedContainer.getContainerId(), AllocationState.SKIPPED);\n    }\n\n    assignment.setSchedulingMode(\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}