{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ClientRMService.java",
  "functionName": "getApplications",
  "functionId": "getApplications___request-GetApplicationsRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
  "functionStartLine": 875,
  "functionEndLine": 988,
  "numCommitsSeen": 179,
  "timeTaken": 12644,
  "changeHistory": [
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
    "7c13872cbbb6f1b0b1c2dde894885b41186b3797",
    "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
    "c05b5d424b000bab766f57e88a07f2b4e9a56647",
    "921338cd86e7215b0c4b1efdf2daf9449fb12c7b",
    "5324388cf2357b1f80efd0c34392f577bf417455",
    "312b1fd9da2781da97f8c76fe1262c4d99b9c37f",
    "72c6d6255a86225ae1771fcc15e46aff7a4cc384",
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
    "ec010a29362c6c5572f8681f4e7d0469176345e1",
    "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
    "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "fab57a144de0cd515e1de9107e4d3ac58037d846",
    "df2991c0cbc3f35c2640b93680667507c4f810dd",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": "Ybodychange",
    "7c13872cbbb6f1b0b1c2dde894885b41186b3797": "Ybodychange",
    "652bcbb3e4950758e61ce123ecc1798ae2b60a7f": "Ybodychange",
    "c05b5d424b000bab766f57e88a07f2b4e9a56647": "Ybodychange",
    "921338cd86e7215b0c4b1efdf2daf9449fb12c7b": "Ybodychange",
    "5324388cf2357b1f80efd0c34392f577bf417455": "Ybodychange",
    "312b1fd9da2781da97f8c76fe1262c4d99b9c37f": "Ybodychange",
    "72c6d6255a86225ae1771fcc15e46aff7a4cc384": "Ybodychange",
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889": "Ybodychange",
    "ec010a29362c6c5572f8681f4e7d0469176345e1": "Ybodychange",
    "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732": "Ybodychange",
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68": "Ybodychange",
    "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "fab57a144de0cd515e1de9107e4d3ac58037d846": "Ybodychange",
    "df2991c0cbc3f35c2640b93680667507c4f810dd": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
      "commitDate": "06/01/20 7:26 AM",
      "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "23/09/19 1:12 PM",
      "commitNameOld": "3d78b1223d3fdc29d500803cefd2931b54f44928",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 104.8,
      "commitsBetweenForRepo": 455,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,114 @@\n   public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n       throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n     Set\u003cString\u003e users \u003d request.getUsers();\n     Set\u003cString\u003e queues \u003d request.getQueues();\n     Set\u003cString\u003e tags \u003d request.getApplicationTags();\n     long limit \u003d request.getLimit();\n     Range\u003cLong\u003e start \u003d request.getStartRange();\n     Range\u003cLong\u003e finish \u003d request.getFinishRange();\n     ApplicationsRequestScope scope \u003d request.getScope();\n+    String name \u003d request.getName();\n \n     final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n     Iterator\u003cRMApp\u003e appsIter \u003d apps.values().iterator();\n     \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n       RMApp application \u003d appsIter.next();\n \n       // Check if current application falls under the specified scope\n       if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n           !callerUGI.getUserName().equals(application.getUser())) {\n         continue;\n       }\n \n       if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n         if (!queues.contains(application.getQueue())) {\n           continue;\n         }\n       }\n \n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         String appTypeToMatch \u003d\n             StringUtils.toLowerCase(application.getApplicationType());\n         if (!applicationTypes.contains(appTypeToMatch)) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n \n       if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n           !users.contains(application.getUser())) {\n         continue;\n       }\n \n       if (start !\u003d null \u0026\u0026 !start.contains(application.getStartTime())) {\n         continue;\n       }\n \n       if (finish !\u003d null \u0026\u0026 !finish.contains(application.getFinishTime())) {\n         continue;\n       }\n \n       if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n         Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n         if (appTags \u003d\u003d null || appTags.isEmpty()) {\n           continue;\n         }\n         boolean match \u003d false;\n         for (String tag : tags) {\n           if (appTags.contains(tag)) {\n             match \u003d true;\n             break;\n           }\n         }\n         if (!match) {\n           continue;\n         }\n       }\n \n       // checkAccess can grab the scheduler lock so call it last\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application);\n       if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n+      if (name !\u003d null \u0026\u0026 !name.equals(application.getName())) {\n+        continue;\n+      }\n+\n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getUserName(),\n         AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    Range\u003cLong\u003e start \u003d request.getStartRange();\n    Range\u003cLong\u003e finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n    String name \u003d request.getName();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter \u003d apps.values().iterator();\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n        if (!queues.contains(application.getQueue())) {\n          continue;\n        }\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.contains(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.contains(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      if (name !\u003d null \u0026\u0026 !name.equals(application.getName())) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getUserName(),\n        AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "7c13872cbbb6f1b0b1c2dde894885b41186b3797": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8659. RMWebServices returns only RUNNING apps when filtered with queue. (Contributed by Szilard Nemeth)\n",
      "commitDate": "08/10/18 9:40 AM",
      "commitName": "7c13872cbbb6f1b0b1c2dde894885b41186b3797",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 26.26,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,109 @@\n   public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n       throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n     Set\u003cString\u003e users \u003d request.getUsers();\n     Set\u003cString\u003e queues \u003d request.getQueues();\n     Set\u003cString\u003e tags \u003d request.getApplicationTags();\n     long limit \u003d request.getLimit();\n     Range\u003cLong\u003e start \u003d request.getStartRange();\n     Range\u003cLong\u003e finish \u003d request.getFinishRange();\n     ApplicationsRequestScope scope \u003d request.getScope();\n \n     final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n-    Iterator\u003cRMApp\u003e appsIter;\n-    // If the query filters by queues, we can avoid considering apps outside\n-    // of those queues by asking the scheduler for the apps in those queues.\n-    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n-      // Construct an iterator over apps in given queues\n-      // Collect list of lists to avoid copying all apps\n-      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n-          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n-      for (String queue : queues) {\n-        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n-        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n-          queueAppLists.add(appsInQueue);\n-        }\n-      }\n-      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n-        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n-        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n-\n-        @Override\n-        public boolean hasNext() {\n-          // Because queueAppLists has no empty lists, hasNext is whether the\n-          // current list hasNext or whether there are any remaining lists\n-          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n-              || appListIter.hasNext();\n-        }\n-        @Override\n-        public RMApp next() {\n-          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n-            schedAppsIter \u003d appListIter.next().iterator();\n-          }\n-          return apps.get(schedAppsIter.next().getApplicationId());\n-        }\n-        @Override\n-        public void remove() {\n-          throw new UnsupportedOperationException(\"Remove not supported\");\n-        }\n-      };\n-    } else {\n-      appsIter \u003d apps.values().iterator();\n-    }\n+    Iterator\u003cRMApp\u003e appsIter \u003d apps.values().iterator();\n     \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n       RMApp application \u003d appsIter.next();\n \n       // Check if current application falls under the specified scope\n       if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n           !callerUGI.getUserName().equals(application.getUser())) {\n         continue;\n       }\n \n+      if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n+        if (!queues.contains(application.getQueue())) {\n+          continue;\n+        }\n+      }\n+\n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         String appTypeToMatch \u003d\n             StringUtils.toLowerCase(application.getApplicationType());\n         if (!applicationTypes.contains(appTypeToMatch)) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n \n       if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n           !users.contains(application.getUser())) {\n         continue;\n       }\n \n       if (start !\u003d null \u0026\u0026 !start.contains(application.getStartTime())) {\n         continue;\n       }\n \n       if (finish !\u003d null \u0026\u0026 !finish.contains(application.getFinishTime())) {\n         continue;\n       }\n \n       if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n         Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n         if (appTags \u003d\u003d null || appTags.isEmpty()) {\n           continue;\n         }\n         boolean match \u003d false;\n         for (String tag : tags) {\n           if (appTags.contains(tag)) {\n             match \u003d true;\n             break;\n           }\n         }\n         if (!match) {\n           continue;\n         }\n       }\n \n       // checkAccess can grab the scheduler lock so call it last\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application);\n       if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getUserName(),\n         AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    Range\u003cLong\u003e start \u003d request.getStartRange();\n    Range\u003cLong\u003e finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter \u003d apps.values().iterator();\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n        if (!queues.contains(application.getQueue())) {\n          continue;\n        }\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.contains(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.contains(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getUserName(),\n        AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "652bcbb3e4950758e61ce123ecc1798ae2b60a7f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8363. Upgrade commons-lang version to 3.7 in hadoop-yarn-project. Contributed by Takanobu Asanuma.\n",
      "commitDate": "12/06/18 8:35 AM",
      "commitName": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "24/05/18 1:49 AM",
      "commitNameOld": "c05b5d424b000bab766f57e88a07f2b4e9a56647",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 19.28,
      "commitsBetweenForRepo": 144,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,142 @@\n   public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n       throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n     Set\u003cString\u003e users \u003d request.getUsers();\n     Set\u003cString\u003e queues \u003d request.getQueues();\n     Set\u003cString\u003e tags \u003d request.getApplicationTags();\n     long limit \u003d request.getLimit();\n-    LongRange start \u003d request.getStartRange();\n-    LongRange finish \u003d request.getFinishRange();\n+    Range\u003cLong\u003e start \u003d request.getStartRange();\n+    Range\u003cLong\u003e finish \u003d request.getFinishRange();\n     ApplicationsRequestScope scope \u003d request.getScope();\n \n     final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n     Iterator\u003cRMApp\u003e appsIter;\n     // If the query filters by queues, we can avoid considering apps outside\n     // of those queues by asking the scheduler for the apps in those queues.\n     if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n       // Construct an iterator over apps in given queues\n       // Collect list of lists to avoid copying all apps\n       final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n           new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n       for (String queue : queues) {\n         List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n         if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n           queueAppLists.add(appsInQueue);\n         }\n       }\n       appsIter \u003d new Iterator\u003cRMApp\u003e() {\n         Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n         Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n \n         @Override\n         public boolean hasNext() {\n           // Because queueAppLists has no empty lists, hasNext is whether the\n           // current list hasNext or whether there are any remaining lists\n           return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n               || appListIter.hasNext();\n         }\n         @Override\n         public RMApp next() {\n           if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n             schedAppsIter \u003d appListIter.next().iterator();\n           }\n           return apps.get(schedAppsIter.next().getApplicationId());\n         }\n         @Override\n         public void remove() {\n           throw new UnsupportedOperationException(\"Remove not supported\");\n         }\n       };\n     } else {\n       appsIter \u003d apps.values().iterator();\n     }\n     \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n       RMApp application \u003d appsIter.next();\n \n       // Check if current application falls under the specified scope\n       if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n           !callerUGI.getUserName().equals(application.getUser())) {\n         continue;\n       }\n \n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         String appTypeToMatch \u003d\n             StringUtils.toLowerCase(application.getApplicationType());\n         if (!applicationTypes.contains(appTypeToMatch)) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n \n       if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n           !users.contains(application.getUser())) {\n         continue;\n       }\n \n-      if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n+      if (start !\u003d null \u0026\u0026 !start.contains(application.getStartTime())) {\n         continue;\n       }\n \n-      if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n+      if (finish !\u003d null \u0026\u0026 !finish.contains(application.getFinishTime())) {\n         continue;\n       }\n \n       if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n         Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n         if (appTags \u003d\u003d null || appTags.isEmpty()) {\n           continue;\n         }\n         boolean match \u003d false;\n         for (String tag : tags) {\n           if (appTags.contains(tag)) {\n             match \u003d true;\n             break;\n           }\n         }\n         if (!match) {\n           continue;\n         }\n       }\n \n       // checkAccess can grab the scheduler lock so call it last\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application);\n       if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getUserName(),\n         AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    Range\u003cLong\u003e start \u003d request.getStartRange();\n    Range\u003cLong\u003e finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter;\n    // If the query filters by queues, we can avoid considering apps outside\n    // of those queues by asking the scheduler for the apps in those queues.\n    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n      // Construct an iterator over apps in given queues\n      // Collect list of lists to avoid copying all apps\n      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n      for (String queue : queues) {\n        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n          queueAppLists.add(appsInQueue);\n        }\n      }\n      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n\n        @Override\n        public boolean hasNext() {\n          // Because queueAppLists has no empty lists, hasNext is whether the\n          // current list hasNext or whether there are any remaining lists\n          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n              || appListIter.hasNext();\n        }\n        @Override\n        public RMApp next() {\n          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n            schedAppsIter \u003d appListIter.next().iterator();\n          }\n          return apps.get(schedAppsIter.next().getApplicationId());\n        }\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException(\"Remove not supported\");\n        }\n      };\n    } else {\n      appsIter \u003d apps.values().iterator();\n    }\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.contains(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.contains(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getUserName(),\n        AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "c05b5d424b000bab766f57e88a07f2b4e9a56647": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8319. More YARN pages need to honor yarn.resourcemanager.display.per-user-apps. Contributed by Sunil G.\n",
      "commitDate": "24/05/18 1:49 AM",
      "commitName": "c05b5d424b000bab766f57e88a07f2b4e9a56647",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "09/05/18 8:45 PM",
      "commitNameOld": "cc0310a5266c8b8351f338f5fc8087a203c68cac",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 14.21,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,142 @@\n   public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n       throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n     Set\u003cString\u003e users \u003d request.getUsers();\n     Set\u003cString\u003e queues \u003d request.getQueues();\n     Set\u003cString\u003e tags \u003d request.getApplicationTags();\n     long limit \u003d request.getLimit();\n     LongRange start \u003d request.getStartRange();\n     LongRange finish \u003d request.getFinishRange();\n     ApplicationsRequestScope scope \u003d request.getScope();\n \n     final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n     Iterator\u003cRMApp\u003e appsIter;\n     // If the query filters by queues, we can avoid considering apps outside\n     // of those queues by asking the scheduler for the apps in those queues.\n     if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n       // Construct an iterator over apps in given queues\n       // Collect list of lists to avoid copying all apps\n       final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n           new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n       for (String queue : queues) {\n         List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n         if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n           queueAppLists.add(appsInQueue);\n         }\n       }\n       appsIter \u003d new Iterator\u003cRMApp\u003e() {\n         Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n         Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n \n         @Override\n         public boolean hasNext() {\n           // Because queueAppLists has no empty lists, hasNext is whether the\n           // current list hasNext or whether there are any remaining lists\n           return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n               || appListIter.hasNext();\n         }\n         @Override\n         public RMApp next() {\n           if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n             schedAppsIter \u003d appListIter.next().iterator();\n           }\n           return apps.get(schedAppsIter.next().getApplicationId());\n         }\n         @Override\n         public void remove() {\n           throw new UnsupportedOperationException(\"Remove not supported\");\n         }\n       };\n     } else {\n       appsIter \u003d apps.values().iterator();\n     }\n     \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n       RMApp application \u003d appsIter.next();\n \n       // Check if current application falls under the specified scope\n       if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n           !callerUGI.getUserName().equals(application.getUser())) {\n         continue;\n       }\n \n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         String appTypeToMatch \u003d\n             StringUtils.toLowerCase(application.getApplicationType());\n         if (!applicationTypes.contains(appTypeToMatch)) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n \n       if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n           !users.contains(application.getUser())) {\n         continue;\n       }\n \n       if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n         continue;\n       }\n \n       if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n         continue;\n       }\n \n       if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n         Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n         if (appTags \u003d\u003d null || appTags.isEmpty()) {\n           continue;\n         }\n         boolean match \u003d false;\n         for (String tag : tags) {\n           if (appTags.contains(tag)) {\n             match \u003d true;\n             break;\n           }\n         }\n         if (!match) {\n           continue;\n         }\n       }\n \n       // checkAccess can grab the scheduler lock so call it last\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application);\n       if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n-      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n+      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getUserName(),\n         AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    LongRange start \u003d request.getStartRange();\n    LongRange finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter;\n    // If the query filters by queues, we can avoid considering apps outside\n    // of those queues by asking the scheduler for the apps in those queues.\n    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n      // Construct an iterator over apps in given queues\n      // Collect list of lists to avoid copying all apps\n      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n      for (String queue : queues) {\n        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n          queueAppLists.add(appsInQueue);\n        }\n      }\n      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n\n        @Override\n        public boolean hasNext() {\n          // Because queueAppLists has no empty lists, hasNext is whether the\n          // current list hasNext or whether there are any remaining lists\n          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n              || appListIter.hasNext();\n        }\n        @Override\n        public RMApp next() {\n          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n            schedAppsIter \u003d appListIter.next().iterator();\n          }\n          return apps.get(schedAppsIter.next().getApplicationId());\n        }\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException(\"Remove not supported\");\n        }\n      };\n    } else {\n      appsIter \u003d apps.values().iterator();\n    }\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getUserName(),\n        AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "921338cd86e7215b0c4b1efdf2daf9449fb12c7b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4163: Audit getQueueInfo and getApplications calls\n",
      "commitDate": "23/10/17 9:43 AM",
      "commitName": "921338cd86e7215b0c4b1efdf2daf9449fb12c7b",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "13/09/17 11:06 AM",
      "commitNameOld": "5324388cf2357b1f80efd0c34392f577bf417455",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 39.94,
      "commitsBetweenForRepo": 304,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,142 @@\n   public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n       throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n     Set\u003cString\u003e users \u003d request.getUsers();\n     Set\u003cString\u003e queues \u003d request.getQueues();\n     Set\u003cString\u003e tags \u003d request.getApplicationTags();\n     long limit \u003d request.getLimit();\n     LongRange start \u003d request.getStartRange();\n     LongRange finish \u003d request.getFinishRange();\n     ApplicationsRequestScope scope \u003d request.getScope();\n \n     final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n     Iterator\u003cRMApp\u003e appsIter;\n     // If the query filters by queues, we can avoid considering apps outside\n     // of those queues by asking the scheduler for the apps in those queues.\n     if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n       // Construct an iterator over apps in given queues\n       // Collect list of lists to avoid copying all apps\n       final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n           new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n       for (String queue : queues) {\n         List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n         if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n           queueAppLists.add(appsInQueue);\n         }\n       }\n       appsIter \u003d new Iterator\u003cRMApp\u003e() {\n         Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n         Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n \n         @Override\n         public boolean hasNext() {\n           // Because queueAppLists has no empty lists, hasNext is whether the\n           // current list hasNext or whether there are any remaining lists\n           return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n               || appListIter.hasNext();\n         }\n         @Override\n         public RMApp next() {\n           if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n             schedAppsIter \u003d appListIter.next().iterator();\n           }\n           return apps.get(schedAppsIter.next().getApplicationId());\n         }\n         @Override\n         public void remove() {\n           throw new UnsupportedOperationException(\"Remove not supported\");\n         }\n       };\n     } else {\n       appsIter \u003d apps.values().iterator();\n     }\n     \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n       RMApp application \u003d appsIter.next();\n \n       // Check if current application falls under the specified scope\n       if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n           !callerUGI.getUserName().equals(application.getUser())) {\n         continue;\n       }\n \n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         String appTypeToMatch \u003d\n             StringUtils.toLowerCase(application.getApplicationType());\n         if (!applicationTypes.contains(appTypeToMatch)) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n \n       if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n           !users.contains(application.getUser())) {\n         continue;\n       }\n \n       if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n         continue;\n       }\n \n       if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n         continue;\n       }\n \n       if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n         Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n         if (appTags \u003d\u003d null || appTags.isEmpty()) {\n           continue;\n         }\n         boolean match \u003d false;\n         for (String tag : tags) {\n           if (appTags.contains(tag)) {\n             match \u003d true;\n             break;\n           }\n         }\n         if (!match) {\n           continue;\n         }\n       }\n \n       // checkAccess can grab the scheduler lock so call it last\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application);\n       if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (displayPerUserApps \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n+    RMAuditLogger.logSuccess(callerUGI.getUserName(),\n+        AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    LongRange start \u003d request.getStartRange();\n    LongRange finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter;\n    // If the query filters by queues, we can avoid considering apps outside\n    // of those queues by asking the scheduler for the apps in those queues.\n    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n      // Construct an iterator over apps in given queues\n      // Collect list of lists to avoid copying all apps\n      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n      for (String queue : queues) {\n        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n          queueAppLists.add(appsInQueue);\n        }\n      }\n      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n\n        @Override\n        public boolean hasNext() {\n          // Because queueAppLists has no empty lists, hasNext is whether the\n          // current list hasNext or whether there are any remaining lists\n          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n              || appListIter.hasNext();\n        }\n        @Override\n        public RMApp next() {\n          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n            schedAppsIter \u003d appListIter.next().iterator();\n          }\n          return apps.get(schedAppsIter.next().getApplicationId());\n        }\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException(\"Remove not supported\");\n        }\n      };\n    } else {\n      appsIter \u003d apps.values().iterator();\n    }\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getUserName(),\n        AuditConstants.GET_APPLICATIONS_REQUEST, \"ClientRMService\");\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "5324388cf2357b1f80efd0c34392f577bf417455": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7157. Add admin configuration to filter per-user\u0027s apps in secure cluster. Contributed by Sunil G.\n",
      "commitDate": "13/09/17 11:06 AM",
      "commitName": "5324388cf2357b1f80efd0c34392f577bf417455",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "39240b61a163b127eec385decd30ffd96e694c28",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 1.07,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,140 @@\n   public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n       throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n     Set\u003cString\u003e users \u003d request.getUsers();\n     Set\u003cString\u003e queues \u003d request.getQueues();\n     Set\u003cString\u003e tags \u003d request.getApplicationTags();\n     long limit \u003d request.getLimit();\n     LongRange start \u003d request.getStartRange();\n     LongRange finish \u003d request.getFinishRange();\n     ApplicationsRequestScope scope \u003d request.getScope();\n \n     final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n     Iterator\u003cRMApp\u003e appsIter;\n     // If the query filters by queues, we can avoid considering apps outside\n     // of those queues by asking the scheduler for the apps in those queues.\n     if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n       // Construct an iterator over apps in given queues\n       // Collect list of lists to avoid copying all apps\n       final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n           new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n       for (String queue : queues) {\n         List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n         if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n           queueAppLists.add(appsInQueue);\n         }\n       }\n       appsIter \u003d new Iterator\u003cRMApp\u003e() {\n         Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n         Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n \n         @Override\n         public boolean hasNext() {\n           // Because queueAppLists has no empty lists, hasNext is whether the\n           // current list hasNext or whether there are any remaining lists\n           return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n               || appListIter.hasNext();\n         }\n         @Override\n         public RMApp next() {\n           if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n             schedAppsIter \u003d appListIter.next().iterator();\n           }\n           return apps.get(schedAppsIter.next().getApplicationId());\n         }\n         @Override\n         public void remove() {\n           throw new UnsupportedOperationException(\"Remove not supported\");\n         }\n       };\n     } else {\n       appsIter \u003d apps.values().iterator();\n     }\n     \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n       RMApp application \u003d appsIter.next();\n \n       // Check if current application falls under the specified scope\n       if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n           !callerUGI.getUserName().equals(application.getUser())) {\n         continue;\n       }\n \n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         String appTypeToMatch \u003d\n             StringUtils.toLowerCase(application.getApplicationType());\n         if (!applicationTypes.contains(appTypeToMatch)) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n \n       if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n           !users.contains(application.getUser())) {\n         continue;\n       }\n \n       if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n         continue;\n       }\n \n       if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n         continue;\n       }\n \n       if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n         Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n         if (appTags \u003d\u003d null || appTags.isEmpty()) {\n           continue;\n         }\n         boolean match \u003d false;\n         for (String tag : tags) {\n           if (appTags.contains(tag)) {\n             match \u003d true;\n             break;\n           }\n         }\n         if (!match) {\n           continue;\n         }\n       }\n \n       // checkAccess can grab the scheduler lock so call it last\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application);\n       if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n+      // Given RM is configured to display apps per user, skip apps to which\n+      // this caller doesn\u0027t have access to view.\n+      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n+        continue;\n+      }\n+\n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    LongRange start \u003d request.getStartRange();\n    LongRange finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter;\n    // If the query filters by queues, we can avoid considering apps outside\n    // of those queues by asking the scheduler for the apps in those queues.\n    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n      // Construct an iterator over apps in given queues\n      // Collect list of lists to avoid copying all apps\n      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n      for (String queue : queues) {\n        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n          queueAppLists.add(appsInQueue);\n        }\n      }\n      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n\n        @Override\n        public boolean hasNext() {\n          // Because queueAppLists has no empty lists, hasNext is whether the\n          // current list hasNext or whether there are any remaining lists\n          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n              || appListIter.hasNext();\n        }\n        @Override\n        public RMApp next() {\n          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n            schedAppsIter \u003d appListIter.next().iterator();\n          }\n          return apps.get(schedAppsIter.next().getApplicationId());\n        }\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException(\"Remove not supported\");\n        }\n      };\n    } else {\n      appsIter \u003d apps.values().iterator();\n    }\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "312b1fd9da2781da97f8c76fe1262c4d99b9c37f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7076. yarn application -list -appTypes is not working. Contributed by Jian He.\n",
      "commitDate": "28/08/17 6:26 PM",
      "commitName": "312b1fd9da2781da97f8c76fe1262c4d99b9c37f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "26/03/17 7:23 PM",
      "commitNameOld": "b63ae854f9f5a900ca860dcb26c30785af32bde0",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 154.96,
      "commitsBetweenForRepo": 882,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,134 @@\n-  public GetApplicationsResponse getApplications(\n-      GetApplicationsRequest request) throws YarnException {\n-    return getApplications(request, true);\n+  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n+      throws YarnException {\n+    UserGroupInformation callerUGI;\n+    try {\n+      callerUGI \u003d UserGroupInformation.getCurrentUser();\n+    } catch (IOException ie) {\n+      LOG.info(\"Error getting UGI \", ie);\n+      throw RPCUtil.getRemoteException(ie);\n+    }\n+\n+    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n+    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n+        request.getApplicationStates();\n+    Set\u003cString\u003e users \u003d request.getUsers();\n+    Set\u003cString\u003e queues \u003d request.getQueues();\n+    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n+    long limit \u003d request.getLimit();\n+    LongRange start \u003d request.getStartRange();\n+    LongRange finish \u003d request.getFinishRange();\n+    ApplicationsRequestScope scope \u003d request.getScope();\n+\n+    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n+    Iterator\u003cRMApp\u003e appsIter;\n+    // If the query filters by queues, we can avoid considering apps outside\n+    // of those queues by asking the scheduler for the apps in those queues.\n+    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n+      // Construct an iterator over apps in given queues\n+      // Collect list of lists to avoid copying all apps\n+      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n+          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n+      for (String queue : queues) {\n+        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n+        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n+          queueAppLists.add(appsInQueue);\n+        }\n+      }\n+      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n+        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n+        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n+\n+        @Override\n+        public boolean hasNext() {\n+          // Because queueAppLists has no empty lists, hasNext is whether the\n+          // current list hasNext or whether there are any remaining lists\n+          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n+              || appListIter.hasNext();\n+        }\n+        @Override\n+        public RMApp next() {\n+          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n+            schedAppsIter \u003d appListIter.next().iterator();\n+          }\n+          return apps.get(schedAppsIter.next().getApplicationId());\n+        }\n+        @Override\n+        public void remove() {\n+          throw new UnsupportedOperationException(\"Remove not supported\");\n+        }\n+      };\n+    } else {\n+      appsIter \u003d apps.values().iterator();\n+    }\n+    \n+    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n+    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n+      RMApp application \u003d appsIter.next();\n+\n+      // Check if current application falls under the specified scope\n+      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n+          !callerUGI.getUserName().equals(application.getUser())) {\n+        continue;\n+      }\n+\n+      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n+        String appTypeToMatch \u003d\n+            StringUtils.toLowerCase(application.getApplicationType());\n+        if (!applicationTypes.contains(appTypeToMatch)) {\n+          continue;\n+        }\n+      }\n+\n+      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n+        if (!applicationStates.contains(application\n+            .createApplicationState())) {\n+          continue;\n+        }\n+      }\n+\n+      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n+          !users.contains(application.getUser())) {\n+        continue;\n+      }\n+\n+      if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n+        continue;\n+      }\n+\n+      if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n+        continue;\n+      }\n+\n+      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n+        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n+        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n+          continue;\n+        }\n+        boolean match \u003d false;\n+        for (String tag : tags) {\n+          if (appTags.contains(tag)) {\n+            match \u003d true;\n+            break;\n+          }\n+        }\n+        if (!match) {\n+          continue;\n+        }\n+      }\n+\n+      // checkAccess can grab the scheduler lock so call it last\n+      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n+          ApplicationAccessType.VIEW_APP, application);\n+      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n+        continue;\n+      }\n+\n+      reports.add(application.createAndGetApplicationReport(\n+          callerUGI.getUserName(), allowAccess));\n+    }\n+\n+    GetApplicationsResponse response \u003d\n+      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n+    response.setApplicationList(reports);\n+    return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(GetApplicationsRequest request)\n      throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d getLowerCasedAppTypes(request);\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n    Set\u003cString\u003e users \u003d request.getUsers();\n    Set\u003cString\u003e queues \u003d request.getQueues();\n    Set\u003cString\u003e tags \u003d request.getApplicationTags();\n    long limit \u003d request.getLimit();\n    LongRange start \u003d request.getStartRange();\n    LongRange finish \u003d request.getFinishRange();\n    ApplicationsRequestScope scope \u003d request.getScope();\n\n    final Map\u003cApplicationId, RMApp\u003e apps \u003d rmContext.getRMApps();\n    Iterator\u003cRMApp\u003e appsIter;\n    // If the query filters by queues, we can avoid considering apps outside\n    // of those queues by asking the scheduler for the apps in those queues.\n    if (queues !\u003d null \u0026\u0026 !queues.isEmpty()) {\n      // Construct an iterator over apps in given queues\n      // Collect list of lists to avoid copying all apps\n      final List\u003cList\u003cApplicationAttemptId\u003e\u003e queueAppLists \u003d\n          new ArrayList\u003cList\u003cApplicationAttemptId\u003e\u003e();\n      for (String queue : queues) {\n        List\u003cApplicationAttemptId\u003e appsInQueue \u003d scheduler.getAppsInQueue(queue);\n        if (appsInQueue !\u003d null \u0026\u0026 !appsInQueue.isEmpty()) {\n          queueAppLists.add(appsInQueue);\n        }\n      }\n      appsIter \u003d new Iterator\u003cRMApp\u003e() {\n        Iterator\u003cList\u003cApplicationAttemptId\u003e\u003e appListIter \u003d queueAppLists.iterator();\n        Iterator\u003cApplicationAttemptId\u003e schedAppsIter;\n\n        @Override\n        public boolean hasNext() {\n          // Because queueAppLists has no empty lists, hasNext is whether the\n          // current list hasNext or whether there are any remaining lists\n          return (schedAppsIter !\u003d null \u0026\u0026 schedAppsIter.hasNext())\n              || appListIter.hasNext();\n        }\n        @Override\n        public RMApp next() {\n          if (schedAppsIter \u003d\u003d null || !schedAppsIter.hasNext()) {\n            schedAppsIter \u003d appListIter.next().iterator();\n          }\n          return apps.get(schedAppsIter.next().getApplicationId());\n        }\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException(\"Remove not supported\");\n        }\n      };\n    } else {\n      appsIter \u003d apps.values().iterator();\n    }\n    \n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    while (appsIter.hasNext() \u0026\u0026 reports.size() \u003c limit) {\n      RMApp application \u003d appsIter.next();\n\n      // Check if current application falls under the specified scope\n      if (scope \u003d\u003d ApplicationsRequestScope.OWN \u0026\u0026\n          !callerUGI.getUserName().equals(application.getUser())) {\n        continue;\n      }\n\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        String appTypeToMatch \u003d\n            StringUtils.toLowerCase(application.getApplicationType());\n        if (!applicationTypes.contains(appTypeToMatch)) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n\n      if (users !\u003d null \u0026\u0026 !users.isEmpty() \u0026\u0026\n          !users.contains(application.getUser())) {\n        continue;\n      }\n\n      if (start !\u003d null \u0026\u0026 !start.containsLong(application.getStartTime())) {\n        continue;\n      }\n\n      if (finish !\u003d null \u0026\u0026 !finish.containsLong(application.getFinishTime())) {\n        continue;\n      }\n\n      if (tags !\u003d null \u0026\u0026 !tags.isEmpty()) {\n        Set\u003cString\u003e appTags \u003d application.getApplicationTags();\n        if (appTags \u003d\u003d null || appTags.isEmpty()) {\n          continue;\n        }\n        boolean match \u003d false;\n        for (String tag : tags) {\n          if (appTags.contains(tag)) {\n            match \u003d true;\n            break;\n          }\n        }\n        if (!match) {\n          continue;\n        }\n      }\n\n      // checkAccess can grab the scheduler lock so call it last\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      if (scope \u003d\u003d ApplicationsRequestScope.VIEWABLE \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "72c6d6255a86225ae1771fcc15e46aff7a4cc384": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1387. RMWebServices should use ClientRMService for filtering applications (Karthik Kambatla via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1540851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/11/13 1:49 PM",
      "commitName": "72c6d6255a86225ae1771fcc15e46aff7a4cc384",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/09/13 1:21 AM",
      "commitNameOld": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 43.56,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,4 @@\n   public GetApplicationsResponse getApplications(\n       GetApplicationsRequest request) throws YarnException {\n-    UserGroupInformation callerUGI;\n-    try {\n-      callerUGI \u003d UserGroupInformation.getCurrentUser();\n-    } catch (IOException ie) {\n-      LOG.info(\"Error getting UGI \", ie);\n-      throw RPCUtil.getRemoteException(ie);\n-    }\n-\n-    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n-    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n-        request.getApplicationStates();\n-\n-    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n-    for (RMApp application : this.rmContext.getRMApps().values()) {\n-      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n-        if (!applicationTypes.contains(application.getApplicationType())) {\n-          continue;\n-        }\n-      }\n-\n-      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n-        if (!applicationStates.contains(application\n-            .createApplicationState())) {\n-          continue;\n-        }\n-      }\n-      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n-          ApplicationAccessType.VIEW_APP, application);\n-      reports.add(application.createAndGetApplicationReport(\n-          callerUGI.getUserName(), allowAccess));\n-    }\n-\n-    GetApplicationsResponse response \u003d\n-      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n-    response.setApplicationList(reports);\n-    return response;\n+    return getApplications(request, true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n    return getApplications(request, true);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889": {
      "type": "Ybodychange",
      "commitMessage": "YARN-899. Added back queue level administrator-acls so that there is no regression w.r.t 1.x. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527282 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/09/13 1:21 AM",
      "commitName": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/09/13 11:33 AM",
      "commitNameOld": "ead3dcc3dea0d5b6d3248c1e1a6300f0714a8456",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 12.57,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public GetApplicationsResponse getApplications(\n       GetApplicationsRequest request) throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         if (!applicationTypes.contains(application.getApplicationType())) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(application\n             .createApplicationState())) {\n           continue;\n         }\n       }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n-          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n+          ApplicationAccessType.VIEW_APP, application);\n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        if (!applicationTypes.contains(application.getApplicationType())) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application);\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "ec010a29362c6c5572f8681f4e7d0469176345e1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-540. Race condition causing RM to potentially relaunch already unregistered AMs on RM restart (Jian He via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523376 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/13 6:01 PM",
      "commitName": "ec010a29362c6c5572f8681f4e7d0469176345e1",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "06/09/13 10:43 PM",
      "commitNameOld": "f35983b8056b7bd9ac4685acabef53f4dd0e355e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.8,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public GetApplicationsResponse getApplications(\n       GetApplicationsRequest request) throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         if (!applicationTypes.contains(application.getApplicationType())) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n-        if (!applicationStates.contains(RMServerUtils\n-            .createApplicationState(application.getState()))) {\n+        if (!applicationStates.contains(application\n+            .createApplicationState())) {\n           continue;\n         }\n       }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(\n           callerUGI.getUserName(), allowAccess));\n     }\n \n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        if (!applicationTypes.contains(application.getApplicationType())) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(application\n            .createApplicationState())) {\n          continue;\n        }\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732": {
      "type": "Ybodychange",
      "commitMessage": "YARN-707. Added user information also in the YARN ClientToken so that AMs can implement authorization based on incoming users. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518868 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/08/13 6:12 PM",
      "commitName": "89fb4d8ffd32b06db42cc3e21d2a89e99deb7732",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/13 2:16 PM",
      "commitNameOld": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.16,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   public GetApplicationsResponse getApplications(\n       GetApplicationsRequest request) throws YarnException {\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n     EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n         request.getApplicationStates();\n \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n       if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n         if (!applicationTypes.contains(application.getApplicationType())) {\n           continue;\n         }\n       }\n \n       if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n         if (!applicationStates.contains(RMServerUtils\n             .createApplicationState(application.getState()))) {\n           continue;\n         }\n       }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n-      reports.add(application.createAndGetApplicationReport(allowAccess));\n+      reports.add(application.createAndGetApplicationReport(\n+          callerUGI.getUserName(), allowAccess));\n     }\n \n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        if (!applicationTypes.contains(application.getApplicationType())) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(RMServerUtils\n            .createApplicationState(application.getState()))) {\n          continue;\n        }\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(\n          callerUGI.getUserName(), allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1074. Cleaned up YARN CLI application list to only display running applications by default. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1517196 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/13 2:16 PM",
      "commitName": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/08/13 4:00 PM",
      "commitNameOld": "1ad3fe46332586cea73c47ba06342f91359db561",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.93,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,38 @@\n   public GetApplicationsResponse getApplications(\n       GetApplicationsRequest request) throws YarnException {\n-\n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n-    boolean bypassFilter \u003d applicationTypes.isEmpty();\n+    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n+        request.getApplicationStates();\n+\n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n-      if (!(bypassFilter || applicationTypes.contains(application\n-          .getApplicationType()))) {\n-        continue;\n+      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n+        if (!applicationTypes.contains(application.getApplicationType())) {\n+          continue;\n+        }\n+      }\n+\n+      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n+        if (!applicationStates.contains(RMServerUtils\n+            .createApplicationState(application.getState()))) {\n+          continue;\n+        }\n       }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n     GetApplicationsResponse response \u003d\n       recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    EnumSet\u003cYarnApplicationState\u003e applicationStates \u003d\n        request.getApplicationStates();\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (applicationTypes !\u003d null \u0026\u0026 !applicationTypes.isEmpty()) {\n        if (!applicationTypes.contains(application.getApplicationType())) {\n          continue;\n        }\n      }\n\n      if (applicationStates !\u003d null \u0026\u0026 !applicationStates.isEmpty()) {\n        if (!applicationStates.contains(RMServerUtils\n            .createApplicationState(application.getState()))) {\n          continue;\n        }\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-727, MAPREDUCE-5325. ClientRMProtocol.getAllApplications should accept ApplicationType as a parameter. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501599 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/13 4:01 PM",
      "commitName": "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
      "commitAuthor": "Hitesh Shah",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-727, MAPREDUCE-5325. ClientRMProtocol.getAllApplications should accept ApplicationType as a parameter. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501599 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/07/13 4:01 PM",
          "commitName": "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "08/07/13 3:30 PM",
          "commitNameOld": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 1.02,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,29 @@\n-  public GetAllApplicationsResponse getAllApplications(\n-      GetAllApplicationsRequest request) throws YarnException {\n+  public GetApplicationsResponse getApplications(\n+      GetApplicationsRequest request) throws YarnException {\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n+    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n+    boolean bypassFilter \u003d applicationTypes.isEmpty();\n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n+      if (!(bypassFilter || applicationTypes.contains(application\n+          .getApplicationType()))) {\n+        continue;\n+      }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n-    GetAllApplicationsResponse response \u003d \n-      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n+    GetApplicationsResponse response \u003d\n+      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    boolean bypassFilter \u003d applicationTypes.isEmpty();\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (!(bypassFilter || applicationTypes.contains(application\n          .getApplicationType()))) {\n        continue;\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
          "extendedDetails": {
            "oldValue": "getAllApplications",
            "newValue": "getApplications"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-727, MAPREDUCE-5325. ClientRMProtocol.getAllApplications should accept ApplicationType as a parameter. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501599 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/07/13 4:01 PM",
          "commitName": "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "08/07/13 3:30 PM",
          "commitNameOld": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 1.02,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,29 @@\n-  public GetAllApplicationsResponse getAllApplications(\n-      GetAllApplicationsRequest request) throws YarnException {\n+  public GetApplicationsResponse getApplications(\n+      GetApplicationsRequest request) throws YarnException {\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n+    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n+    boolean bypassFilter \u003d applicationTypes.isEmpty();\n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n+      if (!(bypassFilter || applicationTypes.contains(application\n+          .getApplicationType()))) {\n+        continue;\n+      }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n-    GetAllApplicationsResponse response \u003d \n-      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n+    GetApplicationsResponse response \u003d\n+      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    boolean bypassFilter \u003d applicationTypes.isEmpty();\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (!(bypassFilter || applicationTypes.contains(application\n          .getApplicationType()))) {\n        continue;\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
          "extendedDetails": {
            "oldValue": "[request-GetAllApplicationsRequest]",
            "newValue": "[request-GetApplicationsRequest]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-727, MAPREDUCE-5325. ClientRMProtocol.getAllApplications should accept ApplicationType as a parameter. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501599 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/07/13 4:01 PM",
          "commitName": "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "08/07/13 3:30 PM",
          "commitNameOld": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 1.02,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,29 @@\n-  public GetAllApplicationsResponse getAllApplications(\n-      GetAllApplicationsRequest request) throws YarnException {\n+  public GetApplicationsResponse getApplications(\n+      GetApplicationsRequest request) throws YarnException {\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n+    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n+    boolean bypassFilter \u003d applicationTypes.isEmpty();\n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n+      if (!(bypassFilter || applicationTypes.contains(application\n+          .getApplicationType()))) {\n+        continue;\n+      }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n-    GetAllApplicationsResponse response \u003d \n-      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n+    GetApplicationsResponse response \u003d\n+      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    boolean bypassFilter \u003d applicationTypes.isEmpty();\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (!(bypassFilter || applicationTypes.contains(application\n          .getApplicationType()))) {\n        continue;\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
          "extendedDetails": {
            "oldValue": "GetAllApplicationsResponse",
            "newValue": "GetApplicationsResponse"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-727, MAPREDUCE-5325. ClientRMProtocol.getAllApplications should accept ApplicationType as a parameter. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501599 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/07/13 4:01 PM",
          "commitName": "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "08/07/13 3:30 PM",
          "commitNameOld": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 1.02,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,29 @@\n-  public GetAllApplicationsResponse getAllApplications(\n-      GetAllApplicationsRequest request) throws YarnException {\n+  public GetApplicationsResponse getApplications(\n+      GetApplicationsRequest request) throws YarnException {\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n+    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n+    boolean bypassFilter \u003d applicationTypes.isEmpty();\n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n+      if (!(bypassFilter || applicationTypes.contains(application\n+          .getApplicationType()))) {\n+        continue;\n+      }\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n-    GetAllApplicationsResponse response \u003d \n-      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n+    GetApplicationsResponse response \u003d\n+      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public GetApplicationsResponse getApplications(\n      GetApplicationsRequest request) throws YarnException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    Set\u003cString\u003e applicationTypes \u003d request.getApplicationTypes();\n    boolean bypassFilter \u003d applicationTypes.isEmpty();\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      if (!(bypassFilter || applicationTypes.contains(application\n          .getApplicationType()))) {\n        continue;\n      }\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetApplicationsResponse response \u003d\n      recordFactory.newRecordInstance(GetApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
          "extendedDetails": {}
        }
      ]
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   public GetAllApplicationsResponse getAllApplications(\n-      GetAllApplicationsRequest request) throws YarnRemoteException {\n+      GetAllApplicationsRequest request) throws YarnException {\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n       boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n           ApplicationAccessType.VIEW_APP, application.getApplicationId());\n       reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n     GetAllApplicationsResponse response \u003d \n       recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetAllApplicationsResponse getAllApplications(\n      GetAllApplicationsRequest request) throws YarnException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetAllApplicationsResponse response \u003d \n      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnException]"
      }
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public GetAllApplicationsResponse getAllApplications(\n      GetAllApplicationsRequest request) throws YarnRemoteException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetAllApplicationsResponse response \u003d \n      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java"
      }
    },
    "fab57a144de0cd515e1de9107e4d3ac58037d846": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3792. Fix \"bin/mapred job -list\" to display all jobs instead of only the jobs owned by the user. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296721 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/12 3:40 PM",
      "commitName": "fab57a144de0cd515e1de9107e4d3ac58037d846",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/02/12 12:03 PM",
      "commitNameOld": "c7d64769c1a72f2aab9958e33a7cf28d02612306",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 28.15,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,23 @@\n   public GetAllApplicationsResponse getAllApplications(\n       GetAllApplicationsRequest request) throws YarnRemoteException {\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n-      // Only give out the applications viewable by the user as\n-      // ApplicationReport has confidential information like client-token, ACLs\n-      // etc. Web UI displays all applications though as we filter and print\n-      // only public information there.\n-      if (checkAccess(callerUGI, application.getUser(),\n-          ApplicationAccessType.VIEW_APP, application.getApplicationId())) {\n-        reports.add(application.createAndGetApplicationReport());\n-      }\n+      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n+          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n+      reports.add(application.createAndGetApplicationReport(allowAccess));\n     }\n \n     GetAllApplicationsResponse response \u003d \n       recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetAllApplicationsResponse getAllApplications(\n      GetAllApplicationsRequest request) throws YarnRemoteException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      boolean allowAccess \u003d checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId());\n      reports.add(application.createAndGetApplicationReport(allowAccess));\n    }\n\n    GetAllApplicationsResponse response \u003d \n      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "df2991c0cbc3f35c2640b93680667507c4f810dd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3104. Implemented Application-acls. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/10/11 4:45 AM",
      "commitName": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/10/11 10:21 PM",
      "commitNameOld": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,28 @@\n   public GetAllApplicationsResponse getAllApplications(\n       GetAllApplicationsRequest request) throws YarnRemoteException {\n \n+    UserGroupInformation callerUGI;\n+    try {\n+      callerUGI \u003d UserGroupInformation.getCurrentUser();\n+    } catch (IOException ie) {\n+      LOG.info(\"Error getting UGI \", ie);\n+      throw RPCUtil.getRemoteException(ie);\n+    }\n+\n     List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n     for (RMApp application : this.rmContext.getRMApps().values()) {\n-      reports.add(application.createAndGetApplicationReport());\n+      // Only give out the applications viewable by the user as\n+      // ApplicationReport has confidential information like client-token, ACLs\n+      // etc. Web UI displays all applications though as we filter and print\n+      // only public information there.\n+      if (checkAccess(callerUGI, application.getUser(),\n+          ApplicationAccessType.VIEW_APP, application.getApplicationId())) {\n+        reports.add(application.createAndGetApplicationReport());\n+      }\n     }\n \n     GetAllApplicationsResponse response \u003d \n       recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n     response.setApplicationList(reports);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetAllApplicationsResponse getAllApplications(\n      GetAllApplicationsRequest request) throws YarnRemoteException {\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      // Only give out the applications viewable by the user as\n      // ApplicationReport has confidential information like client-token, ACLs\n      // etc. Web UI displays all applications though as we filter and print\n      // only public information there.\n      if (checkAccess(callerUGI, application.getUser(),\n          ApplicationAccessType.VIEW_APP, application.getApplicationId())) {\n        reports.add(application.createAndGetApplicationReport());\n      }\n    }\n\n    GetAllApplicationsResponse response \u003d \n      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public GetAllApplicationsResponse getAllApplications(\n      GetAllApplicationsRequest request) throws YarnRemoteException {\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      reports.add(application.createAndGetApplicationReport());\n    }\n\n    GetAllApplicationsResponse response \u003d \n      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,13 @@\n+  public GetAllApplicationsResponse getAllApplications(\n+      GetAllApplicationsRequest request) throws YarnRemoteException {\n+\n+    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n+    for (RMApp application : this.rmContext.getRMApps().values()) {\n+      reports.add(application.createAndGetApplicationReport());\n+    }\n+\n+    GetAllApplicationsResponse response \u003d \n+      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n+    response.setApplicationList(reports);\n+    return response;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public GetAllApplicationsResponse getAllApplications(\n      GetAllApplicationsRequest request) throws YarnRemoteException {\n\n    List\u003cApplicationReport\u003e reports \u003d new ArrayList\u003cApplicationReport\u003e();\n    for (RMApp application : this.rmContext.getRMApps().values()) {\n      reports.add(application.createAndGetApplicationReport());\n    }\n\n    GetAllApplicationsResponse response \u003d \n      recordFactory.newRecordInstance(GetAllApplicationsResponse.class);\n    response.setApplicationList(reports);\n    return response;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java"
    }
  }
}