{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultPlacementAlgorithm.java",
  "functionName": "doPlacement",
  "functionId": "doPlacement___requests-BatchedRequests__resp-ConstraintPlacementAlgorithmOutput__allNodes-List__SchedulerNode____rejectedRequests-List__SchedulingRequest____availableResources-Map__NodeId,Resource__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
  "functionStartLine": 131,
  "functionEndLine": 187,
  "numCommitsSeen": 15,
  "timeTaken": 3127,
  "changeHistory": [
    "6e5ba9366fc05719906ff2789b1a0fd26001182b",
    "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
    "adbe87abf8b2814e0e2988d09ef8a8569190c80e",
    "28fe7f331837b36e78fa34ed990993677dddeaee"
  ],
  "changeHistoryShort": {
    "6e5ba9366fc05719906ff2789b1a0fd26001182b": "Ymultichange(Yparameterchange,Ybodychange)",
    "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd": "Ybodychange",
    "adbe87abf8b2814e0e2988d09ef8a8569190c80e": "Ybodychange",
    "28fe7f331837b36e78fa34ed990993677dddeaee": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6e5ba9366fc05719906ff2789b1a0fd26001182b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7839. Modify PlacementAlgorithm to Check node capacity before placing request on node. (Panagiotis Garefalakis via asuresh)\n",
      "commitDate": "02/02/18 10:28 AM",
      "commitName": "6e5ba9366fc05719906ff2789b1a0fd26001182b",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7839. Modify PlacementAlgorithm to Check node capacity before placing request on node. (Panagiotis Garefalakis via asuresh)\n",
          "commitDate": "02/02/18 10:28 AM",
          "commitName": "6e5ba9366fc05719906ff2789b1a0fd26001182b",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 2.37,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,57 @@\n   private void doPlacement(BatchedRequests requests,\n       ConstraintPlacementAlgorithmOutput resp,\n       List\u003cSchedulerNode\u003e allNodes,\n-      List\u003cSchedulingRequest\u003e rejectedRequests) {\n+      List\u003cSchedulingRequest\u003e rejectedRequests,\n+      Map\u003cNodeId, Resource\u003e availableResources) {\n     Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n     Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n     SchedulerNode lastSatisfiedNode \u003d null;\n     while (requestIterator.hasNext()) {\n       if (allNodes.isEmpty()) {\n         LOG.warn(\"No nodes available for placement at the moment !!\");\n         break;\n       }\n       SchedulingRequest schedulingRequest \u003d requestIterator.next();\n       PlacedSchedulingRequest placedReq \u003d\n           new PlacedSchedulingRequest(schedulingRequest);\n       placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n       resp.getPlacedRequests().add(placedReq);\n       CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n           new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n       int numAllocs \u003d\n           schedulingRequest.getResourceSizing().getNumAllocations();\n       while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n         SchedulerNode node \u003d nodeIter.next();\n         try {\n           String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n               schedulingRequest.getAllocationTags().iterator().next();\n+          Resource unallocatedResource \u003d\n+              availableResources.computeIfAbsent(node.getNodeID(),\n+                  x -\u003e Resource.newInstance(node.getUnallocatedResource()));\n           if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n               attemptPlacementOnNode(\n-                  requests.getApplicationId(), schedulingRequest, node)) {\n+                  requests.getApplicationId(), unallocatedResource,\n+                  schedulingRequest, node, false)) {\n             schedulingRequest.getResourceSizing()\n                 .setNumAllocations(--numAllocs);\n+            Resources.addTo(unallocatedResource,\n+                schedulingRequest.getResourceSizing().getResources());\n             placedReq.getNodes().add(node);\n             numAllocs \u003d\n                 schedulingRequest.getResourceSizing().getNumAllocations();\n             // Add temp-container tags for current placement cycle\n             this.tagsManager.addTempTags(node.getNodeID(),\n                 requests.getApplicationId(),\n                 schedulingRequest.getAllocationTags());\n             lastSatisfiedNode \u003d node;\n           }\n         } catch (InvalidAllocationTagsQueryException e) {\n           LOG.warn(\"Got exception from TagManager !\", e);\n         }\n       }\n     }\n     // Add all requests whose numAllocations still \u003e 0 to rejected list.\n     requests.getSchedulingRequests().stream()\n         .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n         .forEach(rejReq -\u003e rejectedRequests.add(cloneReq(rejReq)));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doPlacement(BatchedRequests requests,\n      ConstraintPlacementAlgorithmOutput resp,\n      List\u003cSchedulerNode\u003e allNodes,\n      List\u003cSchedulingRequest\u003e rejectedRequests,\n      Map\u003cNodeId, Resource\u003e availableResources) {\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n    SchedulerNode lastSatisfiedNode \u003d null;\n    while (requestIterator.hasNext()) {\n      if (allNodes.isEmpty()) {\n        LOG.warn(\"No nodes available for placement at the moment !!\");\n        break;\n      }\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      PlacedSchedulingRequest placedReq \u003d\n          new PlacedSchedulingRequest(schedulingRequest);\n      placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n      resp.getPlacedRequests().add(placedReq);\n      CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n          new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n      int numAllocs \u003d\n          schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n              schedulingRequest.getAllocationTags().iterator().next();\n          Resource unallocatedResource \u003d\n              availableResources.computeIfAbsent(node.getNodeID(),\n                  x -\u003e Resource.newInstance(node.getUnallocatedResource()));\n          if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n              attemptPlacementOnNode(\n                  requests.getApplicationId(), unallocatedResource,\n                  schedulingRequest, node, false)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            Resources.addTo(unallocatedResource,\n                schedulingRequest.getResourceSizing().getResources());\n            placedReq.getNodes().add(node);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempTags(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n            lastSatisfiedNode \u003d node;\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e rejectedRequests.add(cloneReq(rejReq)));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
          "extendedDetails": {
            "oldValue": "[requests-BatchedRequests, resp-ConstraintPlacementAlgorithmOutput, allNodes-List\u003cSchedulerNode\u003e, rejectedRequests-List\u003cSchedulingRequest\u003e]",
            "newValue": "[requests-BatchedRequests, resp-ConstraintPlacementAlgorithmOutput, allNodes-List\u003cSchedulerNode\u003e, rejectedRequests-List\u003cSchedulingRequest\u003e, availableResources-Map\u003cNodeId,Resource\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7839. Modify PlacementAlgorithm to Check node capacity before placing request on node. (Panagiotis Garefalakis via asuresh)\n",
          "commitDate": "02/02/18 10:28 AM",
          "commitName": "6e5ba9366fc05719906ff2789b1a0fd26001182b",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 2.37,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,57 @@\n   private void doPlacement(BatchedRequests requests,\n       ConstraintPlacementAlgorithmOutput resp,\n       List\u003cSchedulerNode\u003e allNodes,\n-      List\u003cSchedulingRequest\u003e rejectedRequests) {\n+      List\u003cSchedulingRequest\u003e rejectedRequests,\n+      Map\u003cNodeId, Resource\u003e availableResources) {\n     Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n     Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n     SchedulerNode lastSatisfiedNode \u003d null;\n     while (requestIterator.hasNext()) {\n       if (allNodes.isEmpty()) {\n         LOG.warn(\"No nodes available for placement at the moment !!\");\n         break;\n       }\n       SchedulingRequest schedulingRequest \u003d requestIterator.next();\n       PlacedSchedulingRequest placedReq \u003d\n           new PlacedSchedulingRequest(schedulingRequest);\n       placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n       resp.getPlacedRequests().add(placedReq);\n       CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n           new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n       int numAllocs \u003d\n           schedulingRequest.getResourceSizing().getNumAllocations();\n       while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n         SchedulerNode node \u003d nodeIter.next();\n         try {\n           String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n               schedulingRequest.getAllocationTags().iterator().next();\n+          Resource unallocatedResource \u003d\n+              availableResources.computeIfAbsent(node.getNodeID(),\n+                  x -\u003e Resource.newInstance(node.getUnallocatedResource()));\n           if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n               attemptPlacementOnNode(\n-                  requests.getApplicationId(), schedulingRequest, node)) {\n+                  requests.getApplicationId(), unallocatedResource,\n+                  schedulingRequest, node, false)) {\n             schedulingRequest.getResourceSizing()\n                 .setNumAllocations(--numAllocs);\n+            Resources.addTo(unallocatedResource,\n+                schedulingRequest.getResourceSizing().getResources());\n             placedReq.getNodes().add(node);\n             numAllocs \u003d\n                 schedulingRequest.getResourceSizing().getNumAllocations();\n             // Add temp-container tags for current placement cycle\n             this.tagsManager.addTempTags(node.getNodeID(),\n                 requests.getApplicationId(),\n                 schedulingRequest.getAllocationTags());\n             lastSatisfiedNode \u003d node;\n           }\n         } catch (InvalidAllocationTagsQueryException e) {\n           LOG.warn(\"Got exception from TagManager !\", e);\n         }\n       }\n     }\n     // Add all requests whose numAllocations still \u003e 0 to rejected list.\n     requests.getSchedulingRequests().stream()\n         .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n         .forEach(rejReq -\u003e rejectedRequests.add(cloneReq(rejReq)));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doPlacement(BatchedRequests requests,\n      ConstraintPlacementAlgorithmOutput resp,\n      List\u003cSchedulerNode\u003e allNodes,\n      List\u003cSchedulingRequest\u003e rejectedRequests,\n      Map\u003cNodeId, Resource\u003e availableResources) {\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n    SchedulerNode lastSatisfiedNode \u003d null;\n    while (requestIterator.hasNext()) {\n      if (allNodes.isEmpty()) {\n        LOG.warn(\"No nodes available for placement at the moment !!\");\n        break;\n      }\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      PlacedSchedulingRequest placedReq \u003d\n          new PlacedSchedulingRequest(schedulingRequest);\n      placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n      resp.getPlacedRequests().add(placedReq);\n      CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n          new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n      int numAllocs \u003d\n          schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n              schedulingRequest.getAllocationTags().iterator().next();\n          Resource unallocatedResource \u003d\n              availableResources.computeIfAbsent(node.getNodeID(),\n                  x -\u003e Resource.newInstance(node.getUnallocatedResource()));\n          if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n              attemptPlacementOnNode(\n                  requests.getApplicationId(), unallocatedResource,\n                  schedulingRequest, node, false)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            Resources.addTo(unallocatedResource,\n                schedulingRequest.getResourceSizing().getResources());\n            placedReq.getNodes().add(node);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempTags(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n            lastSatisfiedNode \u003d node;\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e rejectedRequests.add(cloneReq(rejReq)));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
          "extendedDetails": {}
        }
      ]
    },
    "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7783. Add validation step to ensure constraints are not violated due to order in which a request is processed. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "adbe87abf8b2814e0e2988d09ef8a8569190c80e",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   private void doPlacement(BatchedRequests requests,\n       ConstraintPlacementAlgorithmOutput resp,\n       List\u003cSchedulerNode\u003e allNodes,\n       List\u003cSchedulingRequest\u003e rejectedRequests) {\n     Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n     Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n     SchedulerNode lastSatisfiedNode \u003d null;\n     while (requestIterator.hasNext()) {\n       if (allNodes.isEmpty()) {\n         LOG.warn(\"No nodes available for placement at the moment !!\");\n         break;\n       }\n       SchedulingRequest schedulingRequest \u003d requestIterator.next();\n+      PlacedSchedulingRequest placedReq \u003d\n+          new PlacedSchedulingRequest(schedulingRequest);\n+      placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n+      resp.getPlacedRequests().add(placedReq);\n       CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n           new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n-      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n+      int numAllocs \u003d\n+          schedulingRequest.getResourceSizing().getNumAllocations();\n       while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n         SchedulerNode node \u003d nodeIter.next();\n         try {\n           String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n               schedulingRequest.getAllocationTags().iterator().next();\n           if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n               attemptPlacementOnNode(\n                   requests.getApplicationId(), schedulingRequest, node)) {\n             schedulingRequest.getResourceSizing()\n                 .setNumAllocations(--numAllocs);\n-            PlacedSchedulingRequest placedReq \u003d\n-                new PlacedSchedulingRequest(schedulingRequest);\n-            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n             placedReq.getNodes().add(node);\n-            resp.getPlacedRequests().add(placedReq);\n             numAllocs \u003d\n                 schedulingRequest.getResourceSizing().getNumAllocations();\n             // Add temp-container tags for current placement cycle\n             this.tagsManager.addTempTags(node.getNodeID(),\n                 requests.getApplicationId(),\n                 schedulingRequest.getAllocationTags());\n             lastSatisfiedNode \u003d node;\n           }\n         } catch (InvalidAllocationTagsQueryException e) {\n           LOG.warn(\"Got exception from TagManager !\", e);\n         }\n       }\n     }\n     // Add all requests whose numAllocations still \u003e 0 to rejected list.\n     requests.getSchedulingRequests().stream()\n         .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n-        .forEach(rejReq -\u003e rejectedRequests.add(rejReq));\n+        .forEach(rejReq -\u003e rejectedRequests.add(cloneReq(rejReq)));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doPlacement(BatchedRequests requests,\n      ConstraintPlacementAlgorithmOutput resp,\n      List\u003cSchedulerNode\u003e allNodes,\n      List\u003cSchedulingRequest\u003e rejectedRequests) {\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n    SchedulerNode lastSatisfiedNode \u003d null;\n    while (requestIterator.hasNext()) {\n      if (allNodes.isEmpty()) {\n        LOG.warn(\"No nodes available for placement at the moment !!\");\n        break;\n      }\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      PlacedSchedulingRequest placedReq \u003d\n          new PlacedSchedulingRequest(schedulingRequest);\n      placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n      resp.getPlacedRequests().add(placedReq);\n      CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n          new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n      int numAllocs \u003d\n          schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n              schedulingRequest.getAllocationTags().iterator().next();\n          if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n              attemptPlacementOnNode(\n                  requests.getApplicationId(), schedulingRequest, node)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            placedReq.getNodes().add(node);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempTags(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n            lastSatisfiedNode \u003d node;\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e rejectedRequests.add(cloneReq(rejReq)));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
      "extendedDetails": {}
    },
    "adbe87abf8b2814e0e2988d09ef8a8569190c80e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7788. Factor out management of temp tags from AllocationTagsManager. (Arun Suresh via kkaranasos)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "adbe87abf8b2814e0e2988d09ef8a8569190c80e",
      "commitAuthor": "Konstantinos Karanasos",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "8bf7c444368f48f63f8011cf155f551c6b51ee21",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   private void doPlacement(BatchedRequests requests,\n       ConstraintPlacementAlgorithmOutput resp,\n       List\u003cSchedulerNode\u003e allNodes,\n       List\u003cSchedulingRequest\u003e rejectedRequests) {\n     Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n     Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n     SchedulerNode lastSatisfiedNode \u003d null;\n     while (requestIterator.hasNext()) {\n       if (allNodes.isEmpty()) {\n         LOG.warn(\"No nodes available for placement at the moment !!\");\n         break;\n       }\n       SchedulingRequest schedulingRequest \u003d requestIterator.next();\n       CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n           new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n       int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n       while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n         SchedulerNode node \u003d nodeIter.next();\n         try {\n           String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n               schedulingRequest.getAllocationTags().iterator().next();\n           if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n               attemptPlacementOnNode(\n                   requests.getApplicationId(), schedulingRequest, node)) {\n             schedulingRequest.getResourceSizing()\n                 .setNumAllocations(--numAllocs);\n             PlacedSchedulingRequest placedReq \u003d\n                 new PlacedSchedulingRequest(schedulingRequest);\n             placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n             placedReq.getNodes().add(node);\n             resp.getPlacedRequests().add(placedReq);\n             numAllocs \u003d\n                 schedulingRequest.getResourceSizing().getNumAllocations();\n             // Add temp-container tags for current placement cycle\n-            this.tagsManager.addTempContainer(node.getNodeID(),\n+            this.tagsManager.addTempTags(node.getNodeID(),\n                 requests.getApplicationId(),\n                 schedulingRequest.getAllocationTags());\n             lastSatisfiedNode \u003d node;\n           }\n         } catch (InvalidAllocationTagsQueryException e) {\n           LOG.warn(\"Got exception from TagManager !\", e);\n         }\n       }\n     }\n     // Add all requests whose numAllocations still \u003e 0 to rejected list.\n     requests.getSchedulingRequests().stream()\n         .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n         .forEach(rejReq -\u003e rejectedRequests.add(rejReq));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doPlacement(BatchedRequests requests,\n      ConstraintPlacementAlgorithmOutput resp,\n      List\u003cSchedulerNode\u003e allNodes,\n      List\u003cSchedulingRequest\u003e rejectedRequests) {\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n    SchedulerNode lastSatisfiedNode \u003d null;\n    while (requestIterator.hasNext()) {\n      if (allNodes.isEmpty()) {\n        LOG.warn(\"No nodes available for placement at the moment !!\");\n        break;\n      }\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n          new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n              schedulingRequest.getAllocationTags().iterator().next();\n          if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n              attemptPlacementOnNode(\n                  requests.getApplicationId(), schedulingRequest, node)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            PlacedSchedulingRequest placedReq \u003d\n                new PlacedSchedulingRequest(schedulingRequest);\n            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n            placedReq.getNodes().add(node);\n            resp.getPlacedRequests().add(placedReq);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempTags(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n            lastSatisfiedNode \u003d node;\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e rejectedRequests.add(rejReq));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
      "extendedDetails": {}
    },
    "28fe7f331837b36e78fa34ed990993677dddeaee": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7774. Miscellaneous fixes to the PlacementProcessor. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "28fe7f331837b36e78fa34ed990993677dddeaee",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,49 @@\n+  private void doPlacement(BatchedRequests requests,\n+      ConstraintPlacementAlgorithmOutput resp,\n+      List\u003cSchedulerNode\u003e allNodes,\n+      List\u003cSchedulingRequest\u003e rejectedRequests) {\n+    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n+    Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n+    SchedulerNode lastSatisfiedNode \u003d null;\n+    while (requestIterator.hasNext()) {\n+      if (allNodes.isEmpty()) {\n+        LOG.warn(\"No nodes available for placement at the moment !!\");\n+        break;\n+      }\n+      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n+      CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n+          new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n+      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n+      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n+        SchedulerNode node \u003d nodeIter.next();\n+        try {\n+          String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n+              schedulingRequest.getAllocationTags().iterator().next();\n+          if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n+              attemptPlacementOnNode(\n+                  requests.getApplicationId(), schedulingRequest, node)) {\n+            schedulingRequest.getResourceSizing()\n+                .setNumAllocations(--numAllocs);\n+            PlacedSchedulingRequest placedReq \u003d\n+                new PlacedSchedulingRequest(schedulingRequest);\n+            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n+            placedReq.getNodes().add(node);\n+            resp.getPlacedRequests().add(placedReq);\n+            numAllocs \u003d\n+                schedulingRequest.getResourceSizing().getNumAllocations();\n+            // Add temp-container tags for current placement cycle\n+            this.tagsManager.addTempContainer(node.getNodeID(),\n+                requests.getApplicationId(),\n+                schedulingRequest.getAllocationTags());\n+            lastSatisfiedNode \u003d node;\n+          }\n+        } catch (InvalidAllocationTagsQueryException e) {\n+          LOG.warn(\"Got exception from TagManager !\", e);\n+        }\n+      }\n+    }\n+    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n+    requests.getSchedulingRequests().stream()\n+        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n+        .forEach(rejReq -\u003e rejectedRequests.add(rejReq));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doPlacement(BatchedRequests requests,\n      ConstraintPlacementAlgorithmOutput resp,\n      List\u003cSchedulerNode\u003e allNodes,\n      List\u003cSchedulingRequest\u003e rejectedRequests) {\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    Iterator\u003cSchedulerNode\u003e nIter \u003d allNodes.iterator();\n    SchedulerNode lastSatisfiedNode \u003d null;\n    while (requestIterator.hasNext()) {\n      if (allNodes.isEmpty()) {\n        LOG.warn(\"No nodes available for placement at the moment !!\");\n        break;\n      }\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      CircularIterator\u003cSchedulerNode\u003e nodeIter \u003d\n          new CircularIterator(lastSatisfiedNode, nIter, allNodes);\n      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          String tag \u003d schedulingRequest.getAllocationTags() \u003d\u003d null ? \"\" :\n              schedulingRequest.getAllocationTags().iterator().next();\n          if (!requests.getBlacklist(tag).contains(node.getNodeID()) \u0026\u0026\n              attemptPlacementOnNode(\n                  requests.getApplicationId(), schedulingRequest, node)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            PlacedSchedulingRequest placedReq \u003d\n                new PlacedSchedulingRequest(schedulingRequest);\n            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n            placedReq.getNodes().add(node);\n            resp.getPlacedRequests().add(placedReq);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempContainer(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n            lastSatisfiedNode \u003d node;\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e rejectedRequests.add(rejReq));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java"
    }
  }
}