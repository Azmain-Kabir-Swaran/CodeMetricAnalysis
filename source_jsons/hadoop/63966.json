{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PlacementConstraintParser.java",
  "functionName": "parsePlacementSpec",
  "functionId": "parsePlacementSpec___expression-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/util/constraint/PlacementConstraintParser.java",
  "functionStartLine": 723,
  "functionEndLine": 785,
  "numCommitsSeen": 6,
  "timeTaken": 1974,
  "changeHistory": [
    "6c4ab0312b9829f5cb3db0480406fe79f0125f5e",
    "33d8327cffdc483b538aec3022fd8730b85babdb",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
    "a08c048832d68c203fbdfce8d9f0e7dcccb02a55"
  ],
  "changeHistoryShort": {
    "6c4ab0312b9829f5cb3db0480406fe79f0125f5e": "Ybodychange",
    "33d8327cffdc483b538aec3022fd8730b85babdb": "Ybodychange",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": "Ybodychange",
    "a08c048832d68c203fbdfce8d9f0e7dcccb02a55": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6c4ab0312b9829f5cb3db0480406fe79f0125f5e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9258. Support to specify allocation tags without constraint in distributed shell CLI. Contributed by Prabhu Joseph.\n",
      "commitDate": "21/02/19 8:18 AM",
      "commitName": "6c4ab0312b9829f5cb3db0480406fe79f0125f5e",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "10/02/19 10:42 PM",
      "commitNameOld": "2b7f828d4646e1837ef81e127ba86c6d77128e9b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 10.4,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,63 @@\n   public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n       String expression) throws PlacementConstraintParseException {\n     // Continue handling for application tag based constraint otherwise.\n     // Respect insertion order.\n     Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n     PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n         new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n     tokenizer.validate();\n     while (tokenizer.hasMoreElements()) {\n       String specStr \u003d tokenizer.nextElement();\n-      // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n+      // each spec starts with sourceAllocationTag(numOfContainers) and\n       // followed by a constraint expression.\n-      // foo\u003d4,Pn\n-      String[] splitted \u003d specStr.split(\n-          String.valueOf(EXPRESSION_VAL_DELIM), 2);\n+      // foo(4),Pn\n       final SourceTags st;\n-      final String exprs;\n-      if (splitted.length \u003d\u003d 1) {\n-        // source tags not specified\n-        exprs \u003d splitted[0];\n-        st \u003d SourceTags.emptySourceTags();\n-      } else if (splitted.length \u003d\u003d 2) {\n-        exprs \u003d splitted[1];\n-        String tagAlloc \u003d splitted[0];\n-        st \u003d SourceTags.parseFrom(tagAlloc);\n+      PlacementConstraint constraint;\n+      String delimiter \u003d new String(new char[]{\u0027[\u0027, BRACKET_END, \u0027]\u0027,\n+          EXPRESSION_VAL_DELIM});\n+      String[] splitted \u003d specStr.split(delimiter, 2);\n+      if (splitted.length \u003d\u003d 2) {\n+        st \u003d SourceTags.parseFrom(splitted[0] + String.valueOf(BRACKET_END));\n+        constraint \u003d PlacementConstraintParser.parseExpression(splitted[1]).\n+            build();\n+      } else if (splitted.length \u003d\u003d 1) {\n+        // Either Node Attribute Constraint or Source Allocation Tag alone\n+        NodeConstraintParser np \u003d new NodeConstraintParser(specStr);\n+        Optional\u003cAbstractConstraint\u003e constraintOptional \u003d\n+            Optional.ofNullable(np.tryParse());\n+        if (constraintOptional.isPresent()) {\n+          st \u003d SourceTags.emptySourceTags();\n+          constraint \u003d constraintOptional.get().build();\n+        } else {\n+          st \u003d SourceTags.parseFrom(specStr);\n+          constraint \u003d null;\n+        }\n       } else {\n         throw new PlacementConstraintParseException(\n             \"Unexpected placement constraint expression \" + specStr);\n       }\n-\n-      AbstractConstraint constraint \u003d\n-          PlacementConstraintParser.parseExpression(exprs);\n-\n-      result.put(st, constraint.build());\n+      result.put(st, constraint);\n     }\n \n     // Validation\n     Set\u003cSourceTags\u003e sourceTagSet \u003d result.keySet();\n     if (sourceTagSet.stream()\n         .filter(sourceTags -\u003e sourceTags.isEmpty())\n         .findAny()\n         .isPresent()) {\n-      // Source tags, e.g foo\u003d3, is optional for a node-attribute constraint,\n+      // Source tags, e.g foo(3), is optional for a node-attribute constraint,\n       // but when source tags is absent, the parser only accept single\n       // constraint expression to avoid ambiguous semantic. This is because\n       // DS AM is requesting number of containers per the number specified\n       // in the source tags, we do overwrite when there is no source tags\n       // with num_containers argument from commandline. If that is partially\n       // missed in the constraints, we don\u0027t know if it is ought to\n       // overwritten or not.\n       if (result.size() !\u003d 1) {\n         throw new PlacementConstraintParseException(\n             \"Source allocation tags is required for a multi placement\"\n                 + \" constraint expression.\");\n       }\n     }\n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n      String expression) throws PlacementConstraintParseException {\n    // Continue handling for application tag based constraint otherwise.\n    // Respect insertion order.\n    Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n    PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n        new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n    tokenizer.validate();\n    while (tokenizer.hasMoreElements()) {\n      String specStr \u003d tokenizer.nextElement();\n      // each spec starts with sourceAllocationTag(numOfContainers) and\n      // followed by a constraint expression.\n      // foo(4),Pn\n      final SourceTags st;\n      PlacementConstraint constraint;\n      String delimiter \u003d new String(new char[]{\u0027[\u0027, BRACKET_END, \u0027]\u0027,\n          EXPRESSION_VAL_DELIM});\n      String[] splitted \u003d specStr.split(delimiter, 2);\n      if (splitted.length \u003d\u003d 2) {\n        st \u003d SourceTags.parseFrom(splitted[0] + String.valueOf(BRACKET_END));\n        constraint \u003d PlacementConstraintParser.parseExpression(splitted[1]).\n            build();\n      } else if (splitted.length \u003d\u003d 1) {\n        // Either Node Attribute Constraint or Source Allocation Tag alone\n        NodeConstraintParser np \u003d new NodeConstraintParser(specStr);\n        Optional\u003cAbstractConstraint\u003e constraintOptional \u003d\n            Optional.ofNullable(np.tryParse());\n        if (constraintOptional.isPresent()) {\n          st \u003d SourceTags.emptySourceTags();\n          constraint \u003d constraintOptional.get().build();\n        } else {\n          st \u003d SourceTags.parseFrom(specStr);\n          constraint \u003d null;\n        }\n      } else {\n        throw new PlacementConstraintParseException(\n            \"Unexpected placement constraint expression \" + specStr);\n      }\n      result.put(st, constraint);\n    }\n\n    // Validation\n    Set\u003cSourceTags\u003e sourceTagSet \u003d result.keySet();\n    if (sourceTagSet.stream()\n        .filter(sourceTags -\u003e sourceTags.isEmpty())\n        .findAny()\n        .isPresent()) {\n      // Source tags, e.g foo(3), is optional for a node-attribute constraint,\n      // but when source tags is absent, the parser only accept single\n      // constraint expression to avoid ambiguous semantic. This is because\n      // DS AM is requesting number of containers per the number specified\n      // in the source tags, we do overwrite when there is no source tags\n      // with num_containers argument from commandline. If that is partially\n      // missed in the constraints, we don\u0027t know if it is ought to\n      // overwritten or not.\n      if (result.size() !\u003d 1) {\n        throw new PlacementConstraintParseException(\n            \"Source allocation tags is required for a multi placement\"\n                + \" constraint expression.\");\n      }\n    }\n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/util/constraint/PlacementConstraintParser.java",
      "extendedDetails": {}
    },
    "33d8327cffdc483b538aec3022fd8730b85babdb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8715. Make allocation tags in the placement spec optional for node-attributes. Contributed by Weiwei Yang.\n",
      "commitDate": "16/09/18 9:37 PM",
      "commitName": "33d8327cffdc483b538aec3022fd8730b85babdb",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,58 @@\n   public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n       String expression) throws PlacementConstraintParseException {\n     // Continue handling for application tag based constraint otherwise.\n     // Respect insertion order.\n     Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n     PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n         new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n     tokenizer.validate();\n     while (tokenizer.hasMoreElements()) {\n       String specStr \u003d tokenizer.nextElement();\n       // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n       // followed by a constraint expression.\n       // foo\u003d4,Pn\n       String[] splitted \u003d specStr.split(\n           String.valueOf(EXPRESSION_VAL_DELIM), 2);\n-      if (splitted.length !\u003d 2) {\n+      final SourceTags st;\n+      final String exprs;\n+      if (splitted.length \u003d\u003d 1) {\n+        // source tags not specified\n+        exprs \u003d splitted[0];\n+        st \u003d SourceTags.emptySourceTags();\n+      } else if (splitted.length \u003d\u003d 2) {\n+        exprs \u003d splitted[1];\n+        String tagAlloc \u003d splitted[0];\n+        st \u003d SourceTags.parseFrom(tagAlloc);\n+      } else {\n         throw new PlacementConstraintParseException(\n             \"Unexpected placement constraint expression \" + specStr);\n       }\n \n-      String tagAlloc \u003d splitted[0];\n-      SourceTags st \u003d SourceTags.parseFrom(tagAlloc);\n-      String exprs \u003d splitted[1];\n       AbstractConstraint constraint \u003d\n           PlacementConstraintParser.parseExpression(exprs);\n \n       result.put(st, constraint.build());\n     }\n \n+    // Validation\n+    Set\u003cSourceTags\u003e sourceTagSet \u003d result.keySet();\n+    if (sourceTagSet.stream()\n+        .filter(sourceTags -\u003e sourceTags.isEmpty())\n+        .findAny()\n+        .isPresent()) {\n+      // Source tags, e.g foo\u003d3, is optional for a node-attribute constraint,\n+      // but when source tags is absent, the parser only accept single\n+      // constraint expression to avoid ambiguous semantic. This is because\n+      // DS AM is requesting number of containers per the number specified\n+      // in the source tags, we do overwrite when there is no source tags\n+      // with num_containers argument from commandline. If that is partially\n+      // missed in the constraints, we don\u0027t know if it is ought to\n+      // overwritten or not.\n+      if (result.size() !\u003d 1) {\n+        throw new PlacementConstraintParseException(\n+            \"Source allocation tags is required for a multi placement\"\n+                + \" constraint expression.\");\n+      }\n+    }\n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n      String expression) throws PlacementConstraintParseException {\n    // Continue handling for application tag based constraint otherwise.\n    // Respect insertion order.\n    Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n    PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n        new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n    tokenizer.validate();\n    while (tokenizer.hasMoreElements()) {\n      String specStr \u003d tokenizer.nextElement();\n      // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n      // followed by a constraint expression.\n      // foo\u003d4,Pn\n      String[] splitted \u003d specStr.split(\n          String.valueOf(EXPRESSION_VAL_DELIM), 2);\n      final SourceTags st;\n      final String exprs;\n      if (splitted.length \u003d\u003d 1) {\n        // source tags not specified\n        exprs \u003d splitted[0];\n        st \u003d SourceTags.emptySourceTags();\n      } else if (splitted.length \u003d\u003d 2) {\n        exprs \u003d splitted[1];\n        String tagAlloc \u003d splitted[0];\n        st \u003d SourceTags.parseFrom(tagAlloc);\n      } else {\n        throw new PlacementConstraintParseException(\n            \"Unexpected placement constraint expression \" + specStr);\n      }\n\n      AbstractConstraint constraint \u003d\n          PlacementConstraintParser.parseExpression(exprs);\n\n      result.put(st, constraint.build());\n    }\n\n    // Validation\n    Set\u003cSourceTags\u003e sourceTagSet \u003d result.keySet();\n    if (sourceTagSet.stream()\n        .filter(sourceTags -\u003e sourceTags.isEmpty())\n        .findAny()\n        .isPresent()) {\n      // Source tags, e.g foo\u003d3, is optional for a node-attribute constraint,\n      // but when source tags is absent, the parser only accept single\n      // constraint expression to avoid ambiguous semantic. This is because\n      // DS AM is requesting number of containers per the number specified\n      // in the source tags, we do overwrite when there is no source tags\n      // with num_containers argument from commandline. If that is partially\n      // missed in the constraints, we don\u0027t know if it is ought to\n      // overwritten or not.\n      if (result.size() !\u003d 1) {\n        throw new PlacementConstraintParseException(\n            \"Source allocation tags is required for a multi placement\"\n                + \" constraint expression.\");\n      }\n    }\n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/util/constraint/PlacementConstraintParser.java",
      "extendedDetails": {}
    },
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7863. Modify placement constraints to support node attributes. Contributed by Sunil Govindan.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "04/03/18 7:49 PM",
      "commitNameOld": "e8c5be63f0110b3c761575207dc3234c25b76078",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 191.28,
      "commitsBetweenForRepo": 2026,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,31 @@\n   public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n       String expression) throws PlacementConstraintParseException {\n+    // Continue handling for application tag based constraint otherwise.\n     // Respect insertion order.\n     Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n     PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n         new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n     tokenizer.validate();\n-    while(tokenizer.hasMoreElements()) {\n+    while (tokenizer.hasMoreElements()) {\n       String specStr \u003d tokenizer.nextElement();\n       // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n       // followed by a constraint expression.\n       // foo\u003d4,Pn\n       String[] splitted \u003d specStr.split(\n           String.valueOf(EXPRESSION_VAL_DELIM), 2);\n       if (splitted.length !\u003d 2) {\n         throw new PlacementConstraintParseException(\n             \"Unexpected placement constraint expression \" + specStr);\n       }\n \n       String tagAlloc \u003d splitted[0];\n       SourceTags st \u003d SourceTags.parseFrom(tagAlloc);\n       String exprs \u003d splitted[1];\n       AbstractConstraint constraint \u003d\n           PlacementConstraintParser.parseExpression(exprs);\n \n       result.put(st, constraint.build());\n     }\n \n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n      String expression) throws PlacementConstraintParseException {\n    // Continue handling for application tag based constraint otherwise.\n    // Respect insertion order.\n    Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n    PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n        new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n    tokenizer.validate();\n    while (tokenizer.hasMoreElements()) {\n      String specStr \u003d tokenizer.nextElement();\n      // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n      // followed by a constraint expression.\n      // foo\u003d4,Pn\n      String[] splitted \u003d specStr.split(\n          String.valueOf(EXPRESSION_VAL_DELIM), 2);\n      if (splitted.length !\u003d 2) {\n        throw new PlacementConstraintParseException(\n            \"Unexpected placement constraint expression \" + specStr);\n      }\n\n      String tagAlloc \u003d splitted[0];\n      SourceTags st \u003d SourceTags.parseFrom(tagAlloc);\n      String exprs \u003d splitted[1];\n      AbstractConstraint constraint \u003d\n          PlacementConstraintParser.parseExpression(exprs);\n\n      result.put(st, constraint.build());\n    }\n\n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/util/constraint/PlacementConstraintParser.java",
      "extendedDetails": {}
    },
    "a08c048832d68c203fbdfce8d9f0e7dcccb02a55": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7838. Support AND/OR constraints in Distributed Shell. Contributed by Weiwei Yang.\n",
      "commitDate": "10/02/18 10:20 PM",
      "commitName": "a08c048832d68c203fbdfce8d9f0e7dcccb02a55",
      "commitAuthor": "Weiwei Yang",
      "diff": "@@ -0,0 +1,30 @@\n+  public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n+      String expression) throws PlacementConstraintParseException {\n+    // Respect insertion order.\n+    Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n+    PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n+        new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n+    tokenizer.validate();\n+    while(tokenizer.hasMoreElements()) {\n+      String specStr \u003d tokenizer.nextElement();\n+      // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n+      // followed by a constraint expression.\n+      // foo\u003d4,Pn\n+      String[] splitted \u003d specStr.split(\n+          String.valueOf(EXPRESSION_VAL_DELIM), 2);\n+      if (splitted.length !\u003d 2) {\n+        throw new PlacementConstraintParseException(\n+            \"Unexpected placement constraint expression \" + specStr);\n+      }\n+\n+      String tagAlloc \u003d splitted[0];\n+      SourceTags st \u003d SourceTags.parseFrom(tagAlloc);\n+      String exprs \u003d splitted[1];\n+      AbstractConstraint constraint \u003d\n+          PlacementConstraintParser.parseExpression(exprs);\n+\n+      result.put(st, constraint.build());\n+    }\n+\n+    return result;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static Map\u003cSourceTags, PlacementConstraint\u003e parsePlacementSpec(\n      String expression) throws PlacementConstraintParseException {\n    // Respect insertion order.\n    Map\u003cSourceTags, PlacementConstraint\u003e result \u003d new LinkedHashMap\u003c\u003e();\n    PlacementConstraintParser.ConstraintTokenizer tokenizer \u003d\n        new PlacementConstraintParser.MultipleConstraintsTokenizer(expression);\n    tokenizer.validate();\n    while(tokenizer.hasMoreElements()) {\n      String specStr \u003d tokenizer.nextElement();\n      // each spec starts with sourceAllocationTag\u003dnumOfContainers and\n      // followed by a constraint expression.\n      // foo\u003d4,Pn\n      String[] splitted \u003d specStr.split(\n          String.valueOf(EXPRESSION_VAL_DELIM), 2);\n      if (splitted.length !\u003d 2) {\n        throw new PlacementConstraintParseException(\n            \"Unexpected placement constraint expression \" + specStr);\n      }\n\n      String tagAlloc \u003d splitted[0];\n      SourceTags st \u003d SourceTags.parseFrom(tagAlloc);\n      String exprs \u003d splitted[1];\n      AbstractConstraint constraint \u003d\n          PlacementConstraintParser.parseExpression(exprs);\n\n      result.put(st, constraint.build());\n    }\n\n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/src/main/java/org/apache/hadoop/yarn/util/constraint/PlacementConstraintParser.java"
    }
  }
}