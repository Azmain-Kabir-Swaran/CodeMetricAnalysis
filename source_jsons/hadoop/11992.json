{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "convertTemporaryToRbw",
  "functionId": "convertTemporaryToRbw___b-ExtendedBlock(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 1598,
  "functionEndLine": 1662,
  "numCommitsSeen": 230,
  "timeTaken": 12517,
  "changeHistory": [
    "d3b595157256e198c4340d555e14ad6144f2eaa1",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
    "86c9862bec0248d671e657aa56094a2919b8ac14",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
    "d1fa58292e87bc29b4ef1278368c2be938a0afc4",
    "fba994ffe20d387e8ed875e727fc3d93f7097101",
    "f39f8c57344ede533ca4363c98230f3a0c401a76",
    "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "bc13dfb1426944ce45293cb8f444239a7406762c",
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "d3b595157256e198c4340d555e14ad6144f2eaa1": "Ybodychange",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": "Ybodychange",
    "86c9862bec0248d671e657aa56094a2919b8ac14": "Ybodychange",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": "Ymultichange(Ymodifierchange,Ybodychange)",
    "d1fa58292e87bc29b4ef1278368c2be938a0afc4": "Ybodychange",
    "fba994ffe20d387e8ed875e727fc3d93f7097101": "Ybodychange",
    "f39f8c57344ede533ca4363c98230f3a0c401a76": "Ybodychange",
    "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "bc13dfb1426944ce45293cb8f444239a7406762c": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange)",
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d3b595157256e198c4340d555e14ad6144f2eaa1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15242. Add metrics for operations hold lock times of FsDatasetImpl. Contributed by Xiaoqiao He.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\nReviewed-by: Inigo Goiri \u003cinigoiri@apache.org\u003e\n",
      "commitDate": "01/04/20 4:36 PM",
      "commitName": "d3b595157256e198c4340d555e14ad6144f2eaa1",
      "commitAuthor": "He Xiaoqiao",
      "commitDateOld": "11/02/20 8:00 AM",
      "commitNameOld": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 50.32,
      "commitsBetweenForRepo": 174,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,65 @@\n   public ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n-\n+    long startTimeMs \u003d Time.monotonicNow();\n     try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       final long blockId \u003d b.getBlockId();\n       final long expectedGs \u003d b.getGenerationStamp();\n       final long visible \u003d b.getNumBytes();\n       LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n           + visible);\n \n       final ReplicaInfo temp;\n       {\n         // get replica\n         final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n         if (r \u003d\u003d null) {\n           throw new ReplicaNotFoundException(\n               ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n         }\n         // check the replica\u0027s state\n         if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n           throw new ReplicaAlreadyExistsException(\n               \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n         }\n         temp \u003d r;\n       }\n       // check generation stamp\n       if (temp.getGenerationStamp() !\u003d expectedGs) {\n         throw new ReplicaAlreadyExistsException(\n             \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                 + \", temp\u003d\" + temp);\n       }\n \n       // TODO: check writer?\n       // set writer to the current thread\n       // temp.setWriter(Thread.currentThread());\n \n       // check length\n       final long numBytes \u003d temp.getNumBytes();\n       if (numBytes \u003c visible) {\n         throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n             + visible + \", temp\u003d\" + temp);\n       }\n       // check volume\n       final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n       if (v \u003d\u003d null) {\n         throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n       }\n \n       final ReplicaInPipeline rbw \u003d v.convertTemporaryToRbw(b, temp);\n \n       if(rbw.getState() !\u003d ReplicaState.RBW) {\n         throw new IOException(\"Expected replica state: \" + ReplicaState.RBW\n             + \" obtained \" + rbw.getState() + \" for converting block \"\n             + b.getBlockId());\n       }\n       // overwrite the RBW in the volume map\n       volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());\n       return rbw;\n+    } finally {\n+      if (dataNodeMetrics !\u003d null) {\n+        long convertTemporaryToRbwMs \u003d Time.monotonicNow() - startTimeMs;\n+        dataNodeMetrics.addConvertTemporaryToRbwOp(convertTemporaryToRbwMs);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    long startTimeMs \u003d Time.monotonicNow();\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      final long blockId \u003d b.getBlockId();\n      final long expectedGs \u003d b.getGenerationStamp();\n      final long visible \u003d b.getNumBytes();\n      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n          + visible);\n\n      final ReplicaInfo temp;\n      {\n        // get replica\n        final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n        if (r \u003d\u003d null) {\n          throw new ReplicaNotFoundException(\n              ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n        }\n        // check the replica\u0027s state\n        if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n          throw new ReplicaAlreadyExistsException(\n              \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n        }\n        temp \u003d r;\n      }\n      // check generation stamp\n      if (temp.getGenerationStamp() !\u003d expectedGs) {\n        throw new ReplicaAlreadyExistsException(\n            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                + \", temp\u003d\" + temp);\n      }\n\n      // TODO: check writer?\n      // set writer to the current thread\n      // temp.setWriter(Thread.currentThread());\n\n      // check length\n      final long numBytes \u003d temp.getNumBytes();\n      if (numBytes \u003c visible) {\n        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n            + visible + \", temp\u003d\" + temp);\n      }\n      // check volume\n      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n      if (v \u003d\u003d null) {\n        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n      }\n\n      final ReplicaInPipeline rbw \u003d v.convertTemporaryToRbw(b, temp);\n\n      if(rbw.getState() !\u003d ReplicaState.RBW) {\n        throw new IOException(\"Expected replica state: \" + ReplicaState.RBW\n            + \" obtained \" + rbw.getState() + \" for converting block \"\n            + b.getBlockId());\n      }\n      // overwrite the RBW in the volume map\n      volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());\n      return rbw;\n    } finally {\n      if (dataNodeMetrics !\u003d null) {\n        long convertTemporaryToRbwMs \u003d Time.monotonicNow() - startTimeMs;\n        dataNodeMetrics.addConvertTemporaryToRbwOp(convertTemporaryToRbwMs);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15150. Introduce read write lock to Datanode. Contributed Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/02/20 8:00 AM",
      "commitName": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "28/01/20 10:10 AM",
      "commitNameOld": "1839c467f60cbb8592d446694ec3d7710cda5142",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n \n-    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       final long blockId \u003d b.getBlockId();\n       final long expectedGs \u003d b.getGenerationStamp();\n       final long visible \u003d b.getNumBytes();\n       LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n           + visible);\n \n       final ReplicaInfo temp;\n       {\n         // get replica\n         final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n         if (r \u003d\u003d null) {\n           throw new ReplicaNotFoundException(\n               ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n         }\n         // check the replica\u0027s state\n         if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n           throw new ReplicaAlreadyExistsException(\n               \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n         }\n         temp \u003d r;\n       }\n       // check generation stamp\n       if (temp.getGenerationStamp() !\u003d expectedGs) {\n         throw new ReplicaAlreadyExistsException(\n             \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                 + \", temp\u003d\" + temp);\n       }\n \n       // TODO: check writer?\n       // set writer to the current thread\n       // temp.setWriter(Thread.currentThread());\n \n       // check length\n       final long numBytes \u003d temp.getNumBytes();\n       if (numBytes \u003c visible) {\n         throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n             + visible + \", temp\u003d\" + temp);\n       }\n       // check volume\n       final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n       if (v \u003d\u003d null) {\n         throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n       }\n \n       final ReplicaInPipeline rbw \u003d v.convertTemporaryToRbw(b, temp);\n \n       if(rbw.getState() !\u003d ReplicaState.RBW) {\n         throw new IOException(\"Expected replica state: \" + ReplicaState.RBW\n             + \" obtained \" + rbw.getState() + \" for converting block \"\n             + b.getBlockId());\n       }\n       // overwrite the RBW in the volume map\n       volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());\n       return rbw;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      final long blockId \u003d b.getBlockId();\n      final long expectedGs \u003d b.getGenerationStamp();\n      final long visible \u003d b.getNumBytes();\n      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n          + visible);\n\n      final ReplicaInfo temp;\n      {\n        // get replica\n        final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n        if (r \u003d\u003d null) {\n          throw new ReplicaNotFoundException(\n              ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n        }\n        // check the replica\u0027s state\n        if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n          throw new ReplicaAlreadyExistsException(\n              \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n        }\n        temp \u003d r;\n      }\n      // check generation stamp\n      if (temp.getGenerationStamp() !\u003d expectedGs) {\n        throw new ReplicaAlreadyExistsException(\n            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                + \", temp\u003d\" + temp);\n      }\n\n      // TODO: check writer?\n      // set writer to the current thread\n      // temp.setWriter(Thread.currentThread());\n\n      // check length\n      final long numBytes \u003d temp.getNumBytes();\n      if (numBytes \u003c visible) {\n        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n            + visible + \", temp\u003d\" + temp);\n      }\n      // check volume\n      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n      if (v \u003d\u003d null) {\n        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n      }\n\n      final ReplicaInPipeline rbw \u003d v.convertTemporaryToRbw(b, temp);\n\n      if(rbw.getState() !\u003d ReplicaState.RBW) {\n        throw new IOException(\"Expected replica state: \" + ReplicaState.RBW\n            + \" obtained \" + rbw.getState() + \" for converting block \"\n            + b.getBlockId());\n      }\n      // overwrite the RBW in the volume map\n      volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());\n      return rbw;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "86c9862bec0248d671e657aa56094a2919b8ac14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "13/09/16 12:54 PM",
      "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/09/16 6:22 PM",
      "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,60 @@\n   public ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n+\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       final long blockId \u003d b.getBlockId();\n       final long expectedGs \u003d b.getGenerationStamp();\n       final long visible \u003d b.getNumBytes();\n       LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n           + visible);\n \n-      final ReplicaInPipeline temp;\n-\n-      // get replica\n-      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n-      if (r \u003d\u003d null) {\n-        throw new ReplicaNotFoundException(\n-            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n+      final ReplicaInfo temp;\n+      {\n+        // get replica\n+        final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n+        if (r \u003d\u003d null) {\n+          throw new ReplicaNotFoundException(\n+              ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n+        }\n+        // check the replica\u0027s state\n+        if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n+          throw new ReplicaAlreadyExistsException(\n+              \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n+        }\n+        temp \u003d r;\n       }\n-      // check the replica\u0027s state\n-      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n-        throw new ReplicaAlreadyExistsException(\n-            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n-      }\n-      temp \u003d (ReplicaInPipeline) r;\n-\n       // check generation stamp\n       if (temp.getGenerationStamp() !\u003d expectedGs) {\n         throw new ReplicaAlreadyExistsException(\n             \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                 + \", temp\u003d\" + temp);\n       }\n \n       // TODO: check writer?\n       // set writer to the current thread\n       // temp.setWriter(Thread.currentThread());\n \n       // check length\n       final long numBytes \u003d temp.getNumBytes();\n       if (numBytes \u003c visible) {\n         throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n             + visible + \", temp\u003d\" + temp);\n       }\n       // check volume\n       final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n       if (v \u003d\u003d null) {\n         throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n       }\n \n-      // move block files to the rbw directory\n-      BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n-      final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(),\n-          bpslice.getRbwDir());\n-      // create RBW\n-      final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n-          blockId, numBytes, expectedGs,\n-          v, dest.getParentFile(), Thread.currentThread(), 0);\n-      rbw.setBytesAcked(visible);\n+      final ReplicaInPipeline rbw \u003d v.convertTemporaryToRbw(b, temp);\n+\n+      if(rbw.getState() !\u003d ReplicaState.RBW) {\n+        throw new IOException(\"Expected replica state: \" + ReplicaState.RBW\n+            + \" obtained \" + rbw.getState() + \" for converting block \"\n+            + b.getBlockId());\n+      }\n       // overwrite the RBW in the volume map\n-      volumeMap.add(b.getBlockPoolId(), rbw);\n+      volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());\n       return rbw;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      final long blockId \u003d b.getBlockId();\n      final long expectedGs \u003d b.getGenerationStamp();\n      final long visible \u003d b.getNumBytes();\n      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n          + visible);\n\n      final ReplicaInfo temp;\n      {\n        // get replica\n        final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n        if (r \u003d\u003d null) {\n          throw new ReplicaNotFoundException(\n              ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n        }\n        // check the replica\u0027s state\n        if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n          throw new ReplicaAlreadyExistsException(\n              \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n        }\n        temp \u003d r;\n      }\n      // check generation stamp\n      if (temp.getGenerationStamp() !\u003d expectedGs) {\n        throw new ReplicaAlreadyExistsException(\n            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                + \", temp\u003d\" + temp);\n      }\n\n      // TODO: check writer?\n      // set writer to the current thread\n      // temp.setWriter(Thread.currentThread());\n\n      // check length\n      final long numBytes \u003d temp.getNumBytes();\n      if (numBytes \u003c visible) {\n        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n            + visible + \", temp\u003d\" + temp);\n      }\n      // check volume\n      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n      if (v \u003d\u003d null) {\n        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n      }\n\n      final ReplicaInPipeline rbw \u003d v.convertTemporaryToRbw(b, temp);\n\n      if(rbw.getState() !\u003d ReplicaState.RBW) {\n        throw new IOException(\"Expected replica state: \" + ReplicaState.RBW\n            + \" obtained \" + rbw.getState() + \" for converting block \"\n            + b.getBlockId());\n      }\n      // overwrite the RBW in the volume map\n      volumeMap.add(b.getBlockPoolId(), rbw.getReplicaInfo());\n      return rbw;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
      "commitDate": "08/08/16 12:02 PM",
      "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
          "commitDate": "08/08/16 12:02 PM",
          "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "08/07/16 7:40 PM",
          "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 30.68,
          "commitsBetweenForRepo": 320,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,61 @@\n-  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n+  public ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n-    final long blockId \u003d b.getBlockId();\n-    final long expectedGs \u003d b.getGenerationStamp();\n-    final long visible \u003d b.getNumBytes();\n-    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n-        + visible);\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+      final long blockId \u003d b.getBlockId();\n+      final long expectedGs \u003d b.getGenerationStamp();\n+      final long visible \u003d b.getNumBytes();\n+      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n+          + visible);\n \n-    final ReplicaInPipeline temp;\n-    {\n+      final ReplicaInPipeline temp;\n+\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n-      temp \u003d (ReplicaInPipeline)r;\n-    }\n-    // check generation stamp\n-    if (temp.getGenerationStamp() !\u003d expectedGs) {\n-      throw new ReplicaAlreadyExistsException(\n-          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n-          + \", temp\u003d\" + temp);\n-    }\n+      temp \u003d (ReplicaInPipeline) r;\n \n-    // TODO: check writer?\n-    // set writer to the current thread\n-    // temp.setWriter(Thread.currentThread());\n+      // check generation stamp\n+      if (temp.getGenerationStamp() !\u003d expectedGs) {\n+        throw new ReplicaAlreadyExistsException(\n+            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n+                + \", temp\u003d\" + temp);\n+      }\n \n-    // check length\n-    final long numBytes \u003d temp.getNumBytes();\n-    if (numBytes \u003c visible) {\n-      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n-          + visible + \", temp\u003d\" + temp);\n+      // TODO: check writer?\n+      // set writer to the current thread\n+      // temp.setWriter(Thread.currentThread());\n+\n+      // check length\n+      final long numBytes \u003d temp.getNumBytes();\n+      if (numBytes \u003c visible) {\n+        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n+            + visible + \", temp\u003d\" + temp);\n+      }\n+      // check volume\n+      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n+      if (v \u003d\u003d null) {\n+        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n+      }\n+\n+      // move block files to the rbw directory\n+      BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n+      final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(),\n+          bpslice.getRbwDir());\n+      // create RBW\n+      final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n+          blockId, numBytes, expectedGs,\n+          v, dest.getParentFile(), Thread.currentThread(), 0);\n+      rbw.setBytesAcked(visible);\n+      // overwrite the RBW in the volume map\n+      volumeMap.add(b.getBlockPoolId(), rbw);\n+      return rbw;\n     }\n-    // check volume\n-    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n-    if (v \u003d\u003d null) {\n-      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n-    }\n-    \n-    // move block files to the rbw directory\n-    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n-    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n-        bpslice.getRbwDir());\n-    // create RBW\n-    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n-        blockId, numBytes, expectedGs,\n-        v, dest.getParentFile(), Thread.currentThread(), 0);\n-    rbw.setBytesAcked(visible);\n-    // overwrite the RBW in the volume map\n-    volumeMap.add(b.getBlockPoolId(), rbw);\n-    return rbw;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      final long blockId \u003d b.getBlockId();\n      final long expectedGs \u003d b.getGenerationStamp();\n      final long visible \u003d b.getNumBytes();\n      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n          + visible);\n\n      final ReplicaInPipeline temp;\n\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline) r;\n\n      // check generation stamp\n      if (temp.getGenerationStamp() !\u003d expectedGs) {\n        throw new ReplicaAlreadyExistsException(\n            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                + \", temp\u003d\" + temp);\n      }\n\n      // TODO: check writer?\n      // set writer to the current thread\n      // temp.setWriter(Thread.currentThread());\n\n      // check length\n      final long numBytes \u003d temp.getNumBytes();\n      if (numBytes \u003c visible) {\n        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n            + visible + \", temp\u003d\" + temp);\n      }\n      // check volume\n      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n      if (v \u003d\u003d null) {\n        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n      }\n\n      // move block files to the rbw directory\n      BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n      final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(),\n          bpslice.getRbwDir());\n      // create RBW\n      final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n          blockId, numBytes, expectedGs,\n          v, dest.getParentFile(), Thread.currentThread(), 0);\n      rbw.setBytesAcked(visible);\n      // overwrite the RBW in the volume map\n      volumeMap.add(b.getBlockPoolId(), rbw);\n      return rbw;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
          "commitDate": "08/08/16 12:02 PM",
          "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "08/07/16 7:40 PM",
          "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 30.68,
          "commitsBetweenForRepo": 320,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,61 @@\n-  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n+  public ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n-    final long blockId \u003d b.getBlockId();\n-    final long expectedGs \u003d b.getGenerationStamp();\n-    final long visible \u003d b.getNumBytes();\n-    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n-        + visible);\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+      final long blockId \u003d b.getBlockId();\n+      final long expectedGs \u003d b.getGenerationStamp();\n+      final long visible \u003d b.getNumBytes();\n+      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n+          + visible);\n \n-    final ReplicaInPipeline temp;\n-    {\n+      final ReplicaInPipeline temp;\n+\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n-      temp \u003d (ReplicaInPipeline)r;\n-    }\n-    // check generation stamp\n-    if (temp.getGenerationStamp() !\u003d expectedGs) {\n-      throw new ReplicaAlreadyExistsException(\n-          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n-          + \", temp\u003d\" + temp);\n-    }\n+      temp \u003d (ReplicaInPipeline) r;\n \n-    // TODO: check writer?\n-    // set writer to the current thread\n-    // temp.setWriter(Thread.currentThread());\n+      // check generation stamp\n+      if (temp.getGenerationStamp() !\u003d expectedGs) {\n+        throw new ReplicaAlreadyExistsException(\n+            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n+                + \", temp\u003d\" + temp);\n+      }\n \n-    // check length\n-    final long numBytes \u003d temp.getNumBytes();\n-    if (numBytes \u003c visible) {\n-      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n-          + visible + \", temp\u003d\" + temp);\n+      // TODO: check writer?\n+      // set writer to the current thread\n+      // temp.setWriter(Thread.currentThread());\n+\n+      // check length\n+      final long numBytes \u003d temp.getNumBytes();\n+      if (numBytes \u003c visible) {\n+        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n+            + visible + \", temp\u003d\" + temp);\n+      }\n+      // check volume\n+      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n+      if (v \u003d\u003d null) {\n+        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n+      }\n+\n+      // move block files to the rbw directory\n+      BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n+      final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(),\n+          bpslice.getRbwDir());\n+      // create RBW\n+      final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n+          blockId, numBytes, expectedGs,\n+          v, dest.getParentFile(), Thread.currentThread(), 0);\n+      rbw.setBytesAcked(visible);\n+      // overwrite the RBW in the volume map\n+      volumeMap.add(b.getBlockPoolId(), rbw);\n+      return rbw;\n     }\n-    // check volume\n-    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n-    if (v \u003d\u003d null) {\n-      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n-    }\n-    \n-    // move block files to the rbw directory\n-    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n-    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n-        bpslice.getRbwDir());\n-    // create RBW\n-    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n-        blockId, numBytes, expectedGs,\n-        v, dest.getParentFile(), Thread.currentThread(), 0);\n-    rbw.setBytesAcked(visible);\n-    // overwrite the RBW in the volume map\n-    volumeMap.add(b.getBlockPoolId(), rbw);\n-    return rbw;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      final long blockId \u003d b.getBlockId();\n      final long expectedGs \u003d b.getGenerationStamp();\n      final long visible \u003d b.getNumBytes();\n      LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n          + visible);\n\n      final ReplicaInPipeline temp;\n\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline) r;\n\n      // check generation stamp\n      if (temp.getGenerationStamp() !\u003d expectedGs) {\n        throw new ReplicaAlreadyExistsException(\n            \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n                + \", temp\u003d\" + temp);\n      }\n\n      // TODO: check writer?\n      // set writer to the current thread\n      // temp.setWriter(Thread.currentThread());\n\n      // check length\n      final long numBytes \u003d temp.getNumBytes();\n      if (numBytes \u003c visible) {\n        throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n            + visible + \", temp\u003d\" + temp);\n      }\n      // check volume\n      final FsVolumeImpl v \u003d (FsVolumeImpl) temp.getVolume();\n      if (v \u003d\u003d null) {\n        throw new IOException(\"r.getVolume() \u003d null, temp\u003d\" + temp);\n      }\n\n      // move block files to the rbw directory\n      BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n      final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(),\n          bpslice.getRbwDir());\n      // create RBW\n      final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n          blockId, numBytes, expectedGs,\n          v, dest.getParentFile(), Thread.currentThread(), 0);\n      rbw.setBytesAcked(visible);\n      // overwrite the RBW in the volume map\n      volumeMap.add(b.getBlockPoolId(), rbw);\n      return rbw;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "d1fa58292e87bc29b4ef1278368c2be938a0afc4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6898. DN must reserve space for a full block when an RBW block is created. (Contributed by Arpit Agarwal)\n",
      "commitDate": "06/09/14 9:04 PM",
      "commitName": "d1fa58292e87bc29b4ef1278368c2be938a0afc4",
      "commitAuthor": "arp",
      "commitDateOld": "29/08/14 1:00 PM",
      "commitNameOld": "7eab2a29a5706ce10912c12fa225ef6b27a82cbe",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 8.34,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n     LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n         + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n     final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n-        v, dest.getParentFile(), Thread.currentThread());\n+        v, dest.getParentFile(), Thread.currentThread(), 0);\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n        + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread(), 0);\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "fba994ffe20d387e8ed875e727fc3d93f7097101": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5648. Get rid of FsDatasetImpl#perVolumeReplicaMap.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1550357 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/12/13 11:01 PM",
      "commitName": "fba994ffe20d387e8ed875e727fc3d93f7097101",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "03/12/13 8:30 AM",
      "commitNameOld": "a1aa1836fb6831c25efe326cdfdc014370cf5957",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.6,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,59 @@\n   public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n     LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n         + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n     final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n-    perVolumeReplicaMap.get(v.getStorageID()).add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n        + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "f39f8c57344ede533ca4363c98230f3a0c401a76": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5401. Fix NPE in Directory Scanner.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1535158 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/10/13 1:28 PM",
      "commitName": "f39f8c57344ede533ca4363c98230f3a0c401a76",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/10/13 6:28 PM",
      "commitNameOld": "01f37e42f050207b7659bf74e2484cf8bdae2d89",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n     LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n         + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n     final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n-    perVolumeReplicaMap.get(v).add(b.getBlockPoolId(), rbw);\n+    perVolumeReplicaMap.get(v.getStorageID()).add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n        + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    perVolumeReplicaMap.get(v.getStorageID()).add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4988. Datanode must support all the volumes as individual storages.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1526969 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 9:05 AM",
      "commitName": "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "10/09/13 11:30 PM",
      "commitNameOld": "b2976af14034c6e2a7e9964535b9f363bfc31150",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 16.4,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n   public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n     LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n         + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n     final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n+    perVolumeReplicaMap.get(v).add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n        + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    perVolumeReplicaMap.get(v).add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "13/09/12 4:48 PM",
      "commitNameOld": "86635168feaaf9a8f20d01b5fd6c1b6fbe98c1ea",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 44.97,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n-    LOG.info(\"Convert replica \" + b\n-        + \" from Temporary to RBW, visible length\u003d\" + visible);\n+    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n+        + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n     final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert \" + b + \" from Temporary to RBW, visible length\u003d\"\n        + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "bc13dfb1426944ce45293cb8f444239a7406762c": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/12 10:38 AM",
      "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n+  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n-    DataNode.LOG.info(\"Convert replica \" + b\n+    LOG.info(\"Convert replica \" + b\n         + \" from Temporary to RBW, visible length\u003d\" + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n-    final FSVolume v \u003d (FSVolume)temp.getVolume();\n+    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
            "oldMethodName": "convertTemporaryToRbw",
            "newMethodName": "convertTemporaryToRbw"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n+  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n-    DataNode.LOG.info(\"Convert replica \" + b\n+    LOG.info(\"Convert replica \" + b\n         + \" from Temporary to RBW, visible length\u003d\" + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n-    final FSVolume v \u003d (FSVolume)temp.getVolume();\n+    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "ReplicaInPipelineInterface",
            "newValue": "ReplicaInPipeline"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n+  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n-    DataNode.LOG.info(\"Convert replica \" + b\n+    LOG.info(\"Convert replica \" + b\n         + \" from Temporary to RBW, visible length\u003d\" + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n-    final FSVolume v \u003d (FSVolume)temp.getVolume();\n+    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ReplicaInPipeline convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FsVolumeImpl v \u003d (FsVolumeImpl)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2887. FSVolume, is a part of FSDatasetInterface implementation, should not be referred outside FSDataset.  A new FSVolumeInterface is defined.  The BlockVolumeChoosingPolicy.chooseVolume(..) method signature is also updated.  (szetszwo)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1242087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/02/12 12:58 PM",
      "commitName": "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/02/12 11:26 PM",
      "commitNameOld": "38ad4b503686a0d18cb2d42ffdecf06f0ba7b98f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 5.56,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n       final ExtendedBlock b) throws IOException {\n     final long blockId \u003d b.getBlockId();\n     final long expectedGs \u003d b.getGenerationStamp();\n     final long visible \u003d b.getNumBytes();\n     DataNode.LOG.info(\"Convert replica \" + b\n         + \" from Temporary to RBW, visible length\u003d\" + visible);\n \n     final ReplicaInPipeline temp;\n     {\n       // get replica\n       final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n       if (r \u003d\u003d null) {\n         throw new ReplicaNotFoundException(\n             ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n       }\n       // check the replica\u0027s state\n       if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n         throw new ReplicaAlreadyExistsException(\n             \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n       }\n       temp \u003d (ReplicaInPipeline)r;\n     }\n     // check generation stamp\n     if (temp.getGenerationStamp() !\u003d expectedGs) {\n       throw new ReplicaAlreadyExistsException(\n           \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n           + \", temp\u003d\" + temp);\n     }\n \n     // TODO: check writer?\n     // set writer to the current thread\n     // temp.setWriter(Thread.currentThread());\n \n     // check length\n     final long numBytes \u003d temp.getNumBytes();\n     if (numBytes \u003c visible) {\n       throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n           + visible + \", temp\u003d\" + temp);\n     }\n     // check volume\n-    final FSVolume v \u003d temp.getVolume();\n+    final FSVolume v \u003d (FSVolume)temp.getVolume();\n     if (v \u003d\u003d null) {\n       throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n     }\n     \n     // move block files to the rbw directory\n     BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n     final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n         bpslice.getRbwDir());\n     // create RBW\n     final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n         blockId, numBytes, expectedGs,\n         v, dest.getParentFile(), Thread.currentThread());\n     rbw.setBytesAcked(visible);\n     // overwrite the RBW in the volume map\n     volumeMap.add(b.getBlockPoolId(), rbw);\n     return rbw;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    DataNode.LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FSVolume v \u003d (FSVolume)temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    DataNode.LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FSVolume v \u003d temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    DataNode.LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FSVolume v \u003d temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,59 @@\n+  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n+      final ExtendedBlock b) throws IOException {\n+    final long blockId \u003d b.getBlockId();\n+    final long expectedGs \u003d b.getGenerationStamp();\n+    final long visible \u003d b.getNumBytes();\n+    DataNode.LOG.info(\"Convert replica \" + b\n+        + \" from Temporary to RBW, visible length\u003d\" + visible);\n+\n+    final ReplicaInPipeline temp;\n+    {\n+      // get replica\n+      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n+      if (r \u003d\u003d null) {\n+        throw new ReplicaNotFoundException(\n+            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n+      }\n+      // check the replica\u0027s state\n+      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n+        throw new ReplicaAlreadyExistsException(\n+            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n+      }\n+      temp \u003d (ReplicaInPipeline)r;\n+    }\n+    // check generation stamp\n+    if (temp.getGenerationStamp() !\u003d expectedGs) {\n+      throw new ReplicaAlreadyExistsException(\n+          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n+          + \", temp\u003d\" + temp);\n+    }\n+\n+    // TODO: check writer?\n+    // set writer to the current thread\n+    // temp.setWriter(Thread.currentThread());\n+\n+    // check length\n+    final long numBytes \u003d temp.getNumBytes();\n+    if (numBytes \u003c visible) {\n+      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n+          + visible + \", temp\u003d\" + temp);\n+    }\n+    // check volume\n+    final FSVolume v \u003d temp.getVolume();\n+    if (v \u003d\u003d null) {\n+      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n+    }\n+    \n+    // move block files to the rbw directory\n+    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n+    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n+        bpslice.getRbwDir());\n+    // create RBW\n+    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n+        blockId, numBytes, expectedGs,\n+        v, dest.getParentFile(), Thread.currentThread());\n+    rbw.setBytesAcked(visible);\n+    // overwrite the RBW in the volume map\n+    volumeMap.add(b.getBlockPoolId(), rbw);\n+    return rbw;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInPipelineInterface convertTemporaryToRbw(\n      final ExtendedBlock b) throws IOException {\n    final long blockId \u003d b.getBlockId();\n    final long expectedGs \u003d b.getGenerationStamp();\n    final long visible \u003d b.getNumBytes();\n    DataNode.LOG.info(\"Convert replica \" + b\n        + \" from Temporary to RBW, visible length\u003d\" + visible);\n\n    final ReplicaInPipeline temp;\n    {\n      // get replica\n      final ReplicaInfo r \u003d volumeMap.get(b.getBlockPoolId(), blockId);\n      if (r \u003d\u003d null) {\n        throw new ReplicaNotFoundException(\n            ReplicaNotFoundException.NON_EXISTENT_REPLICA + b);\n      }\n      // check the replica\u0027s state\n      if (r.getState() !\u003d ReplicaState.TEMPORARY) {\n        throw new ReplicaAlreadyExistsException(\n            \"r.getState() !\u003d ReplicaState.TEMPORARY, r\u003d\" + r);\n      }\n      temp \u003d (ReplicaInPipeline)r;\n    }\n    // check generation stamp\n    if (temp.getGenerationStamp() !\u003d expectedGs) {\n      throw new ReplicaAlreadyExistsException(\n          \"temp.getGenerationStamp() !\u003d expectedGs \u003d \" + expectedGs\n          + \", temp\u003d\" + temp);\n    }\n\n    // TODO: check writer?\n    // set writer to the current thread\n    // temp.setWriter(Thread.currentThread());\n\n    // check length\n    final long numBytes \u003d temp.getNumBytes();\n    if (numBytes \u003c visible) {\n      throw new IOException(numBytes + \" \u003d numBytes \u003c visible \u003d \"\n          + visible + \", temp\u003d\" + temp);\n    }\n    // check volume\n    final FSVolume v \u003d temp.getVolume();\n    if (v \u003d\u003d null) {\n      throw new IOException(\"r.getVolume() \u003d null, temp\u003d\"  + temp);\n    }\n    \n    // move block files to the rbw directory\n    BlockPoolSlice bpslice \u003d v.getBlockPoolSlice(b.getBlockPoolId());\n    final File dest \u003d moveBlockFiles(b.getLocalBlock(), temp.getBlockFile(), \n        bpslice.getRbwDir());\n    // create RBW\n    final ReplicaBeingWritten rbw \u003d new ReplicaBeingWritten(\n        blockId, numBytes, expectedGs,\n        v, dest.getParentFile(), Thread.currentThread());\n    rbw.setBytesAcked(visible);\n    // overwrite the RBW in the volume map\n    volumeMap.add(b.getBlockPoolId(), rbw);\n    return rbw;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
    }
  }
}