{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineV2ClientImpl.java",
  "functionName": "setTimelineDelegationToken",
  "functionId": "setTimelineDelegationToken___delegationToken-Token__collectorAddr-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
  "functionStartLine": 196,
  "functionEndLine": 241,
  "numCommitsSeen": 11,
  "timeTaken": 1452,
  "changeHistory": [
    "16ba4f544f13d614c1ebd6101ee14f7714e0fc54",
    "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3"
  ],
  "changeHistoryShort": {
    "16ba4f544f13d614c1ebd6101ee14f7714e0fc54": "Ybodychange",
    "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "16ba4f544f13d614c1ebd6101ee14f7714e0fc54": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6838. Addendum to fix code comment\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "16ba4f544f13d614c1ebd6101ee14f7714e0fc54",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,46 @@\n   private void setTimelineDelegationToken(Token delegationToken,\n       String collectorAddr) {\n     // Checks below are to ensure that an invalid token is not updated in UGI.\n     // This is required because timeline token is set via a public API.\n     if (!delegationToken.getKind().equals(\n         TimelineDelegationTokenIdentifier.KIND_NAME.toString())) {\n       LOG.warn(\"Timeline token to be updated should be of kind \" +\n           TimelineDelegationTokenIdentifier.KIND_NAME);\n       return;\n     }\n     if (collectorAddr \u003d\u003d null || collectorAddr.isEmpty()) {\n       collectorAddr \u003d timelineServiceAddress;\n     }\n-    // Token need not be updated if either address or token service does not\n-    // exist.\n+    // Token need not be updated if both address and token service do not exist.\n     String service \u003d delegationToken.getService();\n     if ((service \u003d\u003d null || service.isEmpty()) \u0026\u0026\n         (collectorAddr \u003d\u003d null || collectorAddr.isEmpty())) {\n       LOG.warn(\"Timeline token does not have service and timeline service \" +\n           \"address is not yet set. Not updating the token\");\n       return;\n     }\n     // No need to update a duplicate token.\n     if (currentTimelineToken !\u003d null \u0026\u0026\n         currentTimelineToken.equals(delegationToken)) {\n       return;\n     }\n     currentTimelineToken \u003d delegationToken;\n     // Convert the token, sanitize the token service and add it to UGI.\n     org.apache.hadoop.security.token.\n         Token\u003cTimelineDelegationTokenIdentifier\u003e timelineToken \u003d\n             new org.apache.hadoop.security.token.\n             Token\u003cTimelineDelegationTokenIdentifier\u003e(\n                 delegationToken.getIdentifier().array(),\n                 delegationToken.getPassword().array(),\n                 new Text(delegationToken.getKind()),\n                 service \u003d\u003d null ? new Text() : new Text(service));\n     // Prefer timeline service address over service coming in the token for\n     // updating the token service.\n     InetSocketAddress serviceAddr \u003d\n         (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) ?\n         NetUtils.createSocketAddr(collectorAddr) :\n         SecurityUtil.getTokenServiceAddr(timelineToken);\n     SecurityUtil.setTokenService(timelineToken, serviceAddr);\n     authUgi.addToken(timelineToken);\n     LOG.info(\"Updated timeline delegation token \" + timelineToken);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setTimelineDelegationToken(Token delegationToken,\n      String collectorAddr) {\n    // Checks below are to ensure that an invalid token is not updated in UGI.\n    // This is required because timeline token is set via a public API.\n    if (!delegationToken.getKind().equals(\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString())) {\n      LOG.warn(\"Timeline token to be updated should be of kind \" +\n          TimelineDelegationTokenIdentifier.KIND_NAME);\n      return;\n    }\n    if (collectorAddr \u003d\u003d null || collectorAddr.isEmpty()) {\n      collectorAddr \u003d timelineServiceAddress;\n    }\n    // Token need not be updated if both address and token service do not exist.\n    String service \u003d delegationToken.getService();\n    if ((service \u003d\u003d null || service.isEmpty()) \u0026\u0026\n        (collectorAddr \u003d\u003d null || collectorAddr.isEmpty())) {\n      LOG.warn(\"Timeline token does not have service and timeline service \" +\n          \"address is not yet set. Not updating the token\");\n      return;\n    }\n    // No need to update a duplicate token.\n    if (currentTimelineToken !\u003d null \u0026\u0026\n        currentTimelineToken.equals(delegationToken)) {\n      return;\n    }\n    currentTimelineToken \u003d delegationToken;\n    // Convert the token, sanitize the token service and add it to UGI.\n    org.apache.hadoop.security.token.\n        Token\u003cTimelineDelegationTokenIdentifier\u003e timelineToken \u003d\n            new org.apache.hadoop.security.token.\n            Token\u003cTimelineDelegationTokenIdentifier\u003e(\n                delegationToken.getIdentifier().array(),\n                delegationToken.getPassword().array(),\n                new Text(delegationToken.getKind()),\n                service \u003d\u003d null ? new Text() : new Text(service));\n    // Prefer timeline service address over service coming in the token for\n    // updating the token service.\n    InetSocketAddress serviceAddr \u003d\n        (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) ?\n        NetUtils.createSocketAddr(collectorAddr) :\n        SecurityUtil.getTokenServiceAddr(timelineToken);\n    SecurityUtil.setTokenService(timelineToken, serviceAddr);\n    authUgi.addToken(timelineToken);\n    LOG.info(\"Updated timeline delegation token \" + timelineToken);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
      "extendedDetails": {}
    },
    "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-6838. [ATSv2 Security] Add timeline delegation token received in allocate response to UGI. Contributed by Varun Saxena\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,47 @@\n+  private void setTimelineDelegationToken(Token delegationToken,\n+      String collectorAddr) {\n+    // Checks below are to ensure that an invalid token is not updated in UGI.\n+    // This is required because timeline token is set via a public API.\n+    if (!delegationToken.getKind().equals(\n+        TimelineDelegationTokenIdentifier.KIND_NAME.toString())) {\n+      LOG.warn(\"Timeline token to be updated should be of kind \" +\n+          TimelineDelegationTokenIdentifier.KIND_NAME);\n+      return;\n+    }\n+    if (collectorAddr \u003d\u003d null || collectorAddr.isEmpty()) {\n+      collectorAddr \u003d timelineServiceAddress;\n+    }\n+    // Token need not be updated if either address or token service does not\n+    // exist.\n+    String service \u003d delegationToken.getService();\n+    if ((service \u003d\u003d null || service.isEmpty()) \u0026\u0026\n+        (collectorAddr \u003d\u003d null || collectorAddr.isEmpty())) {\n+      LOG.warn(\"Timeline token does not have service and timeline service \" +\n+          \"address is not yet set. Not updating the token\");\n+      return;\n+    }\n+    // No need to update a duplicate token.\n+    if (currentTimelineToken !\u003d null \u0026\u0026\n+        currentTimelineToken.equals(delegationToken)) {\n+      return;\n+    }\n+    currentTimelineToken \u003d delegationToken;\n+    // Convert the token, sanitize the token service and add it to UGI.\n+    org.apache.hadoop.security.token.\n+        Token\u003cTimelineDelegationTokenIdentifier\u003e timelineToken \u003d\n+            new org.apache.hadoop.security.token.\n+            Token\u003cTimelineDelegationTokenIdentifier\u003e(\n+                delegationToken.getIdentifier().array(),\n+                delegationToken.getPassword().array(),\n+                new Text(delegationToken.getKind()),\n+                service \u003d\u003d null ? new Text() : new Text(service));\n+    // Prefer timeline service address over service coming in the token for\n+    // updating the token service.\n+    InetSocketAddress serviceAddr \u003d\n+        (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) ?\n+        NetUtils.createSocketAddr(collectorAddr) :\n+        SecurityUtil.getTokenServiceAddr(timelineToken);\n+    SecurityUtil.setTokenService(timelineToken, serviceAddr);\n+    authUgi.addToken(timelineToken);\n+    LOG.info(\"Updated timeline delegation token \" + timelineToken);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void setTimelineDelegationToken(Token delegationToken,\n      String collectorAddr) {\n    // Checks below are to ensure that an invalid token is not updated in UGI.\n    // This is required because timeline token is set via a public API.\n    if (!delegationToken.getKind().equals(\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString())) {\n      LOG.warn(\"Timeline token to be updated should be of kind \" +\n          TimelineDelegationTokenIdentifier.KIND_NAME);\n      return;\n    }\n    if (collectorAddr \u003d\u003d null || collectorAddr.isEmpty()) {\n      collectorAddr \u003d timelineServiceAddress;\n    }\n    // Token need not be updated if either address or token service does not\n    // exist.\n    String service \u003d delegationToken.getService();\n    if ((service \u003d\u003d null || service.isEmpty()) \u0026\u0026\n        (collectorAddr \u003d\u003d null || collectorAddr.isEmpty())) {\n      LOG.warn(\"Timeline token does not have service and timeline service \" +\n          \"address is not yet set. Not updating the token\");\n      return;\n    }\n    // No need to update a duplicate token.\n    if (currentTimelineToken !\u003d null \u0026\u0026\n        currentTimelineToken.equals(delegationToken)) {\n      return;\n    }\n    currentTimelineToken \u003d delegationToken;\n    // Convert the token, sanitize the token service and add it to UGI.\n    org.apache.hadoop.security.token.\n        Token\u003cTimelineDelegationTokenIdentifier\u003e timelineToken \u003d\n            new org.apache.hadoop.security.token.\n            Token\u003cTimelineDelegationTokenIdentifier\u003e(\n                delegationToken.getIdentifier().array(),\n                delegationToken.getPassword().array(),\n                new Text(delegationToken.getKind()),\n                service \u003d\u003d null ? new Text() : new Text(service));\n    // Prefer timeline service address over service coming in the token for\n    // updating the token service.\n    InetSocketAddress serviceAddr \u003d\n        (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) ?\n        NetUtils.createSocketAddr(collectorAddr) :\n        SecurityUtil.getTokenServiceAddr(timelineToken);\n    SecurityUtil.setTokenService(timelineToken, serviceAddr);\n    authUgi.addToken(timelineToken);\n    LOG.info(\"Updated timeline delegation token \" + timelineToken);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java"
    }
  }
}