{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ObserverReadProxyProvider.java",
  "functionName": "invoke",
  "functionId": "invoke___proxy-Object__method-Method(modifiers-final)__args-Object[](modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
  "functionStartLine": 414,
  "functionEndLine": 530,
  "numCommitsSeen": 24,
  "timeTaken": 3925,
  "changeHistory": [
    "74780c22eb0a9e6025d0ff2502042cdd29f5af83",
    "483397c7f7e89108cb650b29b7c62e515319fa0d",
    "3e868078020756de58ee714c48ef5a5023ca756b",
    "ff8ff0f7e50cfc147fe383b18b344b46a23220df",
    "62423910a4020bea6200c44c12fe96b6e14bd59c",
    "2adcc3c932fd4f39a42724390ba81b2d431d7782",
    "5847e0014343f60f853cb796781ca1fa03a72efd",
    "55b3a718e95e62cdd01789050376b36d8e6a0f20",
    "fc17ba172bde2aeea98a84f9a8cd104a2fada673",
    "3bb92a1d9a7a3e71bbd3b96d9adfd0e2db4485bc",
    "8c491350789a676cc8fbefab6414773054b9b495",
    "aa42fb0db78454e5cadc2df7b6fdaa8d913ae847",
    "f9fc01cd7fef2fab1a6f696653b5de1d821b4d2a",
    "64b7cf59bde66bc58f67d2c3a97324ef679fb60a"
  ],
  "changeHistoryShort": {
    "74780c22eb0a9e6025d0ff2502042cdd29f5af83": "Ybodychange",
    "483397c7f7e89108cb650b29b7c62e515319fa0d": "Ybodychange",
    "3e868078020756de58ee714c48ef5a5023ca756b": "Ybodychange",
    "ff8ff0f7e50cfc147fe383b18b344b46a23220df": "Ybodychange",
    "62423910a4020bea6200c44c12fe96b6e14bd59c": "Ybodychange",
    "2adcc3c932fd4f39a42724390ba81b2d431d7782": "Ybodychange",
    "5847e0014343f60f853cb796781ca1fa03a72efd": "Ybodychange",
    "55b3a718e95e62cdd01789050376b36d8e6a0f20": "Ybodychange",
    "fc17ba172bde2aeea98a84f9a8cd104a2fada673": "Ybodychange",
    "3bb92a1d9a7a3e71bbd3b96d9adfd0e2db4485bc": "Ybodychange",
    "8c491350789a676cc8fbefab6414773054b9b495": "Ybodychange",
    "aa42fb0db78454e5cadc2df7b6fdaa8d913ae847": "Ybodychange",
    "f9fc01cd7fef2fab1a6f696653b5de1d821b4d2a": "Ybodychange",
    "64b7cf59bde66bc58f67d2c3a97324ef679fb60a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "74780c22eb0a9e6025d0ff2502042cdd29f5af83": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15197. [SBN read] Change ObserverRetryOnActiveException log to debug. Contributed by Chen Liang.\n",
      "commitDate": "15/03/20 4:00 AM",
      "commitName": "74780c22eb0a9e6025d0ff2502042cdd29f5af83",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "28/01/20 3:20 PM",
      "commitNameOld": "483397c7f7e89108cb650b29b7c62e515319fa0d",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 46.49,
      "commitsBetweenForRepo": 149,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             } else if (currState \u003d\u003d null) {\n               unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(),\n                 currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof InterruptedIOException ||\n                 e instanceof InterruptedException) {\n               // If interrupted, do not retry.\n               LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                   current.proxyInfo, e);\n               throw e;\n             }\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n-                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n+                LOG.debug(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // Only log message if there are actual observer failures.\n         // Getting here with failedObserverCount \u003d 0 could\n         // be that there is simply no Observer node running at all.\n         if (failedObserverCount \u003e 0) {\n           // If we get here, it means all observers have failed.\n           LOG.warn(\"{} observers have failed for read request {}; \"\n                   + \"also found {} standby, {} active, and {} unreachable. \"\n                   + \"Falling back to active.\", failedObserverCount,\n               method.getName(), standbyCount, activeCount, unreachableCount);\n           lastObserverProbeTime \u003d 0;\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Read falling back to active without observer read \"\n                 + \"fail, is there no observer node running?\");\n           }\n           lastObserverProbeTime \u003d Time.monotonicNow();\n         }\n       }\n \n       // Either all observers have failed, observer reads are disabled,\n       // or this is a write request. In any case, forward the request to\n       // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof InterruptedIOException ||\n                e instanceof InterruptedException) {\n              // If interrupted, do not retry.\n              LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                  current.proxyInfo, e);\n              throw e;\n            }\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.debug(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // Only log message if there are actual observer failures.\n        // Getting here with failedObserverCount \u003d 0 could\n        // be that there is simply no Observer node running at all.\n        if (failedObserverCount \u003e 0) {\n          // If we get here, it means all observers have failed.\n          LOG.warn(\"{} observers have failed for read request {}; \"\n                  + \"also found {} standby, {} active, and {} unreachable. \"\n                  + \"Falling back to active.\", failedObserverCount,\n              method.getName(), standbyCount, activeCount, unreachableCount);\n          lastObserverProbeTime \u003d 0;\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Read falling back to active without observer read \"\n                + \"fail, is there no observer node running?\");\n          }\n          lastObserverProbeTime \u003d Time.monotonicNow();\n        }\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "483397c7f7e89108cb650b29b7c62e515319fa0d": {
      "type": "Ybodychange",
      "commitMessage": "[SBN Read] Slow clients when Observer reads are enabled but there are no Observers on the cluster. Conntributed by Chen Liang\n",
      "commitDate": "28/01/20 3:20 PM",
      "commitName": "483397c7f7e89108cb650b29b7c62e515319fa0d",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "28/01/20 3:19 PM",
      "commitNameOld": "3e868078020756de58ee714c48ef5a5023ca756b",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,117 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n-      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n+      if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             } else if (currState \u003d\u003d null) {\n               unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(),\n                 currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof InterruptedIOException ||\n                 e instanceof InterruptedException) {\n               // If interrupted, do not retry.\n               LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                   current.proxyInfo, e);\n               throw e;\n             }\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // Only log message if there are actual observer failures.\n         // Getting here with failedObserverCount \u003d 0 could\n         // be that there is simply no Observer node running at all.\n         if (failedObserverCount \u003e 0) {\n           // If we get here, it means all observers have failed.\n           LOG.warn(\"{} observers have failed for read request {}; \"\n                   + \"also found {} standby, {} active, and {} unreachable. \"\n                   + \"Falling back to active.\", failedObserverCount,\n               method.getName(), standbyCount, activeCount, unreachableCount);\n+          lastObserverProbeTime \u003d 0;\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Read falling back to active without observer read \"\n                 + \"fail, is there no observer node running?\");\n           }\n+          lastObserverProbeTime \u003d Time.monotonicNow();\n         }\n       }\n \n       // Either all observers have failed, observer reads are disabled,\n       // or this is a write request. In any case, forward the request to\n       // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof InterruptedIOException ||\n                e instanceof InterruptedException) {\n              // If interrupted, do not retry.\n              LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                  current.proxyInfo, e);\n              throw e;\n            }\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // Only log message if there are actual observer failures.\n        // Getting here with failedObserverCount \u003d 0 could\n        // be that there is simply no Observer node running at all.\n        if (failedObserverCount \u003e 0) {\n          // If we get here, it means all observers have failed.\n          LOG.warn(\"{} observers have failed for read request {}; \"\n                  + \"also found {} standby, {} active, and {} unreachable. \"\n                  + \"Falling back to active.\", failedObserverCount,\n              method.getName(), standbyCount, activeCount, unreachableCount);\n          lastObserverProbeTime \u003d 0;\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Read falling back to active without observer read \"\n                + \"fail, is there no observer node running?\");\n          }\n          lastObserverProbeTime \u003d Time.monotonicNow();\n        }\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "3e868078020756de58ee714c48ef5a5023ca756b": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"[SBN Read] Slow clients when Observer reads are enabled but there are no Observers on the cluster. Contributed by Chen Liang.\"\n\nThis reverts commit ff8ff0f7e50cfc147fe383b18b344b46a23220df.\n",
      "commitDate": "28/01/20 3:19 PM",
      "commitName": "3e868078020756de58ee714c48ef5a5023ca756b",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "28/01/20 3:14 PM",
      "commitNameOld": "ff8ff0f7e50cfc147fe383b18b344b46a23220df",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,115 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n-      if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n+      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             } else if (currState \u003d\u003d null) {\n               unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(),\n                 currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof InterruptedIOException ||\n                 e instanceof InterruptedException) {\n               // If interrupted, do not retry.\n               LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                   current.proxyInfo, e);\n               throw e;\n             }\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // Only log message if there are actual observer failures.\n         // Getting here with failedObserverCount \u003d 0 could\n         // be that there is simply no Observer node running at all.\n         if (failedObserverCount \u003e 0) {\n           // If we get here, it means all observers have failed.\n           LOG.warn(\"{} observers have failed for read request {}; \"\n                   + \"also found {} standby, {} active, and {} unreachable. \"\n                   + \"Falling back to active.\", failedObserverCount,\n               method.getName(), standbyCount, activeCount, unreachableCount);\n-          lastObserverProbeTime \u003d 0;\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Read falling back to active without observer read \"\n                 + \"fail, is there no observer node running?\");\n           }\n-          lastObserverProbeTime \u003d Time.monotonicNow();\n         }\n       }\n \n       // Either all observers have failed, observer reads are disabled,\n       // or this is a write request. In any case, forward the request to\n       // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof InterruptedIOException ||\n                e instanceof InterruptedException) {\n              // If interrupted, do not retry.\n              LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                  current.proxyInfo, e);\n              throw e;\n            }\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // Only log message if there are actual observer failures.\n        // Getting here with failedObserverCount \u003d 0 could\n        // be that there is simply no Observer node running at all.\n        if (failedObserverCount \u003e 0) {\n          // If we get here, it means all observers have failed.\n          LOG.warn(\"{} observers have failed for read request {}; \"\n                  + \"also found {} standby, {} active, and {} unreachable. \"\n                  + \"Falling back to active.\", failedObserverCount,\n              method.getName(), standbyCount, activeCount, unreachableCount);\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Read falling back to active without observer read \"\n                + \"fail, is there no observer node running?\");\n          }\n        }\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "ff8ff0f7e50cfc147fe383b18b344b46a23220df": {
      "type": "Ybodychange",
      "commitMessage": "[SBN Read] Slow clients when Observer reads are enabled but there are no Observers on the cluster. Contributed by Chen Liang.\n",
      "commitDate": "28/01/20 3:14 PM",
      "commitName": "ff8ff0f7e50cfc147fe383b18b344b46a23220df",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "28/12/19 11:37 PM",
      "commitNameOld": "62423910a4020bea6200c44c12fe96b6e14bd59c",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 30.65,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,117 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n-      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n+      if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             } else if (currState \u003d\u003d null) {\n               unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(),\n                 currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof InterruptedIOException ||\n                 e instanceof InterruptedException) {\n               // If interrupted, do not retry.\n               LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                   current.proxyInfo, e);\n               throw e;\n             }\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // Only log message if there are actual observer failures.\n         // Getting here with failedObserverCount \u003d 0 could\n         // be that there is simply no Observer node running at all.\n         if (failedObserverCount \u003e 0) {\n           // If we get here, it means all observers have failed.\n           LOG.warn(\"{} observers have failed for read request {}; \"\n                   + \"also found {} standby, {} active, and {} unreachable. \"\n                   + \"Falling back to active.\", failedObserverCount,\n               method.getName(), standbyCount, activeCount, unreachableCount);\n+          lastObserverProbeTime \u003d 0;\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Read falling back to active without observer read \"\n                 + \"fail, is there no observer node running?\");\n           }\n+          lastObserverProbeTime \u003d Time.monotonicNow();\n         }\n       }\n \n       // Either all observers have failed, observer reads are disabled,\n       // or this is a write request. In any case, forward the request to\n       // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 shouldFindObserver() \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof InterruptedIOException ||\n                e instanceof InterruptedException) {\n              // If interrupted, do not retry.\n              LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                  current.proxyInfo, e);\n              throw e;\n            }\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // Only log message if there are actual observer failures.\n        // Getting here with failedObserverCount \u003d 0 could\n        // be that there is simply no Observer node running at all.\n        if (failedObserverCount \u003e 0) {\n          // If we get here, it means all observers have failed.\n          LOG.warn(\"{} observers have failed for read request {}; \"\n                  + \"also found {} standby, {} active, and {} unreachable. \"\n                  + \"Falling back to active.\", failedObserverCount,\n              method.getName(), standbyCount, activeCount, unreachableCount);\n          lastObserverProbeTime \u003d 0;\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Read falling back to active without observer read \"\n                + \"fail, is there no observer node running?\");\n          }\n          lastObserverProbeTime \u003d Time.monotonicNow();\n        }\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "62423910a4020bea6200c44c12fe96b6e14bd59c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14937. [SBN read] ObserverReadProxyProvider should throw InterruptException. Contributed by xuzq.\n",
      "commitDate": "28/12/19 11:37 PM",
      "commitName": "62423910a4020bea6200c44c12fe96b6e14bd59c",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "26/09/19 3:48 PM",
      "commitNameOld": "2adcc3c932fd4f39a42724390ba81b2d431d7782",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 93.37,
      "commitsBetweenForRepo": 404,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,115 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             } else if (currState \u003d\u003d null) {\n               unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(),\n                 currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n+            if (e instanceof InterruptedIOException ||\n+                e instanceof InterruptedException) {\n+              // If interrupted, do not retry.\n+              LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n+                  current.proxyInfo, e);\n+              throw e;\n+            }\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // Only log message if there are actual observer failures.\n         // Getting here with failedObserverCount \u003d 0 could\n         // be that there is simply no Observer node running at all.\n         if (failedObserverCount \u003e 0) {\n           // If we get here, it means all observers have failed.\n           LOG.warn(\"{} observers have failed for read request {}; \"\n                   + \"also found {} standby, {} active, and {} unreachable. \"\n                   + \"Falling back to active.\", failedObserverCount,\n               method.getName(), standbyCount, activeCount, unreachableCount);\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Read falling back to active without observer read \"\n                 + \"fail, is there no observer node running?\");\n           }\n         }\n       }\n \n       // Either all observers have failed, observer reads are disabled,\n       // or this is a write request. In any case, forward the request to\n       // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof InterruptedIOException ||\n                e instanceof InterruptedException) {\n              // If interrupted, do not retry.\n              LOG.warn(\"Invocation returned interrupted exception on [{}];\",\n                  current.proxyInfo, e);\n              throw e;\n            }\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // Only log message if there are actual observer failures.\n        // Getting here with failedObserverCount \u003d 0 could\n        // be that there is simply no Observer node running at all.\n        if (failedObserverCount \u003e 0) {\n          // If we get here, it means all observers have failed.\n          LOG.warn(\"{} observers have failed for read request {}; \"\n                  + \"also found {} standby, {} active, and {} unreachable. \"\n                  + \"Falling back to active.\", failedObserverCount,\n              method.getName(), standbyCount, activeCount, unreachableCount);\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Read falling back to active without observer read \"\n                + \"fail, is there no observer node running?\");\n          }\n        }\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "2adcc3c932fd4f39a42724390ba81b2d431d7782": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14785. [SBN read] Change client logging to be less aggressive. Contributed by Chen Liang.\n",
      "commitDate": "26/09/19 3:48 PM",
      "commitName": "2adcc3c932fd4f39a42724390ba81b2d431d7782",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "13/05/19 8:39 AM",
      "commitNameOld": "5847e0014343f60f853cb796781ca1fa03a72efd",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 136.3,
      "commitsBetweenForRepo": 1145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,108 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             } else if (currState \u003d\u003d null) {\n               unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(),\n                 currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n-        // If we get here, it means all observers have failed.\n-        LOG.warn(\"{} observers have failed for read request {}; also found {} \"\n-            + \"standby, {} active, and {} unreachable. Falling back to active.\",\n-            failedObserverCount, method.getName(), standbyCount, activeCount,\n-            unreachableCount);\n+        // Only log message if there are actual observer failures.\n+        // Getting here with failedObserverCount \u003d 0 could\n+        // be that there is simply no Observer node running at all.\n+        if (failedObserverCount \u003e 0) {\n+          // If we get here, it means all observers have failed.\n+          LOG.warn(\"{} observers have failed for read request {}; \"\n+                  + \"also found {} standby, {} active, and {} unreachable. \"\n+                  + \"Falling back to active.\", failedObserverCount,\n+              method.getName(), standbyCount, activeCount, unreachableCount);\n+        } else {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Read falling back to active without observer read \"\n+                + \"fail, is there no observer node running?\");\n+          }\n+        }\n       }\n \n       // Either all observers have failed, observer reads are disabled,\n       // or this is a write request. In any case, forward the request to\n       // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // Only log message if there are actual observer failures.\n        // Getting here with failedObserverCount \u003d 0 could\n        // be that there is simply no Observer node running at all.\n        if (failedObserverCount \u003e 0) {\n          // If we get here, it means all observers have failed.\n          LOG.warn(\"{} observers have failed for read request {}; \"\n                  + \"also found {} standby, {} active, and {} unreachable. \"\n                  + \"Falling back to active.\", failedObserverCount,\n              method.getName(), standbyCount, activeCount, unreachableCount);\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Read falling back to active without observer read \"\n                + \"fail, is there no observer node running?\");\n          }\n        }\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "5847e0014343f60f853cb796781ca1fa03a72efd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14245. [SBN read] Enable ObserverReadProxyProvider to work with non-ClientProtocol proxy types. Contributed by Erik Krogen.\n",
      "commitDate": "13/05/19 8:39 AM",
      "commitName": "5847e0014343f60f853cb796781ca1fa03a72efd",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "22/04/19 1:29 PM",
      "commitNameOld": "174b7d3126e215c519b1c4a74892c7020712f9df",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 20.8,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,98 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n         } else {\n           autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n+        int unreachableCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n+            } else if (currState \u003d\u003d null) {\n+              unreachableCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n-                current.proxyInfo, method.getName(), currState);\n+                current.proxyInfo, method.getName(),\n+                currState \u003d\u003d null ? \"unreachable\" : currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n-        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n-            \"{} standby and {} active. Falling back to active.\",\n-            failedObserverCount, method.getName(), standbyCount, activeCount);\n+        LOG.warn(\"{} observers have failed for read request {}; also found {} \"\n+            + \"standby, {} active, and {} unreachable. Falling back to active.\",\n+            failedObserverCount, method.getName(), standbyCount, activeCount,\n+            unreachableCount);\n       }\n \n-      // Either all observers have failed, or that it is a write request.\n-      // In either case, we\u0027ll forward the request to active NameNode.\n+      // Either all observers have failed, observer reads are disabled,\n+      // or this is a write request. In any case, forward the request to\n+      // the active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n       lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        int unreachableCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            } else if (currState \u003d\u003d null) {\n              unreachableCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(),\n                currState \u003d\u003d null ? \"unreachable\" : currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"{} observers have failed for read request {}; also found {} \"\n            + \"standby, {} active, and {} unreachable. Falling back to active.\",\n            failedObserverCount, method.getName(), standbyCount, activeCount,\n            unreachableCount);\n      }\n\n      // Either all observers have failed, observer reads are disabled,\n      // or this is a write request. In any case, forward the request to\n      // the active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "55b3a718e95e62cdd01789050376b36d8e6a0f20": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14211. [SBN Read]. Add a configurable flag to enable always-msync mode to ObserverReadProxyProvider. Contributed by Erik Krogen.\n",
      "commitDate": "19/03/19 8:14 AM",
      "commitName": "55b3a718e95e62cdd01789050376b36d8e6a0f20",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "03/03/19 11:52 PM",
      "commitNameOld": "fc17ba172bde2aeea98a84f9a8cd104a2fada673",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 15.31,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,92 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         if (!msynced) {\n           // An msync() must first be performed to ensure that this client is\n           // up-to-date with the active\u0027s state. This will only be done once.\n           initializeMsync();\n+        } else {\n+          autoMsyncIfNecessary();\n         }\n \n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(), currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n         LOG.warn(\"{} observers have failed for read request {}; also found \" +\n             \"{} standby and {} active. Falling back to active.\",\n             failedObserverCount, method.getName(), standbyCount, activeCount);\n       }\n \n       // Either all observers have failed, or that it is a write request.\n       // In either case, we\u0027ll forward the request to active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       // If this was reached, the request reached the active, so the\n       // state is up-to-date with active and no further msync is needed.\n       msynced \u003d true;\n+      lastMsyncTimeMs \u003d Time.monotonicNow();\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        } else {\n          autoMsyncIfNecessary();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(), currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n            \"{} standby and {} active. Falling back to active.\",\n            failedObserverCount, method.getName(), standbyCount, activeCount);\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastMsyncTimeMs \u003d Time.monotonicNow();\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "fc17ba172bde2aeea98a84f9a8cd104a2fada673": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14272. [SBN read] Make ObserverReadProxyProvider initialize its state ID against the active NN on startup. Contributed by Erik Krogen.\n",
      "commitDate": "03/03/19 11:52 PM",
      "commitName": "fc17ba172bde2aeea98a84f9a8cd104a2fada673",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "22/02/19 1:58 PM",
      "commitNameOld": "bad3ffd2907d75395907ff6b76c909ab50add4bc",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 9.41,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,89 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n+        if (!msynced) {\n+          // An msync() must first be performed to ensure that this client is\n+          // up-to-date with the active\u0027s state. This will only be done once.\n+          initializeMsync();\n+        }\n+\n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(), currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n         LOG.warn(\"{} observers have failed for read request {}; also found \" +\n             \"{} standby and {} active. Falling back to active.\",\n             failedObserverCount, method.getName(), standbyCount, activeCount);\n       }\n \n       // Either all observers have failed, or that it is a write request.\n       // In either case, we\u0027ll forward the request to active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n+      // If this was reached, the request reached the active, so the\n+      // state is up-to-date with active and no further msync is needed.\n+      msynced \u003d true;\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        if (!msynced) {\n          // An msync() must first be performed to ensure that this client is\n          // up-to-date with the active\u0027s state. This will only be done once.\n          initializeMsync();\n        }\n\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(), currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n            \"{} standby and {} active. Falling back to active.\",\n            failedObserverCount, method.getName(), standbyCount, activeCount);\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      // If this was reached, the request reached the active, so the\n      // state is up-to-date with active and no further msync is needed.\n      msynced \u003d true;\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "3bb92a1d9a7a3e71bbd3b96d9adfd0e2db4485bc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14094. [SBN read] Fix the order of logging arguments in ObserverReadProxyProvider. Contributed by Ayush Saxena.",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "3bb92a1d9a7a3e71bbd3b96d9adfd0e2db4485bc",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "652b257478f723a9e119e5e9181f3c7450ac92b5",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(), currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n             if (e instanceof RemoteException) {\n               RemoteException re \u003d (RemoteException) e;\n               Exception unwrapped \u003d re.unwrapRemoteException(\n                   ObserverRetryOnActiveException.class);\n               if (unwrapped instanceof ObserverRetryOnActiveException) {\n                 LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                     \" Retry active namenode directly.\", current.proxyInfo);\n                 break;\n               }\n             }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n         LOG.warn(\"{} observers have failed for read request {}; also found \" +\n             \"{} standby and {} active. Falling back to active.\",\n-            failedObserverCount, standbyCount, activeCount, method.getName());\n+            failedObserverCount, method.getName(), standbyCount, activeCount);\n       }\n \n       // Either all observers have failed, or that it is a write request.\n       // In either case, we\u0027ll forward the request to active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(), currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n            \"{} standby and {} active. Falling back to active.\",\n            failedObserverCount, method.getName(), standbyCount, activeCount);\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "8c491350789a676cc8fbefab6414773054b9b495": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13924. [SBN read] Handle BlockMissingException when reading from observer. Contributed by Chao Sun.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "8c491350789a676cc8fbefab6414773054b9b495",
      "commitAuthor": "Chao Sun",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "25b63e8da8e84252072bcd09ee5557c48e07a745",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,80 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         int failedObserverCount \u003d 0;\n         int activeCount \u003d 0;\n         int standbyCount \u003d 0;\n         for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n           NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n           HAServiceState currState \u003d current.getCachedState();\n           if (currState !\u003d HAServiceState.OBSERVER) {\n             if (currState \u003d\u003d HAServiceState.ACTIVE) {\n               activeCount++;\n             } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n               standbyCount++;\n             }\n             LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                 current.proxyInfo, method.getName(), currState);\n             changeProxy(current);\n             continue;\n           }\n           LOG.debug(\"Attempting to service {} using proxy {}\",\n               method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             LOG.debug(\"Invocation of {} using {} was successful\",\n                 method.getName(), current.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ite) {\n             if (!(ite.getCause() instanceof Exception)) {\n               throw ite.getCause();\n             }\n             Exception e \u003d (Exception) ite.getCause();\n+            if (e instanceof RemoteException) {\n+              RemoteException re \u003d (RemoteException) e;\n+              Exception unwrapped \u003d re.unwrapRemoteException(\n+                  ObserverRetryOnActiveException.class);\n+              if (unwrapped instanceof ObserverRetryOnActiveException) {\n+                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n+                    \" Retry active namenode directly.\", current.proxyInfo);\n+                break;\n+              }\n+            }\n             RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                 method.isAnnotationPresent(Idempotent.class)\n                     || method.isAnnotationPresent(AtMostOnce.class));\n             if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n               throw e;\n             } else {\n               failedObserverCount++;\n               LOG.warn(\n                   \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                   current.proxyInfo, failedObserverCount, e);\n               changeProxy(current);\n             }\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n         LOG.warn(\"{} observers have failed for read request {}; also found \" +\n             \"{} standby and {} active. Falling back to active.\",\n             failedObserverCount, standbyCount, activeCount, method.getName());\n       }\n \n       // Either all observers have failed, or that it is a write request.\n       // In either case, we\u0027ll forward the request to active NameNode.\n       LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n       ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (InvocationTargetException e) {\n         // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(), currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            if (e instanceof RemoteException) {\n              RemoteException re \u003d (RemoteException) e;\n              Exception unwrapped \u003d re.unwrapRemoteException(\n                  ObserverRetryOnActiveException.class);\n              if (unwrapped instanceof ObserverRetryOnActiveException) {\n                LOG.info(\"Encountered ObserverRetryOnActiveException from {}.\" +\n                    \" Retry active namenode directly.\", current.proxyInfo);\n                break;\n              }\n            }\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n            \"{} standby and {} active. Falling back to active.\",\n            failedObserverCount, standbyCount, activeCount, method.getName());\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "aa42fb0db78454e5cadc2df7b6fdaa8d913ae847": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13779. [SBN read] Implement proper failover and observer failure handling logic for for ObserverReadProxyProvider. Contributed by Erik Krogen.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "aa42fb0db78454e5cadc2df7b6fdaa8d913ae847",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "f9fc01cd7fef2fab1a6f696653b5de1d821b4d2a",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,70 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n-        // Loop through all the proxies, starting from the current index.\n-        for (int i \u003d 0; i \u003c observerProxies.size(); i++) {\n-          NNProxyInfo\u003cT\u003e current \u003d observerProxies.get(currentIndex.get());\n+        int failedObserverCount \u003d 0;\n+        int activeCount \u003d 0;\n+        int standbyCount \u003d 0;\n+        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n+          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n+          HAServiceState currState \u003d current.getCachedState();\n+          if (currState !\u003d HAServiceState.OBSERVER) {\n+            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n+              activeCount++;\n+            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n+              standbyCount++;\n+            }\n+            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n+                current.proxyInfo, method.getName(), currState);\n+            changeProxy(current);\n+            continue;\n+          }\n+          LOG.debug(\"Attempting to service {} using proxy {}\",\n+              method.getName(), current.proxyInfo);\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n+            LOG.debug(\"Invocation of {} using {} was successful\",\n+                method.getName(), current.proxyInfo);\n             return retVal;\n-          } catch (Exception e) {\n-            if (!shouldRetry(e)) {\n-              throw e;\n+          } catch (InvocationTargetException ite) {\n+            if (!(ite.getCause() instanceof Exception)) {\n+              throw ite.getCause();\n             }\n-            currentIndex.set((currentIndex.get() + 1) % observerProxies.size());\n-            LOG.warn(\"Invocation returned exception on [{}]\",\n-                current.proxyInfo, e.getCause());\n+            Exception e \u003d (Exception) ite.getCause();\n+            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n+                method.isAnnotationPresent(Idempotent.class)\n+                    || method.isAnnotationPresent(AtMostOnce.class));\n+            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n+              throw e;\n+            } else {\n+              failedObserverCount++;\n+              LOG.warn(\n+                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n+                  current.proxyInfo, failedObserverCount, e);\n+              changeProxy(current);\n+            }\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n-        LOG.warn(\"All observers have failed for read request {}. \" +\n-            \"Fall back on active: {}\", method.getName(), activeProxy);\n+        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n+            \"{} standby and {} active. Falling back to active.\",\n+            failedObserverCount, standbyCount, activeCount, method.getName());\n       }\n \n       // Either all observers have failed, or that it is a write request.\n       // In either case, we\u0027ll forward the request to active NameNode.\n+      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n+      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n-      } catch (Exception e) {\n+      } catch (InvocationTargetException e) {\n+        // This exception will be handled by higher layers\n         throw e.getCause();\n       }\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        int failedObserverCount \u003d 0;\n        int activeCount \u003d 0;\n        int standbyCount \u003d 0;\n        for (int i \u003d 0; i \u003c nameNodeProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d getCurrentProxy();\n          HAServiceState currState \u003d current.getCachedState();\n          if (currState !\u003d HAServiceState.OBSERVER) {\n            if (currState \u003d\u003d HAServiceState.ACTIVE) {\n              activeCount++;\n            } else if (currState \u003d\u003d HAServiceState.STANDBY) {\n              standbyCount++;\n            }\n            LOG.debug(\"Skipping proxy {} for {} because it is in state {}\",\n                current.proxyInfo, method.getName(), currState);\n            changeProxy(current);\n            continue;\n          }\n          LOG.debug(\"Attempting to service {} using proxy {}\",\n              method.getName(), current.proxyInfo);\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            LOG.debug(\"Invocation of {} using {} was successful\",\n                method.getName(), current.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ite) {\n            if (!(ite.getCause() instanceof Exception)) {\n              throw ite.getCause();\n            }\n            Exception e \u003d (Exception) ite.getCause();\n            RetryAction retryInfo \u003d observerRetryPolicy.shouldRetry(e, 0, 0,\n                method.isAnnotationPresent(Idempotent.class)\n                    || method.isAnnotationPresent(AtMostOnce.class));\n            if (retryInfo.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n              throw e;\n            } else {\n              failedObserverCount++;\n              LOG.warn(\n                  \"Invocation returned exception on [{}]; {} failure(s) so far\",\n                  current.proxyInfo, failedObserverCount, e);\n              changeProxy(current);\n            }\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"{} observers have failed for read request {}; also found \" +\n            \"{} standby and {} active. Falling back to active.\",\n            failedObserverCount, standbyCount, activeCount, method.getName());\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      LOG.debug(\"Using failoverProxy to service {}\", method.getName());\n      ProxyInfo\u003cT\u003e activeProxy \u003d failoverProxy.getProxy();\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (InvocationTargetException e) {\n        // This exception will be handled by higher layers\n        throw e.getCause();\n      }\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "f9fc01cd7fef2fab1a6f696653b5de1d821b4d2a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13782. ObserverReadProxyProvider should work with IPFailoverProxyProvider. Contributed by Konstantin Shvachko.",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "f9fc01cd7fef2fab1a6f696653b5de1d821b4d2a",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "25d8e39b5c7477338344a8d9aadd100cd08cd9a5",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       lastProxy \u003d null;\n       Object retVal;\n \n       if (observerReadEnabled \u0026\u0026 isRead(method)) {\n         // Loop through all the proxies, starting from the current index.\n         for (int i \u003d 0; i \u003c observerProxies.size(); i++) {\n-          ProxyInfo\u003cT\u003e current \u003d observerProxies.get(currentIndex.get());\n+          NNProxyInfo\u003cT\u003e current \u003d observerProxies.get(currentIndex.get());\n           try {\n             retVal \u003d method.invoke(current.proxy, args);\n             lastProxy \u003d current;\n             return retVal;\n           } catch (Exception e) {\n             if (!shouldRetry(e)) {\n               throw e;\n             }\n             currentIndex.set((currentIndex.get() + 1) % observerProxies.size());\n             LOG.warn(\"Invocation returned exception on [{}]\",\n                 current.proxyInfo, e.getCause());\n           }\n         }\n \n         // If we get here, it means all observers have failed.\n         LOG.warn(\"All observers have failed for read request {}. \" +\n             \"Fall back on active: {}\", method.getName(), activeProxy);\n       }\n \n       // Either all observers have failed, or that it is a write request.\n       // In either case, we\u0027ll forward the request to active NameNode.\n       try {\n         retVal \u003d method.invoke(activeProxy.proxy, args);\n       } catch (Exception e) {\n         throw e.getCause();\n       }\n       lastProxy \u003d activeProxy;\n       return retVal;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        // Loop through all the proxies, starting from the current index.\n        for (int i \u003d 0; i \u003c observerProxies.size(); i++) {\n          NNProxyInfo\u003cT\u003e current \u003d observerProxies.get(currentIndex.get());\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            return retVal;\n          } catch (Exception e) {\n            if (!shouldRetry(e)) {\n              throw e;\n            }\n            currentIndex.set((currentIndex.get() + 1) % observerProxies.size());\n            LOG.warn(\"Invocation returned exception on [{}]\",\n                current.proxyInfo, e.getCause());\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"All observers have failed for read request {}. \" +\n            \"Fall back on active: {}\", method.getName(), activeProxy);\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (Exception e) {\n        throw e.getCause();\n      }\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java",
      "extendedDetails": {}
    },
    "64b7cf59bde66bc58f67d2c3a97324ef679fb60a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12976. [SBN read] Introduce ObserverReadProxyProvider. Contributed by Chao Sun.",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "64b7cf59bde66bc58f67d2c3a97324ef679fb60a",
      "commitAuthor": "Chao Sun",
      "diff": "@@ -0,0 +1,38 @@\n+    public Object invoke(Object proxy, final Method method, final Object[] args)\n+        throws Throwable {\n+      lastProxy \u003d null;\n+      Object retVal;\n+\n+      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n+        // Loop through all the proxies, starting from the current index.\n+        for (int i \u003d 0; i \u003c observerProxies.size(); i++) {\n+          ProxyInfo\u003cT\u003e current \u003d observerProxies.get(currentIndex.get());\n+          try {\n+            retVal \u003d method.invoke(current.proxy, args);\n+            lastProxy \u003d current;\n+            return retVal;\n+          } catch (Exception e) {\n+            if (!shouldRetry(e)) {\n+              throw e;\n+            }\n+            currentIndex.set((currentIndex.get() + 1) % observerProxies.size());\n+            LOG.warn(\"Invocation returned exception on [{}]\",\n+                current.proxyInfo, e.getCause());\n+          }\n+        }\n+\n+        // If we get here, it means all observers have failed.\n+        LOG.warn(\"All observers have failed for read request {}. \" +\n+            \"Fall back on active: {}\", method.getName(), activeProxy);\n+      }\n+\n+      // Either all observers have failed, or that it is a write request.\n+      // In either case, we\u0027ll forward the request to active NameNode.\n+      try {\n+        retVal \u003d method.invoke(activeProxy.proxy, args);\n+      } catch (Exception e) {\n+        throw e.getCause();\n+      }\n+      lastProxy \u003d activeProxy;\n+      return retVal;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      lastProxy \u003d null;\n      Object retVal;\n\n      if (observerReadEnabled \u0026\u0026 isRead(method)) {\n        // Loop through all the proxies, starting from the current index.\n        for (int i \u003d 0; i \u003c observerProxies.size(); i++) {\n          ProxyInfo\u003cT\u003e current \u003d observerProxies.get(currentIndex.get());\n          try {\n            retVal \u003d method.invoke(current.proxy, args);\n            lastProxy \u003d current;\n            return retVal;\n          } catch (Exception e) {\n            if (!shouldRetry(e)) {\n              throw e;\n            }\n            currentIndex.set((currentIndex.get() + 1) % observerProxies.size());\n            LOG.warn(\"Invocation returned exception on [{}]\",\n                current.proxyInfo, e.getCause());\n          }\n        }\n\n        // If we get here, it means all observers have failed.\n        LOG.warn(\"All observers have failed for read request {}. \" +\n            \"Fall back on active: {}\", method.getName(), activeProxy);\n      }\n\n      // Either all observers have failed, or that it is a write request.\n      // In either case, we\u0027ll forward the request to active NameNode.\n      try {\n        retVal \u003d method.invoke(activeProxy.proxy, args);\n      } catch (Exception e) {\n        throw e.getCause();\n      }\n      lastProxy \u003d activeProxy;\n      return retVal;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/ObserverReadProxyProvider.java"
    }
  }
}