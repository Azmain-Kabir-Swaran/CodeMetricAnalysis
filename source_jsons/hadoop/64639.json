{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "delete",
  "functionId": "delete___f-Path__recursive-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 2463,
  "functionEndLine": 2490,
  "numCommitsSeen": 141,
  "timeTaken": 8204,
  "changeHistory": [
    "56dee667707926f3796c7757be1a133a362f05c9",
    "9221704f857e33a5f9e00c19d3705e46e94f427b",
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "9a013b255f301c557c3868dc1ad657202e9e7a67",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
    "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
    "ef450df443f1dea1c52082cf281f25db7141972f",
    "621b43e254afaff708cd6fc4698b29628f6abc33",
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "29ae25801380b94442253c4202dee782dc4713f5",
    "709ff99cff4124823bde631e272af7be9a22f83b",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "56dee667707926f3796c7757be1a133a362f05c9": "Ybodychange",
    "9221704f857e33a5f9e00c19d3705e46e94f427b": "Ybodychange",
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "9a013b255f301c557c3868dc1ad657202e9e7a67": "Ybodychange",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": "Ybodychange",
    "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c": "Ybodychange",
    "ef450df443f1dea1c52082cf281f25db7141972f": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Ybodychange",
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "29ae25801380b94442253c4202dee782dc4713f5": "Ybodychange",
    "709ff99cff4124823bde631e272af7be9a22f83b": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56dee667707926f3796c7757be1a133a362f05c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
      "commitDate": "13/02/20 11:09 AM",
      "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "30/01/20 2:16 AM",
      "commitNameOld": "5977360878e6780bd04842c8a2156f9848e1d088",
      "commitAuthorOld": "Mustafa Ä°man",
      "daysBetweenCommits": 14.37,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n       entryPoint(INVOCATION_DELETE);\n       DeleteOperation deleteOperation \u003d new DeleteOperation(\n           createStoreContext(),\n           innerGetFileStatus(f, true, StatusProbeEnum.ALL),\n           recursive,\n           operationCallbacks,\n-          InternalConstants.MAX_ENTRIES_TO_DELETE);\n+          pageSize);\n       boolean outcome \u003d deleteOperation.execute();\n       if (outcome) {\n         try {\n           maybeCreateFakeParentDirectory(f);\n         } catch (AccessDeniedException e) {\n           LOG.warn(\"Cannot create directory marker at {}: {}\",\n               f.getParent(), e.toString());\n           LOG.debug(\"Failed to create fake dir above {}\", f, e);\n         }\n       }\n       return outcome;\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      DeleteOperation deleteOperation \u003d new DeleteOperation(\n          createStoreContext(),\n          innerGetFileStatus(f, true, StatusProbeEnum.ALL),\n          recursive,\n          operationCallbacks,\n          pageSize);\n      boolean outcome \u003d deleteOperation.execute();\n      if (outcome) {\n        try {\n          maybeCreateFakeParentDirectory(f);\n        } catch (AccessDeniedException e) {\n          LOG.warn(\"Cannot create directory marker at {}: {}\",\n              f.getParent(), e.toString());\n          LOG.debug(\"Failed to create fake dir above {}\", f, e);\n        }\n      }\n      return outcome;\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "9221704f857e33a5f9e00c19d3705e46e94f427b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
      "commitDate": "11/09/19 8:46 AM",
      "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/19 6:25 AM",
      "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n       entryPoint(INVOCATION_DELETE);\n       DeleteOperation deleteOperation \u003d new DeleteOperation(\n           createStoreContext(),\n-          innerGetFileStatus(f, true),\n+          innerGetFileStatus(f, true, StatusProbeEnum.ALL),\n           recursive,\n           operationCallbacks,\n           InternalConstants.MAX_ENTRIES_TO_DELETE);\n       boolean outcome \u003d deleteOperation.execute();\n       if (outcome) {\n         try {\n           maybeCreateFakeParentDirectory(f);\n         } catch (AccessDeniedException e) {\n           LOG.warn(\"Cannot create directory marker at {}: {}\",\n               f.getParent(), e.toString());\n           LOG.debug(\"Failed to create fake dir above {}\", f, e);\n         }\n       }\n       return outcome;\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      DeleteOperation deleteOperation \u003d new DeleteOperation(\n          createStoreContext(),\n          innerGetFileStatus(f, true, StatusProbeEnum.ALL),\n          recursive,\n          operationCallbacks,\n          InternalConstants.MAX_ENTRIES_TO_DELETE);\n      boolean outcome \u003d deleteOperation.execute();\n      if (outcome) {\n        try {\n          maybeCreateFakeParentDirectory(f);\n        } catch (AccessDeniedException e) {\n          LOG.warn(\"Cannot create directory marker at {}: {}\",\n              f.getParent(), e.toString());\n          LOG.debug(\"Failed to create fake dir above {}\", f, e);\n        }\n      }\n      return outcome;\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "23/07/19 6:52 AM",
      "commitNameOld": "4317d332321778269a583e2223d433107fab82eb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 43.98,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,28 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n       entryPoint(INVOCATION_DELETE);\n-      boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n+      DeleteOperation deleteOperation \u003d new DeleteOperation(\n+          createStoreContext(),\n+          innerGetFileStatus(f, true),\n+          recursive,\n+          operationCallbacks,\n+          InternalConstants.MAX_ENTRIES_TO_DELETE);\n+      boolean outcome \u003d deleteOperation.execute();\n       if (outcome) {\n         try {\n           maybeCreateFakeParentDirectory(f);\n         } catch (AccessDeniedException e) {\n           LOG.warn(\"Cannot create directory marker at {}: {}\",\n               f.getParent(), e.toString());\n           LOG.debug(\"Failed to create fake dir above {}\", f, e);\n         }\n       }\n       return outcome;\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      DeleteOperation deleteOperation \u003d new DeleteOperation(\n          createStoreContext(),\n          innerGetFileStatus(f, true),\n          recursive,\n          operationCallbacks,\n          InternalConstants.MAX_ENTRIES_TO_DELETE);\n      boolean outcome \u003d deleteOperation.execute();\n      if (outcome) {\n        try {\n          maybeCreateFakeParentDirectory(f);\n        } catch (AccessDeniedException e) {\n          LOG.warn(\"Cannot create directory marker at {}: {}\",\n              f.getParent(), e.toString());\n          LOG.debug(\"Failed to create fake dir above {}\", f, e);\n        }\n      }\n      return outcome;\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,22 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n       entryPoint(INVOCATION_DELETE);\n       boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n       if (outcome) {\n         try {\n           maybeCreateFakeParentDirectory(f);\n         } catch (AccessDeniedException e) {\n           LOG.warn(\"Cannot create directory marker at {}: {}\",\n               f.getParent(), e.toString());\n           LOG.debug(\"Failed to create fake dir above {}\", f, e);\n         }\n       }\n       return outcome;\n     } catch (FileNotFoundException e) {\n-      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n+      LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n      if (outcome) {\n        try {\n          maybeCreateFakeParentDirectory(f);\n        } catch (AccessDeniedException e) {\n          LOG.warn(\"Cannot create directory marker at {}: {}\",\n              f.getParent(), e.toString());\n          LOG.debug(\"Failed to create fake dir above {}\", f, e);\n        }\n      }\n      return outcome;\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist: {}\", f, e.toString());\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "9a013b255f301c557c3868dc1ad657202e9e7a67": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15176. Enhance IAM Assumed Role support in S3A client.\nContributed by Steve Loughran\n\n(cherry picked from commit 96c047fbb98c2378eed9693a724d4cbbd03c00fd)\n",
      "commitDate": "15/02/18 7:57 AM",
      "commitName": "9a013b255f301c557c3868dc1ad657202e9e7a67",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/01/18 5:13 AM",
      "commitNameOld": "1093a73689912f78547e6d23023be2fd1c7ddc85",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 28.11,
      "commitsBetweenForRepo": 184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,22 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n       entryPoint(INVOCATION_DELETE);\n       boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n       if (outcome) {\n-        maybeCreateFakeParentDirectory(f);\n+        try {\n+          maybeCreateFakeParentDirectory(f);\n+        } catch (AccessDeniedException e) {\n+          LOG.warn(\"Cannot create directory marker at {}: {}\",\n+              f.getParent(), e.toString());\n+          LOG.debug(\"Failed to create fake dir above {}\", f, e);\n+        }\n       }\n       return outcome;\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n      if (outcome) {\n        try {\n          maybeCreateFakeParentDirectory(f);\n        } catch (AccessDeniedException e) {\n          LOG.warn(\"Cannot create directory marker at {}: {}\",\n              f.getParent(), e.toString());\n          LOG.debug(\"Failed to create fake dir above {}\", f, e);\n        }\n      }\n      return outcome;\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15079. ITestS3AFileOperationCost#testFakeDirectoryDeletion failing\nafter OutputCommitter patch.\nContributed by Steve Loughran\n",
      "commitDate": "15/01/18 3:33 AM",
      "commitName": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "09/01/18 10:46 AM",
      "commitNameOld": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,16 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n       entryPoint(INVOCATION_DELETE);\n-      return innerDelete(innerGetFileStatus(f, true), recursive);\n+      boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n+      if (outcome) {\n+        maybeCreateFakeParentDirectory(f);\n+      }\n+      return outcome;\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      boolean outcome \u003d innerDelete(innerGetFileStatus(f, true), recursive);\n      if (outcome) {\n        maybeCreateFakeParentDirectory(f);\n      }\n      return outcome;\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15161. s3a: Stream and common statistics missing from metrics\nContributed by Sean Mackrory\n",
      "commitDate": "09/01/18 10:46 AM",
      "commitName": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "21/12/17 6:58 AM",
      "commitNameOld": "c8ff0cc304f07bf793192291e0611b2fb4bcc4e3",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 19.16,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,12 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n-      checkNotClosed();\n+      entryPoint(INVOCATION_DELETE);\n       return innerDelete(innerGetFileStatus(f, true), recursive);\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      entryPoint(INVOCATION_DELETE);\n      return innerDelete(innerGetFileStatus(f, true), recursive);\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ef450df443f1dea1c52082cf281f25db7141972f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15113. NPE in S3A getFileStatus: null instrumentation on using closed instance.\nContributed by Steve Loughran.\n",
      "commitDate": "21/12/17 6:15 AM",
      "commitName": "ef450df443f1dea1c52082cf281f25db7141972f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,11 +1,12 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n+      checkNotClosed();\n       return innerDelete(innerGetFileStatus(f, true), recursive);\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      checkNotClosed();\n      return innerDelete(innerGetFileStatus(f, true), recursive);\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/06/17 11:26 AM",
      "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 87.78,
      "commitsBetweenForRepo": 591,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,11 +1,11 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n-      return innerDelete(getFileStatus(f), recursive);\n+      return innerDelete(innerGetFileStatus(f, true), recursive);\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n       instrumentation.errorIgnored();\n       return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      return innerDelete(innerGetFileStatus(f, true), recursive);\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13406 S3AFileSystem: Consider reusing filestatus in delete() and mkdirs(). Contributed by Rajesh Balamohan\n",
      "commitDate": "25/07/16 6:45 AM",
      "commitName": "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/07/16 5:42 AM",
      "commitNameOld": "37362c2f922b8d038002e61132b110ae4dd6d5ba",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.04,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,7 +1,11 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     try {\n-      return innerDelete(f, recursive);\n+      return innerDelete(getFileStatus(f), recursive);\n+    } catch (FileNotFoundException e) {\n+      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n+      instrumentation.errorIgnored();\n+      return false;\n     } catch (AmazonClientException e) {\n       throw translateException(\"delete\", f, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      return innerDelete(getFileStatus(f), recursive);\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/05/16 5:52 AM",
      "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,7 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n-    LOG.debug(\"Delete path {} - recursive {}\", f , recursive);\n-    S3AFileStatus status;\n     try {\n-      status \u003d getFileStatus(f);\n-    } catch (FileNotFoundException e) {\n-      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n-      instrumentation.errorIgnored();\n-      return false;\n+      return innerDelete(f, recursive);\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"delete\", f, e);\n     }\n-\n-    String key \u003d pathToKey(f);\n-\n-    if (status.isDirectory()) {\n-      LOG.debug(\"delete: Path is a directory: {}\", f);\n-\n-      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n-        throw new IOException(\"Path is a folder: \" + f +\n-                              \" and it is not an empty directory\");\n-      }\n-\n-      if (!key.endsWith(\"/\")) {\n-        key \u003d key + \"/\";\n-      }\n-\n-      if (key.equals(\"/\")) {\n-        LOG.info(\"s3a cannot delete the root directory\");\n-        return false;\n-      }\n-\n-      if (status.isEmptyDirectory()) {\n-        LOG.debug(\"Deleting fake empty directory {}\", key);\n-        s3.deleteObject(bucket, key);\n-        instrumentation.directoryDeleted();\n-        statistics.incrementWriteOps(1);\n-      } else {\n-        LOG.debug(\"Getting objects for directory prefix {} to delete\", key);\n-\n-        ListObjectsRequest request \u003d new ListObjectsRequest();\n-        request.setBucketName(bucket);\n-        request.setPrefix(key);\n-        // Hopefully not setting a delimiter will cause this to find everything\n-        //request.setDelimiter(\"/\");\n-        request.setMaxKeys(maxKeys);\n-\n-        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d new ArrayList\u003c\u003e();\n-        ObjectListing objects \u003d s3.listObjects(request);\n-        statistics.incrementReadOps(1);\n-        while (true) {\n-          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n-            LOG.debug(\"Got object to delete {}\", summary.getKey());\n-\n-            if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-              removeKeys(keys, true);\n-            }\n-          }\n-\n-          if (objects.isTruncated()) {\n-            objects \u003d s3.listNextBatchOfObjects(objects);\n-            statistics.incrementReadOps(1);\n-          } else {\n-            if (!keys.isEmpty()) {\n-              removeKeys(keys, false);\n-            }\n-            break;\n-          }\n-        }\n-      }\n-    } else {\n-      LOG.debug(\"delete: Path is a file\");\n-      s3.deleteObject(bucket, key);\n-      instrumentation.fileDeleted(1);\n-      statistics.incrementWriteOps(1);\n-    }\n-\n-    createFakeDirectoryIfNecessary(f.getParent());\n-\n-    return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    try {\n      return innerDelete(f, recursive);\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,80 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n-    }\n+    LOG.debug(\"Delete path {} - recursive {}\", f , recursive);\n     S3AFileStatus status;\n     try {\n       status \u003d getFileStatus(f);\n     } catch (FileNotFoundException e) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n-      }\n+      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n+      instrumentation.errorIgnored();\n       return false;\n     }\n \n     String key \u003d pathToKey(f);\n \n     if (status.isDirectory()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"delete: Path is a directory\");\n-      }\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n \n       if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n         throw new IOException(\"Path is a folder: \" + f +\n                               \" and it is not an empty directory\");\n       }\n \n       if (!key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n \n       if (key.equals(\"/\")) {\n         LOG.info(\"s3a cannot delete the root directory\");\n         return false;\n       }\n \n       if (status.isEmptyDirectory()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Deleting fake empty directory\");\n-        }\n+        LOG.debug(\"Deleting fake empty directory {}\", key);\n         s3.deleteObject(bucket, key);\n+        instrumentation.directoryDeleted();\n         statistics.incrementWriteOps(1);\n       } else {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n-        }\n+        LOG.debug(\"Getting objects for directory prefix {} to delete\", key);\n \n         ListObjectsRequest request \u003d new ListObjectsRequest();\n         request.setBucketName(bucket);\n         request.setPrefix(key);\n         // Hopefully not setting a delimiter will cause this to find everything\n         //request.setDelimiter(\"/\");\n         request.setMaxKeys(maxKeys);\n \n-        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d\n-          new ArrayList\u003c\u003e();\n+        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d new ArrayList\u003c\u003e();\n         ObjectListing objects \u003d s3.listObjects(request);\n         statistics.incrementReadOps(1);\n         while (true) {\n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Got object to delete \" + summary.getKey());\n-            }\n+            LOG.debug(\"Got object to delete {}\", summary.getKey());\n \n             if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n               removeKeys(keys, true);\n             }\n           }\n \n           if (objects.isTruncated()) {\n             objects \u003d s3.listNextBatchOfObjects(objects);\n             statistics.incrementReadOps(1);\n           } else {\n             if (!keys.isEmpty()) {\n               removeKeys(keys, false);\n             }\n             break;\n           }\n         }\n       }\n     } else {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"delete: Path is a file\");\n-      }\n+      LOG.debug(\"delete: Path is a file\");\n       s3.deleteObject(bucket, key);\n+      instrumentation.fileDeleted(1);\n       statistics.incrementWriteOps(1);\n     }\n \n     createFakeDirectoryIfNecessary(f.getParent());\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    LOG.debug(\"Delete path {} - recursive {}\", f , recursive);\n    S3AFileStatus status;\n    try {\n      status \u003d getFileStatus(f);\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"Couldn\u0027t delete {} - does not exist\", f);\n      instrumentation.errorIgnored();\n      return false;\n    }\n\n    String key \u003d pathToKey(f);\n\n    if (status.isDirectory()) {\n      LOG.debug(\"delete: Path is a directory: {}\", f);\n\n      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n        throw new IOException(\"Path is a folder: \" + f +\n                              \" and it is not an empty directory\");\n      }\n\n      if (!key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n\n      if (key.equals(\"/\")) {\n        LOG.info(\"s3a cannot delete the root directory\");\n        return false;\n      }\n\n      if (status.isEmptyDirectory()) {\n        LOG.debug(\"Deleting fake empty directory {}\", key);\n        s3.deleteObject(bucket, key);\n        instrumentation.directoryDeleted();\n        statistics.incrementWriteOps(1);\n      } else {\n        LOG.debug(\"Getting objects for directory prefix {} to delete\", key);\n\n        ListObjectsRequest request \u003d new ListObjectsRequest();\n        request.setBucketName(bucket);\n        request.setPrefix(key);\n        // Hopefully not setting a delimiter will cause this to find everything\n        //request.setDelimiter(\"/\");\n        request.setMaxKeys(maxKeys);\n\n        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d new ArrayList\u003c\u003e();\n        ObjectListing objects \u003d s3.listObjects(request);\n        statistics.incrementReadOps(1);\n        while (true) {\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n            LOG.debug(\"Got object to delete {}\", summary.getKey());\n\n            if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n              removeKeys(keys, true);\n            }\n          }\n\n          if (objects.isTruncated()) {\n            objects \u003d s3.listNextBatchOfObjects(objects);\n            statistics.incrementReadOps(1);\n          } else {\n            if (!keys.isEmpty()) {\n              removeKeys(keys, false);\n            }\n            break;\n          }\n        }\n      }\n    } else {\n      LOG.debug(\"delete: Path is a file\");\n      s3.deleteObject(bucket, key);\n      instrumentation.fileDeleted(1);\n      statistics.incrementWriteOps(1);\n    }\n\n    createFakeDirectoryIfNecessary(f.getParent());\n\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "29ae25801380b94442253c4202dee782dc4713f5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12292. Make use of DeleteObjects optional.  (Thomas Demoor via stevel)\n",
      "commitDate": "06/02/16 7:05 AM",
      "commitName": "29ae25801380b94442253c4202dee782dc4713f5",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/01/16 12:19 PM",
      "commitNameOld": "126705f67eaa6d866f7572fbddf133c5d7552353",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 24.78,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,92 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n     }\n     S3AFileStatus status;\n     try {\n       status \u003d getFileStatus(f);\n     } catch (FileNotFoundException e) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n       }\n       return false;\n     }\n \n     String key \u003d pathToKey(f);\n \n     if (status.isDirectory()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"delete: Path is a directory\");\n       }\n \n       if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n         throw new IOException(\"Path is a folder: \" + f + \n                               \" and it is not an empty directory\");\n       }\n \n       if (!key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n \n       if (key.equals(\"/\")) {\n         LOG.info(\"s3a cannot delete the root directory\");\n         return false;\n       }\n \n       if (status.isEmptyDirectory()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Deleting fake empty directory\");\n         }\n         s3.deleteObject(bucket, key);\n         statistics.incrementWriteOps(1);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n         }\n \n         ListObjectsRequest request \u003d new ListObjectsRequest();\n         request.setBucketName(bucket);\n         request.setPrefix(key);\n         // Hopefully not setting a delimiter will cause this to find everything\n         //request.setDelimiter(\"/\");\n         request.setMaxKeys(maxKeys);\n \n         List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n           new ArrayList\u003c\u003e();\n         ObjectListing objects \u003d s3.listObjects(request);\n         statistics.incrementReadOps(1);\n         while (true) {\n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Got object to delete \" + summary.getKey());\n             }\n \n             if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-              DeleteObjectsRequest deleteRequest \u003d\n-                  new DeleteObjectsRequest(bucket).withKeys(keys);\n-              s3.deleteObjects(deleteRequest);\n-              statistics.incrementWriteOps(1);\n-              keys.clear();\n+              removeKeys(keys, true);\n             }\n           }\n \n           if (objects.isTruncated()) {\n             objects \u003d s3.listNextBatchOfObjects(objects);\n             statistics.incrementReadOps(1);\n           } else {\n             if (!keys.isEmpty()) {\n-              DeleteObjectsRequest deleteRequest \u003d\n-                  new DeleteObjectsRequest(bucket).withKeys(keys);\n-              s3.deleteObjects(deleteRequest);\n-              statistics.incrementWriteOps(1);\n+              removeKeys(keys, false);\n             }\n             break;\n           }\n         }\n       }\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"delete: Path is a file\");\n       }\n       s3.deleteObject(bucket, key);\n       statistics.incrementWriteOps(1);\n     }\n \n     createFakeDirectoryIfNecessary(f.getParent());\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n    }\n    S3AFileStatus status;\n    try {\n      status \u003d getFileStatus(f);\n    } catch (FileNotFoundException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n      }\n      return false;\n    }\n\n    String key \u003d pathToKey(f);\n\n    if (status.isDirectory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a directory\");\n      }\n\n      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n        throw new IOException(\"Path is a folder: \" + f + \n                              \" and it is not an empty directory\");\n      }\n\n      if (!key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n\n      if (key.equals(\"/\")) {\n        LOG.info(\"s3a cannot delete the root directory\");\n        return false;\n      }\n\n      if (status.isEmptyDirectory()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Deleting fake empty directory\");\n        }\n        s3.deleteObject(bucket, key);\n        statistics.incrementWriteOps(1);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n        }\n\n        ListObjectsRequest request \u003d new ListObjectsRequest();\n        request.setBucketName(bucket);\n        request.setPrefix(key);\n        // Hopefully not setting a delimiter will cause this to find everything\n        //request.setDelimiter(\"/\");\n        request.setMaxKeys(maxKeys);\n\n        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n          new ArrayList\u003c\u003e();\n        ObjectListing objects \u003d s3.listObjects(request);\n        statistics.incrementReadOps(1);\n        while (true) {\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got object to delete \" + summary.getKey());\n            }\n\n            if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n              removeKeys(keys, true);\n            }\n          }\n\n          if (objects.isTruncated()) {\n            objects \u003d s3.listNextBatchOfObjects(objects);\n            statistics.incrementReadOps(1);\n          } else {\n            if (!keys.isEmpty()) {\n              removeKeys(keys, false);\n            }\n            break;\n          }\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a file\");\n      }\n      s3.deleteObject(bucket, key);\n      statistics.incrementWriteOps(1);\n    }\n\n    createFakeDirectoryIfNecessary(f.getParent());\n\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "709ff99cff4124823bde631e272af7be9a22f83b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11584 s3a file block size set to 0 in getFileStatus. (Brahma Reddy Battula via stevel)\n",
      "commitDate": "21/02/15 4:03 AM",
      "commitName": "709ff99cff4124823bde631e272af7be9a22f83b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/02/15 12:51 PM",
      "commitNameOld": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n     }\n     S3AFileStatus status;\n     try {\n       status \u003d getFileStatus(f);\n     } catch (FileNotFoundException e) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n       }\n       return false;\n     }\n \n     String key \u003d pathToKey(f);\n \n     if (status.isDirectory()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"delete: Path is a directory\");\n       }\n \n       if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n         throw new IOException(\"Path is a folder: \" + f + \n                               \" and it is not an empty directory\");\n       }\n \n       if (!key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n \n       if (key.equals(\"/\")) {\n         LOG.info(\"s3a cannot delete the root directory\");\n         return false;\n       }\n \n       if (status.isEmptyDirectory()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Deleting fake empty directory\");\n         }\n         s3.deleteObject(bucket, key);\n         statistics.incrementWriteOps(1);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n         }\n \n         ListObjectsRequest request \u003d new ListObjectsRequest();\n         request.setBucketName(bucket);\n         request.setPrefix(key);\n         // Hopefully not setting a delimiter will cause this to find everything\n         //request.setDelimiter(\"/\");\n         request.setMaxKeys(maxKeys);\n \n         List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n-          new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n+          new ArrayList\u003c\u003e();\n         ObjectListing objects \u003d s3.listObjects(request);\n         statistics.incrementReadOps(1);\n         while (true) {\n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Got object to delete \" + summary.getKey());\n             }\n \n             if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n               DeleteObjectsRequest deleteRequest \u003d\n                   new DeleteObjectsRequest(bucket).withKeys(keys);\n               s3.deleteObjects(deleteRequest);\n               statistics.incrementWriteOps(1);\n               keys.clear();\n             }\n           }\n \n           if (objects.isTruncated()) {\n             objects \u003d s3.listNextBatchOfObjects(objects);\n             statistics.incrementReadOps(1);\n           } else {\n-            if (keys.size() \u003e 0) {\n+            if (!keys.isEmpty()) {\n               DeleteObjectsRequest deleteRequest \u003d\n                   new DeleteObjectsRequest(bucket).withKeys(keys);\n               s3.deleteObjects(deleteRequest);\n               statistics.incrementWriteOps(1);\n             }\n             break;\n           }\n         }\n       }\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"delete: Path is a file\");\n       }\n       s3.deleteObject(bucket, key);\n       statistics.incrementWriteOps(1);\n     }\n \n     createFakeDirectoryIfNecessary(f.getParent());\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n    }\n    S3AFileStatus status;\n    try {\n      status \u003d getFileStatus(f);\n    } catch (FileNotFoundException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n      }\n      return false;\n    }\n\n    String key \u003d pathToKey(f);\n\n    if (status.isDirectory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a directory\");\n      }\n\n      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n        throw new IOException(\"Path is a folder: \" + f + \n                              \" and it is not an empty directory\");\n      }\n\n      if (!key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n\n      if (key.equals(\"/\")) {\n        LOG.info(\"s3a cannot delete the root directory\");\n        return false;\n      }\n\n      if (status.isEmptyDirectory()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Deleting fake empty directory\");\n        }\n        s3.deleteObject(bucket, key);\n        statistics.incrementWriteOps(1);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n        }\n\n        ListObjectsRequest request \u003d new ListObjectsRequest();\n        request.setBucketName(bucket);\n        request.setPrefix(key);\n        // Hopefully not setting a delimiter will cause this to find everything\n        //request.setDelimiter(\"/\");\n        request.setMaxKeys(maxKeys);\n\n        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n          new ArrayList\u003c\u003e();\n        ObjectListing objects \u003d s3.listObjects(request);\n        statistics.incrementReadOps(1);\n        while (true) {\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got object to delete \" + summary.getKey());\n            }\n\n            if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n              DeleteObjectsRequest deleteRequest \u003d\n                  new DeleteObjectsRequest(bucket).withKeys(keys);\n              s3.deleteObjects(deleteRequest);\n              statistics.incrementWriteOps(1);\n              keys.clear();\n            }\n          }\n\n          if (objects.isTruncated()) {\n            objects \u003d s3.listNextBatchOfObjects(objects);\n            statistics.incrementReadOps(1);\n          } else {\n            if (!keys.isEmpty()) {\n              DeleteObjectsRequest deleteRequest \u003d\n                  new DeleteObjectsRequest(bucket).withKeys(keys);\n              s3.deleteObjects(deleteRequest);\n              statistics.incrementWriteOps(1);\n            }\n            break;\n          }\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a file\");\n      }\n      s3.deleteObject(bucket, key);\n      statistics.incrementWriteOps(1);\n    }\n\n    createFakeDirectoryIfNecessary(f.getParent());\n\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 4:49 PM",
      "commitNameOld": "0ac760a58d96b36ab30e9d60679bbea6365ef120",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,99 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n-    LOG.info(\"Delete path \" + f + \" - recursive \" + recursive);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n+    }\n     S3AFileStatus status;\n     try {\n       status \u003d getFileStatus(f);\n     } catch (FileNotFoundException e) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n       }\n       return false;\n     }\n \n     String key \u003d pathToKey(f);\n \n     if (status.isDirectory()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"delete: Path is a directory\");\n       }\n \n       if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n         throw new IOException(\"Path is a folder: \" + f + \n                               \" and it is not an empty directory\");\n       }\n \n       if (!key.endsWith(\"/\")) {\n         key \u003d key + \"/\";\n       }\n \n       if (key.equals(\"/\")) {\n         LOG.info(\"s3a cannot delete the root directory\");\n         return false;\n       }\n \n       if (status.isEmptyDirectory()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Deleting fake empty directory\");\n         }\n         s3.deleteObject(bucket, key);\n         statistics.incrementWriteOps(1);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n         }\n \n         ListObjectsRequest request \u003d new ListObjectsRequest();\n         request.setBucketName(bucket);\n         request.setPrefix(key);\n         // Hopefully not setting a delimiter will cause this to find everything\n         //request.setDelimiter(\"/\");\n         request.setMaxKeys(maxKeys);\n \n         List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n           new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n         ObjectListing objects \u003d s3.listObjects(request);\n         statistics.incrementReadOps(1);\n         while (true) {\n           for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n             keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Got object to delete \" + summary.getKey());\n             }\n-          }\n \n-          DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n-          deleteRequest.setKeys(keys);\n-          s3.deleteObjects(deleteRequest);\n-          statistics.incrementWriteOps(1);\n-          keys.clear();\n+            if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+              DeleteObjectsRequest deleteRequest \u003d\n+                  new DeleteObjectsRequest(bucket).withKeys(keys);\n+              s3.deleteObjects(deleteRequest);\n+              statistics.incrementWriteOps(1);\n+              keys.clear();\n+            }\n+          }\n \n           if (objects.isTruncated()) {\n             objects \u003d s3.listNextBatchOfObjects(objects);\n             statistics.incrementReadOps(1);\n           } else {\n+            if (keys.size() \u003e 0) {\n+              DeleteObjectsRequest deleteRequest \u003d\n+                  new DeleteObjectsRequest(bucket).withKeys(keys);\n+              s3.deleteObjects(deleteRequest);\n+              statistics.incrementWriteOps(1);\n+            }\n             break;\n           }\n         }\n       }\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"delete: Path is a file\");\n       }\n       s3.deleteObject(bucket, key);\n       statistics.incrementWriteOps(1);\n     }\n \n     createFakeDirectoryIfNecessary(f.getParent());\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Delete path \" + f + \" - recursive \" + recursive);\n    }\n    S3AFileStatus status;\n    try {\n      status \u003d getFileStatus(f);\n    } catch (FileNotFoundException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n      }\n      return false;\n    }\n\n    String key \u003d pathToKey(f);\n\n    if (status.isDirectory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a directory\");\n      }\n\n      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n        throw new IOException(\"Path is a folder: \" + f + \n                              \" and it is not an empty directory\");\n      }\n\n      if (!key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n\n      if (key.equals(\"/\")) {\n        LOG.info(\"s3a cannot delete the root directory\");\n        return false;\n      }\n\n      if (status.isEmptyDirectory()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Deleting fake empty directory\");\n        }\n        s3.deleteObject(bucket, key);\n        statistics.incrementWriteOps(1);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n        }\n\n        ListObjectsRequest request \u003d new ListObjectsRequest();\n        request.setBucketName(bucket);\n        request.setPrefix(key);\n        // Hopefully not setting a delimiter will cause this to find everything\n        //request.setDelimiter(\"/\");\n        request.setMaxKeys(maxKeys);\n\n        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n          new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n        ObjectListing objects \u003d s3.listObjects(request);\n        statistics.incrementReadOps(1);\n        while (true) {\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got object to delete \" + summary.getKey());\n            }\n\n            if (keys.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n              DeleteObjectsRequest deleteRequest \u003d\n                  new DeleteObjectsRequest(bucket).withKeys(keys);\n              s3.deleteObjects(deleteRequest);\n              statistics.incrementWriteOps(1);\n              keys.clear();\n            }\n          }\n\n          if (objects.isTruncated()) {\n            objects \u003d s3.listNextBatchOfObjects(objects);\n            statistics.incrementReadOps(1);\n          } else {\n            if (keys.size() \u003e 0) {\n              DeleteObjectsRequest deleteRequest \u003d\n                  new DeleteObjectsRequest(bucket).withKeys(keys);\n              s3.deleteObjects(deleteRequest);\n              statistics.incrementWriteOps(1);\n            }\n            break;\n          }\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a file\");\n      }\n      s3.deleteObject(bucket, key);\n      statistics.incrementWriteOps(1);\n    }\n\n    createFakeDirectoryIfNecessary(f.getParent());\n\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,89 @@\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    LOG.info(\"Delete path \" + f + \" - recursive \" + recursive);\n+    S3AFileStatus status;\n+    try {\n+      status \u003d getFileStatus(f);\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n+      }\n+      return false;\n+    }\n+\n+    String key \u003d pathToKey(f);\n+\n+    if (status.isDirectory()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"delete: Path is a directory\");\n+      }\n+\n+      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n+        throw new IOException(\"Path is a folder: \" + f + \n+                              \" and it is not an empty directory\");\n+      }\n+\n+      if (!key.endsWith(\"/\")) {\n+        key \u003d key + \"/\";\n+      }\n+\n+      if (key.equals(\"/\")) {\n+        LOG.info(\"s3a cannot delete the root directory\");\n+        return false;\n+      }\n+\n+      if (status.isEmptyDirectory()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Deleting fake empty directory\");\n+        }\n+        s3.deleteObject(bucket, key);\n+        statistics.incrementWriteOps(1);\n+      } else {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n+        }\n+\n+        ListObjectsRequest request \u003d new ListObjectsRequest();\n+        request.setBucketName(bucket);\n+        request.setPrefix(key);\n+        // Hopefully not setting a delimiter will cause this to find everything\n+        //request.setDelimiter(\"/\");\n+        request.setMaxKeys(maxKeys);\n+\n+        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n+          new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n+        ObjectListing objects \u003d s3.listObjects(request);\n+        statistics.incrementReadOps(1);\n+        while (true) {\n+          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n+            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Got object to delete \" + summary.getKey());\n+            }\n+          }\n+\n+          DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n+          deleteRequest.setKeys(keys);\n+          s3.deleteObjects(deleteRequest);\n+          statistics.incrementWriteOps(1);\n+          keys.clear();\n+\n+          if (objects.isTruncated()) {\n+            objects \u003d s3.listNextBatchOfObjects(objects);\n+            statistics.incrementReadOps(1);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"delete: Path is a file\");\n+      }\n+      s3.deleteObject(bucket, key);\n+      statistics.incrementWriteOps(1);\n+    }\n+\n+    createFakeDirectoryIfNecessary(f.getParent());\n+\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    LOG.info(\"Delete path \" + f + \" - recursive \" + recursive);\n    S3AFileStatus status;\n    try {\n      status \u003d getFileStatus(f);\n    } catch (FileNotFoundException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t delete \" + f + \" - does not exist\");\n      }\n      return false;\n    }\n\n    String key \u003d pathToKey(f);\n\n    if (status.isDirectory()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a directory\");\n      }\n\n      if (!recursive \u0026\u0026 !status.isEmptyDirectory()) {\n        throw new IOException(\"Path is a folder: \" + f + \n                              \" and it is not an empty directory\");\n      }\n\n      if (!key.endsWith(\"/\")) {\n        key \u003d key + \"/\";\n      }\n\n      if (key.equals(\"/\")) {\n        LOG.info(\"s3a cannot delete the root directory\");\n        return false;\n      }\n\n      if (status.isEmptyDirectory()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Deleting fake empty directory\");\n        }\n        s3.deleteObject(bucket, key);\n        statistics.incrementWriteOps(1);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Getting objects for directory prefix \" + key + \" to delete\");\n        }\n\n        ListObjectsRequest request \u003d new ListObjectsRequest();\n        request.setBucketName(bucket);\n        request.setPrefix(key);\n        // Hopefully not setting a delimiter will cause this to find everything\n        //request.setDelimiter(\"/\");\n        request.setMaxKeys(maxKeys);\n\n        List\u003cDeleteObjectsRequest.KeyVersion\u003e keys \u003d \n          new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n        ObjectListing objects \u003d s3.listObjects(request);\n        statistics.incrementReadOps(1);\n        while (true) {\n          for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n            keys.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got object to delete \" + summary.getKey());\n            }\n          }\n\n          DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n          deleteRequest.setKeys(keys);\n          s3.deleteObjects(deleteRequest);\n          statistics.incrementWriteOps(1);\n          keys.clear();\n\n          if (objects.isTruncated()) {\n            objects \u003d s3.listNextBatchOfObjects(objects);\n            statistics.incrementReadOps(1);\n          } else {\n            break;\n          }\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"delete: Path is a file\");\n      }\n      s3.deleteObject(bucket, key);\n      statistics.incrementWriteOps(1);\n    }\n\n    createFakeDirectoryIfNecessary(f.getParent());\n\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}