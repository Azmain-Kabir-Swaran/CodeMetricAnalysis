{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReencryptionHandler.java",
  "functionName": "throttle",
  "functionId": "throttle",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionHandler.java",
  "functionStartLine": 748,
  "functionEndLine": 797,
  "numCommitsSeen": 10,
  "timeTaken": 3444,
  "changeHistory": [
    "f89594f0b80e8efffdcb887daa4a18a2b0a228b3",
    "248d9b6fff648cdb02581d458556b6f7c090ef1a",
    "1000a2af04b24c123a3b08168f36b4e90420cab7"
  ],
  "changeHistoryShort": {
    "f89594f0b80e8efffdcb887daa4a18a2b0a228b3": "Ymultichange(Ymodifierchange,Ybodychange)",
    "248d9b6fff648cdb02581d458556b6f7c090ef1a": "Ybodychange",
    "1000a2af04b24c123a3b08168f36b4e90420cab7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f89594f0b80e8efffdcb887daa4a18a2b0a228b3": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-13328. Abstract ReencryptionHandler recursive logic in separate class. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "10/04/18 11:05 AM",
      "commitName": "f89594f0b80e8efffdcb887daa4a18a2b0a228b3",
      "commitAuthor": "Rakesh Radhakrishnan",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-13328. Abstract ReencryptionHandler recursive logic in separate class. Contributed by Surendra Singh Lilhore.\n",
          "commitDate": "10/04/18 11:05 AM",
          "commitName": "f89594f0b80e8efffdcb887daa4a18a2b0a228b3",
          "commitAuthor": "Rakesh Radhakrishnan",
          "commitDateOld": "08/02/18 10:55 AM",
          "commitNameOld": "996796f1048369e0f307f935ba01af64cc751a85",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 60.96,
          "commitsBetweenForRepo": 509,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,50 @@\n-  void throttle() throws InterruptedException {\n-    // 1.\n-    final int numCores \u003d Runtime.getRuntime().availableProcessors();\n-    if (taskQueue.size() \u003e\u003d numCores) {\n-      LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n-          + \"larger than number of cores {}\", taskQueue.size(), numCores);\n-      while (taskQueue.size() \u003e\u003d numCores) {\n-        Thread.sleep(100);\n+    protected void throttle() throws InterruptedException {\n+      assert !dir.hasReadLock();\n+      assert !dir.getFSNamesystem().hasReadLock();\n+      final int numCores \u003d Runtime.getRuntime().availableProcessors();\n+      if (taskQueue.size() \u003e\u003d numCores) {\n+        LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n+            + \"larger than number of cores {}\", taskQueue.size(), numCores);\n+        while (taskQueue.size() \u003e\u003d numCores) {\n+          Thread.sleep(100);\n+        }\n       }\n-    }\n \n-    // 2. if tasks are piling up on the updater, don\u0027t create new callables\n-    // until the queue size goes down.\n-    final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n-    int numTasks \u003d numTasksSubmitted();\n-    if (numTasks \u003e\u003d maxTasksPiled) {\n-      LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n-          + \" re-encryption updater is {}\", numTasks);\n-      while (numTasks \u003e\u003d maxTasksPiled) {\n-        Thread.sleep(500);\n-        numTasks \u003d numTasksSubmitted();\n+      // 2. if tasks are piling up on the updater, don\u0027t create new callables\n+      // until the queue size goes down.\n+      final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n+      int numTasks \u003d numTasksSubmitted();\n+      if (numTasks \u003e\u003d maxTasksPiled) {\n+        LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n+            + \" re-encryption updater is {}\", numTasks);\n+        while (numTasks \u003e\u003d maxTasksPiled) {\n+          Thread.sleep(500);\n+          numTasks \u003d numTasksSubmitted();\n+        }\n       }\n-    }\n \n-    // 3.\n-    if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n-      return;\n-    }\n-    final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n-        * throttleLimitHandlerRatio);\n-    final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n-              + \" throttleTimerAll:{}\", expect, actual,\n-          throttleTimerAll.now(TimeUnit.MILLISECONDS));\n-    }\n-    if (expect - actual \u003c 0) {\n-      // in case throttleLimitHandlerRatio is very small, expect will be 0.\n-      // so sleepMs should not be calculated from expect, to really meet the\n-      // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n-      // should be 1000 - throttleTimerAll.now()\n-      final long sleepMs \u003d\n-          (long) (actual / throttleLimitHandlerRatio) - throttleTimerAll\n-              .now(TimeUnit.MILLISECONDS);\n-      LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n-      Thread.sleep(sleepMs);\n-    }\n-    throttleTimerAll.reset().start();\n-    throttleTimerLocked.reset();\n-  }\n\\ No newline at end of file\n+      // 3.\n+      if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n+        return;\n+      }\n+      final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n+          * throttleLimitHandlerRatio);\n+      final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n+            + \" throttleTimerAll:{}\", expect, actual,\n+            throttleTimerAll.now(TimeUnit.MILLISECONDS));\n+      }\n+      if (expect - actual \u003c 0) {\n+        // in case throttleLimitHandlerRatio is very small, expect will be 0.\n+        // so sleepMs should not be calculated from expect, to really meet the\n+        // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n+        // should be 1000 - throttleTimerAll.now()\n+        final long sleepMs \u003d (long) (actual / throttleLimitHandlerRatio)\n+            - throttleTimerAll.now(TimeUnit.MILLISECONDS);\n+        LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n+        Thread.sleep(sleepMs);\n+      }\n+      throttleTimerAll.reset().start();\n+      throttleTimerLocked.reset();\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    protected void throttle() throws InterruptedException {\n      assert !dir.hasReadLock();\n      assert !dir.getFSNamesystem().hasReadLock();\n      final int numCores \u003d Runtime.getRuntime().availableProcessors();\n      if (taskQueue.size() \u003e\u003d numCores) {\n        LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n            + \"larger than number of cores {}\", taskQueue.size(), numCores);\n        while (taskQueue.size() \u003e\u003d numCores) {\n          Thread.sleep(100);\n        }\n      }\n\n      // 2. if tasks are piling up on the updater, don\u0027t create new callables\n      // until the queue size goes down.\n      final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n      int numTasks \u003d numTasksSubmitted();\n      if (numTasks \u003e\u003d maxTasksPiled) {\n        LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n            + \" re-encryption updater is {}\", numTasks);\n        while (numTasks \u003e\u003d maxTasksPiled) {\n          Thread.sleep(500);\n          numTasks \u003d numTasksSubmitted();\n        }\n      }\n\n      // 3.\n      if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n        return;\n      }\n      final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n          * throttleLimitHandlerRatio);\n      final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n            + \" throttleTimerAll:{}\", expect, actual,\n            throttleTimerAll.now(TimeUnit.MILLISECONDS));\n      }\n      if (expect - actual \u003c 0) {\n        // in case throttleLimitHandlerRatio is very small, expect will be 0.\n        // so sleepMs should not be calculated from expect, to really meet the\n        // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n        // should be 1000 - throttleTimerAll.now()\n        final long sleepMs \u003d (long) (actual / throttleLimitHandlerRatio)\n            - throttleTimerAll.now(TimeUnit.MILLISECONDS);\n        LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n        Thread.sleep(sleepMs);\n      }\n      throttleTimerAll.reset().start();\n      throttleTimerLocked.reset();\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionHandler.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13328. Abstract ReencryptionHandler recursive logic in separate class. Contributed by Surendra Singh Lilhore.\n",
          "commitDate": "10/04/18 11:05 AM",
          "commitName": "f89594f0b80e8efffdcb887daa4a18a2b0a228b3",
          "commitAuthor": "Rakesh Radhakrishnan",
          "commitDateOld": "08/02/18 10:55 AM",
          "commitNameOld": "996796f1048369e0f307f935ba01af64cc751a85",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 60.96,
          "commitsBetweenForRepo": 509,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,50 @@\n-  void throttle() throws InterruptedException {\n-    // 1.\n-    final int numCores \u003d Runtime.getRuntime().availableProcessors();\n-    if (taskQueue.size() \u003e\u003d numCores) {\n-      LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n-          + \"larger than number of cores {}\", taskQueue.size(), numCores);\n-      while (taskQueue.size() \u003e\u003d numCores) {\n-        Thread.sleep(100);\n+    protected void throttle() throws InterruptedException {\n+      assert !dir.hasReadLock();\n+      assert !dir.getFSNamesystem().hasReadLock();\n+      final int numCores \u003d Runtime.getRuntime().availableProcessors();\n+      if (taskQueue.size() \u003e\u003d numCores) {\n+        LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n+            + \"larger than number of cores {}\", taskQueue.size(), numCores);\n+        while (taskQueue.size() \u003e\u003d numCores) {\n+          Thread.sleep(100);\n+        }\n       }\n-    }\n \n-    // 2. if tasks are piling up on the updater, don\u0027t create new callables\n-    // until the queue size goes down.\n-    final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n-    int numTasks \u003d numTasksSubmitted();\n-    if (numTasks \u003e\u003d maxTasksPiled) {\n-      LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n-          + \" re-encryption updater is {}\", numTasks);\n-      while (numTasks \u003e\u003d maxTasksPiled) {\n-        Thread.sleep(500);\n-        numTasks \u003d numTasksSubmitted();\n+      // 2. if tasks are piling up on the updater, don\u0027t create new callables\n+      // until the queue size goes down.\n+      final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n+      int numTasks \u003d numTasksSubmitted();\n+      if (numTasks \u003e\u003d maxTasksPiled) {\n+        LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n+            + \" re-encryption updater is {}\", numTasks);\n+        while (numTasks \u003e\u003d maxTasksPiled) {\n+          Thread.sleep(500);\n+          numTasks \u003d numTasksSubmitted();\n+        }\n       }\n-    }\n \n-    // 3.\n-    if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n-      return;\n-    }\n-    final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n-        * throttleLimitHandlerRatio);\n-    final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n-              + \" throttleTimerAll:{}\", expect, actual,\n-          throttleTimerAll.now(TimeUnit.MILLISECONDS));\n-    }\n-    if (expect - actual \u003c 0) {\n-      // in case throttleLimitHandlerRatio is very small, expect will be 0.\n-      // so sleepMs should not be calculated from expect, to really meet the\n-      // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n-      // should be 1000 - throttleTimerAll.now()\n-      final long sleepMs \u003d\n-          (long) (actual / throttleLimitHandlerRatio) - throttleTimerAll\n-              .now(TimeUnit.MILLISECONDS);\n-      LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n-      Thread.sleep(sleepMs);\n-    }\n-    throttleTimerAll.reset().start();\n-    throttleTimerLocked.reset();\n-  }\n\\ No newline at end of file\n+      // 3.\n+      if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n+        return;\n+      }\n+      final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n+          * throttleLimitHandlerRatio);\n+      final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n+            + \" throttleTimerAll:{}\", expect, actual,\n+            throttleTimerAll.now(TimeUnit.MILLISECONDS));\n+      }\n+      if (expect - actual \u003c 0) {\n+        // in case throttleLimitHandlerRatio is very small, expect will be 0.\n+        // so sleepMs should not be calculated from expect, to really meet the\n+        // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n+        // should be 1000 - throttleTimerAll.now()\n+        final long sleepMs \u003d (long) (actual / throttleLimitHandlerRatio)\n+            - throttleTimerAll.now(TimeUnit.MILLISECONDS);\n+        LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n+        Thread.sleep(sleepMs);\n+      }\n+      throttleTimerAll.reset().start();\n+      throttleTimerLocked.reset();\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    protected void throttle() throws InterruptedException {\n      assert !dir.hasReadLock();\n      assert !dir.getFSNamesystem().hasReadLock();\n      final int numCores \u003d Runtime.getRuntime().availableProcessors();\n      if (taskQueue.size() \u003e\u003d numCores) {\n        LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n            + \"larger than number of cores {}\", taskQueue.size(), numCores);\n        while (taskQueue.size() \u003e\u003d numCores) {\n          Thread.sleep(100);\n        }\n      }\n\n      // 2. if tasks are piling up on the updater, don\u0027t create new callables\n      // until the queue size goes down.\n      final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n      int numTasks \u003d numTasksSubmitted();\n      if (numTasks \u003e\u003d maxTasksPiled) {\n        LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n            + \" re-encryption updater is {}\", numTasks);\n        while (numTasks \u003e\u003d maxTasksPiled) {\n          Thread.sleep(500);\n          numTasks \u003d numTasksSubmitted();\n        }\n      }\n\n      // 3.\n      if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n        return;\n      }\n      final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n          * throttleLimitHandlerRatio);\n      final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n            + \" throttleTimerAll:{}\", expect, actual,\n            throttleTimerAll.now(TimeUnit.MILLISECONDS));\n      }\n      if (expect - actual \u003c 0) {\n        // in case throttleLimitHandlerRatio is very small, expect will be 0.\n        // so sleepMs should not be calculated from expect, to really meet the\n        // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n        // should be 1000 - throttleTimerAll.now()\n        final long sleepMs \u003d (long) (actual / throttleLimitHandlerRatio)\n            - throttleTimerAll.now(TimeUnit.MILLISECONDS);\n        LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n        Thread.sleep(sleepMs);\n      }\n      throttleTimerAll.reset().start();\n      throttleTimerLocked.reset();\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionHandler.java",
          "extendedDetails": {}
        }
      ]
    },
    "248d9b6fff648cdb02581d458556b6f7c090ef1a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12518. Re-encryption should handle task cancellation and progress better.\n",
      "commitDate": "20/10/17 4:25 PM",
      "commitName": "248d9b6fff648cdb02581d458556b6f7c090ef1a",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "23/08/17 5:06 PM",
      "commitNameOld": "1000a2af04b24c123a3b08168f36b4e90420cab7",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 57.97,
      "commitsBetweenForRepo": 544,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,50 @@\n   void throttle() throws InterruptedException {\n     // 1.\n     final int numCores \u003d Runtime.getRuntime().availableProcessors();\n     if (taskQueue.size() \u003e\u003d numCores) {\n       LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n           + \"larger than number of cores {}\", taskQueue.size(), numCores);\n       while (taskQueue.size() \u003e\u003d numCores) {\n         Thread.sleep(100);\n       }\n     }\n \n     // 2. if tasks are piling up on the updater, don\u0027t create new callables\n     // until the queue size goes down.\n     final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n-    int totalTasks \u003d 0;\n-    for (ZoneSubmissionTracker zst : submissions.values()) {\n-      totalTasks +\u003d zst.getTasks().size();\n-    }\n-    if (totalTasks \u003e\u003d maxTasksPiled) {\n+    int numTasks \u003d numTasksSubmitted();\n+    if (numTasks \u003e\u003d maxTasksPiled) {\n       LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n-          + \" re-encryption updater is {}\", totalTasks);\n-      while (totalTasks \u003e\u003d maxTasksPiled) {\n+          + \" re-encryption updater is {}\", numTasks);\n+      while (numTasks \u003e\u003d maxTasksPiled) {\n         Thread.sleep(500);\n-        totalTasks \u003d 0;\n-        for (ZoneSubmissionTracker zst : submissions.values()) {\n-          totalTasks +\u003d zst.getTasks().size();\n-        }\n+        numTasks \u003d numTasksSubmitted();\n       }\n     }\n \n     // 3.\n     if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n       return;\n     }\n     final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n         * throttleLimitHandlerRatio);\n     final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n               + \" throttleTimerAll:{}\", expect, actual,\n           throttleTimerAll.now(TimeUnit.MILLISECONDS));\n     }\n     if (expect - actual \u003c 0) {\n       // in case throttleLimitHandlerRatio is very small, expect will be 0.\n       // so sleepMs should not be calculated from expect, to really meet the\n       // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n       // should be 1000 - throttleTimerAll.now()\n       final long sleepMs \u003d\n           (long) (actual / throttleLimitHandlerRatio) - throttleTimerAll\n               .now(TimeUnit.MILLISECONDS);\n       LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n       Thread.sleep(sleepMs);\n     }\n     throttleTimerAll.reset().start();\n     throttleTimerLocked.reset();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void throttle() throws InterruptedException {\n    // 1.\n    final int numCores \u003d Runtime.getRuntime().availableProcessors();\n    if (taskQueue.size() \u003e\u003d numCores) {\n      LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n          + \"larger than number of cores {}\", taskQueue.size(), numCores);\n      while (taskQueue.size() \u003e\u003d numCores) {\n        Thread.sleep(100);\n      }\n    }\n\n    // 2. if tasks are piling up on the updater, don\u0027t create new callables\n    // until the queue size goes down.\n    final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n    int numTasks \u003d numTasksSubmitted();\n    if (numTasks \u003e\u003d maxTasksPiled) {\n      LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n          + \" re-encryption updater is {}\", numTasks);\n      while (numTasks \u003e\u003d maxTasksPiled) {\n        Thread.sleep(500);\n        numTasks \u003d numTasksSubmitted();\n      }\n    }\n\n    // 3.\n    if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n      return;\n    }\n    final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n        * throttleLimitHandlerRatio);\n    final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n              + \" throttleTimerAll:{}\", expect, actual,\n          throttleTimerAll.now(TimeUnit.MILLISECONDS));\n    }\n    if (expect - actual \u003c 0) {\n      // in case throttleLimitHandlerRatio is very small, expect will be 0.\n      // so sleepMs should not be calculated from expect, to really meet the\n      // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n      // should be 1000 - throttleTimerAll.now()\n      final long sleepMs \u003d\n          (long) (actual / throttleLimitHandlerRatio) - throttleTimerAll\n              .now(TimeUnit.MILLISECONDS);\n      LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n      Thread.sleep(sleepMs);\n    }\n    throttleTimerAll.reset().start();\n    throttleTimerLocked.reset();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionHandler.java",
      "extendedDetails": {}
    },
    "1000a2af04b24c123a3b08168f36b4e90420cab7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10899. Add functionality to re-encrypt EDEKs.\n",
      "commitDate": "23/08/17 5:06 PM",
      "commitName": "1000a2af04b24c123a3b08168f36b4e90420cab7",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,56 @@\n+  void throttle() throws InterruptedException {\n+    // 1.\n+    final int numCores \u003d Runtime.getRuntime().availableProcessors();\n+    if (taskQueue.size() \u003e\u003d numCores) {\n+      LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n+          + \"larger than number of cores {}\", taskQueue.size(), numCores);\n+      while (taskQueue.size() \u003e\u003d numCores) {\n+        Thread.sleep(100);\n+      }\n+    }\n+\n+    // 2. if tasks are piling up on the updater, don\u0027t create new callables\n+    // until the queue size goes down.\n+    final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n+    int totalTasks \u003d 0;\n+    for (ZoneSubmissionTracker zst : submissions.values()) {\n+      totalTasks +\u003d zst.getTasks().size();\n+    }\n+    if (totalTasks \u003e\u003d maxTasksPiled) {\n+      LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n+          + \" re-encryption updater is {}\", totalTasks);\n+      while (totalTasks \u003e\u003d maxTasksPiled) {\n+        Thread.sleep(500);\n+        totalTasks \u003d 0;\n+        for (ZoneSubmissionTracker zst : submissions.values()) {\n+          totalTasks +\u003d zst.getTasks().size();\n+        }\n+      }\n+    }\n+\n+    // 3.\n+    if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n+      return;\n+    }\n+    final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n+        * throttleLimitHandlerRatio);\n+    final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n+              + \" throttleTimerAll:{}\", expect, actual,\n+          throttleTimerAll.now(TimeUnit.MILLISECONDS));\n+    }\n+    if (expect - actual \u003c 0) {\n+      // in case throttleLimitHandlerRatio is very small, expect will be 0.\n+      // so sleepMs should not be calculated from expect, to really meet the\n+      // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n+      // should be 1000 - throttleTimerAll.now()\n+      final long sleepMs \u003d\n+          (long) (actual / throttleLimitHandlerRatio) - throttleTimerAll\n+              .now(TimeUnit.MILLISECONDS);\n+      LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n+      Thread.sleep(sleepMs);\n+    }\n+    throttleTimerAll.reset().start();\n+    throttleTimerLocked.reset();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void throttle() throws InterruptedException {\n    // 1.\n    final int numCores \u003d Runtime.getRuntime().availableProcessors();\n    if (taskQueue.size() \u003e\u003d numCores) {\n      LOG.debug(\"Re-encryption handler throttling because queue size {} is\"\n          + \"larger than number of cores {}\", taskQueue.size(), numCores);\n      while (taskQueue.size() \u003e\u003d numCores) {\n        Thread.sleep(100);\n      }\n    }\n\n    // 2. if tasks are piling up on the updater, don\u0027t create new callables\n    // until the queue size goes down.\n    final int maxTasksPiled \u003d Runtime.getRuntime().availableProcessors() * 2;\n    int totalTasks \u003d 0;\n    for (ZoneSubmissionTracker zst : submissions.values()) {\n      totalTasks +\u003d zst.getTasks().size();\n    }\n    if (totalTasks \u003e\u003d maxTasksPiled) {\n      LOG.debug(\"Re-encryption handler throttling because total tasks pending\"\n          + \" re-encryption updater is {}\", totalTasks);\n      while (totalTasks \u003e\u003d maxTasksPiled) {\n        Thread.sleep(500);\n        totalTasks \u003d 0;\n        for (ZoneSubmissionTracker zst : submissions.values()) {\n          totalTasks +\u003d zst.getTasks().size();\n        }\n      }\n    }\n\n    // 3.\n    if (throttleLimitHandlerRatio \u003e\u003d 1.0) {\n      return;\n    }\n    final long expect \u003d (long) (throttleTimerAll.now(TimeUnit.MILLISECONDS)\n        * throttleLimitHandlerRatio);\n    final long actual \u003d throttleTimerLocked.now(TimeUnit.MILLISECONDS);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Re-encryption handler throttling expect: {}, actual: {},\"\n              + \" throttleTimerAll:{}\", expect, actual,\n          throttleTimerAll.now(TimeUnit.MILLISECONDS));\n    }\n    if (expect - actual \u003c 0) {\n      // in case throttleLimitHandlerRatio is very small, expect will be 0.\n      // so sleepMs should not be calculated from expect, to really meet the\n      // ratio. e.g. if ratio is 0.001, expect \u003d 0 and actual \u003d 1, sleepMs\n      // should be 1000 - throttleTimerAll.now()\n      final long sleepMs \u003d\n          (long) (actual / throttleLimitHandlerRatio) - throttleTimerAll\n              .now(TimeUnit.MILLISECONDS);\n      LOG.debug(\"Throttling re-encryption, sleeping for {} ms\", sleepMs);\n      Thread.sleep(sleepMs);\n    }\n    throttleTimerAll.reset().start();\n    throttleTimerLocked.reset();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionHandler.java"
    }
  }
}