{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "EntityGroupFSTimelineStore.java",
  "functionName": "cleanLogs",
  "functionId": "cleanLogs___dirpath-Path__retainMillis-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
  "functionStartLine": 466,
  "functionEndLine": 482,
  "numCommitsSeen": 28,
  "timeTaken": 5303,
  "changeHistory": [
    "89a53c7eb41098d85d238c39a62d3f98e5f51585",
    "7b03072fd466de5817fdcd65f9dd88fd59c0bb00",
    "06413da72efed9a50e49efaf7110c220c88a7f4a",
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
    "02f597c5db36ded385413958bdee793ad7eda40e"
  ],
  "changeHistoryShort": {
    "89a53c7eb41098d85d238c39a62d3f98e5f51585": "Ybodychange",
    "7b03072fd466de5817fdcd65f9dd88fd59c0bb00": "Ymultichange(Yparameterchange,Ybodychange)",
    "06413da72efed9a50e49efaf7110c220c88a7f4a": "Ybodychange",
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec": "Ymultichange(Ymodifierchange,Ybodychange)",
    "02f597c5db36ded385413958bdee793ad7eda40e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "89a53c7eb41098d85d238c39a62d3f98e5f51585": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9747. Reduce additional namenode call by EntityGroupFSTimelineStore#cleanLogs. Contributed by Prabhu Joseph.\n",
      "commitDate": "14/08/19 1:16 AM",
      "commitName": "89a53c7eb41098d85d238c39a62d3f98e5f51585",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "30/05/19 11:42 AM",
      "commitNameOld": "f1552f6edb8fe152003fd71944851b2b46a6677d",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 75.57,
      "commitsBetweenForRepo": 648,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,17 @@\n   void cleanLogs(Path dirpath, long retainMillis)\n       throws IOException {\n     long now \u003d Time.now();\n     RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n     while (iter.hasNext()) {\n       FileStatus stat \u003d iter.next();\n-      Path clusterTimeStampPath \u003d stat.getPath();\n-      if (isValidClusterTimeStampDir(clusterTimeStampPath)) {\n+      if (isValidClusterTimeStampDir(stat)) {\n+        Path clusterTimeStampPath \u003d stat.getPath();\n         MutableBoolean appLogDirPresent \u003d new MutableBoolean(false);\n         cleanAppLogDir(clusterTimeStampPath, retainMillis, appLogDirPresent);\n         if (appLogDirPresent.isFalse() \u0026\u0026\n             (now - stat.getModificationTime() \u003e retainMillis)) {\n           deleteDir(clusterTimeStampPath);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void cleanLogs(Path dirpath, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      if (isValidClusterTimeStampDir(stat)) {\n        Path clusterTimeStampPath \u003d stat.getPath();\n        MutableBoolean appLogDirPresent \u003d new MutableBoolean(false);\n        cleanAppLogDir(clusterTimeStampPath, retainMillis, appLogDirPresent);\n        if (appLogDirPresent.isFalse() \u0026\u0026\n            (now - stat.getModificationTime() \u003e retainMillis)) {\n          deleteDir(clusterTimeStampPath);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "7b03072fd466de5817fdcd65f9dd88fd59c0bb00": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9080.  Added clean up of bucket directories.\n            Contributed by Prabhu Joseph, Peter Bacsko, Szilard Nemeth\n",
      "commitDate": "23/05/19 9:08 AM",
      "commitName": "7b03072fd466de5817fdcd65f9dd88fd59c0bb00",
      "commitAuthor": "Eric Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9080.  Added clean up of bucket directories.\n            Contributed by Prabhu Joseph, Peter Bacsko, Szilard Nemeth\n",
          "commitDate": "23/05/19 9:08 AM",
          "commitName": "7b03072fd466de5817fdcd65f9dd88fd59c0bb00",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "04/08/17 4:03 PM",
          "commitNameOld": "f44b349b813508f0f6d99ca10bddba683dedf6c4",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 656.71,
          "commitsBetweenForRepo": 5462,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,17 @@\n-  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n+  void cleanLogs(Path dirpath, long retainMillis)\n       throws IOException {\n     long now \u003d Time.now();\n-    // Depth first search from root directory for all application log dirs\n     RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n     while (iter.hasNext()) {\n       FileStatus stat \u003d iter.next();\n-      if (stat.isDirectory()) {\n-        // If current is an application log dir, decide if we need to remove it\n-        // and remove if necessary.\n-        // Otherwise, keep iterating into it.\n-        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n-        if (appId !\u003d null) { // Application log dir\n-          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n-            try {\n-              LOG.info(\"Deleting {}\", dirpath);\n-              if (!fs.delete(dirpath, true)) {\n-                LOG.error(\"Unable to remove \" + dirpath);\n-              }\n-              metrics.incrLogsDirsCleaned();\n-            } catch (IOException e) {\n-              LOG.error(\"Unable to remove \" + dirpath, e);\n-            }\n-          }\n-        } else { // Keep cleaning inside\n-          cleanLogs(stat.getPath(), fs, retainMillis);\n+      Path clusterTimeStampPath \u003d stat.getPath();\n+      if (isValidClusterTimeStampDir(clusterTimeStampPath)) {\n+        MutableBoolean appLogDirPresent \u003d new MutableBoolean(false);\n+        cleanAppLogDir(clusterTimeStampPath, retainMillis, appLogDirPresent);\n+        if (appLogDirPresent.isFalse() \u0026\u0026\n+            (now - stat.getModificationTime() \u003e retainMillis)) {\n+          deleteDir(clusterTimeStampPath);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void cleanLogs(Path dirpath, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      Path clusterTimeStampPath \u003d stat.getPath();\n      if (isValidClusterTimeStampDir(clusterTimeStampPath)) {\n        MutableBoolean appLogDirPresent \u003d new MutableBoolean(false);\n        cleanAppLogDir(clusterTimeStampPath, retainMillis, appLogDirPresent);\n        if (appLogDirPresent.isFalse() \u0026\u0026\n            (now - stat.getModificationTime() \u003e retainMillis)) {\n          deleteDir(clusterTimeStampPath);\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
          "extendedDetails": {
            "oldValue": "[dirpath-Path, fs-FileSystem, retainMillis-long]",
            "newValue": "[dirpath-Path, retainMillis-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9080.  Added clean up of bucket directories.\n            Contributed by Prabhu Joseph, Peter Bacsko, Szilard Nemeth\n",
          "commitDate": "23/05/19 9:08 AM",
          "commitName": "7b03072fd466de5817fdcd65f9dd88fd59c0bb00",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "04/08/17 4:03 PM",
          "commitNameOld": "f44b349b813508f0f6d99ca10bddba683dedf6c4",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 656.71,
          "commitsBetweenForRepo": 5462,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,17 @@\n-  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n+  void cleanLogs(Path dirpath, long retainMillis)\n       throws IOException {\n     long now \u003d Time.now();\n-    // Depth first search from root directory for all application log dirs\n     RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n     while (iter.hasNext()) {\n       FileStatus stat \u003d iter.next();\n-      if (stat.isDirectory()) {\n-        // If current is an application log dir, decide if we need to remove it\n-        // and remove if necessary.\n-        // Otherwise, keep iterating into it.\n-        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n-        if (appId !\u003d null) { // Application log dir\n-          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n-            try {\n-              LOG.info(\"Deleting {}\", dirpath);\n-              if (!fs.delete(dirpath, true)) {\n-                LOG.error(\"Unable to remove \" + dirpath);\n-              }\n-              metrics.incrLogsDirsCleaned();\n-            } catch (IOException e) {\n-              LOG.error(\"Unable to remove \" + dirpath, e);\n-            }\n-          }\n-        } else { // Keep cleaning inside\n-          cleanLogs(stat.getPath(), fs, retainMillis);\n+      Path clusterTimeStampPath \u003d stat.getPath();\n+      if (isValidClusterTimeStampDir(clusterTimeStampPath)) {\n+        MutableBoolean appLogDirPresent \u003d new MutableBoolean(false);\n+        cleanAppLogDir(clusterTimeStampPath, retainMillis, appLogDirPresent);\n+        if (appLogDirPresent.isFalse() \u0026\u0026\n+            (now - stat.getModificationTime() \u003e retainMillis)) {\n+          deleteDir(clusterTimeStampPath);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void cleanLogs(Path dirpath, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      Path clusterTimeStampPath \u003d stat.getPath();\n      if (isValidClusterTimeStampDir(clusterTimeStampPath)) {\n        MutableBoolean appLogDirPresent \u003d new MutableBoolean(false);\n        cleanAppLogDir(clusterTimeStampPath, retainMillis, appLogDirPresent);\n        if (appLogDirPresent.isFalse() \u0026\u0026\n            (now - stat.getModificationTime() \u003e retainMillis)) {\n          deleteDir(clusterTimeStampPath);\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "06413da72efed9a50e49efaf7110c220c88a7f4a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4851. Metric improvements for ATS v1.5 storage components. Li Lu via junping_du.\n",
      "commitDate": "03/05/16 4:16 AM",
      "commitName": "06413da72efed9a50e49efaf7110c220c88a7f4a",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/04/16 10:38 AM",
      "commitNameOld": "e0cb426758b3d716ff143f723fc16ef2f1e4971b",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 19.73,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n       throws IOException {\n     long now \u003d Time.now();\n     // Depth first search from root directory for all application log dirs\n     RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n     while (iter.hasNext()) {\n       FileStatus stat \u003d iter.next();\n       if (stat.isDirectory()) {\n         // If current is an application log dir, decide if we need to remove it\n         // and remove if necessary.\n         // Otherwise, keep iterating into it.\n         ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n         if (appId !\u003d null) { // Application log dir\n           if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n             try {\n               LOG.info(\"Deleting {}\", dirpath);\n               if (!fs.delete(dirpath, true)) {\n                 LOG.error(\"Unable to remove \" + dirpath);\n               }\n+              metrics.incrLogsDirsCleaned();\n             } catch (IOException e) {\n               LOG.error(\"Unable to remove \" + dirpath, e);\n             }\n           }\n         } else { // Keep cleaning inside\n           cleanLogs(stat.getPath(), fs, retainMillis);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    // Depth first search from root directory for all application log dirs\n    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      if (stat.isDirectory()) {\n        // If current is an application log dir, decide if we need to remove it\n        // and remove if necessary.\n        // Otherwise, keep iterating into it.\n        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n        if (appId !\u003d null) { // Application log dir\n          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n            try {\n              LOG.info(\"Deleting {}\", dirpath);\n              if (!fs.delete(dirpath, true)) {\n                LOG.error(\"Unable to remove \" + dirpath);\n              }\n              metrics.incrLogsDirsCleaned();\n            } catch (IOException e) {\n              LOG.error(\"Unable to remove \" + dirpath, e);\n            }\n          }\n        } else { // Keep cleaning inside\n          cleanLogs(stat.getPath(), fs, retainMillis);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-4696. Improving EntityGroupFSTimelineStore on exception handling, test setup, and concurrency. (Steve Loughran via gtcarrera9)\n",
      "commitDate": "10/03/16 10:51 AM",
      "commitName": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
      "commitAuthor": "Li Lu",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-4696. Improving EntityGroupFSTimelineStore on exception handling, test setup, and concurrency. (Steve Loughran via gtcarrera9)\n",
          "commitDate": "10/03/16 10:51 AM",
          "commitName": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
          "commitAuthor": "Li Lu",
          "commitDateOld": "17/01/16 5:37 PM",
          "commitNameOld": "02f597c5db36ded385413958bdee793ad7eda40e",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.72,
          "commitsBetweenForRepo": 371,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  static void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n+  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n       throws IOException {\n     long now \u003d Time.now();\n     // Depth first search from root directory for all application log dirs\n-    RemoteIterator\u003cFileStatus\u003e iter \u003d fs.listStatusIterator(dirpath);\n+    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n     while (iter.hasNext()) {\n       FileStatus stat \u003d iter.next();\n       if (stat.isDirectory()) {\n         // If current is an application log dir, decide if we need to remove it\n         // and remove if necessary.\n         // Otherwise, keep iterating into it.\n         ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n         if (appId !\u003d null) { // Application log dir\n           if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n             try {\n               LOG.info(\"Deleting {}\", dirpath);\n               if (!fs.delete(dirpath, true)) {\n                 LOG.error(\"Unable to remove \" + dirpath);\n               }\n             } catch (IOException e) {\n               LOG.error(\"Unable to remove \" + dirpath, e);\n             }\n           }\n         } else { // Keep cleaning inside\n           cleanLogs(stat.getPath(), fs, retainMillis);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    // Depth first search from root directory for all application log dirs\n    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      if (stat.isDirectory()) {\n        // If current is an application log dir, decide if we need to remove it\n        // and remove if necessary.\n        // Otherwise, keep iterating into it.\n        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n        if (appId !\u003d null) { // Application log dir\n          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n            try {\n              LOG.info(\"Deleting {}\", dirpath);\n              if (!fs.delete(dirpath, true)) {\n                LOG.error(\"Unable to remove \" + dirpath);\n              }\n            } catch (IOException e) {\n              LOG.error(\"Unable to remove \" + dirpath, e);\n            }\n          }\n        } else { // Keep cleaning inside\n          cleanLogs(stat.getPath(), fs, retainMillis);\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
          "extendedDetails": {
            "oldValue": "[static]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4696. Improving EntityGroupFSTimelineStore on exception handling, test setup, and concurrency. (Steve Loughran via gtcarrera9)\n",
          "commitDate": "10/03/16 10:51 AM",
          "commitName": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
          "commitAuthor": "Li Lu",
          "commitDateOld": "17/01/16 5:37 PM",
          "commitNameOld": "02f597c5db36ded385413958bdee793ad7eda40e",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.72,
          "commitsBetweenForRepo": 371,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  static void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n+  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n       throws IOException {\n     long now \u003d Time.now();\n     // Depth first search from root directory for all application log dirs\n-    RemoteIterator\u003cFileStatus\u003e iter \u003d fs.listStatusIterator(dirpath);\n+    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n     while (iter.hasNext()) {\n       FileStatus stat \u003d iter.next();\n       if (stat.isDirectory()) {\n         // If current is an application log dir, decide if we need to remove it\n         // and remove if necessary.\n         // Otherwise, keep iterating into it.\n         ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n         if (appId !\u003d null) { // Application log dir\n           if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n             try {\n               LOG.info(\"Deleting {}\", dirpath);\n               if (!fs.delete(dirpath, true)) {\n                 LOG.error(\"Unable to remove \" + dirpath);\n               }\n             } catch (IOException e) {\n               LOG.error(\"Unable to remove \" + dirpath, e);\n             }\n           }\n         } else { // Keep cleaning inside\n           cleanLogs(stat.getPath(), fs, retainMillis);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    // Depth first search from root directory for all application log dirs\n    RemoteIterator\u003cFileStatus\u003e iter \u003d list(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      if (stat.isDirectory()) {\n        // If current is an application log dir, decide if we need to remove it\n        // and remove if necessary.\n        // Otherwise, keep iterating into it.\n        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n        if (appId !\u003d null) { // Application log dir\n          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n            try {\n              LOG.info(\"Deleting {}\", dirpath);\n              if (!fs.delete(dirpath, true)) {\n                LOG.error(\"Unable to remove \" + dirpath);\n              }\n            } catch (IOException e) {\n              LOG.error(\"Unable to remove \" + dirpath, e);\n            }\n          }\n        } else { // Keep cleaning inside\n          cleanLogs(stat.getPath(), fs, retainMillis);\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "02f597c5db36ded385413958bdee793ad7eda40e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4265. Provide new timeline plugin storage to support fine-grained entity caching. Contributed by Li Lu and Jason Lowe\n",
      "commitDate": "17/01/16 5:37 PM",
      "commitName": "02f597c5db36ded385413958bdee793ad7eda40e",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,29 @@\n+  static void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n+      throws IOException {\n+    long now \u003d Time.now();\n+    // Depth first search from root directory for all application log dirs\n+    RemoteIterator\u003cFileStatus\u003e iter \u003d fs.listStatusIterator(dirpath);\n+    while (iter.hasNext()) {\n+      FileStatus stat \u003d iter.next();\n+      if (stat.isDirectory()) {\n+        // If current is an application log dir, decide if we need to remove it\n+        // and remove if necessary.\n+        // Otherwise, keep iterating into it.\n+        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n+        if (appId !\u003d null) { // Application log dir\n+          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n+            try {\n+              LOG.info(\"Deleting {}\", dirpath);\n+              if (!fs.delete(dirpath, true)) {\n+                LOG.error(\"Unable to remove \" + dirpath);\n+              }\n+            } catch (IOException e) {\n+              LOG.error(\"Unable to remove \" + dirpath, e);\n+            }\n+          }\n+        } else { // Keep cleaning inside\n+          cleanLogs(stat.getPath(), fs, retainMillis);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static void cleanLogs(Path dirpath, FileSystem fs, long retainMillis)\n      throws IOException {\n    long now \u003d Time.now();\n    // Depth first search from root directory for all application log dirs\n    RemoteIterator\u003cFileStatus\u003e iter \u003d fs.listStatusIterator(dirpath);\n    while (iter.hasNext()) {\n      FileStatus stat \u003d iter.next();\n      if (stat.isDirectory()) {\n        // If current is an application log dir, decide if we need to remove it\n        // and remove if necessary.\n        // Otherwise, keep iterating into it.\n        ApplicationId appId \u003d parseApplicationId(dirpath.getName());\n        if (appId !\u003d null) { // Application log dir\n          if (shouldCleanAppLogDir(dirpath, now, fs, retainMillis)) {\n            try {\n              LOG.info(\"Deleting {}\", dirpath);\n              if (!fs.delete(dirpath, true)) {\n                LOG.error(\"Unable to remove \" + dirpath);\n              }\n            } catch (IOException e) {\n              LOG.error(\"Unable to remove \" + dirpath, e);\n            }\n          }\n        } else { // Keep cleaning inside\n          cleanLogs(stat.getPath(), fs, retainMillis);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java"
    }
  }
}