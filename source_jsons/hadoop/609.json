{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReaderFactory.java",
  "functionName": "build",
  "functionId": "build",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
  "functionStartLine": 342,
  "functionEndLine": 382,
  "numCommitsSeen": 63,
  "timeTaken": 4594,
  "changeHistory": [
    "b061215ecfebe476bf58f70788113d1af816f553",
    "f308561f1d885491b88db73ac63003202056d661",
    "188f65287d5b2f26a8862c88198f83ac59035016",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
    "7e971b7315fa2942b4db7ba11ed513766957b777",
    "7087e700e032dabc174ecc12b62c12e7d49b995f",
    "2cc9514ad643ae49d30524743420ee9744e571bd",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be"
  ],
  "changeHistoryShort": {
    "b061215ecfebe476bf58f70788113d1af816f553": "Ybodychange",
    "f308561f1d885491b88db73ac63003202056d661": "Yfilerename",
    "188f65287d5b2f26a8862c88198f83ac59035016": "Ybodychange",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": "Yfilerename",
    "7e971b7315fa2942b4db7ba11ed513766957b777": "Ybodychange",
    "7087e700e032dabc174ecc12b62c12e7d49b995f": "Ybodychange",
    "2cc9514ad643ae49d30524743420ee9744e571bd": "Ybodychange",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b061215ecfebe476bf58f70788113d1af816f553": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11701. NPE from Unresolved Host causes permanent DFSInputStream failures. Contributed by Lokesh Jain.\n",
      "commitDate": "07/02/18 11:22 AM",
      "commitName": "b061215ecfebe476bf58f70788113d1af816f553",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "30/01/18 3:25 PM",
      "commitNameOld": "2e7331ca264dd366b975f3c8e610cf84eb8cc155",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 7.83,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,41 @@\n   public BlockReader build() throws IOException {\n     Preconditions.checkNotNull(configuration);\n     Preconditions\n         .checkState(length \u003e\u003d 0, \"Length must be set to a non-negative value\");\n     BlockReader reader \u003d tryToCreateExternalBlockReader();\n     if (reader !\u003d null) {\n       return reader;\n     }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n-    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n-      if (clientContext.getUseLegacyBlockReaderLocal()) {\n-        reader \u003d getLegacyBlockReaderLocal();\n-        if (reader !\u003d null) {\n-          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n-          return reader;\n+    try {\n+      if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n+        if (clientContext.getUseLegacyBlockReaderLocal()) {\n+          reader \u003d getLegacyBlockReaderLocal();\n+          if (reader !\u003d null) {\n+            LOG.trace(\"{}: returning new legacy block reader local.\", this);\n+            return reader;\n+          }\n+        } else {\n+          reader \u003d getBlockReaderLocal();\n+          if (reader !\u003d null) {\n+            LOG.trace(\"{}: returning new block reader local.\", this);\n+            return reader;\n+          }\n         }\n-      } else {\n-        reader \u003d getBlockReaderLocal();\n+      }\n+      if (scConf.isDomainSocketDataTraffic()) {\n+        reader \u003d getRemoteBlockReaderFromDomain();\n         if (reader !\u003d null) {\n-          LOG.trace(\"{}: returning new block reader local.\", this);\n+          LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n+              + \"socket on {}\", this, pathInfo.getPath());\n           return reader;\n         }\n       }\n-    }\n-    if (scConf.isDomainSocketDataTraffic()) {\n-      reader \u003d getRemoteBlockReaderFromDomain();\n-      if (reader !\u003d null) {\n-        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n-            + \"socket on {}\", this, pathInfo.getPath());\n-        return reader;\n-      }\n+    } catch (IOException e) {\n+      LOG.debug(\"Block read failed. Getting remote block reader using TCP\", e);\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    Preconditions\n        .checkState(length \u003e\u003d 0, \"Length must be set to a non-negative value\");\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    try {\n      if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n        if (clientContext.getUseLegacyBlockReaderLocal()) {\n          reader \u003d getLegacyBlockReaderLocal();\n          if (reader !\u003d null) {\n            LOG.trace(\"{}: returning new legacy block reader local.\", this);\n            return reader;\n          }\n        } else {\n          reader \u003d getBlockReaderLocal();\n          if (reader !\u003d null) {\n            LOG.trace(\"{}: returning new block reader local.\", this);\n            return reader;\n          }\n        }\n      }\n      if (scConf.isDomainSocketDataTraffic()) {\n        reader \u003d getRemoteBlockReaderFromDomain();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n              + \"socket on {}\", this, pathInfo.getPath());\n          return reader;\n        }\n      }\n    } catch (IOException e) {\n      LOG.debug(\"Block read failed. Getting remote block reader using TCP\", e);\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "f308561f1d885491b88db73ac63003202056d661": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8057 Move BlockReader implementation to the client implementation package.  Contributed by Takanobu Asanuma\n",
      "commitDate": "25/04/16 12:01 PM",
      "commitName": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "25/04/16 9:38 AM",
      "commitNameOld": "10f0f7851a3255caab775777e8fb6c2781d97062",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    Preconditions\n        .checkState(length \u003e\u003d 0, \"Length must be set to a non-negative value\");\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new block reader local.\", this);\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n            + \"socket on {}\", this, pathInfo.getPath());\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java"
      }
    },
    "188f65287d5b2f26a8862c88198f83ac59035016": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6520. hdfs fsck passes invalid length value when creating BlockReader (Xiao Chen via cmccabe)\n",
      "commitDate": "06/04/16 11:28 AM",
      "commitName": "188f65287d5b2f26a8862c88198f83ac59035016",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "19/03/16 2:02 PM",
      "commitNameOld": "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 17.89,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,37 @@\n   public BlockReader build() throws IOException {\n     Preconditions.checkNotNull(configuration);\n+    Preconditions\n+        .checkState(length \u003e\u003d 0, \"Length must be set to a non-negative value\");\n     BlockReader reader \u003d tryToCreateExternalBlockReader();\n     if (reader !\u003d null) {\n       return reader;\n     }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n     if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n           LOG.trace(\"{}: returning new legacy block reader local.\", this);\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n           LOG.trace(\"{}: returning new block reader local.\", this);\n           return reader;\n         }\n       }\n     }\n     if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n         LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n             + \"socket on {}\", this, pathInfo.getPath());\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    Preconditions\n        .checkState(length \u003e\u003d 0, \"Length must be set to a non-negative value\");\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new block reader local.\", this);\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n            + \"socket on {}\", this, pathInfo.getPath());\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,35 @@\n   public BlockReader build() throws IOException {\n     Preconditions.checkNotNull(configuration);\n     BlockReader reader \u003d tryToCreateExternalBlockReader();\n     if (reader !\u003d null) {\n       return reader;\n     }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n     if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": returning new legacy block reader local.\");\n-          }\n+          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": returning new block reader local.\");\n-          }\n+          LOG.trace(\"{}: returning new block reader local.\", this);\n           return reader;\n         }\n       }\n     }\n     if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(this + \": returning new remote block reader using \" +\n-              \"UNIX domain socket on \" + pathInfo.getPath());\n-        }\n+        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n+            + \"socket on {}\", this, pathInfo.getPath());\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new block reader local.\", this);\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n            + \"socket on {}\", this, pathInfo.getPath());\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,41 @@\n   public BlockReader build() throws IOException {\n     Preconditions.checkNotNull(configuration);\n     BlockReader reader \u003d tryToCreateExternalBlockReader();\n     if (reader !\u003d null) {\n       return reader;\n     }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n     if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n-          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": returning new legacy block reader local.\");\n+          }\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n-          LOG.trace(\"{}: returning new block reader local.\", this);\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": returning new block reader local.\");\n+          }\n           return reader;\n         }\n       }\n     }\n     if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n-        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n-            + \"socket on {}\", this, pathInfo.getPath());\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(this + \": returning new remote block reader using \" +\n+              \"UNIX domain socket on \" + pathInfo.getPath());\n+        }\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new legacy block reader local.\");\n          }\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new block reader local.\");\n          }\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": returning new remote block reader using \" +\n              \"UNIX domain socket on \" + pathInfo.getPath());\n        }\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/09/15 1:39 PM",
      "commitNameOld": "e5992ef4df63fbc6a6b8e357b32c647e7837c662",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,35 @@\n   public BlockReader build() throws IOException {\n     Preconditions.checkNotNull(configuration);\n     BlockReader reader \u003d tryToCreateExternalBlockReader();\n     if (reader !\u003d null) {\n       return reader;\n     }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n     if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": returning new legacy block reader local.\");\n-          }\n+          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": returning new block reader local.\");\n-          }\n+          LOG.trace(\"{}: returning new block reader local.\", this);\n           return reader;\n         }\n       }\n     }\n     if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(this + \": returning new remote block reader using \" +\n-              \"UNIX domain socket on \" + pathInfo.getPath());\n-        }\n+        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n+            + \"socket on {}\", this, pathInfo.getPath());\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new legacy block reader local.\", this);\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          LOG.trace(\"{}: returning new block reader local.\", this);\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        LOG.trace(\"{}: returning new remote block reader using UNIX domain \"\n            + \"socket on {}\", this, pathInfo.getPath());\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/09/15 11:08 AM",
      "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/09/15 9:06 AM",
      "commitNameOld": "861b52db242f238d7e36ad75c158025be959a696",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new legacy block reader local.\");\n          }\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new block reader local.\");\n          }\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": returning new remote block reader using \" +\n              \"UNIX domain socket on \" + pathInfo.getPath());\n        }\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
      }
    },
    "7e971b7315fa2942b4db7ba11ed513766957b777": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8962. Clean up checkstyle warnings in o.a.h.hdfs.DfsClientConf. Contributed by Mingliang Liu.\n",
      "commitDate": "27/08/15 9:02 AM",
      "commitName": "7e971b7315fa2942b4db7ba11ed513766957b777",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/08/15 2:02 PM",
      "commitNameOld": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,41 @@\n   public BlockReader build() throws IOException {\n-    BlockReader reader \u003d null;\n-\n     Preconditions.checkNotNull(configuration);\n-    reader \u003d tryToCreateExternalBlockReader();\n+    BlockReader reader \u003d tryToCreateExternalBlockReader();\n     if (reader !\u003d null) {\n       return reader;\n     }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n     if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": returning new legacy block reader local.\");\n           }\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": returning new block reader local.\");\n           }\n           return reader;\n         }\n       }\n     }\n     if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \": returning new remote block reader using \" +\n               \"UNIX domain socket on \" + pathInfo.getPath());\n         }\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    Preconditions.checkNotNull(configuration);\n    BlockReader reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new legacy block reader local.\");\n          }\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new block reader local.\");\n          }\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": returning new remote block reader using \" +\n              \"UNIX domain socket on \" + pathInfo.getPath());\n        }\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "7087e700e032dabc174ecc12b62c12e7d49b995f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8924. Add pluggable interface for reading replicas in DFSClient. (Colin Patrick McCabe via Lei Xu)\n",
      "commitDate": "21/08/15 5:02 PM",
      "commitName": "7087e700e032dabc174ecc12b62c12e7d49b995f",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "19/08/15 11:28 AM",
      "commitNameOld": "3aac4758b007a56e3d66998d457b2156effca528",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,43 @@\n   public BlockReader build() throws IOException {\n     BlockReader reader \u003d null;\n \n     Preconditions.checkNotNull(configuration);\n+    reader \u003d tryToCreateExternalBlockReader();\n+    if (reader !\u003d null) {\n+      return reader;\n+    }\n     final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n     if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": returning new legacy block reader local.\");\n           }\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": returning new block reader local.\");\n           }\n           return reader;\n         }\n       }\n     }\n     if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \": returning new remote block reader using \" +\n               \"UNIX domain socket on \" + pathInfo.getPath());\n         }\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    BlockReader reader \u003d null;\n\n    Preconditions.checkNotNull(configuration);\n    reader \u003d tryToCreateExternalBlockReader();\n    if (reader !\u003d null) {\n      return reader;\n    }\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new legacy block reader local.\");\n          }\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new block reader local.\");\n          }\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": returning new remote block reader using \" +\n              \"UNIX domain socket on \" + pathInfo.getPath());\n        }\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "2cc9514ad643ae49d30524743420ee9744e571bd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8100. Refactor DFSClient.Conf to a standalone class and separates short-circuit related conf to ShortCircuitConf.\n",
      "commitDate": "10/04/15 2:48 PM",
      "commitName": "2cc9514ad643ae49d30524743420ee9744e571bd",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/04/15 12:54 PM",
      "commitNameOld": "ed72daa5df97669906234e8ac9a406d78136b206",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 9.08,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   public BlockReader build() throws IOException {\n     BlockReader reader \u003d null;\n \n     Preconditions.checkNotNull(configuration);\n-    if (conf.shortCircuitLocalReads \u0026\u0026 allowShortCircuitLocalReads) {\n+    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n+    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n       if (clientContext.getUseLegacyBlockReaderLocal()) {\n         reader \u003d getLegacyBlockReaderLocal();\n         if (reader !\u003d null) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": returning new legacy block reader local.\");\n           }\n           return reader;\n         }\n       } else {\n         reader \u003d getBlockReaderLocal();\n         if (reader !\u003d null) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": returning new block reader local.\");\n           }\n           return reader;\n         }\n       }\n     }\n-    if (conf.domainSocketDataTraffic) {\n+    if (scConf.isDomainSocketDataTraffic()) {\n       reader \u003d getRemoteBlockReaderFromDomain();\n       if (reader !\u003d null) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \": returning new remote block reader using \" +\n               \"UNIX domain socket on \" + pathInfo.getPath());\n         }\n         return reader;\n       }\n     }\n     Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n         \"TCP reads were disabled for testing, but we failed to \" +\n         \"do a non-TCP read.\");\n     return getRemoteBlockReaderFromTcp();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    BlockReader reader \u003d null;\n\n    Preconditions.checkNotNull(configuration);\n    final ShortCircuitConf scConf \u003d conf.getShortCircuitConf();\n    if (scConf.isShortCircuitLocalReads() \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new legacy block reader local.\");\n          }\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new block reader local.\");\n          }\n          return reader;\n        }\n      }\n    }\n    if (scConf.isDomainSocketDataTraffic()) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": returning new remote block reader using \" +\n              \"UNIX domain socket on \" + pathInfo.getPath());\n        }\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 11:08 AM",
      "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,38 @@\n+  public BlockReader build() throws IOException {\n+    BlockReader reader \u003d null;\n+\n+    Preconditions.checkNotNull(configuration);\n+    if (conf.shortCircuitLocalReads \u0026\u0026 allowShortCircuitLocalReads) {\n+      if (clientContext.getUseLegacyBlockReaderLocal()) {\n+        reader \u003d getLegacyBlockReaderLocal();\n+        if (reader !\u003d null) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": returning new legacy block reader local.\");\n+          }\n+          return reader;\n+        }\n+      } else {\n+        reader \u003d getBlockReaderLocal();\n+        if (reader !\u003d null) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": returning new block reader local.\");\n+          }\n+          return reader;\n+        }\n+      }\n+    }\n+    if (conf.domainSocketDataTraffic) {\n+      reader \u003d getRemoteBlockReaderFromDomain();\n+      if (reader !\u003d null) {\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(this + \": returning new remote block reader using \" +\n+              \"UNIX domain socket on \" + pathInfo.getPath());\n+        }\n+        return reader;\n+      }\n+    }\n+    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n+        \"TCP reads were disabled for testing, but we failed to \" +\n+        \"do a non-TCP read.\");\n+    return getRemoteBlockReaderFromTcp();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockReader build() throws IOException {\n    BlockReader reader \u003d null;\n\n    Preconditions.checkNotNull(configuration);\n    if (conf.shortCircuitLocalReads \u0026\u0026 allowShortCircuitLocalReads) {\n      if (clientContext.getUseLegacyBlockReaderLocal()) {\n        reader \u003d getLegacyBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new legacy block reader local.\");\n          }\n          return reader;\n        }\n      } else {\n        reader \u003d getBlockReaderLocal();\n        if (reader !\u003d null) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": returning new block reader local.\");\n          }\n          return reader;\n        }\n      }\n    }\n    if (conf.domainSocketDataTraffic) {\n      reader \u003d getRemoteBlockReaderFromDomain();\n      if (reader !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": returning new remote block reader using \" +\n              \"UNIX domain socket on \" + pathInfo.getPath());\n        }\n        return reader;\n      }\n    }\n    Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,\n        \"TCP reads were disabled for testing, but we failed to \" +\n        \"do a non-TCP read.\");\n    return getRemoteBlockReaderFromTcp();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
    }
  }
}