{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "processSaslMessage",
  "functionId": "processSaslMessage___saslMessage-RpcSaslProto",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 2079,
  "functionEndLine": 2137,
  "numCommitsSeen": 275,
  "timeTaken": 5523,
  "changeHistory": [
    "37cb314f79f515421cfc2c3605382bf1534dc266",
    "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
    "c03c8fe199429a43c6aa944016566738abd9b193",
    "65be21267587f04a2c33af65b951211cc9085b15",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
    "5f9b4c14a175873b4f82654513e289c657c694eb"
  ],
  "changeHistoryShort": {
    "37cb314f79f515421cfc2c3605382bf1534dc266": "Ybodychange",
    "a4819e70dbf88b0905a6669078afa1ff0924ad4f": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c03c8fe199429a43c6aa944016566738abd9b193": "Ymultichange(Yparameterchange,Ybodychange)",
    "65be21267587f04a2c33af65b951211cc9085b15": "Ybodychange",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": "Ymultichange(Yparameterchange,Ybodychange)",
    "5f9b4c14a175873b4f82654513e289c657c694eb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "37cb314f79f515421cfc2c3605382bf1534dc266": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10407. Fix the javac warnings in org.apache.hadoop.ipc package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577710 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/03/14 2:12 PM",
      "commitName": "37cb314f79f515421cfc2c3605382bf1534dc266",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "21/02/14 12:53 PM",
      "commitNameOld": "d61d1c120d5cecc97514e2f8d79dacdbd4e610a3",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 21.01,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,59 @@\n     private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n         throws SaslException, IOException, AccessControlException,\n         InterruptedException {\n-      RpcSaslProto saslResponse \u003d null;\n+      final RpcSaslProto saslResponse;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n             // FIXME shouldn\u0027t this be SaslException?\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           // simple-only server negotiate response is success which client\n           // interprets as switch to simple\n           if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n             switchToSimple();\n           }\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           // verify the client requested an advertised authType\n           SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n           if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n           // abort SASL for SIMPLE auth, server has already ensured that\n           // SIMPLE is a legit option above.  we will send no response\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             switchToSimple();\n+            saslResponse \u003d null;\n             break;\n           }\n           // sasl server for tokens may already be instantiated\n           if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n             saslServer \u003d createSaslServer(authMethod);\n           }\n-          // fallthru to process sasl token\n+          saslResponse \u003d processSaslToken(saslMessage);\n+          break;\n         }\n         case RESPONSE: {\n-          if (!saslMessage.hasToken()) {\n-            throw new SaslException(\"Client did not send a token\");\n-          }\n-          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Have read input token of size \" + saslToken.length\n-                + \" for processing by saslServer.evaluateResponse()\");\n-          }\n-          saslToken \u003d saslServer.evaluateResponse(saslToken);\n-          saslResponse \u003d buildSaslResponse(\n-              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n-              saslToken);\n+          saslResponse \u003d processSaslToken(saslMessage);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n        throws SaslException, IOException, AccessControlException,\n        InterruptedException {\n      final RpcSaslProto saslResponse;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            // FIXME shouldn\u0027t this be SaslException?\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          // simple-only server negotiate response is success which client\n          // interprets as switch to simple\n          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n            switchToSimple();\n          }\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          // verify the client requested an advertised authType\n          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n          // abort SASL for SIMPLE auth, server has already ensured that\n          // SIMPLE is a legit option above.  we will send no response\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            switchToSimple();\n            saslResponse \u003d null;\n            break;\n          }\n          // sasl server for tokens may already be instantiated\n          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n            saslServer \u003d createSaslServer(authMethod);\n          }\n          saslResponse \u003d processSaslToken(saslMessage);\n          break;\n        }\n        case RESPONSE: {\n          saslResponse \u003d processSaslToken(saslMessage);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a4819e70dbf88b0905a6669078afa1ff0924ad4f": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-10044 Improve the javadoc of rpc code (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 10:56 AM",
      "commitName": "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
      "commitAuthor": "Sanjay Radia",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-10044 Improve the javadoc of rpc code (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550486 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/12/13 10:56 AM",
          "commitName": "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "18/11/13 11:42 PM",
          "commitNameOld": "229472cea7920194c48f5294bf763a8bee2ade63",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 23.47,
          "commitsBetweenForRepo": 136,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,68 @@\n     private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n-        throws IOException, InterruptedException {\n+        throws SaslException, IOException, AccessControlException,\n+        InterruptedException {\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n+            // FIXME shouldn\u0027t this be SaslException?\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           // simple-only server negotiate response is success which client\n           // interprets as switch to simple\n           if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n             switchToSimple();\n           }\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           // verify the client requested an advertised authType\n           SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n           if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n           // abort SASL for SIMPLE auth, server has already ensured that\n           // SIMPLE is a legit option above.  we will send no response\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             switchToSimple();\n             break;\n           }\n           // sasl server for tokens may already be instantiated\n           if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n             saslServer \u003d createSaslServer(authMethod);\n           }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n        throws SaslException, IOException, AccessControlException,\n        InterruptedException {\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            // FIXME shouldn\u0027t this be SaslException?\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          // simple-only server negotiate response is success which client\n          // interprets as switch to simple\n          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n            switchToSimple();\n          }\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          // verify the client requested an advertised authType\n          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n          // abort SASL for SIMPLE auth, server has already ensured that\n          // SIMPLE is a legit option above.  we will send no response\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            switchToSimple();\n            break;\n          }\n          // sasl server for tokens may already be instantiated\n          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n            saslServer \u003d createSaslServer(authMethod);\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[IOException, InterruptedException]",
            "newValue": "[SaslException, IOException, AccessControlException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-10044 Improve the javadoc of rpc code (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550486 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/12/13 10:56 AM",
          "commitName": "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "18/11/13 11:42 PM",
          "commitNameOld": "229472cea7920194c48f5294bf763a8bee2ade63",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 23.47,
          "commitsBetweenForRepo": 136,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,68 @@\n     private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n-        throws IOException, InterruptedException {\n+        throws SaslException, IOException, AccessControlException,\n+        InterruptedException {\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n+            // FIXME shouldn\u0027t this be SaslException?\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           // simple-only server negotiate response is success which client\n           // interprets as switch to simple\n           if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n             switchToSimple();\n           }\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           // verify the client requested an advertised authType\n           SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n           if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n           // abort SASL for SIMPLE auth, server has already ensured that\n           // SIMPLE is a legit option above.  we will send no response\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             switchToSimple();\n             break;\n           }\n           // sasl server for tokens may already be instantiated\n           if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n             saslServer \u003d createSaslServer(authMethod);\n           }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n        throws SaslException, IOException, AccessControlException,\n        InterruptedException {\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            // FIXME shouldn\u0027t this be SaslException?\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          // simple-only server negotiate response is success which client\n          // interprets as switch to simple\n          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n            switchToSimple();\n          }\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          // verify the client requested an advertised authType\n          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n          // abort SASL for SIMPLE auth, server has already ensured that\n          // SIMPLE is a legit option above.  we will send no response\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            switchToSimple();\n            break;\n          }\n          // sasl server for tokens may already be instantiated\n          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n            saslServer \u003d createSaslServer(authMethod);\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "c03c8fe199429a43c6aa944016566738abd9b193": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-9820. RPCv9 wire protocol is insufficient to support multiplexing. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/13 4:02 PM",
      "commitName": "c03c8fe199429a43c6aa944016566738abd9b193",
      "commitAuthor": "Jitendra Nath Pandey",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9820. RPCv9 wire protocol is insufficient to support multiplexing. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512091 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/08/13 4:02 PM",
          "commitName": "c03c8fe199429a43c6aa944016566738abd9b193",
          "commitAuthor": "Jitendra Nath Pandey",
          "commitDateOld": "05/08/13 4:01 PM",
          "commitNameOld": "63a1273f2a8e0b668ff70330262adedee63112d9",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 3.0,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,66 @@\n-    private RpcSaslProto processSaslMessage(DataInputStream dis)\n+    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n         throws IOException, InterruptedException {\n-      final RpcSaslProto saslMessage \u003d\n-          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           // simple-only server negotiate response is success which client\n           // interprets as switch to simple\n           if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n             switchToSimple();\n           }\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           // verify the client requested an advertised authType\n           SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n           if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n           // abort SASL for SIMPLE auth, server has already ensured that\n           // SIMPLE is a legit option above.  we will send no response\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             switchToSimple();\n             break;\n           }\n           // sasl server for tokens may already be instantiated\n           if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n             saslServer \u003d createSaslServer(authMethod);\n           }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n        throws IOException, InterruptedException {\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          // simple-only server negotiate response is success which client\n          // interprets as switch to simple\n          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n            switchToSimple();\n          }\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          // verify the client requested an advertised authType\n          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n          // abort SASL for SIMPLE auth, server has already ensured that\n          // SIMPLE is a legit option above.  we will send no response\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            switchToSimple();\n            break;\n          }\n          // sasl server for tokens may already be instantiated\n          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n            saslServer \u003d createSaslServer(authMethod);\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[dis-DataInputStream]",
            "newValue": "[saslMessage-RpcSaslProto]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9820. RPCv9 wire protocol is insufficient to support multiplexing. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512091 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/08/13 4:02 PM",
          "commitName": "c03c8fe199429a43c6aa944016566738abd9b193",
          "commitAuthor": "Jitendra Nath Pandey",
          "commitDateOld": "05/08/13 4:01 PM",
          "commitNameOld": "63a1273f2a8e0b668ff70330262adedee63112d9",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 3.0,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,66 @@\n-    private RpcSaslProto processSaslMessage(DataInputStream dis)\n+    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n         throws IOException, InterruptedException {\n-      final RpcSaslProto saslMessage \u003d\n-          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           // simple-only server negotiate response is success which client\n           // interprets as switch to simple\n           if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n             switchToSimple();\n           }\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           // verify the client requested an advertised authType\n           SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n           if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n           // abort SASL for SIMPLE auth, server has already ensured that\n           // SIMPLE is a legit option above.  we will send no response\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             switchToSimple();\n             break;\n           }\n           // sasl server for tokens may already be instantiated\n           if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n             saslServer \u003d createSaslServer(authMethod);\n           }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto processSaslMessage(RpcSaslProto saslMessage)\n        throws IOException, InterruptedException {\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          // simple-only server negotiate response is success which client\n          // interprets as switch to simple\n          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n            switchToSimple();\n          }\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          // verify the client requested an advertised authType\n          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n          // abort SASL for SIMPLE auth, server has already ensured that\n          // SIMPLE is a legit option above.  we will send no response\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            switchToSimple();\n            break;\n          }\n          // sasl server for tokens may already be instantiated\n          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n            saslServer \u003d createSaslServer(authMethod);\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "24/07/13 12:48 AM",
      "commitNameOld": "a0a986dda77ea03dac9cfc7e0631bae611034ef4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.29,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,68 @@\n     private RpcSaslProto processSaslMessage(DataInputStream dis)\n         throws IOException, InterruptedException {\n       final RpcSaslProto saslMessage \u003d\n           decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n+          // simple-only server negotiate response is success which client\n+          // interprets as switch to simple\n+          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n+            switchToSimple();\n+          }\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n-          String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n-          authMethod \u003d createSaslServer(authMethodName);\n-          if (authMethod \u003d\u003d null) { // the auth method is not supported\n+          // verify the client requested an advertised authType\n+          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n+          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n             if (sentNegotiate) {\n               throw new AccessControlException(\n-                  authMethodName + \" authentication is not enabled.\"\n+                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n+          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n+          // abort SASL for SIMPLE auth, server has already ensured that\n+          // SIMPLE is a legit option above.  we will send no response\n+          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n+            switchToSimple();\n+            break;\n+          }\n+          // sasl server for tokens may already be instantiated\n+          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n+            saslServer \u003d createSaslServer(authMethod);\n+          }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private RpcSaslProto processSaslMessage(DataInputStream dis)\n        throws IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          // simple-only server negotiate response is success which client\n          // interprets as switch to simple\n          if (saslResponse.getState() \u003d\u003d SaslState.SUCCESS) {\n            switchToSimple();\n          }\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          // verify the client requested an advertised authType\n          SaslAuth clientSaslAuth \u003d saslMessage.getAuths(0);\n          if (!negotiateResponse.getAuthsList().contains(clientSaslAuth)) {\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  clientSaslAuth.getMethod() + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          authMethod \u003d AuthMethod.valueOf(clientSaslAuth.getMethod());\n          // abort SASL for SIMPLE auth, server has already ensured that\n          // SIMPLE is a legit option above.  we will send no response\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            switchToSimple();\n            break;\n          }\n          // sasl server for tokens may already be instantiated\n          if (saslServer \u003d\u003d null || authMethod !\u003d AuthMethod.TOKEN) {\n            saslServer \u003d createSaslServer(authMethod);\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 10:59 AM",
      "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,52 @@\n-    private RpcSaslProto processSaslMessage(byte[] buf)\n+    private RpcSaslProto processSaslMessage(DataInputStream dis)\n         throws IOException, InterruptedException {\n-      final DataInputStream dis \u003d\n-          new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestMessageWrapper requestWrapper \u003d new RpcRequestMessageWrapper();\n-      requestWrapper.readFields(dis);\n-      \n-      final RpcRequestHeaderProto rpcHeader \u003d requestWrapper.requestHeader;\n-      if (rpcHeader.getCallId() !\u003d AuthProtocol.SASL.callId) {\n-        throw new SaslException(\"Client sent non-SASL request\");\n-      }      \n       final RpcSaslProto saslMessage \u003d\n-          RpcSaslProto.parseFrom(requestWrapper.theRequestRead);\n+          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n           authMethod \u003d createSaslServer(authMethodName);\n           if (authMethod \u003d\u003d null) { // the auth method is not supported\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   authMethodName + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto processSaslMessage(DataInputStream dis)\n        throws IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n          authMethod \u003d createSaslServer(authMethodName);\n          if (authMethod \u003d\u003d null) { // the auth method is not supported\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  authMethodName + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[buf-byte[]]",
            "newValue": "[dis-DataInputStream]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,52 @@\n-    private RpcSaslProto processSaslMessage(byte[] buf)\n+    private RpcSaslProto processSaslMessage(DataInputStream dis)\n         throws IOException, InterruptedException {\n-      final DataInputStream dis \u003d\n-          new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestMessageWrapper requestWrapper \u003d new RpcRequestMessageWrapper();\n-      requestWrapper.readFields(dis);\n-      \n-      final RpcRequestHeaderProto rpcHeader \u003d requestWrapper.requestHeader;\n-      if (rpcHeader.getCallId() !\u003d AuthProtocol.SASL.callId) {\n-        throw new SaslException(\"Client sent non-SASL request\");\n-      }      \n       final RpcSaslProto saslMessage \u003d\n-          RpcSaslProto.parseFrom(requestWrapper.theRequestRead);\n+          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n       RpcSaslProto saslResponse \u003d null;\n       final SaslState state \u003d saslMessage.getState(); // required      \n       switch (state) {\n         case NEGOTIATE: {\n           if (sentNegotiate) {\n             throw new AccessControlException(\n                 \"Client already attempted negotiation\");\n           }\n           saslResponse \u003d buildSaslNegotiateResponse();\n           break;\n         }\n         case INITIATE: {\n           if (saslMessage.getAuthsCount() !\u003d 1) {\n             throw new SaslException(\"Client mechanism is malformed\");\n           }\n           String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n           authMethod \u003d createSaslServer(authMethodName);\n           if (authMethod \u003d\u003d null) { // the auth method is not supported\n             if (sentNegotiate) {\n               throw new AccessControlException(\n                   authMethodName + \" authentication is not enabled.\"\n                       + \"  Available:\" + enabledAuthMethods);\n             }\n             saslResponse \u003d buildSaslNegotiateResponse();\n             break;\n           }\n           // fallthru to process sasl token\n         }\n         case RESPONSE: {\n           if (!saslMessage.hasToken()) {\n             throw new SaslException(\"Client did not send a token\");\n           }\n           byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           }\n           saslToken \u003d saslServer.evaluateResponse(saslToken);\n           saslResponse \u003d buildSaslResponse(\n               saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n               saslToken);\n           break;\n         }\n         default:\n           throw new SaslException(\"Client sent unsupported state \" + state);\n       }\n       return saslResponse;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto processSaslMessage(DataInputStream dis)\n        throws IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n          authMethod \u003d createSaslServer(authMethodName);\n          if (authMethod \u003d\u003d null) { // the auth method is not supported\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  authMethodName + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "5f9b4c14a175873b4f82654513e289c657c694eb": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9421. [RPC v9] Convert SASL to use ProtoBuf and provide negotiation capabilities (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1495577 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/13 1:09 PM",
      "commitName": "5f9b4c14a175873b4f82654513e289c657c694eb",
      "commitAuthor": "Daryn Sharp",
      "diff": "@@ -0,0 +1,61 @@\n+    private RpcSaslProto processSaslMessage(byte[] buf)\n+        throws IOException, InterruptedException {\n+      final DataInputStream dis \u003d\n+          new DataInputStream(new ByteArrayInputStream(buf));\n+      RpcRequestMessageWrapper requestWrapper \u003d new RpcRequestMessageWrapper();\n+      requestWrapper.readFields(dis);\n+      \n+      final RpcRequestHeaderProto rpcHeader \u003d requestWrapper.requestHeader;\n+      if (rpcHeader.getCallId() !\u003d AuthProtocol.SASL.callId) {\n+        throw new SaslException(\"Client sent non-SASL request\");\n+      }      \n+      final RpcSaslProto saslMessage \u003d\n+          RpcSaslProto.parseFrom(requestWrapper.theRequestRead);\n+      RpcSaslProto saslResponse \u003d null;\n+      final SaslState state \u003d saslMessage.getState(); // required      \n+      switch (state) {\n+        case NEGOTIATE: {\n+          if (sentNegotiate) {\n+            throw new AccessControlException(\n+                \"Client already attempted negotiation\");\n+          }\n+          saslResponse \u003d buildSaslNegotiateResponse();\n+          break;\n+        }\n+        case INITIATE: {\n+          if (saslMessage.getAuthsCount() !\u003d 1) {\n+            throw new SaslException(\"Client mechanism is malformed\");\n+          }\n+          String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n+          authMethod \u003d createSaslServer(authMethodName);\n+          if (authMethod \u003d\u003d null) { // the auth method is not supported\n+            if (sentNegotiate) {\n+              throw new AccessControlException(\n+                  authMethodName + \" authentication is not enabled.\"\n+                      + \"  Available:\" + enabledAuthMethods);\n+            }\n+            saslResponse \u003d buildSaslNegotiateResponse();\n+            break;\n+          }\n+          // fallthru to process sasl token\n+        }\n+        case RESPONSE: {\n+          if (!saslMessage.hasToken()) {\n+            throw new SaslException(\"Client did not send a token\");\n+          }\n+          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Have read input token of size \" + saslToken.length\n+                + \" for processing by saslServer.evaluateResponse()\");\n+          }\n+          saslToken \u003d saslServer.evaluateResponse(saslToken);\n+          saslResponse \u003d buildSaslResponse(\n+              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n+              saslToken);\n+          break;\n+        }\n+        default:\n+          throw new SaslException(\"Client sent unsupported state \" + state);\n+      }\n+      return saslResponse;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private RpcSaslProto processSaslMessage(byte[] buf)\n        throws IOException, InterruptedException {\n      final DataInputStream dis \u003d\n          new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestMessageWrapper requestWrapper \u003d new RpcRequestMessageWrapper();\n      requestWrapper.readFields(dis);\n      \n      final RpcRequestHeaderProto rpcHeader \u003d requestWrapper.requestHeader;\n      if (rpcHeader.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Client sent non-SASL request\");\n      }      \n      final RpcSaslProto saslMessage \u003d\n          RpcSaslProto.parseFrom(requestWrapper.theRequestRead);\n      RpcSaslProto saslResponse \u003d null;\n      final SaslState state \u003d saslMessage.getState(); // required      \n      switch (state) {\n        case NEGOTIATE: {\n          if (sentNegotiate) {\n            throw new AccessControlException(\n                \"Client already attempted negotiation\");\n          }\n          saslResponse \u003d buildSaslNegotiateResponse();\n          break;\n        }\n        case INITIATE: {\n          if (saslMessage.getAuthsCount() !\u003d 1) {\n            throw new SaslException(\"Client mechanism is malformed\");\n          }\n          String authMethodName \u003d saslMessage.getAuths(0).getMethod();\n          authMethod \u003d createSaslServer(authMethodName);\n          if (authMethod \u003d\u003d null) { // the auth method is not supported\n            if (sentNegotiate) {\n              throw new AccessControlException(\n                  authMethodName + \" authentication is not enabled.\"\n                      + \"  Available:\" + enabledAuthMethods);\n            }\n            saslResponse \u003d buildSaslNegotiateResponse();\n            break;\n          }\n          // fallthru to process sasl token\n        }\n        case RESPONSE: {\n          if (!saslMessage.hasToken()) {\n            throw new SaslException(\"Client did not send a token\");\n          }\n          byte[] saslToken \u003d saslMessage.getToken().toByteArray();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          }\n          saslToken \u003d saslServer.evaluateResponse(saslToken);\n          saslResponse \u003d buildSaslResponse(\n              saslServer.isComplete() ? SaslState.SUCCESS : SaslState.CHALLENGE,\n              saslToken);\n          break;\n        }\n        default:\n          throw new SaslException(\"Client sent unsupported state \" + state);\n      }\n      return saslResponse;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}