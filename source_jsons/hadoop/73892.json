{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "processRpcRequest",
  "functionId": "processRpcRequest___header-RpcRequestHeaderProto__buffer-RpcWritable.Buffer",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 2631,
  "functionEndLine": 2724,
  "numCommitsSeen": 420,
  "timeTaken": 13708,
  "changeHistory": [
    "d6d95d2686bfc1d1e5511f60f169195734e2998e",
    "4ad295a4f1c202f08e40a57f31c1dc1ade96a4ca",
    "b73fb70f97983aef281a67f100bb28ba270a8b1c",
    "d2e85b0b6d82fef486b08de8a1d04cca1505646f",
    "66ec3a67e8563d17521b65cdae8374d28a24c624",
    "9bf0696c7348879678693176da0071628ca42566",
    "855e0477b1706a2d5b0df6a2b0e461aeec8839c2",
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
    "236ac773c964fa21d6d5f1496023cd61818dd3b1",
    "76cd81f4b656f0d40a4b2122e15f04ea53d8020b",
    "81485dbfc1ffb8daa609be8eb31094cc28646dd3",
    "d288a0ba8364d81aacda9f4a21022eecb6dc4e22",
    "580a8334963709e728ed677c815fb7fef9bca70e",
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
    "600ad7bf4104bcaeec00a4089d59bb1fdf423299",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "a78d5074fb3da4779a6b5fd9947e60b9d755ee14",
    "49f6e3d35e0f89637ae9ea970f249c13bdc0fd49",
    "6962510f729717f776929708813f99a28e582f34",
    "8724ceb2359af66c800043e665c17a2a30981c7d",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
    "eb2a60338715e517ba8e4d32ecfe28691a882188",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
    "589c68ae09effd6c4f26505d61636f779c22e99f",
    "186df142cc19c2969c1f8b56df0d8f75e3db66b1",
    "65200998c01b17e017d1814e8b1f4d82ac334a23",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2",
    "940389afce6a1b9b9e1519aed528cbc444786756",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "d6d95d2686bfc1d1e5511f60f169195734e2998e": "Ybodychange",
    "4ad295a4f1c202f08e40a57f31c1dc1ade96a4ca": "Ybodychange",
    "b73fb70f97983aef281a67f100bb28ba270a8b1c": "Ybodychange",
    "d2e85b0b6d82fef486b08de8a1d04cca1505646f": "Ybodychange",
    "66ec3a67e8563d17521b65cdae8374d28a24c624": "Ybodychange",
    "9bf0696c7348879678693176da0071628ca42566": "Ybodychange",
    "855e0477b1706a2d5b0df6a2b0e461aeec8839c2": "Ybodychange",
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "236ac773c964fa21d6d5f1496023cd61818dd3b1": "Ybodychange",
    "76cd81f4b656f0d40a4b2122e15f04ea53d8020b": "Ybodychange",
    "81485dbfc1ffb8daa609be8eb31094cc28646dd3": "Ybodychange",
    "d288a0ba8364d81aacda9f4a21022eecb6dc4e22": "Ybodychange",
    "580a8334963709e728ed677c815fb7fef9bca70e": "Ymultichange(Yparameterchange,Ybodychange)",
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc": "Ybodychange",
    "600ad7bf4104bcaeec00a4089d59bb1fdf423299": "Ybodychange",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "a78d5074fb3da4779a6b5fd9947e60b9d755ee14": "Ybodychange",
    "49f6e3d35e0f89637ae9ea970f249c13bdc0fd49": "Ybodychange",
    "6962510f729717f776929708813f99a28e582f34": "Ybodychange",
    "8724ceb2359af66c800043e665c17a2a30981c7d": "Ybodychange",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "eb2a60338715e517ba8e4d32ecfe28691a882188": "Ybodychange",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": "Ybodychange",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": "Ybodychange",
    "589c68ae09effd6c4f26505d61636f779c22e99f": "Ybodychange",
    "186df142cc19c2969c1f8b56df0d8f75e3db66b1": "Ybodychange",
    "65200998c01b17e017d1814e8b1f4d82ac334a23": "Ybodychange",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2": "Ybodychange",
    "940389afce6a1b9b9e1519aed528cbc444786756": "Ymultichange(Yparameterchange,Ybodychange)",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d6d95d2686bfc1d1e5511f60f169195734e2998e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14494. Move Server logging of StatedId inside receiveRequestState(). Contributed by Shweta Yakkali.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "10/06/19 10:23 AM",
      "commitName": "d6d95d2686bfc1d1e5511f60f169195734e2998e",
      "commitAuthor": "Shweta Yakkali",
      "commitDateOld": "04/06/19 7:56 AM",
      "commitNameOld": "827a84778a4e3b8f165806dfd2966f0951a5e575",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,94 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n       call.markCallCoordinated(false);\n       if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n           (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n         // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n         // step and treat the call as uncoordinated. As currently only certain\n         // ClientProtocol methods request made through RPC protobuf needs to be\n         // coordinated.\n         String methodName;\n         String protoName;\n         ProtobufRpcEngine.RpcProtobufRequest req \u003d\n             (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n         try {\n           methodName \u003d req.getRequestHeader().getMethodName();\n           protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n           if (alignmentContext.isCoordinatedCall(protoName, methodName)) {\n             call.markCallCoordinated(true);\n             long stateId;\n             stateId \u003d alignmentContext.receiveRequestState(\n                 header, getMaxIdleTime());\n             call.setClientStateId(stateId);\n-            LOG.trace(\"Client State ID\u003d {} and Server State ID\u003d {}\",\n-                call.getClientStateId(), alignmentContext.getLastSeenStateId());\n           }\n         } catch (IOException ioe) {\n           throw new RpcServerException(\"Processing RPC request caught \", ioe);\n         }\n       }\n \n       try {\n         internalQueueCall(call);\n       } catch (RpcServerException rse) {\n         throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n      call.markCallCoordinated(false);\n      if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n          (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n        // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n        // step and treat the call as uncoordinated. As currently only certain\n        // ClientProtocol methods request made through RPC protobuf needs to be\n        // coordinated.\n        String methodName;\n        String protoName;\n        ProtobufRpcEngine.RpcProtobufRequest req \u003d\n            (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n        try {\n          methodName \u003d req.getRequestHeader().getMethodName();\n          protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n          if (alignmentContext.isCoordinatedCall(protoName, methodName)) {\n            call.markCallCoordinated(true);\n            long stateId;\n            stateId \u003d alignmentContext.receiveRequestState(\n                header, getMaxIdleTime());\n            call.setClientStateId(stateId);\n          }\n        } catch (IOException ioe) {\n          throw new RpcServerException(\"Processing RPC request caught \", ioe);\n        }\n      }\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "4ad295a4f1c202f08e40a57f31c1dc1ade96a4ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14270.[SBN Read] Add trace level logging for stateId in RPC Server. Contributed by Shweta Yakkali.",
      "commitDate": "11/03/19 1:48 PM",
      "commitName": "4ad295a4f1c202f08e40a57f31c1dc1ade96a4ca",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "13/02/19 12:40 PM",
      "commitNameOld": "024c87291cb4cc67282fe5645fb827427cc581c6",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 26.01,
      "commitsBetweenForRepo": 237,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n       call.markCallCoordinated(false);\n       if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n           (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n         // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n         // step and treat the call as uncoordinated. As currently only certain\n         // ClientProtocol methods request made through RPC protobuf needs to be\n         // coordinated.\n         String methodName;\n         String protoName;\n         ProtobufRpcEngine.RpcProtobufRequest req \u003d\n             (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n         try {\n           methodName \u003d req.getRequestHeader().getMethodName();\n           protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n           if (alignmentContext.isCoordinatedCall(protoName, methodName)) {\n             call.markCallCoordinated(true);\n             long stateId;\n             stateId \u003d alignmentContext.receiveRequestState(\n                 header, getMaxIdleTime());\n             call.setClientStateId(stateId);\n+            LOG.trace(\"Client State ID\u003d {} and Server State ID\u003d {}\",\n+                call.getClientStateId(), alignmentContext.getLastSeenStateId());\n           }\n         } catch (IOException ioe) {\n           throw new RpcServerException(\"Processing RPC request caught \", ioe);\n         }\n       }\n \n       try {\n         internalQueueCall(call);\n       } catch (RpcServerException rse) {\n         throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n      call.markCallCoordinated(false);\n      if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n          (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n        // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n        // step and treat the call as uncoordinated. As currently only certain\n        // ClientProtocol methods request made through RPC protobuf needs to be\n        // coordinated.\n        String methodName;\n        String protoName;\n        ProtobufRpcEngine.RpcProtobufRequest req \u003d\n            (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n        try {\n          methodName \u003d req.getRequestHeader().getMethodName();\n          protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n          if (alignmentContext.isCoordinatedCall(protoName, methodName)) {\n            call.markCallCoordinated(true);\n            long stateId;\n            stateId \u003d alignmentContext.receiveRequestState(\n                header, getMaxIdleTime());\n            call.setClientStateId(stateId);\n            LOG.trace(\"Client State ID\u003d {} and Server State ID\u003d {}\",\n                call.getClientStateId(), alignmentContext.getLastSeenStateId());\n          }\n        } catch (IOException ioe) {\n          throw new RpcServerException(\"Processing RPC request caught \", ioe);\n        }\n      }\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "b73fb70f97983aef281a67f100bb28ba270a8b1c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13873. [SBN read] ObserverNode should reject read requests when it is too far behind. Contributed by Konstantin Shvachko.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "b73fb70f97983aef281a67f100bb28ba270a8b1c",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "d2e85b0b6d82fef486b08de8a1d04cca1505646f",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,94 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n+      call.markCallCoordinated(false);\n       if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n           (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n         // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n         // step and treat the call as uncoordinated. As currently only certain\n         // ClientProtocol methods request made through RPC protobuf needs to be\n         // coordinated.\n         String methodName;\n         String protoName;\n+        ProtobufRpcEngine.RpcProtobufRequest req \u003d\n+            (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n         try {\n-          ProtobufRpcEngine.RpcProtobufRequest req \u003d\n-              (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n           methodName \u003d req.getRequestHeader().getMethodName();\n           protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n+          if (alignmentContext.isCoordinatedCall(protoName, methodName)) {\n+            call.markCallCoordinated(true);\n+            long stateId;\n+            stateId \u003d alignmentContext.receiveRequestState(\n+                header, getMaxIdleTime());\n+            call.setClientStateId(stateId);\n+          }\n         } catch (IOException ioe) {\n-          throw new RpcServerException(\"Rpc request header check fail\", ioe);\n+          throw new RpcServerException(\"Processing RPC request caught \", ioe);\n         }\n-        if (!alignmentContext.isCoordinatedCall(protoName, methodName)) {\n-          call.markCallCoordinated(false);\n-        } else {\n-          call.markCallCoordinated(true);\n-          long stateId \u003d alignmentContext.receiveRequestState(header);\n-          call.setClientStateId(stateId);\n-        }\n-      } else {\n-        call.markCallCoordinated(false);\n       }\n \n       try {\n         internalQueueCall(call);\n       } catch (RpcServerException rse) {\n         throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n      call.markCallCoordinated(false);\n      if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n          (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n        // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n        // step and treat the call as uncoordinated. As currently only certain\n        // ClientProtocol methods request made through RPC protobuf needs to be\n        // coordinated.\n        String methodName;\n        String protoName;\n        ProtobufRpcEngine.RpcProtobufRequest req \u003d\n            (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n        try {\n          methodName \u003d req.getRequestHeader().getMethodName();\n          protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n          if (alignmentContext.isCoordinatedCall(protoName, methodName)) {\n            call.markCallCoordinated(true);\n            long stateId;\n            stateId \u003d alignmentContext.receiveRequestState(\n                header, getMaxIdleTime());\n            call.setClientStateId(stateId);\n          }\n        } catch (IOException ioe) {\n          throw new RpcServerException(\"Processing RPC request caught \", ioe);\n        }\n      }\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "d2e85b0b6d82fef486b08de8a1d04cca1505646f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13880. Add mechanism to allow certain RPC calls to bypass sync. Contributed by Chen Liang.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "d2e85b0b6d82fef486b08de8a1d04cca1505646f",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "66ec3a67e8563d17521b65cdae8374d28a24c624",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,95 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n-      if(alignmentContext !\u003d null) {\n-        long stateId \u003d alignmentContext.receiveRequestState(header);\n-        call.setClientStateId(stateId);\n+      if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n+          (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n+        // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n+        // step and treat the call as uncoordinated. As currently only certain\n+        // ClientProtocol methods request made through RPC protobuf needs to be\n+        // coordinated.\n+        String methodName;\n+        String protoName;\n+        try {\n+          ProtobufRpcEngine.RpcProtobufRequest req \u003d\n+              (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n+          methodName \u003d req.getRequestHeader().getMethodName();\n+          protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n+        } catch (IOException ioe) {\n+          throw new RpcServerException(\"Rpc request header check fail\", ioe);\n+        }\n+        if (!alignmentContext.isCoordinatedCall(protoName, methodName)) {\n+          call.markCallCoordinated(false);\n+        } else {\n+          call.markCallCoordinated(true);\n+          long stateId \u003d alignmentContext.receiveRequestState(header);\n+          call.setClientStateId(stateId);\n+        }\n+      } else {\n+        call.markCallCoordinated(false);\n       }\n \n       try {\n         internalQueueCall(call);\n       } catch (RpcServerException rse) {\n         throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n      if(alignmentContext !\u003d null \u0026\u0026 call.rpcRequest !\u003d null \u0026\u0026\n          (call.rpcRequest instanceof ProtobufRpcEngine.RpcProtobufRequest)) {\n        // if call.rpcRequest is not RpcProtobufRequest, will skip the following\n        // step and treat the call as uncoordinated. As currently only certain\n        // ClientProtocol methods request made through RPC protobuf needs to be\n        // coordinated.\n        String methodName;\n        String protoName;\n        try {\n          ProtobufRpcEngine.RpcProtobufRequest req \u003d\n              (ProtobufRpcEngine.RpcProtobufRequest) call.rpcRequest;\n          methodName \u003d req.getRequestHeader().getMethodName();\n          protoName \u003d req.getRequestHeader().getDeclaringClassProtocolName();\n        } catch (IOException ioe) {\n          throw new RpcServerException(\"Rpc request header check fail\", ioe);\n        }\n        if (!alignmentContext.isCoordinatedCall(protoName, methodName)) {\n          call.markCallCoordinated(false);\n        } else {\n          call.markCallCoordinated(true);\n          long stateId \u003d alignmentContext.receiveRequestState(header);\n          call.setClientStateId(stateId);\n        }\n      } else {\n        call.markCallCoordinated(false);\n      }\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "66ec3a67e8563d17521b65cdae8374d28a24c624": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13767. Add msync server implementation. Contributed by Chen Liang.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "66ec3a67e8563d17521b65cdae8374d28a24c624",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "e27708c2daf663086380cdf5215cffcab1a0b00c",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,73 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n-      if (alignmentContext !\u003d null) {\n-        // Check incoming RPC request\u0027s state.\n-        alignmentContext.receiveRequestState(header);\n-      }\n-\n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n+      if(alignmentContext !\u003d null) {\n+        long stateId \u003d alignmentContext.receiveRequestState(header);\n+        call.setClientStateId(stateId);\n+      }\n \n       try {\n         internalQueueCall(call);\n       } catch (RpcServerException rse) {\n         throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n      if(alignmentContext !\u003d null) {\n        long stateId \u003d alignmentContext.receiveRequestState(header);\n        call.setClientStateId(stateId);\n      }\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "9bf0696c7348879678693176da0071628ca42566": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13331. [SBN read] Add lastSeenStateId to RpcRequestHeader. Contributed by Plamen Jeliazkov.\n",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "9bf0696c7348879678693176da0071628ca42566",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "c9d73437e881296282abe46a6b3196befc8cef72",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,74 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n+      if (alignmentContext !\u003d null) {\n+        // Check incoming RPC request\u0027s state.\n+        alignmentContext.receiveRequestState(header);\n+      }\n+\n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       try {\n         internalQueueCall(call);\n       } catch (RpcServerException rse) {\n         throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      if (alignmentContext !\u003d null) {\n        // Check incoming RPC request\u0027s state.\n        alignmentContext.receiveRequestState(header);\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "855e0477b1706a2d5b0df6a2b0e461aeec8839c2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14035. Reduce fair call queue backoff\u0027s impact on clients. Contributed by Daryn Sharp.\n",
      "commitDate": "06/06/17 6:35 AM",
      "commitName": "855e0477b1706a2d5b0df6a2b0e461aeec8839c2",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "05/06/17 9:21 AM",
      "commitNameOld": "abdd609e51a80388493417126c3bc9b1badc0ac1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 0.88,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,69 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (RpcServerException rse) { // lets tests inject failures.\n         throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       try {\n-        queueCall(call);\n+        internalQueueCall(call);\n+      } catch (RpcServerException rse) {\n+        throw rse;\n       } catch (IOException ioe) {\n         throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      try {\n        internalQueueCall(call);\n      } catch (RpcServerException rse) {\n        throw rse;\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
      "commitDate": "09/02/17 8:47 AM",
      "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,67 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n-        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n+        RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n-        throw new WrappedRpcServerException(\n-            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n+        throw new FatalRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n+      } catch (RpcServerException rse) { // lets tests inject failures.\n+        throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-        throw new WrappedRpcServerException(\n+        throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       try {\n         queueCall(call);\n       } catch (IOException ioe) {\n-        throw new WrappedRpcServerException(\n+        throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      try {\n        queueCall(call);\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[WrappedRpcServerException, InterruptedException]",
            "newValue": "[RpcServerException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,67 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n-        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n+        RpcWritable.Buffer buffer) throws RpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n-        throw new WrappedRpcServerException(\n-            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n+        throw new FatalRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n+      } catch (RpcServerException rse) { // lets tests inject failures.\n+        throw rse;\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-        throw new WrappedRpcServerException(\n+        throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       try {\n         queueCall(call);\n       } catch (IOException ioe) {\n-        throw new WrappedRpcServerException(\n+        throw new FatalRpcServerException(\n             RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (RpcServerException rse) { // lets tests inject failures.\n        throw rse;\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      try {\n        queueCall(call);\n      } catch (IOException ioe) {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "236ac773c964fa21d6d5f1496023cd61818dd3b1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13537. Support external calls in the RPC call queue. Contributed by Daryn Sharp.\n",
      "commitDate": "29/09/16 11:27 AM",
      "commitName": "236ac773c964fa21d6d5f1496023cd61818dd3b1",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "28/09/16 6:24 AM",
      "commitNameOld": "e19b37ead23805c7ed45bdcbfa7fdc8898cde7b2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,65 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       RpcCall call \u003d new RpcCall(this, header.getCallId(),\n           header.getRetryCount(), rpcRequest,\n           ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n-      if (callQueue.isClientBackoffEnabled()) {\n-        // if RPC queue is full, we will ask the RPC client to back off by\n-        // throwing RetriableException. Whether RPC client will honor\n-        // RetriableException and retry depends on client ipc retry policy.\n-        // For example, FailoverOnNetworkExceptionRetry handles\n-        // RetriableException.\n-        queueRequestOrAskClientToBackOff(call);\n-      } else {\n-        callQueue.put(call);              // queue the call; maybe blocked here\n+      try {\n+        queueCall(call);\n+      } catch (IOException ioe) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      try {\n        queueCall(call);\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.ERROR_RPC_SERVER, ioe);\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "76cd81f4b656f0d40a4b2122e15f04ea53d8020b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp.\n",
      "commitDate": "01/09/16 1:44 PM",
      "commitName": "76cd81f4b656f0d40a4b2122e15f04ea53d8020b",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/08/16 2:04 PM",
      "commitNameOld": "81485dbfc1ffb8daa609be8eb31094cc28646dd3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.99,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n-      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n-          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n+      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n+          header.getRetryCount(), rpcRequest,\n+          ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "81485dbfc1ffb8daa609be8eb31094cc28646dd3": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp.\"\n\nThis reverts commit d288a0ba8364d81aacda9f4a21022eecb6dc4e22.\n",
      "commitDate": "25/08/16 2:04 PM",
      "commitName": "81485dbfc1ffb8daa609be8eb31094cc28646dd3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/08/16 9:44 AM",
      "commitNameOld": "d288a0ba8364d81aacda9f4a21022eecb6dc4e22",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,68 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n-      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n-          header.getRetryCount(), rpcRequest,\n-          ProtoUtil.convert(header.getRpcKind()),\n+      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n+          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "d288a0ba8364d81aacda9f4a21022eecb6dc4e22": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp.\n",
      "commitDate": "25/08/16 9:44 AM",
      "commitName": "d288a0ba8364d81aacda9f4a21022eecb6dc4e22",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "03/08/16 11:22 AM",
      "commitNameOld": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 21.93,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n-      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n-          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n+      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n+          header.getRetryCount(), rpcRequest,\n+          ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      RpcCall call \u003d new RpcCall(this, header.getCallId(),\n          header.getRetryCount(), rpcRequest,\n          ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "580a8334963709e728ed677c815fb7fef9bca70e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "03/08/16 11:22 AM",
      "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "03/08/16 11:22 AM",
          "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/08/16 7:31 AM",
          "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,68 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n-        DataInputStream dis) throws WrappedRpcServerException,\n+        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n-        rpcRequest.readFields(dis);\n+        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[header-RpcRequestHeaderProto, dis-DataInputStream]",
            "newValue": "[header-RpcRequestHeaderProto, buffer-RpcWritable.Buffer]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "03/08/16 11:22 AM",
          "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/08/16 7:31 AM",
          "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,68 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n-        DataInputStream dis) throws WrappedRpcServerException,\n+        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n-        rpcRequest.readFields(dis);\n+        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n       // Save the priority level assignment by the scheduler\n       call.setPriorityLevel(callQueue.getPriorityLevel(call));\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d buffer.newInstance(rpcRequestClass, conf);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12916. Allow RPC scheduler/callqueue backoff using response times. Contributed by Xiaoyu Yao.\n",
      "commitDate": "31/03/16 8:42 AM",
      "commitName": "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "08/03/16 11:29 PM",
      "commitNameOld": "2e040d31c7bba021576e6baf267d937da7ff814a",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 22.34,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,69 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n       CallerContext callerContext \u003d null;\n       if (header.hasCallerContext()) {\n         callerContext \u003d\n             new CallerContext.Builder(header.getCallerContext().getContext())\n                 .setSignature(header.getCallerContext().getSignature()\n                     .toByteArray())\n                 .build();\n       }\n \n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceScope, callerContext);\n \n+      // Save the priority level assignment by the scheduler\n+      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n+\n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      // Save the priority level assignment by the scheduler\n      call.setPriorityLevel(callQueue.getPriorityLevel(call));\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "600ad7bf4104bcaeec00a4089d59bb1fdf423299": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9184. Logging HDFS operation\u0027s caller context into audit logs. Contributed by Mingliang Liu.\n",
      "commitDate": "23/10/15 12:15 PM",
      "commitName": "600ad7bf4104bcaeec00a4089d59bb1fdf423299",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "18/10/15 6:54 PM",
      "commitNameOld": "476a251e5efe5e5850671f924e622b587c262653",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 4.72,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,66 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n         if (tracer !\u003d null) {\n           // If the incoming RPC included tracing info, always continue the\n           // trace\n           SpanId parentSpanId \u003d new SpanId(\n               header.getTraceInfo().getTraceId(),\n               header.getTraceInfo().getParentId());\n           traceScope \u003d tracer.newScope(\n               RpcClientUtil.toTraceName(rpcRequest.toString()),\n               parentSpanId);\n           traceScope.detach();\n         }\n       }\n \n+      CallerContext callerContext \u003d null;\n+      if (header.hasCallerContext()) {\n+        callerContext \u003d\n+            new CallerContext.Builder(header.getCallerContext().getContext())\n+                .setSignature(header.getCallerContext().getSignature()\n+                    .toByteArray())\n+                .build();\n+      }\n+\n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n-          header.getClientId().toByteArray(), traceScope);\n+          header.getClientId().toByteArray(), traceScope, callerContext);\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      CallerContext callerContext \u003d null;\n      if (header.hasCallerContext()) {\n        callerContext \u003d\n            new CallerContext.Builder(header.getCallerContext().getContext())\n                .setSignature(header.getCallerContext().getSignature()\n                    .toByteArray())\n                .build();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope, callerContext);\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "24/08/15 2:31 PM",
      "commitNameOld": "48774d0a45d95557affbd6bbaf8035cc9575ef36",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 34.72,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,57 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n-      Span traceSpan \u003d null;\n+      TraceScope traceScope \u003d null;\n       if (header.hasTraceInfo()) {\n-        // If the incoming RPC included tracing info, always continue the trace\n-        TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n-                                             header.getTraceInfo().getParentId());\n-        traceSpan \u003d Trace.startSpan(\n-            RpcClientUtil.toTraceName(rpcRequest.toString()),\n-            parentSpan).detach();\n+        if (tracer !\u003d null) {\n+          // If the incoming RPC included tracing info, always continue the\n+          // trace\n+          SpanId parentSpanId \u003d new SpanId(\n+              header.getTraceInfo().getTraceId(),\n+              header.getTraceInfo().getParentId());\n+          traceScope \u003d tracer.newScope(\n+              RpcClientUtil.toTraceName(rpcRequest.toString()),\n+              parentSpanId);\n+          traceScope.detach();\n+        }\n       }\n \n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n-          header.getClientId().toByteArray(), traceSpan);\n+          header.getClientId().toByteArray(), traceScope);\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      TraceScope traceScope \u003d null;\n      if (header.hasTraceInfo()) {\n        if (tracer !\u003d null) {\n          // If the incoming RPC included tracing info, always continue the\n          // trace\n          SpanId parentSpanId \u003d new SpanId(\n              header.getTraceInfo().getTraceId(),\n              header.getTraceInfo().getParentId());\n          traceScope \u003d tracer.newScope(\n              RpcClientUtil.toTraceName(rpcRequest.toString()),\n              parentSpanId);\n          traceScope.detach();\n        }\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceScope);\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a78d5074fb3da4779a6b5fd9947e60b9d755ee14": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12171. Shorten overly-long htrace span names for server (cmccabe)\n",
      "commitDate": "01/07/15 5:57 PM",
      "commitName": "a78d5074fb3da4779a6b5fd9947e60b9d755ee14",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "27/05/15 2:04 AM",
      "commitNameOld": "bb1816328a36ec3f8c6bd9fdb950d9a4ec8388c8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 35.66,
      "commitsBetweenForRepo": 269,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,52 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       Span traceSpan \u003d null;\n       if (header.hasTraceInfo()) {\n         // If the incoming RPC included tracing info, always continue the trace\n         TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n                                              header.getTraceInfo().getParentId());\n-        traceSpan \u003d Trace.startSpan(rpcRequest.toString(), parentSpan).detach();\n+        traceSpan \u003d Trace.startSpan(\n+            RpcClientUtil.toTraceName(rpcRequest.toString()),\n+            parentSpan).detach();\n       }\n \n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceSpan);\n \n       if (callQueue.isClientBackoffEnabled()) {\n         // if RPC queue is full, we will ask the RPC client to back off by\n         // throwing RetriableException. Whether RPC client will honor\n         // RetriableException and retry depends on client ipc retry policy.\n         // For example, FailoverOnNetworkExceptionRetry handles\n         // RetriableException.\n         queueRequestOrAskClientToBackOff(call);\n       } else {\n         callQueue.put(call);              // queue the call; maybe blocked here\n       }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Span traceSpan \u003d null;\n      if (header.hasTraceInfo()) {\n        // If the incoming RPC included tracing info, always continue the trace\n        TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n                                             header.getTraceInfo().getParentId());\n        traceSpan \u003d Trace.startSpan(\n            RpcClientUtil.toTraceName(rpcRequest.toString()),\n            parentSpan).detach();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceSpan);\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "49f6e3d35e0f89637ae9ea970f249c13bdc0fd49": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10597. RPC Server signals backoff to clients when all request queues are full. (Contributed by Ming Ma)\n",
      "commitDate": "23/04/15 9:35 AM",
      "commitName": "49f6e3d35e0f89637ae9ea970f249c13bdc0fd49",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "25/03/15 12:36 AM",
      "commitNameOld": "5582b0f1d469e7c98811a341c4b4c78eaa64ede5",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 29.37,
      "commitsBetweenForRepo": 244,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,50 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       Span traceSpan \u003d null;\n       if (header.hasTraceInfo()) {\n         // If the incoming RPC included tracing info, always continue the trace\n         TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n                                              header.getTraceInfo().getParentId());\n         traceSpan \u003d Trace.startSpan(rpcRequest.toString(), parentSpan).detach();\n       }\n \n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n           rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n           header.getClientId().toByteArray(), traceSpan);\n \n-      callQueue.put(call);              // queue the call; maybe blocked here\n+      if (callQueue.isClientBackoffEnabled()) {\n+        // if RPC queue is full, we will ask the RPC client to back off by\n+        // throwing RetriableException. Whether RPC client will honor\n+        // RetriableException and retry depends on client ipc retry policy.\n+        // For example, FailoverOnNetworkExceptionRetry handles\n+        // RetriableException.\n+        queueRequestOrAskClientToBackOff(call);\n+      } else {\n+        callQueue.put(call);              // queue the call; maybe blocked here\n+      }\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Span traceSpan \u003d null;\n      if (header.hasTraceInfo()) {\n        // If the incoming RPC included tracing info, always continue the trace\n        TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n                                             header.getTraceInfo().getParentId());\n        traceSpan \u003d Trace.startSpan(rpcRequest.toString(), parentSpan).detach();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceSpan);\n\n      if (callQueue.isClientBackoffEnabled()) {\n        // if RPC queue is full, we will ask the RPC client to back off by\n        // throwing RetriableException. Whether RPC client will honor\n        // RetriableException and retry depends on client ipc retry policy.\n        // For example, FailoverOnNetworkExceptionRetry handles\n        // RetriableException.\n        queueRequestOrAskClientToBackOff(call);\n      } else {\n        callQueue.put(call);              // queue the call; maybe blocked here\n      }\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "6962510f729717f776929708813f99a28e582f34": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6879. Adding tracing to Hadoop RPC.  Contributed by Masatake Iwasaki.\n",
      "commitDate": "27/08/14 2:12 PM",
      "commitName": "6962510f729717f776929708813f99a28e582f34",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "15/07/14 4:05 PM",
      "commitNameOld": "790ee456439729073d75ccf91e1f63b3d360b1c7",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 42.92,
      "commitsBetweenForRepo": 361,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,41 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n+      Span traceSpan \u003d null;\n+      if (header.hasTraceInfo()) {\n+        // If the incoming RPC included tracing info, always continue the trace\n+        TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n+                                             header.getTraceInfo().getParentId());\n+        traceSpan \u003d Trace.startSpan(rpcRequest.toString(), parentSpan).detach();\n+      }\n+\n       Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n-          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()), header\n-              .getClientId().toByteArray());\n+          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n+          header.getClientId().toByteArray(), traceSpan);\n+\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Span traceSpan \u003d null;\n      if (header.hasTraceInfo()) {\n        // If the incoming RPC included tracing info, always continue the trace\n        TraceInfo parentSpan \u003d new TraceInfo(header.getTraceInfo().getTraceId(),\n                                             header.getTraceInfo().getParentId());\n        traceSpan \u003d Trace.startSpan(rpcRequest.toString(), parentSpan).detach();\n      }\n\n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),\n          header.getClientId().toByteArray(), traceSpan);\n\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "8724ceb2359af66c800043e665c17a2a30981c7d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9717. Add retry attempt count to the RPC requests. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504725 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 4:44 PM",
      "commitName": "8724ceb2359af66c800043e665c17a2a30981c7d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/07/13 9:42 PM",
      "commitNameOld": "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private void processRpcRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException,\n         InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n-          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n-              .toByteArray());\n+      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n+          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()), header\n+              .getClientId().toByteArray());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), header.getRetryCount(),\n          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()), header\n              .getClientId().toByteArray());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 10:59 AM",
      "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,32 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n+    private void processRpcRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException,\n+        InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n           ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n               .toByteArray());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n              .toByteArray());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[buf-byte[]]",
            "newValue": "[header-RpcRequestHeaderProto, dis-DataInputStream]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,32 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n+    private void processRpcRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException,\n+        InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n           ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n               .toByteArray());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n              .toByteArray());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[RpcServerException, IOException, InterruptedException]",
            "newValue": "[WrappedRpcServerException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,32 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n+    private void processRpcRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException,\n+        InterruptedException {\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n           ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n               .toByteArray());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException,\n        InterruptedException {\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST, err);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n              .toByteArray());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "eb2a60338715e517ba8e4d32ecfe28691a882188": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9688. Add globally unique Client ID to RPC requests. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500843 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/07/13 10:08 AM",
      "commitName": "eb2a60338715e517ba8e4d32ecfe28691a882188",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "01/07/13 4:17 PM",
      "commitNameOld": "805e9b5b6d835d1b7a50af18967afb8eebdf8606",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n     private void processRpcRequest(byte[] buf) \n         throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n         String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n         String err \u003d \"IPC Server does not implement rpc header operation\" + \n                 header.getRpcOp();\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n         String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n         setupResponse(responseBuffer, readParamsFailedCall, \n             RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n             null, t.getClass().getName(),\n             err);\n         responder.doRespond(readParamsFailedCall);\n         throw new RpcServerException(err, t);\n       }\n         \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n-          ProtoUtil.convert(header.getRpcKind()));\n+      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n+          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n+              .toByteArray());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n              .toByteArray());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": {
      "type": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/13 10:51 AM",
      "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
      "commitAuthor": "Sanjay Radia",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/05/13 10:51 AM",
          "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "27/03/13 11:51 AM",
          "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 37.96,
          "commitsBetweenForRepo": 210,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-    private void processData(byte[] buf) throws  IOException, InterruptedException {\n+    private void processRpcRequest(byte[] buf) \n+        throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getRpcOp());\n+        String err \u003d \"IPC Server does not implement rpc header operation\" + \n+                header.getRpcOp();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getRpcKind());\n-        responder.doRespond(readParamsFailedCall);\n-        return;   \n+        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n+            header.getRpcKind();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n-      } catch (Throwable t) {\n+      } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            t.getClass().getName(),\n-            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        setupResponse(responseBuffer, readParamsFailedCall, \n+            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n+            null, t.getClass().getName(),\n+            err);\n         responder.doRespond(readParamsFailedCall);\n-        return;\n+        throw new RpcServerException(err, t);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "processData",
            "newValue": "processRpcRequest"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/05/13 10:51 AM",
          "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "27/03/13 11:51 AM",
          "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 37.96,
          "commitsBetweenForRepo": 210,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-    private void processData(byte[] buf) throws  IOException, InterruptedException {\n+    private void processRpcRequest(byte[] buf) \n+        throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getRpcOp());\n+        String err \u003d \"IPC Server does not implement rpc header operation\" + \n+                header.getRpcOp();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getRpcKind());\n-        responder.doRespond(readParamsFailedCall);\n-        return;   \n+        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n+            header.getRpcKind();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n-      } catch (Throwable t) {\n+      } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            t.getClass().getName(),\n-            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        setupResponse(responseBuffer, readParamsFailedCall, \n+            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n+            null, t.getClass().getName(),\n+            err);\n         responder.doRespond(readParamsFailedCall);\n-        return;\n+        throw new RpcServerException(err, t);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[IOException, InterruptedException]",
            "newValue": "[RpcServerException, IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/05/13 10:51 AM",
          "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "27/03/13 11:51 AM",
          "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 37.96,
          "commitsBetweenForRepo": 210,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-    private void processData(byte[] buf) throws  IOException, InterruptedException {\n+    private void processRpcRequest(byte[] buf) \n+        throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getRpcOp());\n+        String err \u003d \"IPC Server does not implement rpc header operation\" + \n+                header.getRpcOp();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getRpcKind());\n-        responder.doRespond(readParamsFailedCall);\n-        return;   \n+        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n+            header.getRpcKind();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n-      } catch (Throwable t) {\n+      } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            t.getClass().getName(),\n-            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        setupResponse(responseBuffer, readParamsFailedCall, \n+            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n+            null, t.getClass().getName(),\n+            err);\n         responder.doRespond(readParamsFailedCall);\n-        return;\n+        throw new RpcServerException(err, t);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9140 Cleanup rpc PB protos (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423189 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/12 2:16 PM",
      "commitName": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "05/12/12 6:53 PM",
      "commitNameOld": "3337588975fa24c0044408c6caf91abea4dca4d4",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 11.81,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n+      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n+        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n       }\n-      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n+      if (header.getRpcOp() !\u003d \n+          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getRpcOp());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n+        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             IOException.class.getName(),\n             \"Unknown rpc kind \"  + header.getRpcKind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getRpcOp());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getRpcKind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8366 Use ProtoBuf for RpcResponseHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1337283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/05/12 9:56 AM",
      "commitName": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "02/05/12 11:35 PM",
      "commitNameOld": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 8.43,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n         throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n       }\n       if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getRpcOp());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n         throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             IOException.class.getName(),\n             \"Unknown rpc kind \"  + header.getRpcKind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n      }\n      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getRpcOp());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getRpcKind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "589c68ae09effd6c4f26505d61636f779c22e99f": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8285 Use ProtoBuf for RpcPayLoadHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1329319 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/12 9:34 AM",
      "commitName": "589c68ae09effd6c4f26505d61636f779c22e99f",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "17/04/12 8:04 AM",
      "commitNameOld": "e8eed2f62d30e0bf2f915ee3ad6b9c9f6d2d97cb",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,59 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n-      header.readFields(dis);           // Read the RpcPayload header\n+      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n-      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n+      if (!header.hasRpcOp()) {\n+        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n+      }\n+      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getOperation());\n+              header.getRpcOp());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n+      if (!header.hasRpcKind()) {\n+        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n+      }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n-          getRpcRequestWrapper(header.getkind());\n+          getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n-        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n+        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getkind());\n+            \"Unknown rpc kind \"  + header.getRpcKind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n-            this.protocolName + \" for rpcKind \" + header.getkind(),  t);\n+            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n+      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n+          ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n      }\n      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getRpcOp());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getRpcKind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "186df142cc19c2969c1f8b56df0d8f75e3db66b1": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7913 Fix bug in ProtoBufRpcEngine  (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213619 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 1:18 AM",
      "commitName": "186df142cc19c2969c1f8b56df0d8f75e3db66b1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "04/12/11 12:44 PM",
      "commitNameOld": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 8.52,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcPayloadHeader header \u003d new RpcPayloadHeader();\n       header.readFields(dis);           // Read the RpcPayload header\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getOperation());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getkind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             IOException.class.getName(),\n             \"Unknown rpc kind \"  + header.getkind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n-                 getHostAddress(), t);\n+                 getHostAddress() + \"on connection protocol \" +\n+            this.protocolName + \" for rpcKind \" + header.getkind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n      header.readFields(dis);           // Read the RpcPayload header\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getOperation());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getkind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getkind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getkind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "65200998c01b17e017d1814e8b1f4d82ac334a23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7862  Move the support for multiple protocols to lower layer so that Writable, PB and Avro can all use it (includes HDFS and MR changes to match) (Sanjay) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210208 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/11 12:44 PM",
      "commitName": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "27/11/11 12:27 PM",
      "commitNameOld": "229a3a23127e33f596d485dec580e31c48ba9057",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,52 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcPayloadHeader header \u003d new RpcPayloadHeader();\n       header.readFields(dis);           // Read the RpcPayload header\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getOperation());\n       }\n+      // If we know the rpc kind, get its class so that we can deserialize\n+      // (Note it would make more sense to have the handler deserialize but \n+      // we continue with this original design.\n+      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n+          getRpcRequestWrapper(header.getkind());\n+      if (rpcRequestClass \u003d\u003d null) {\n+        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n+            \" from client \" + getHostAddress());\n+        final Call readParamsFailedCall \u003d \n+            new Call(header.getCallId(), null, this);\n+        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+\n+        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+            IOException.class.getName(),\n+            \"Unknown rpc kind \"  + header.getkind());\n+        responder.doRespond(readParamsFailedCall);\n+        return;   \n+      }\n       Writable rpcRequest;\n       try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(paramClass, conf);\n+        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress(), t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n      header.readFields(dis);           // Read the RpcPayload header\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getOperation());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getkind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getkind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": {
      "type": "Ybodychange",
      "commitMessage": "\t\tHADOOP-7776 Make the Ipc-Header in a RPC-Payload an explicit header (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1197885 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/11/11 10:06 PM",
      "commitName": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 10.96,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,34 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n-      int id \u003d dis.readInt();                    // try to read an id\n+      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n+      header.readFields(dis);           // Read the RpcPayload header\n         \n       if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + id);\n-      Writable param;\n-      try {\n-        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n-        param.readFields(dis);\n+        LOG.debug(\" got #\" + header.getCallId());\n+      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n+        throw new IOException(\"IPC Server does not implement operation\" + \n+              header.getOperation());\n+      }\n+      Writable rpcRequest;\n+      try { //Read the rpc request\n+        rpcRequest \u003d ReflectionUtils.newInstance(paramClass, conf);\n+        rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress(), t);\n-        final Call readParamsFailedCall \u003d new Call(id, null, this);\n+        final Call readParamsFailedCall \u003d \n+            new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n-      Call call \u003d new Call(id, param, this);\n+      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n      header.readFields(dis);           // Read the RpcPayload header\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getOperation());\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(paramClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7121. Exceptions while serializing IPC call responses are not handled well. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1129982 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/11 7:00 PM",
      "commitName": "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "26/05/11 12:48 AM",
      "commitNameOld": "2f6c03ad54725e59e3d18866cfaaea734bb37c82",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,28 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       int id \u003d dis.readInt();                    // try to read an id\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + id);\n+      Writable param;\n+      try {\n+        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n+        param.readFields(dis);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Unable to read call parameters for client \" +\n+                 getHostAddress(), t);\n+        final Call readParamsFailedCall \u003d new Call(id, null, this);\n+        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n-      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n-      param.readFields(dis);        \n+        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+            t.getClass().getName(),\n+            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        responder.doRespond(readParamsFailedCall);\n+        return;\n+      }\n         \n       Call call \u003d new Call(id, param, this);\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "940389afce6a1b9b9e1519aed528cbc444786756": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/10 5:30 PM",
      "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthor": "Devaraj Das",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/02/10 5:30 PM",
          "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "27/01/10 12:08 AM",
          "commitNameOld": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
          "commitAuthorOld": "Owen O\u0027Malley",
          "daysBetweenCommits": 6.72,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,15 @@\n-    private void processData() throws  IOException, InterruptedException {\n+    private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(data.array()));\n+        new DataInputStream(new ByteArrayInputStream(buf));\n       int id \u003d dis.readInt();                    // try to read an id\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + id);\n \n       Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n       param.readFields(dis);        \n         \n       Call call \u003d new Call(id, param, this);\n       callQueue.put(call);              // queue the call; maybe blocked here\n+      incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n\n      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n      param.readFields(dis);        \n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "src/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[buf-byte[]]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/02/10 5:30 PM",
          "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "27/01/10 12:08 AM",
          "commitNameOld": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
          "commitAuthorOld": "Owen O\u0027Malley",
          "daysBetweenCommits": 6.72,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,15 @@\n-    private void processData() throws  IOException, InterruptedException {\n+    private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(data.array()));\n+        new DataInputStream(new ByteArrayInputStream(buf));\n       int id \u003d dis.readInt();                    // try to read an id\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + id);\n \n       Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n       param.readFields(dis);        \n         \n       Call call \u003d new Call(id, param, this);\n       callQueue.put(call);              // queue the call; maybe blocked here\n+      incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n\n      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n      param.readFields(dis);        \n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "src/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,14 @@\n+    private void processData() throws  IOException, InterruptedException {\n+      DataInputStream dis \u003d\n+        new DataInputStream(new ByteArrayInputStream(data.array()));\n+      int id \u003d dis.readInt();                    // try to read an id\n+        \n+      if (LOG.isDebugEnabled())\n+        LOG.debug(\" got #\" + id);\n+\n+      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);           // read param\n+      param.readFields(dis);        \n+        \n+      Call call \u003d new Call(id, param, this);\n+      callQueue.put(call);              // queue the call; maybe blocked here\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData() throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(data.array()));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n\n      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);           // read param\n      param.readFields(dis);        \n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}