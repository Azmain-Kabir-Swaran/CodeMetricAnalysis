{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirRenameOp.java",
  "functionName": "unprotectedRenameTo",
  "functionId": "unprotectedRenameTo___fsd-FSDirectory__srcIIP-INodesInPath(modifiers-final)__dstIIP-INodesInPath(modifiers-final)__timestamp-long__collectedBlocks-BlocksMapUpdateInfo__options-Options.Rename",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
  "functionStartLine": 356,
  "functionEndLine": 471,
  "numCommitsSeen": 275,
  "timeTaken": 9958,
  "changeHistory": [
    "de6b8b0c0b1933aab2af3e8adc50a2091d428238",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
    "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc",
    "5f34402adae191232fe78e62990396ca07f314bb",
    "f62237bc2f02afe11ce185e13aa51a60b5960037",
    "1af8c148626effe1b41fc536019fd3349f485d59",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
    "65f2a4ee600dfffa5203450261da3c1989de25a9",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
    "5776a41da08af653206bb94d7c76c9c4dcce059a",
    "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
    "4a3161182905afaf450a60d02528161ed1f97471",
    "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8"
  ],
  "changeHistoryShort": {
    "de6b8b0c0b1933aab2af3e8adc50a2091d428238": "Ybodychange",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": "Ybodychange",
    "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc": "Ybodychange",
    "5f34402adae191232fe78e62990396ca07f314bb": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "f62237bc2f02afe11ce185e13aa51a60b5960037": "Ybodychange",
    "1af8c148626effe1b41fc536019fd3349f485d59": "Ybodychange",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": "Ybodychange",
    "65f2a4ee600dfffa5203450261da3c1989de25a9": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yparameterchange,Ybodychange)",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": "Ybodychange",
    "5776a41da08af653206bb94d7c76c9c4dcce059a": "Ybodychange",
    "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2": "Ybodychange",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "4a3161182905afaf450a60d02528161ed1f97471": "Ybodychange",
    "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "de6b8b0c0b1933aab2af3e8adc50a2091d428238": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14925. Rename operation should check nest snapshot (#1670)\n\nIf the src directory or any of its descendant is snapshottable\r\nand the dst directory or any of its ancestors is snapshottable,\r\nwe consider this as nested snapshot, which should be denied.\r\n\r\nReviewed-by: Shashikant Banerjee \u003cshashikant@apache.org\u003e",
      "commitDate": "01/11/19 4:37 PM",
      "commitName": "de6b8b0c0b1933aab2af3e8adc50a2091d428238",
      "commitAuthor": "Zhao Junwang",
      "commitDateOld": "03/09/19 9:29 AM",
      "commitNameOld": "3c117163a343d7da7ac958e22789b461c24efa5f",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 59.3,
      "commitsBetweenForRepo": 392,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,116 @@\n   static RenameResult unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String src \u003d srcIIP.getPath();\n     final String dst \u003d dstIIP.getPath();\n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n-    validateRenameSource(fsd, srcIIP);\n+    List\u003cINodeDirectory\u003e srcSnapshottableDirs \u003d new ArrayList\u003c\u003e();\n+    validateRenameSource(fsd, srcIIP, srcSnapshottableDirs);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n     final INode dstInode \u003d dstIIP.getLastINode();\n-    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n+    List\u003cINodeDirectory\u003e dstSnapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n-      FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, snapshottableDirs);\n+      FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, dstSnapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n+    validateNestSnapshot(fsd, src,\n+            dstParent.asDirectory(), srcSnapshottableDirs);\n+\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n       if (renamedIIP !\u003d null) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n-        if (snapshottableDirs.size() \u003e 0) {\n+        if (dstSnapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n-          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n+          fsd.getFSNamesystem().removeSnapshottableDirs(dstSnapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n         return createRenameResult(\n             fsd, renamedIIP, filesDeleted, collectedBlocks);\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String src \u003d srcIIP.getPath();\n    final String dst \u003d dstIIP.getPath();\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    List\u003cINodeDirectory\u003e srcSnapshottableDirs \u003d new ArrayList\u003c\u003e();\n    validateRenameSource(fsd, srcIIP, srcSnapshottableDirs);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e dstSnapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, dstSnapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    validateNestSnapshot(fsd, src,\n            dstParent.asDirectory(), srcSnapshottableDirs);\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n      if (renamedIIP !\u003d null) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (dstSnapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(dstSnapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return createRenameResult(\n            fsd, renamedIIP, filesDeleted, collectedBlocks);\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
      "commitDate": "06/10/16 1:11 PM",
      "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/10/16 1:05 PM",
      "commitNameOld": "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,112 @@\n   static RenameResult unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String src \u003d srcIIP.getPath();\n     final String dst \u003d dstIIP.getPath();\n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(fsd, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n-    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n       if (renamedIIP !\u003d null) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n         return createRenameResult(\n             fsd, renamedIIP, filesDeleted, collectedBlocks);\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String src \u003d srcIIP.getPath();\n    final String dst \u003d dstIIP.getPath();\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(fsd, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n      if (renamedIIP !\u003d null) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return createRenameResult(\n            fsd, renamedIIP, filesDeleted, collectedBlocks);\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10956. Remove rename/delete performance penalty when not using snapshots. Contributed by Daryn Sharp.\n",
      "commitDate": "04/10/16 1:05 PM",
      "commitName": "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "28/09/16 3:57 PM",
      "commitNameOld": "5f34402adae191232fe78e62990396ca07f314bb",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 5.88,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,112 @@\n   static RenameResult unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String src \u003d srcIIP.getPath();\n     final String dst \u003d dstIIP.getPath();\n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n-    validateRenameSource(srcIIP);\n+    validateRenameSource(fsd, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n-      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n+      FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n       if (renamedIIP !\u003d null) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n         return createRenameResult(\n             fsd, renamedIIP, filesDeleted, collectedBlocks);\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String src \u003d srcIIP.getPath();\n    final String dst \u003d dstIIP.getPath();\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(fsd, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(fsd, dstIIP, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n      if (renamedIIP !\u003d null) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return createRenameResult(\n            fsd, renamedIIP, filesDeleted, collectedBlocks);\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5f34402adae191232fe78e62990396ca07f314bb": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
      "commitDate": "28/09/16 3:57 PM",
      "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,108 +1,112 @@\n-  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n+    final String src \u003d srcIIP.getPath();\n+    final String dst \u003d dstIIP.getPath();\n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n-    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n-      if (tx.addSourceToDestination()) {\n+      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n+      if (renamedIIP !\u003d null) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n-        return filesDeleted;\n+        return createRenameResult(\n+            fsd, renamedIIP, filesDeleted, collectedBlocks);\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String src \u003d srcIIP.getPath();\n    final String dst \u003d dstIIP.getPath();\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n      if (renamedIIP !\u003d null) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return createRenameResult(\n            fsd, renamedIIP, filesDeleted, collectedBlocks);\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, src-String, dst-String, srcIIP-INodesInPath(modifiers-final), dstIIP-INodesInPath(modifiers-final), timestamp-long, collectedBlocks-BlocksMapUpdateInfo, options-Options.Rename]",
            "newValue": "[fsd-FSDirectory, srcIIP-INodesInPath(modifiers-final), dstIIP-INodesInPath(modifiers-final), timestamp-long, collectedBlocks-BlocksMapUpdateInfo, options-Options.Rename]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,108 +1,112 @@\n-  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n+    final String src \u003d srcIIP.getPath();\n+    final String dst \u003d dstIIP.getPath();\n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n-    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n-      if (tx.addSourceToDestination()) {\n+      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n+      if (renamedIIP !\u003d null) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n-        return filesDeleted;\n+        return createRenameResult(\n+            fsd, renamedIIP, filesDeleted, collectedBlocks);\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String src \u003d srcIIP.getPath();\n    final String dst \u003d dstIIP.getPath();\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n      if (renamedIIP !\u003d null) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return createRenameResult(\n            fsd, renamedIIP, filesDeleted, collectedBlocks);\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "RenameResult"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,108 +1,112 @@\n-  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n+    final String src \u003d srcIIP.getPath();\n+    final String dst \u003d dstIIP.getPath();\n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n-    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n-      if (tx.addSourceToDestination()) {\n+      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n+      if (renamedIIP !\u003d null) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n-        return filesDeleted;\n+        return createRenameResult(\n+            fsd, renamedIIP, filesDeleted, collectedBlocks);\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static RenameResult unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String src \u003d srcIIP.getPath();\n    final String dst \u003d dstIIP.getPath();\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      INodesInPath renamedIIP \u003d tx.addSourceToDestination();\n      if (renamedIIP !\u003d null) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return createRenameResult(\n            fsd, renamedIIP, filesDeleted, collectedBlocks);\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "f62237bc2f02afe11ce185e13aa51a60b5960037": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
      "commitDate": "09/09/15 11:07 PM",
      "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "01/09/15 2:30 PM",
      "commitNameOld": "ab56fcdb1219d03713b408dd3a95d7405635254d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 8.36,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,108 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    fsd.ecZoneManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "1af8c148626effe1b41fc536019fd3349f485d59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7839. Erasure coding: implement facilities in NameNode to create and manage EC zones. Contributed by Zhe Zhang\n",
      "commitDate": "26/05/15 11:55 AM",
      "commitName": "1af8c148626effe1b41fc536019fd3349f485d59",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "13/05/15 9:50 PM",
      "commitNameOld": "b2c85db86c9a62b0a03ee87547265077f664970a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 12.59,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,109 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ecZoneManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree(bsps);\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n         tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    fsd.ecZoneManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "02/02/15 4:32 PM",
      "commitNameOld": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 8.76,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,108 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n+    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists, remove it\n         removedNum \u003d tx.removeDst();\n         if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n-            filesDeleted \u003d tx.cleanDst(collectedBlocks);\n+            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n-        tx.updateQuotasInSourceTree();\n+        tx.updateQuotasInSourceTree(bsps);\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n       if (undoRemoveDst) { // Rename failed - restore dst\n-        tx.restoreDst();\n+        tx.restoreDst(bsps);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    BlockStoragePolicySuite bsps \u003d fsd.getBlockStoragePolicySuite();\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(bsps, collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree(bsps);\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst(bsps);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
      "commitDate": "22/12/14 11:19 PM",
      "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/12/14 11:25 AM",
      "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,107 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n-    if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n-          \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n-          error);\n-      throw new IOException(error);\n-    }\n+    tx.removeSrc();\n \n     boolean undoRemoveDst \u003d false;\n-    INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n-      if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n-          removedDst \u003d tx.dstIIP.getLastINode();\n+      if (dstInode !\u003d null) { // dst exists, remove it\n+        removedNum \u003d tx.removeDst();\n+        if (removedNum !\u003d -1) {\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n-        if (removedDst !\u003d null) {\n+        if (undoRemoveDst) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n-            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003c\u003e();\n-            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks,\n-                  removedINodes);\n-              filesDeleted \u003d true;\n-            } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(\n-                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n-                  collectedBlocks, removedINodes, true)\n-                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n-            }\n-            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n-                removedINodes, false);\n+            filesDeleted \u003d tx.cleanDst(collectedBlocks);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n-\n-      if (undoRemoveDst) {\n-        // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026\n-            dstParent.asDirectory().isWithSnapshot()) {\n-          dstParent.asDirectory().undoRename4DstParent(removedDst,\n-              dstIIP.getLatestSnapshotId());\n-        } else {\n-          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n-        }\n-        if (removedDst.isReference()) {\n-          final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n-              removedDstRef.getReferredINode().asReference();\n-          wc.addReference(removedDstRef);\n-        }\n+      if (undoRemoveDst) { // Rename failed - restore dst\n+        tx.restoreDst();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    tx.removeSrc();\n\n    boolean undoRemoveDst \u003d false;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists, remove it\n        removedNum \u003d tx.removeDst();\n        if (removedNum !\u003d -1) {\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (undoRemoveDst) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            filesDeleted \u003d tx.cleanDst(collectedBlocks);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n      if (undoRemoveDst) { // Rename failed - restore dst\n        tx.restoreDst();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "65f2a4ee600dfffa5203450261da3c1989de25a9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7543. Avoid path resolution when getting FileStatus for audit logs. Contributed by Haohui Mai.\n",
      "commitDate": "18/12/14 11:25 AM",
      "commitName": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "17/12/14 10:32 AM",
      "commitNameOld": "4281c96e24739387bc2084f819c0176d0051a5e9",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,141 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n-    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n+    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst +\n           \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n           removedDst \u003d tx.dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n-            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n+            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003c\u003e();\n             if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks,\n                   removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(\n                   Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n                   collectedBlocks, removedINodes, true)\n                   .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026\n             dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n               removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n          removedDst \u003d tx.dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003c\u003e();\n            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "11/12/14 12:36 PM",
          "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,143 +1,141 @@\n-  static boolean unprotectedRenameTo(\n-      FSDirectory fsd, String src, String dst, long timestamp,\n+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n-    validateRenameSource(src, srcIIP);\n+    validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst +\n           \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n-          removedDst \u003d dstIIP.getLastINode();\n+        if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n+          removedDst \u003d tx.dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n+            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks,\n                   removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(\n-                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n                   collectedBlocks, removedINodes, true)\n                   .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026\n             dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n               removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n          removedDst \u003d tx.dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, src-String, dst-String, timestamp-long, collectedBlocks-BlocksMapUpdateInfo, options-Options.Rename]",
            "newValue": "[fsd-FSDirectory, src-String, dst-String, srcIIP-INodesInPath(modifiers-final), dstIIP-INodesInPath(modifiers-final), timestamp-long, collectedBlocks-BlocksMapUpdateInfo, options-Options.Rename]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "11/12/14 12:36 PM",
          "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,143 +1,141 @@\n-  static boolean unprotectedRenameTo(\n-      FSDirectory fsd, String src, String dst, long timestamp,\n+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n-    validateRenameSource(src, srcIIP);\n+    validateRenameSource(srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst +\n           \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n-          removedDst \u003d dstIIP.getLastINode();\n+        if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n+          removedDst \u003d tx.dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n+            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks,\n                   removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(\n-                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n                   collectedBlocks, removedINodes, true)\n                   .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026\n             dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n               removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(tx.dstIIP)) !\u003d -1) {\n          removedDst \u003d tx.dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7515. Fix new findbugs warnings in hadoop-hdfs. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 12:36 PM",
      "commitName": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "09/12/14 11:37 AM",
      "commitNameOld": "5776a41da08af653206bb94d7c76c9c4dcce059a",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,143 @@\n   static boolean unprotectedRenameTo(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst +\n           \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks,\n                   removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(\n                   Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                   collectedBlocks, removedINodes, true)\n                   .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026\n             dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n-        assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n               removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5776a41da08af653206bb94d7c76c9c4dcce059a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7498. Simplify the logic in INodesInPath. Contributed by Jing Zhao.\n",
      "commitDate": "09/12/14 11:37 AM",
      "commitName": "5776a41da08af653206bb94d7c76c9c4dcce059a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/12/14 2:17 PM",
      "commitNameOld": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   static boolean unprotectedRenameTo(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n-    if (dstIIP.getINodes().length \u003d\u003d 1) {\n+    if (dstIIP.length() \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n-    verifyQuotaForRename(fsd, srcIIP.getINodes(), dstIIP.getINodes());\n+    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n+    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst +\n           \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks,\n                   removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(\n                   Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                   collectedBlocks, removedINodes, true)\n                   .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026\n             dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n               removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.length() \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7468. Moving verify* functions to corresponding classes. Contributed by Li Lu.\n",
      "commitDate": "04/12/14 2:09 PM",
      "commitName": "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/12/14 9:48 PM",
      "commitNameOld": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.68,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   static boolean unprotectedRenameTo(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     boolean overwrite \u003d options !\u003d null\n         \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\"The source \" + src +\n           \" and destination \" + dst + \" are the same\");\n     }\n     validateDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n-    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n+    verifyQuotaForRename(fsd, srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst +\n           \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           error);\n       throw new IOException(error);\n     }\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks,\n                   removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(\n                   Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                   collectedBlocks, removedINodes, true)\n                   .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026\n             dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n               removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "01/12/14 9:48 PM",
      "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,144 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n-      throws FileAlreadyExistsException, FileNotFoundException, \n-      ParentNotDirectoryException, QuotaExceededException, \n-      UnresolvedLinkException, IOException {\n-    assert hasWriteLock();\n-    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n-            (Rename.OVERWRITE);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    boolean overwrite \u003d options !\u003d null\n+        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n-      throw new FileAlreadyExistsException(\n-          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+      throw new FileAlreadyExistsException(\"The source \" + src +\n+          \" and destination \" + dst + \" are the same\");\n     }\n-    validateRenameDestination(src, dst, srcInode);\n+    validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n-      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n+      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d removeLastINode(srcIIP);\n+    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst\n-          + \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n+          \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n-    \n+\n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n+        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n-              + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+              + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              removedDst.destroyAndCollectBlocks(collectedBlocks,\n+                  removedINodes);\n               filesDeleted \u003d true;\n             } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+              filesDeleted \u003d removedDst.cleanSubtree(\n+                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  collectedBlocks, removedINodes, true)\n+                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n-            getFSNamesystem().removePathAndBlocks(src, null, \n+            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n-          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+        if (dstParent.isDirectory() \u0026\u0026\n+            dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n+        assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d \n-              (WithCount) removedDstRef.getReferredINode().asReference();\n+          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n+              removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        + \"failed to rename \" + src + \" to \" + dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
            "oldMethodName": "unprotectedRenameTo",
            "newMethodName": "unprotectedRenameTo"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,144 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n-      throws FileAlreadyExistsException, FileNotFoundException, \n-      ParentNotDirectoryException, QuotaExceededException, \n-      UnresolvedLinkException, IOException {\n-    assert hasWriteLock();\n-    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n-            (Rename.OVERWRITE);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    boolean overwrite \u003d options !\u003d null\n+        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n-      throw new FileAlreadyExistsException(\n-          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+      throw new FileAlreadyExistsException(\"The source \" + src +\n+          \" and destination \" + dst + \" are the same\");\n     }\n-    validateRenameDestination(src, dst, srcInode);\n+    validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n-      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n+      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d removeLastINode(srcIIP);\n+    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst\n-          + \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n+          \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n-    \n+\n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n+        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n-              + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+              + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              removedDst.destroyAndCollectBlocks(collectedBlocks,\n+                  removedINodes);\n               filesDeleted \u003d true;\n             } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+              filesDeleted \u003d removedDst.cleanSubtree(\n+                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  collectedBlocks, removedINodes, true)\n+                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n-            getFSNamesystem().removePathAndBlocks(src, null, \n+            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n-          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+        if (dstParent.isDirectory() \u0026\u0026\n+            dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n+        assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d \n-              (WithCount) removedDstRef.getReferredINode().asReference();\n+          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n+              removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        + \"failed to rename \" + src + \" to \" + dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,144 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n-      throws FileAlreadyExistsException, FileNotFoundException, \n-      ParentNotDirectoryException, QuotaExceededException, \n-      UnresolvedLinkException, IOException {\n-    assert hasWriteLock();\n-    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n-            (Rename.OVERWRITE);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    boolean overwrite \u003d options !\u003d null\n+        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n-      throw new FileAlreadyExistsException(\n-          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+      throw new FileAlreadyExistsException(\"The source \" + src +\n+          \" and destination \" + dst + \" are the same\");\n     }\n-    validateRenameDestination(src, dst, srcInode);\n+    validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n-      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n+      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d removeLastINode(srcIIP);\n+    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst\n-          + \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n+          \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n-    \n+\n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n+        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n-              + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+              + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              removedDst.destroyAndCollectBlocks(collectedBlocks,\n+                  removedINodes);\n               filesDeleted \u003d true;\n             } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+              filesDeleted \u003d removedDst.cleanSubtree(\n+                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  collectedBlocks, removedINodes, true)\n+                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n-            getFSNamesystem().removePathAndBlocks(src, null, \n+            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n-          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+        if (dstParent.isDirectory() \u0026\u0026\n+            dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n+        assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d \n-              (WithCount) removedDstRef.getReferredINode().asReference();\n+          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n+              removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        + \"failed to rename \" + src + \" to \" + dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[FileAlreadyExistsException, FileNotFoundException, ParentNotDirectoryException, QuotaExceededException, UnresolvedLinkException, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,144 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n-      throws FileAlreadyExistsException, FileNotFoundException, \n-      ParentNotDirectoryException, QuotaExceededException, \n-      UnresolvedLinkException, IOException {\n-    assert hasWriteLock();\n-    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n-            (Rename.OVERWRITE);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    boolean overwrite \u003d options !\u003d null\n+        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n-      throw new FileAlreadyExistsException(\n-          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+      throw new FileAlreadyExistsException(\"The source \" + src +\n+          \" and destination \" + dst + \" are the same\");\n     }\n-    validateRenameDestination(src, dst, srcInode);\n+    validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n-      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n+      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d removeLastINode(srcIIP);\n+    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst\n-          + \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n+          \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n-    \n+\n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n+        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n-              + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+              + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              removedDst.destroyAndCollectBlocks(collectedBlocks,\n+                  removedINodes);\n               filesDeleted \u003d true;\n             } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+              filesDeleted \u003d removedDst.cleanSubtree(\n+                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  collectedBlocks, removedINodes, true)\n+                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n-            getFSNamesystem().removePathAndBlocks(src, null, \n+            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n-          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+        if (dstParent.isDirectory() \u0026\u0026\n+            dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n+        assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d \n-              (WithCount) removedDstRef.getReferredINode().asReference();\n+          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n+              removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        + \"failed to rename \" + src + \" to \" + dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,144 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n-      throws FileAlreadyExistsException, FileNotFoundException, \n-      ParentNotDirectoryException, QuotaExceededException, \n-      UnresolvedLinkException, IOException {\n-    assert hasWriteLock();\n-    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n-            (Rename.OVERWRITE);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    boolean overwrite \u003d options !\u003d null\n+        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n \n     final String error;\n-    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n-      throw new FileAlreadyExistsException(\n-          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+      throw new FileAlreadyExistsException(\"The source \" + src +\n+          \" and destination \" + dst + \" are the same\");\n     }\n-    validateRenameDestination(src, dst, srcInode);\n+    validateDestination(src, dst, srcInode);\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n-      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n+      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n       FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d removeLastINode(srcIIP);\n+    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst\n-          + \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n+          \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          error);\n       throw new IOException(error);\n     }\n-    \n+\n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n+        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n-              + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+              + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              removedDst.destroyAndCollectBlocks(collectedBlocks,\n+                  removedINodes);\n               filesDeleted \u003d true;\n             } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+              filesDeleted \u003d removedDst.cleanSubtree(\n+                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n+                  collectedBlocks, removedINodes, true)\n+                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n-            getFSNamesystem().removePathAndBlocks(src, null, \n+            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n-          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+        if (dstParent.isDirectory() \u0026\u0026\n+            dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n-          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n+        assert removedDst !\u003d null;\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d \n-              (WithCount) removedDstRef.getReferredINode().asReference();\n+          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n+              removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        + \"failed to rename \" + src + \" to \" + dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    boolean overwrite \u003d options !\u003d null\n        \u0026\u0026 Arrays.asList(options).contains(Options.Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\"The source \" + src +\n          \" and destination \" + dst + \" are the same\");\n    }\n    validateDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst +\n          \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          error);\n      throw new IOException(error);\n    }\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d fsd.removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \"\n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks,\n                  removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(\n                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),\n                  collectedBlocks, removedINodes, true)\n                  .get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            fsd.getFSNamesystem().removePathAndBlocks(src, null,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          fsd.getFSNamesystem().removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026\n            dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        assert removedDst !\u003d null;\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d (INodeReference.WithCount)\n              removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, dst-String, timestamp-long, collectedBlocks-BlocksMapUpdateInfo, options-Options.Rename]",
            "newValue": "[fsd-FSDirectory, src-String, dst-String, timestamp-long, collectedBlocks-BlocksMapUpdateInfo, options-Options.Rename]"
          }
        }
      ]
    },
    "4a3161182905afaf450a60d02528161ed1f97471": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7440. Consolidate snapshot related operations in a single class. Contributed by Haohui Mai.\n",
      "commitDate": "25/11/14 9:04 PM",
      "commitName": "4a3161182905afaf450a60d02528161ed1f97471",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/11/14 3:42 PM",
      "commitNameOld": "8caf537afabc70b0c74e0a29aea0cc2935ecb162",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.22,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,142 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n       throws FileAlreadyExistsException, FileNotFoundException, \n       ParentNotDirectoryException, QuotaExceededException, \n       UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n             (Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     validateRenameDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n-      checkSnapshot(dstInode, snapshottableDirs);\n+      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n               removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n               filesDeleted \u003d true;\n             } else {\n               filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                   dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                   true).get(Quota.NAMESPACE) \u003e\u003d 0;\n             }\n             getFSNamesystem().removePathAndBlocks(src, null, \n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n      throws FileAlreadyExistsException, FileNotFoundException, \n      ParentNotDirectoryException, QuotaExceededException, \n      UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      FSDirSnapshotOp.checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            getFSNamesystem().removePathAndBlocks(src, null, \n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2975. Rename with overwrite flag true can make NameNode to stuck in safemode on NN (crash + restart). (Yi Liu via umamahesh)\n",
      "commitDate": "03/09/14 6:23 AM",
      "commitName": "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,142 @@\n+  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n+      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n+      throws FileAlreadyExistsException, FileNotFoundException, \n+      ParentNotDirectoryException, QuotaExceededException, \n+      UnresolvedLinkException, IOException {\n+    assert hasWriteLock();\n+    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n+            (Rename.OVERWRITE);\n+\n+    final String error;\n+    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+    final INode srcInode \u003d srcIIP.getLastINode();\n+    validateRenameSource(src, srcIIP);\n+\n+    // validate the destination\n+    if (dst.equals(src)) {\n+      throw new FileAlreadyExistsException(\n+          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+    }\n+    validateRenameDestination(src, dst, srcInode);\n+\n+    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    if (dstIIP.getINodes().length \u003d\u003d 1) {\n+      error \u003d \"rename destination cannot be the root\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new IOException(error);\n+    }\n+\n+    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    final INode dstInode \u003d dstIIP.getLastINode();\n+    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n+    if (dstInode !\u003d null) { // Destination exists\n+      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n+      checkSnapshot(dstInode, snapshottableDirs);\n+    }\n+\n+    INode dstParent \u003d dstIIP.getINode(-2);\n+    if (dstParent \u003d\u003d null) {\n+      error \u003d \"rename destination parent \" + dst + \" not found.\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new FileNotFoundException(error);\n+    }\n+    if (!dstParent.isDirectory()) {\n+      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new ParentNotDirectoryException(error);\n+    }\n+\n+    // Ensure dst has quota to accommodate rename\n+    verifyFsLimitsForRename(srcIIP, dstIIP);\n+    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+\n+    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+\n+    boolean undoRemoveSrc \u003d true;\n+    final long removedSrc \u003d removeLastINode(srcIIP);\n+    if (removedSrc \u003d\u003d -1) {\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst\n+          + \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new IOException(error);\n+    }\n+    \n+    boolean undoRemoveDst \u003d false;\n+    INode removedDst \u003d null;\n+    long removedNum \u003d 0;\n+    try {\n+      if (dstInode !\u003d null) { // dst exists remove it\n+        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n+          removedDst \u003d dstIIP.getLastINode();\n+          undoRemoveDst \u003d true;\n+        }\n+      }\n+\n+      // add src as dst to complete rename\n+      if (tx.addSourceToDestination()) {\n+        undoRemoveSrc \u003d false;\n+        if (NameNode.stateChangeLog.isDebugEnabled()) {\n+          NameNode.stateChangeLog.debug(\n+              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n+              + \" is renamed to \" + dst);\n+        }\n+\n+        tx.updateMtimeAndLease(timestamp);\n+\n+        // Collect the blocks and remove the lease for previous dst\n+        boolean filesDeleted \u003d false;\n+        if (removedDst !\u003d null) {\n+          undoRemoveDst \u003d false;\n+          if (removedNum \u003e 0) {\n+            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n+            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n+              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              filesDeleted \u003d true;\n+            } else {\n+              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n+                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n+                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+            }\n+            getFSNamesystem().removePathAndBlocks(src, null, \n+                removedINodes, false);\n+          }\n+        }\n+\n+        if (snapshottableDirs.size() \u003e 0) {\n+          // There are snapshottable directories (without snapshots) to be\n+          // deleted. Need to update the SnapshotManager.\n+          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+        }\n+\n+        tx.updateQuotasInSourceTree();\n+        return filesDeleted;\n+      }\n+    } finally {\n+      if (undoRemoveSrc) {\n+        tx.restoreSource();\n+      }\n+\n+      if (undoRemoveDst) {\n+        // Rename failed - restore dst\n+        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+          dstParent.asDirectory().undoRename4DstParent(removedDst,\n+              dstIIP.getLatestSnapshotId());\n+        } else {\n+          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+        }\n+        if (removedDst.isReference()) {\n+          final INodeReference removedDstRef \u003d removedDst.asReference();\n+          final INodeReference.WithCount wc \u003d \n+              (WithCount) removedDstRef.getReferredINode().asReference();\n+          wc.addReference(removedDstRef);\n+        }\n+      }\n+    }\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+        + \"failed to rename \" + src + \" to \" + dst);\n+    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options) \n      throws FileAlreadyExistsException, FileNotFoundException, \n      ParentNotDirectoryException, QuotaExceededException, \n      UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            getFSNamesystem().removePathAndBlocks(src, null, \n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
    }
  }
}