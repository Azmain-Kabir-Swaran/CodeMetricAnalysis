{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineDataManager.java",
  "functionName": "postEntities",
  "functionId": "postEntities___entities-TimelineEntities__callerUGI-UserGroupInformation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java",
  "functionStartLine": 317,
  "functionEndLine": 327,
  "numCommitsSeen": 15,
  "timeTaken": 1744,
  "changeHistory": [
    "4c659ddbf7629aae92e66a5b54893e9c1c68dfb0",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
    "4a114dd67aae83e5bb2d65470166de954acf36a2",
    "f5b19bed7d71979dc8685b03152188902b6e45e9",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
    "e91d099c4a4182c25c1a19237aff28e4d1bc1357"
  ],
  "changeHistoryShort": {
    "4c659ddbf7629aae92e66a5b54893e9c1c68dfb0": "Ybodychange",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Ybodychange",
    "4a114dd67aae83e5bb2d65470166de954acf36a2": "Ybodychange",
    "f5b19bed7d71979dc8685b03152188902b6e45e9": "Ybodychange",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": "Ybodychange",
    "e91d099c4a4182c25c1a19237aff28e4d1bc1357": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4c659ddbf7629aae92e66a5b54893e9c1c68dfb0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3360. Add JMX metrics to TimelineDataManager (Jason Lowe via jeagles)\n",
      "commitDate": "24/06/15 2:16 PM",
      "commitName": "4c659ddbf7629aae92e66a5b54893e9c1c68dfb0",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "07/05/15 10:01 AM",
      "commitNameOld": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 48.18,
      "commitsBetweenForRepo": 425,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,11 @@\n   public TimelinePutResponse postEntities(\n       TimelineEntities entities,\n       UserGroupInformation callerUGI) throws YarnException, IOException {\n-    if (entities \u003d\u003d null) {\n-      return new TimelinePutResponse();\n+    long startTime \u003d Time.monotonicNow();\n+    metrics.incrPostEntitiesOps();\n+    try {\n+      return doPostEntities(entities, callerUGI);\n+    } finally {\n+      metrics.addPostEntitiesTime(Time.monotonicNow() - startTime);\n     }\n-    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n-    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n-        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n-    for (TimelineEntity entity : entities.getEntities()) {\n-\n-      // if the domain id is not specified, the entity will be put into\n-      // the default domain\n-      if (entity.getDomainId() \u003d\u003d null ||\n-          entity.getDomainId().length() \u003d\u003d 0) {\n-        entity.setDomainId(DEFAULT_DOMAIN_ID);\n-      }\n-\n-      // check if there is existing entity\n-      TimelineEntity existingEntity \u003d null;\n-      try {\n-        existingEntity \u003d\n-            store.getEntity(entity.getEntityId(), entity.getEntityType(),\n-                EnumSet.of(Field.PRIMARY_FILTERS));\n-        if (existingEntity !\u003d null) {\n-          addDefaultDomainIdIfAbsent(existingEntity);\n-          if (!existingEntity.getDomainId().equals(entity.getDomainId())) {\n-            throw new YarnException(\"The domain of the timeline entity \"\n-              + \"{ id: \" + entity.getEntityId() + \", type: \"\n-              + entity.getEntityType() + \" } is not allowed to be changed from \"\n-              + existingEntity.getDomainId() + \" to \" + entity.getDomainId());\n-          }\n-        }\n-        if (!timelineACLsManager.checkAccess(\n-            callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n-          throw new YarnException(callerUGI\n-              + \" is not allowed to put the timeline entity \"\n-              + \"{ id: \" + entity.getEntityId() + \", type: \"\n-              + entity.getEntityType() + \" } into the domain \"\n-              + entity.getDomainId() + \".\");\n-        }\n-      } catch (Exception e) {\n-        // Skip the entity which already exists and was put by others\n-        LOG.warn(\"Skip the timeline entity: { id: \" + entity.getEntityId()\n-            + \", type: \"+ entity.getEntityType() + \" }\", e);\n-        TimelinePutResponse.TimelinePutError error \u003d\n-            new TimelinePutResponse.TimelinePutError();\n-        error.setEntityId(entity.getEntityId());\n-        error.setEntityType(entity.getEntityType());\n-        error.setErrorCode(\n-            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n-        errors.add(error);\n-        continue;\n-      }\n-\n-      entitiesToPut.addEntity(entity);\n-    }\n-\n-    TimelinePutResponse response \u003d store.put(entitiesToPut);\n-    // add the errors of timeline system filter key conflict\n-    response.addErrors(errors);\n-    return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse postEntities(\n      TimelineEntities entities,\n      UserGroupInformation callerUGI) throws YarnException, IOException {\n    long startTime \u003d Time.monotonicNow();\n    metrics.incrPostEntitiesOps();\n    try {\n      return doPostEntities(entities, callerUGI);\n    } finally {\n      metrics.addPostEntitiesTime(Time.monotonicNow() - startTime);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java",
      "extendedDetails": {}
    },
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "13/03/15 10:04 AM",
      "commitNameOld": "8180e676abb2bb500a48b3a0c0809d2a807ab235",
      "commitAuthorOld": "Jonathan Eagles",
      "daysBetweenCommits": 55.0,
      "commitsBetweenForRepo": 503,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,63 @@\n   public TimelinePutResponse postEntities(\n       TimelineEntities entities,\n       UserGroupInformation callerUGI) throws YarnException, IOException {\n     if (entities \u003d\u003d null) {\n       return new TimelinePutResponse();\n     }\n-    List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n     TimelineEntities entitiesToPut \u003d new TimelineEntities();\n     List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n         new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n     for (TimelineEntity entity : entities.getEntities()) {\n-      EntityIdentifier entityID \u003d\n-          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n \n       // if the domain id is not specified, the entity will be put into\n       // the default domain\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         entity.setDomainId(DEFAULT_DOMAIN_ID);\n       }\n \n       // check if there is existing entity\n       TimelineEntity existingEntity \u003d null;\n       try {\n         existingEntity \u003d\n-            store.getEntity(entityID.getId(), entityID.getType(),\n+            store.getEntity(entity.getEntityId(), entity.getEntityType(),\n                 EnumSet.of(Field.PRIMARY_FILTERS));\n         if (existingEntity !\u003d null) {\n           addDefaultDomainIdIfAbsent(existingEntity);\n           if (!existingEntity.getDomainId().equals(entity.getDomainId())) {\n             throw new YarnException(\"The domain of the timeline entity \"\n-              + entityID + \" is not allowed to be changed.\");\n+              + \"{ id: \" + entity.getEntityId() + \", type: \"\n+              + entity.getEntityType() + \" } is not allowed to be changed from \"\n+              + existingEntity.getDomainId() + \" to \" + entity.getDomainId());\n           }\n         }\n         if (!timelineACLsManager.checkAccess(\n             callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n           throw new YarnException(callerUGI\n-              + \" is not allowed to put the timeline entity \" + entityID\n-              + \" into the domain \" + entity.getDomainId() + \".\");\n+              + \" is not allowed to put the timeline entity \"\n+              + \"{ id: \" + entity.getEntityId() + \", type: \"\n+              + entity.getEntityType() + \" } into the domain \"\n+              + entity.getDomainId() + \".\");\n         }\n       } catch (Exception e) {\n         // Skip the entity which already exists and was put by others\n-        LOG.error(\"Skip the timeline entity: \" + entityID, e);\n+        LOG.warn(\"Skip the timeline entity: { id: \" + entity.getEntityId()\n+            + \", type: \"+ entity.getEntityType() + \" }\", e);\n         TimelinePutResponse.TimelinePutError error \u003d\n             new TimelinePutResponse.TimelinePutError();\n-        error.setEntityId(entityID.getId());\n-        error.setEntityType(entityID.getType());\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n         error.setErrorCode(\n             TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n         errors.add(error);\n         continue;\n       }\n \n-      entityIDs.add(entityID);\n       entitiesToPut.addEntity(entity);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n-            + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n-      }\n     }\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n-    }\n+\n     TimelinePutResponse response \u003d store.put(entitiesToPut);\n     // add the errors of timeline system filter key conflict\n     response.addErrors(errors);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse postEntities(\n      TimelineEntities entities,\n      UserGroupInformation callerUGI) throws YarnException, IOException {\n    if (entities \u003d\u003d null) {\n      return new TimelinePutResponse();\n    }\n    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n    for (TimelineEntity entity : entities.getEntities()) {\n\n      // if the domain id is not specified, the entity will be put into\n      // the default domain\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        entity.setDomainId(DEFAULT_DOMAIN_ID);\n      }\n\n      // check if there is existing entity\n      TimelineEntity existingEntity \u003d null;\n      try {\n        existingEntity \u003d\n            store.getEntity(entity.getEntityId(), entity.getEntityType(),\n                EnumSet.of(Field.PRIMARY_FILTERS));\n        if (existingEntity !\u003d null) {\n          addDefaultDomainIdIfAbsent(existingEntity);\n          if (!existingEntity.getDomainId().equals(entity.getDomainId())) {\n            throw new YarnException(\"The domain of the timeline entity \"\n              + \"{ id: \" + entity.getEntityId() + \", type: \"\n              + entity.getEntityType() + \" } is not allowed to be changed from \"\n              + existingEntity.getDomainId() + \" to \" + entity.getDomainId());\n          }\n        }\n        if (!timelineACLsManager.checkAccess(\n            callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n          throw new YarnException(callerUGI\n              + \" is not allowed to put the timeline entity \"\n              + \"{ id: \" + entity.getEntityId() + \", type: \"\n              + entity.getEntityType() + \" } into the domain \"\n              + entity.getDomainId() + \".\");\n        }\n      } catch (Exception e) {\n        // Skip the entity which already exists and was put by others\n        LOG.warn(\"Skip the timeline entity: { id: \" + entity.getEntityId()\n            + \", type: \"+ entity.getEntityType() + \" }\", e);\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n        errors.add(error);\n        continue;\n      }\n\n      entitiesToPut.addEntity(entity);\n    }\n\n    TimelinePutResponse response \u003d store.put(entitiesToPut);\n    // add the errors of timeline system filter key conflict\n    response.addErrors(errors);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java",
      "extendedDetails": {}
    },
    "4a114dd67aae83e5bb2d65470166de954acf36a2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2819. NPE in ATS Timeline Domains when upgrading from 2.4 to 2.6. Contributed by Zhijie Shen\n",
      "commitDate": "07/11/14 4:11 PM",
      "commitName": "4a114dd67aae83e5bb2d65470166de954acf36a2",
      "commitAuthor": "Xuan",
      "commitDateOld": "06/11/14 11:48 AM",
      "commitNameOld": "f5b19bed7d71979dc8685b03152188902b6e45e9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.18,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   public TimelinePutResponse postEntities(\n       TimelineEntities entities,\n       UserGroupInformation callerUGI) throws YarnException, IOException {\n     if (entities \u003d\u003d null) {\n       return new TimelinePutResponse();\n     }\n     List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n     TimelineEntities entitiesToPut \u003d new TimelineEntities();\n     List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n         new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n     for (TimelineEntity entity : entities.getEntities()) {\n       EntityIdentifier entityID \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n \n       // if the domain id is not specified, the entity will be put into\n       // the default domain\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         entity.setDomainId(DEFAULT_DOMAIN_ID);\n       }\n \n       // check if there is existing entity\n       TimelineEntity existingEntity \u003d null;\n       try {\n         existingEntity \u003d\n             store.getEntity(entityID.getId(), entityID.getType(),\n                 EnumSet.of(Field.PRIMARY_FILTERS));\n-        if (existingEntity !\u003d null \u0026\u0026\n-            !existingEntity.getDomainId().equals(entity.getDomainId())) {\n-          throw new YarnException(\"The domain of the timeline entity \"\n-            + entityID + \" is not allowed to be changed.\");\n+        if (existingEntity !\u003d null) {\n+          addDefaultDomainIdIfAbsent(existingEntity);\n+          if (!existingEntity.getDomainId().equals(entity.getDomainId())) {\n+            throw new YarnException(\"The domain of the timeline entity \"\n+              + entityID + \" is not allowed to be changed.\");\n+          }\n         }\n         if (!timelineACLsManager.checkAccess(\n             callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n           throw new YarnException(callerUGI\n               + \" is not allowed to put the timeline entity \" + entityID\n               + \" into the domain \" + entity.getDomainId() + \".\");\n         }\n       } catch (Exception e) {\n         // Skip the entity which already exists and was put by others\n         LOG.error(\"Skip the timeline entity: \" + entityID, e);\n         TimelinePutResponse.TimelinePutError error \u003d\n             new TimelinePutResponse.TimelinePutError();\n         error.setEntityId(entityID.getId());\n         error.setEntityType(entityID.getType());\n         error.setErrorCode(\n             TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n         errors.add(error);\n         continue;\n       }\n \n       entityIDs.add(entityID);\n       entitiesToPut.addEntity(entity);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n             + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n     }\n     TimelinePutResponse response \u003d store.put(entitiesToPut);\n     // add the errors of timeline system filter key conflict\n     response.addErrors(errors);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse postEntities(\n      TimelineEntities entities,\n      UserGroupInformation callerUGI) throws YarnException, IOException {\n    if (entities \u003d\u003d null) {\n      return new TimelinePutResponse();\n    }\n    List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n    for (TimelineEntity entity : entities.getEntities()) {\n      EntityIdentifier entityID \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n\n      // if the domain id is not specified, the entity will be put into\n      // the default domain\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        entity.setDomainId(DEFAULT_DOMAIN_ID);\n      }\n\n      // check if there is existing entity\n      TimelineEntity existingEntity \u003d null;\n      try {\n        existingEntity \u003d\n            store.getEntity(entityID.getId(), entityID.getType(),\n                EnumSet.of(Field.PRIMARY_FILTERS));\n        if (existingEntity !\u003d null) {\n          addDefaultDomainIdIfAbsent(existingEntity);\n          if (!existingEntity.getDomainId().equals(entity.getDomainId())) {\n            throw new YarnException(\"The domain of the timeline entity \"\n              + entityID + \" is not allowed to be changed.\");\n          }\n        }\n        if (!timelineACLsManager.checkAccess(\n            callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n          throw new YarnException(callerUGI\n              + \" is not allowed to put the timeline entity \" + entityID\n              + \" into the domain \" + entity.getDomainId() + \".\");\n        }\n      } catch (Exception e) {\n        // Skip the entity which already exists and was put by others\n        LOG.error(\"Skip the timeline entity: \" + entityID, e);\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entityID.getId());\n        error.setEntityType(entityID.getType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n        errors.add(error);\n        continue;\n      }\n\n      entityIDs.add(entityID);\n      entitiesToPut.addEntity(entity);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n            + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n    }\n    TimelinePutResponse response \u003d store.put(entitiesToPut);\n    // add the errors of timeline system filter key conflict\n    response.addErrors(errors);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java",
      "extendedDetails": {}
    },
    "f5b19bed7d71979dc8685b03152188902b6e45e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2818. Removed the now unnecessary user entity injection from Timeline service given we now have domains. Contributed by Zhijie Shen.\n",
      "commitDate": "06/11/14 11:48 AM",
      "commitName": "f5b19bed7d71979dc8685b03152188902b6e45e9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/10/14 4:37 PM",
      "commitNameOld": "233d446be1bc1bc77c7c1c45386086a732897afd",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 20.84,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,66 @@\n   public TimelinePutResponse postEntities(\n       TimelineEntities entities,\n       UserGroupInformation callerUGI) throws YarnException, IOException {\n     if (entities \u003d\u003d null) {\n       return new TimelinePutResponse();\n     }\n     List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n     TimelineEntities entitiesToPut \u003d new TimelineEntities();\n     List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n         new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n     for (TimelineEntity entity : entities.getEntities()) {\n       EntityIdentifier entityID \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n \n       // if the domain id is not specified, the entity will be put into\n       // the default domain\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         entity.setDomainId(DEFAULT_DOMAIN_ID);\n       }\n \n       // check if there is existing entity\n       TimelineEntity existingEntity \u003d null;\n       try {\n         existingEntity \u003d\n             store.getEntity(entityID.getId(), entityID.getType(),\n                 EnumSet.of(Field.PRIMARY_FILTERS));\n         if (existingEntity !\u003d null \u0026\u0026\n             !existingEntity.getDomainId().equals(entity.getDomainId())) {\n           throw new YarnException(\"The domain of the timeline entity \"\n             + entityID + \" is not allowed to be changed.\");\n         }\n         if (!timelineACLsManager.checkAccess(\n             callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n           throw new YarnException(callerUGI\n               + \" is not allowed to put the timeline entity \" + entityID\n               + \" into the domain \" + entity.getDomainId() + \".\");\n         }\n       } catch (Exception e) {\n         // Skip the entity which already exists and was put by others\n-        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n-            + e.getMessage());\n+        LOG.error(\"Skip the timeline entity: \" + entityID, e);\n         TimelinePutResponse.TimelinePutError error \u003d\n             new TimelinePutResponse.TimelinePutError();\n         error.setEntityId(entityID.getId());\n         error.setEntityType(entityID.getType());\n         error.setErrorCode(\n             TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n         errors.add(error);\n         continue;\n       }\n \n-      // inject owner information for the access check if this is the first\n-      // time to post the entity, in case it\u0027s the admin who is updating\n-      // the timeline data.\n-      try {\n-        if (existingEntity \u003d\u003d null) {\n-          injectOwnerInfo(entity, callerUGI.getShortUserName());\n-        }\n-      } catch (YarnException e) {\n-        // Skip the entity which messes up the primary filter and record the\n-        // error\n-        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n-            + e.getMessage());\n-        TimelinePutResponse.TimelinePutError error \u003d\n-            new TimelinePutResponse.TimelinePutError();\n-        error.setEntityId(entityID.getId());\n-        error.setEntityType(entityID.getType());\n-        error.setErrorCode(\n-            TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n-        errors.add(error);\n-        continue;\n-      }\n-\n       entityIDs.add(entityID);\n       entitiesToPut.addEntity(entity);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n             + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n     }\n     TimelinePutResponse response \u003d store.put(entitiesToPut);\n     // add the errors of timeline system filter key conflict\n     response.addErrors(errors);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse postEntities(\n      TimelineEntities entities,\n      UserGroupInformation callerUGI) throws YarnException, IOException {\n    if (entities \u003d\u003d null) {\n      return new TimelinePutResponse();\n    }\n    List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n    for (TimelineEntity entity : entities.getEntities()) {\n      EntityIdentifier entityID \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n\n      // if the domain id is not specified, the entity will be put into\n      // the default domain\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        entity.setDomainId(DEFAULT_DOMAIN_ID);\n      }\n\n      // check if there is existing entity\n      TimelineEntity existingEntity \u003d null;\n      try {\n        existingEntity \u003d\n            store.getEntity(entityID.getId(), entityID.getType(),\n                EnumSet.of(Field.PRIMARY_FILTERS));\n        if (existingEntity !\u003d null \u0026\u0026\n            !existingEntity.getDomainId().equals(entity.getDomainId())) {\n          throw new YarnException(\"The domain of the timeline entity \"\n            + entityID + \" is not allowed to be changed.\");\n        }\n        if (!timelineACLsManager.checkAccess(\n            callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n          throw new YarnException(callerUGI\n              + \" is not allowed to put the timeline entity \" + entityID\n              + \" into the domain \" + entity.getDomainId() + \".\");\n        }\n      } catch (Exception e) {\n        // Skip the entity which already exists and was put by others\n        LOG.error(\"Skip the timeline entity: \" + entityID, e);\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entityID.getId());\n        error.setEntityType(entityID.getType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n        errors.add(error);\n        continue;\n      }\n\n      entityIDs.add(entityID);\n      entitiesToPut.addEntity(entity);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n            + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n    }\n    TimelinePutResponse response \u003d store.put(entitiesToPut);\n    // add the errors of timeline system filter key conflict\n    response.addErrors(errors);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java",
      "extendedDetails": {}
    },
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
      "commitDate": "01/10/14 5:52 PM",
      "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/09/14 11:27 AM",
      "commitNameOld": "d78b452a4f413c6931a494c33df0666ce9b44973",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.27,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,89 @@\n   public TimelinePutResponse postEntities(\n       TimelineEntities entities,\n       UserGroupInformation callerUGI) throws YarnException, IOException {\n     if (entities \u003d\u003d null) {\n       return new TimelinePutResponse();\n     }\n     List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n     TimelineEntities entitiesToPut \u003d new TimelineEntities();\n     List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n         new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n     for (TimelineEntity entity : entities.getEntities()) {\n       EntityIdentifier entityID \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n \n+      // if the domain id is not specified, the entity will be put into\n+      // the default domain\n+      if (entity.getDomainId() \u003d\u003d null ||\n+          entity.getDomainId().length() \u003d\u003d 0) {\n+        entity.setDomainId(DEFAULT_DOMAIN_ID);\n+      }\n+\n       // check if there is existing entity\n       TimelineEntity existingEntity \u003d null;\n       try {\n         existingEntity \u003d\n             store.getEntity(entityID.getId(), entityID.getType(),\n                 EnumSet.of(Field.PRIMARY_FILTERS));\n-        if (existingEntity !\u003d null\n-            \u0026\u0026 !timelineACLsManager.checkAccess(callerUGI, existingEntity)) {\n-          throw new YarnException(\"The timeline entity \" + entityID\n-              + \" was not put by \" + callerUGI + \" before\");\n+        if (existingEntity !\u003d null \u0026\u0026\n+            !existingEntity.getDomainId().equals(entity.getDomainId())) {\n+          throw new YarnException(\"The domain of the timeline entity \"\n+            + entityID + \" is not allowed to be changed.\");\n+        }\n+        if (!timelineACLsManager.checkAccess(\n+            callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n+          throw new YarnException(callerUGI\n+              + \" is not allowed to put the timeline entity \" + entityID\n+              + \" into the domain \" + entity.getDomainId() + \".\");\n         }\n       } catch (Exception e) {\n         // Skip the entity which already exists and was put by others\n         LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n             + e.getMessage());\n         TimelinePutResponse.TimelinePutError error \u003d\n             new TimelinePutResponse.TimelinePutError();\n         error.setEntityId(entityID.getId());\n         error.setEntityType(entityID.getType());\n         error.setErrorCode(\n             TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n         errors.add(error);\n         continue;\n       }\n \n       // inject owner information for the access check if this is the first\n       // time to post the entity, in case it\u0027s the admin who is updating\n       // the timeline data.\n       try {\n         if (existingEntity \u003d\u003d null) {\n           injectOwnerInfo(entity, callerUGI.getShortUserName());\n         }\n       } catch (YarnException e) {\n         // Skip the entity which messes up the primary filter and record the\n         // error\n         LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n             + e.getMessage());\n         TimelinePutResponse.TimelinePutError error \u003d\n             new TimelinePutResponse.TimelinePutError();\n         error.setEntityId(entityID.getId());\n         error.setEntityType(entityID.getType());\n         error.setErrorCode(\n             TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n         errors.add(error);\n         continue;\n       }\n \n       entityIDs.add(entityID);\n       entitiesToPut.addEntity(entity);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n             + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n     }\n     TimelinePutResponse response \u003d store.put(entitiesToPut);\n     // add the errors of timeline system filter key conflict\n     response.addErrors(errors);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse postEntities(\n      TimelineEntities entities,\n      UserGroupInformation callerUGI) throws YarnException, IOException {\n    if (entities \u003d\u003d null) {\n      return new TimelinePutResponse();\n    }\n    List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n    for (TimelineEntity entity : entities.getEntities()) {\n      EntityIdentifier entityID \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n\n      // if the domain id is not specified, the entity will be put into\n      // the default domain\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        entity.setDomainId(DEFAULT_DOMAIN_ID);\n      }\n\n      // check if there is existing entity\n      TimelineEntity existingEntity \u003d null;\n      try {\n        existingEntity \u003d\n            store.getEntity(entityID.getId(), entityID.getType(),\n                EnumSet.of(Field.PRIMARY_FILTERS));\n        if (existingEntity !\u003d null \u0026\u0026\n            !existingEntity.getDomainId().equals(entity.getDomainId())) {\n          throw new YarnException(\"The domain of the timeline entity \"\n            + entityID + \" is not allowed to be changed.\");\n        }\n        if (!timelineACLsManager.checkAccess(\n            callerUGI, ApplicationAccessType.MODIFY_APP, entity)) {\n          throw new YarnException(callerUGI\n              + \" is not allowed to put the timeline entity \" + entityID\n              + \" into the domain \" + entity.getDomainId() + \".\");\n        }\n      } catch (Exception e) {\n        // Skip the entity which already exists and was put by others\n        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n            + e.getMessage());\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entityID.getId());\n        error.setEntityType(entityID.getType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n        errors.add(error);\n        continue;\n      }\n\n      // inject owner information for the access check if this is the first\n      // time to post the entity, in case it\u0027s the admin who is updating\n      // the timeline data.\n      try {\n        if (existingEntity \u003d\u003d null) {\n          injectOwnerInfo(entity, callerUGI.getShortUserName());\n        }\n      } catch (YarnException e) {\n        // Skip the entity which messes up the primary filter and record the\n        // error\n        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n            + e.getMessage());\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entityID.getId());\n        error.setEntityType(entityID.getType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n        errors.add(error);\n        continue;\n      }\n\n      entityIDs.add(entityID);\n      entitiesToPut.addEntity(entity);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n            + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n    }\n    TimelinePutResponse response \u003d store.put(entitiesToPut);\n    // add the errors of timeline system filter key conflict\n    response.addErrors(errors);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java",
      "extendedDetails": {}
    },
    "e91d099c4a4182c25c1a19237aff28e4d1bc1357": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2302. Refactor TimelineWebServices. (Contributed by Zhijie Shen)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/08/14 12:21 AM",
      "commitName": "e91d099c4a4182c25c1a19237aff28e4d1bc1357",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,76 @@\n+  public TimelinePutResponse postEntities(\n+      TimelineEntities entities,\n+      UserGroupInformation callerUGI) throws YarnException, IOException {\n+    if (entities \u003d\u003d null) {\n+      return new TimelinePutResponse();\n+    }\n+    List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n+    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n+    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n+        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n+    for (TimelineEntity entity : entities.getEntities()) {\n+      EntityIdentifier entityID \u003d\n+          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n+\n+      // check if there is existing entity\n+      TimelineEntity existingEntity \u003d null;\n+      try {\n+        existingEntity \u003d\n+            store.getEntity(entityID.getId(), entityID.getType(),\n+                EnumSet.of(Field.PRIMARY_FILTERS));\n+        if (existingEntity !\u003d null\n+            \u0026\u0026 !timelineACLsManager.checkAccess(callerUGI, existingEntity)) {\n+          throw new YarnException(\"The timeline entity \" + entityID\n+              + \" was not put by \" + callerUGI + \" before\");\n+        }\n+      } catch (Exception e) {\n+        // Skip the entity which already exists and was put by others\n+        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n+            + e.getMessage());\n+        TimelinePutResponse.TimelinePutError error \u003d\n+            new TimelinePutResponse.TimelinePutError();\n+        error.setEntityId(entityID.getId());\n+        error.setEntityType(entityID.getType());\n+        error.setErrorCode(\n+            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n+        errors.add(error);\n+        continue;\n+      }\n+\n+      // inject owner information for the access check if this is the first\n+      // time to post the entity, in case it\u0027s the admin who is updating\n+      // the timeline data.\n+      try {\n+        if (existingEntity \u003d\u003d null) {\n+          injectOwnerInfo(entity, callerUGI.getShortUserName());\n+        }\n+      } catch (YarnException e) {\n+        // Skip the entity which messes up the primary filter and record the\n+        // error\n+        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n+            + e.getMessage());\n+        TimelinePutResponse.TimelinePutError error \u003d\n+            new TimelinePutResponse.TimelinePutError();\n+        error.setEntityId(entityID.getId());\n+        error.setEntityType(entityID.getType());\n+        error.setErrorCode(\n+            TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n+        errors.add(error);\n+        continue;\n+      }\n+\n+      entityIDs.add(entityID);\n+      entitiesToPut.addEntity(entity);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n+            + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n+      }\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n+    }\n+    TimelinePutResponse response \u003d store.put(entitiesToPut);\n+    // add the errors of timeline system filter key conflict\n+    response.addErrors(errors);\n+    return response;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse postEntities(\n      TimelineEntities entities,\n      UserGroupInformation callerUGI) throws YarnException, IOException {\n    if (entities \u003d\u003d null) {\n      return new TimelinePutResponse();\n    }\n    List\u003cEntityIdentifier\u003e entityIDs \u003d new ArrayList\u003cEntityIdentifier\u003e();\n    TimelineEntities entitiesToPut \u003d new TimelineEntities();\n    List\u003cTimelinePutResponse.TimelinePutError\u003e errors \u003d\n        new ArrayList\u003cTimelinePutResponse.TimelinePutError\u003e();\n    for (TimelineEntity entity : entities.getEntities()) {\n      EntityIdentifier entityID \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n\n      // check if there is existing entity\n      TimelineEntity existingEntity \u003d null;\n      try {\n        existingEntity \u003d\n            store.getEntity(entityID.getId(), entityID.getType(),\n                EnumSet.of(Field.PRIMARY_FILTERS));\n        if (existingEntity !\u003d null\n            \u0026\u0026 !timelineACLsManager.checkAccess(callerUGI, existingEntity)) {\n          throw new YarnException(\"The timeline entity \" + entityID\n              + \" was not put by \" + callerUGI + \" before\");\n        }\n      } catch (Exception e) {\n        // Skip the entity which already exists and was put by others\n        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n            + e.getMessage());\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entityID.getId());\n        error.setEntityType(entityID.getType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n        errors.add(error);\n        continue;\n      }\n\n      // inject owner information for the access check if this is the first\n      // time to post the entity, in case it\u0027s the admin who is updating\n      // the timeline data.\n      try {\n        if (existingEntity \u003d\u003d null) {\n          injectOwnerInfo(entity, callerUGI.getShortUserName());\n        }\n      } catch (YarnException e) {\n        // Skip the entity which messes up the primary filter and record the\n        // error\n        LOG.error(\"Skip the timeline entity: \" + entityID + \", because \"\n            + e.getMessage());\n        TimelinePutResponse.TimelinePutError error \u003d\n            new TimelinePutResponse.TimelinePutError();\n        error.setEntityId(entityID.getId());\n        error.setEntityType(entityID.getType());\n        error.setErrorCode(\n            TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n        errors.add(error);\n        continue;\n      }\n\n      entityIDs.add(entityID);\n      entitiesToPut.addEntity(entity);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n            + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n    }\n    TimelinePutResponse response \u003d store.put(entitiesToPut);\n    // add the errors of timeline system filter key conflict\n    response.addErrors(errors);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/TimelineDataManager.java"
    }
  }
}