{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DomainSocketWatcher.java",
  "functionName": "sendCallback",
  "functionId": "sendCallback___caller-String__entries-TreeMap__Integer,Entry____fdSet-FdSet__fd-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
  "functionStartLine": 386,
  "functionEndLine": 424,
  "numCommitsSeen": 15,
  "timeTaken": 1544,
  "changeHistory": [
    "ccaf036662e22da14583942054898c99fa51dae5",
    "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5",
    "140246bad816ae7bf06eda193cc624e1e62923e0"
  ],
  "changeHistoryShort": {
    "ccaf036662e22da14583942054898c99fa51dae5": "Ybodychange",
    "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5": "Ymultichange(Yreturntypechange,Ybodychange)",
    "140246bad816ae7bf06eda193cc624e1e62923e0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ccaf036662e22da14583942054898c99fa51dae5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14539. Move commons logging APIs over to slf4j in hadoop-common. Contributed by Wenxin He.\n",
      "commitDate": "17/07/17 9:32 PM",
      "commitName": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "23/03/17 1:34 PM",
      "commitNameOld": "d35e79abc2fee7153a6168e6088f100de59d8c81",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 116.33,
      "commitsBetweenForRepo": 606,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   private boolean sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n       FdSet fdSet, int fd) {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n     }\n     Entry entry \u003d entries.get(fd);\n     Preconditions.checkNotNull(entry,\n         this + \": fdSet contained \" + fd + \", which we were \" +\n         \"not tracking.\");\n     DomainSocket sock \u003d entry.getDomainSocket();\n     if (entry.getHandler().handle(sock)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n             \" at the request of the handler.\");\n       }\n       if (toRemove.remove(fd) !\u003d null) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n             fd  + \" in toRemove.\");\n         }\n       }\n       try {\n         sock.refCount.unreferenceCheckClosed();\n       } catch (IOException e) {\n         Preconditions.checkArgument(false,\n             this + \": file descriptor \" + sock.fd + \" was closed while \" +\n             \"still in the poll(2) loop.\");\n       }\n-      IOUtils.cleanup(LOG, sock);\n+      IOUtils.cleanupWithLogger(LOG, sock);\n       fdSet.remove(fd);\n       return true;\n     } else {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n             \"closing fd \" + fd);\n       }\n       return false;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n      FdSet fdSet, int fd) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n    }\n    Entry entry \u003d entries.get(fd);\n    Preconditions.checkNotNull(entry,\n        this + \": fdSet contained \" + fd + \", which we were \" +\n        \"not tracking.\");\n    DomainSocket sock \u003d entry.getDomainSocket();\n    if (entry.getHandler().handle(sock)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n            \" at the request of the handler.\");\n      }\n      if (toRemove.remove(fd) !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n            fd  + \" in toRemove.\");\n        }\n      }\n      try {\n        sock.refCount.unreferenceCheckClosed();\n      } catch (IOException e) {\n        Preconditions.checkArgument(false,\n            this + \": file descriptor \" + sock.fd + \" was closed while \" +\n            \"still in the poll(2) loop.\");\n      }\n      IOUtils.cleanupWithLogger(LOG, sock);\n      fdSet.remove(fd);\n      return true;\n    } else {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n            \"closing fd \" + fd);\n      }\n      return false;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-11604. Prevent ConcurrentModificationException while closing domain sockets during shutdown of DomainSocketWatcher thread. Contributed by Chris Nauroth.\n",
      "commitDate": "20/02/15 1:07 PM",
      "commitName": "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-11604. Prevent ConcurrentModificationException while closing domain sockets during shutdown of DomainSocketWatcher thread. Contributed by Chris Nauroth.\n",
          "commitDate": "20/02/15 1:07 PM",
          "commitName": "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "01/12/14 11:42 AM",
          "commitNameOld": "86e3993def01223f92b8d1dd35f6c1f8ab6033f5",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 81.06,
          "commitsBetweenForRepo": 633,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,39 @@\n-  private void sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n+  private boolean sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n       FdSet fdSet, int fd) {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n     }\n     Entry entry \u003d entries.get(fd);\n     Preconditions.checkNotNull(entry,\n         this + \": fdSet contained \" + fd + \", which we were \" +\n         \"not tracking.\");\n     DomainSocket sock \u003d entry.getDomainSocket();\n     if (entry.getHandler().handle(sock)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n             \" at the request of the handler.\");\n       }\n       if (toRemove.remove(fd) !\u003d null) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n             fd  + \" in toRemove.\");\n         }\n       }\n       try {\n         sock.refCount.unreferenceCheckClosed();\n       } catch (IOException e) {\n         Preconditions.checkArgument(false,\n             this + \": file descriptor \" + sock.fd + \" was closed while \" +\n             \"still in the poll(2) loop.\");\n       }\n       IOUtils.cleanup(LOG, sock);\n-      entries.remove(fd);\n       fdSet.remove(fd);\n+      return true;\n     } else {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n             \"closing fd \" + fd);\n       }\n+      return false;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n      FdSet fdSet, int fd) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n    }\n    Entry entry \u003d entries.get(fd);\n    Preconditions.checkNotNull(entry,\n        this + \": fdSet contained \" + fd + \", which we were \" +\n        \"not tracking.\");\n    DomainSocket sock \u003d entry.getDomainSocket();\n    if (entry.getHandler().handle(sock)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n            \" at the request of the handler.\");\n      }\n      if (toRemove.remove(fd) !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n            fd  + \" in toRemove.\");\n        }\n      }\n      try {\n        sock.refCount.unreferenceCheckClosed();\n      } catch (IOException e) {\n        Preconditions.checkArgument(false,\n            this + \": file descriptor \" + sock.fd + \" was closed while \" +\n            \"still in the poll(2) loop.\");\n      }\n      IOUtils.cleanup(LOG, sock);\n      fdSet.remove(fd);\n      return true;\n    } else {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n            \"closing fd \" + fd);\n      }\n      return false;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11604. Prevent ConcurrentModificationException while closing domain sockets during shutdown of DomainSocketWatcher thread. Contributed by Chris Nauroth.\n",
          "commitDate": "20/02/15 1:07 PM",
          "commitName": "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "01/12/14 11:42 AM",
          "commitNameOld": "86e3993def01223f92b8d1dd35f6c1f8ab6033f5",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 81.06,
          "commitsBetweenForRepo": 633,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,39 @@\n-  private void sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n+  private boolean sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n       FdSet fdSet, int fd) {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n     }\n     Entry entry \u003d entries.get(fd);\n     Preconditions.checkNotNull(entry,\n         this + \": fdSet contained \" + fd + \", which we were \" +\n         \"not tracking.\");\n     DomainSocket sock \u003d entry.getDomainSocket();\n     if (entry.getHandler().handle(sock)) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n             \" at the request of the handler.\");\n       }\n       if (toRemove.remove(fd) !\u003d null) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n             fd  + \" in toRemove.\");\n         }\n       }\n       try {\n         sock.refCount.unreferenceCheckClosed();\n       } catch (IOException e) {\n         Preconditions.checkArgument(false,\n             this + \": file descriptor \" + sock.fd + \" was closed while \" +\n             \"still in the poll(2) loop.\");\n       }\n       IOUtils.cleanup(LOG, sock);\n-      entries.remove(fd);\n       fdSet.remove(fd);\n+      return true;\n     } else {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n             \"closing fd \" + fd);\n       }\n+      return false;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n      FdSet fdSet, int fd) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n    }\n    Entry entry \u003d entries.get(fd);\n    Preconditions.checkNotNull(entry,\n        this + \": fdSet contained \" + fd + \", which we were \" +\n        \"not tracking.\");\n    DomainSocket sock \u003d entry.getDomainSocket();\n    if (entry.getHandler().handle(sock)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n            \" at the request of the handler.\");\n      }\n      if (toRemove.remove(fd) !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n            fd  + \" in toRemove.\");\n        }\n      }\n      try {\n        sock.refCount.unreferenceCheckClosed();\n      } catch (IOException e) {\n        Preconditions.checkArgument(false,\n            this + \": file descriptor \" + sock.fd + \" was closed while \" +\n            \"still in the poll(2) loop.\");\n      }\n      IOUtils.cleanup(LOG, sock);\n      fdSet.remove(fd);\n      return true;\n    } else {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n            \"closing fd \" + fd);\n      }\n      return false;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
          "extendedDetails": {}
        }
      ]
    },
    "140246bad816ae7bf06eda193cc624e1e62923e0": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5746.  Add ShortCircuitSharedMemorySegment (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1563362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 6:25 PM",
      "commitName": "140246bad816ae7bf06eda193cc624e1e62923e0",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,38 @@\n+  private void sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n+      FdSet fdSet, int fd) {\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n+    }\n+    Entry entry \u003d entries.get(fd);\n+    Preconditions.checkNotNull(entry,\n+        this + \": fdSet contained \" + fd + \", which we were \" +\n+        \"not tracking.\");\n+    DomainSocket sock \u003d entry.getDomainSocket();\n+    if (entry.getHandler().handle(sock)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n+            \" at the request of the handler.\");\n+      }\n+      if (toRemove.remove(fd) !\u003d null) {\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n+            fd  + \" in toRemove.\");\n+        }\n+      }\n+      try {\n+        sock.refCount.unreferenceCheckClosed();\n+      } catch (IOException e) {\n+        Preconditions.checkArgument(false,\n+            this + \": file descriptor \" + sock.fd + \" was closed while \" +\n+            \"still in the poll(2) loop.\");\n+      }\n+      IOUtils.cleanup(LOG, sock);\n+      entries.remove(fd);\n+      fdSet.remove(fd);\n+    } else {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n+            \"closing fd \" + fd);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void sendCallback(String caller, TreeMap\u003cInteger, Entry\u003e entries,\n      FdSet fdSet, int fd) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": \" + caller + \" starting sendCallback for fd \" + fd);\n    }\n    Entry entry \u003d entries.get(fd);\n    Preconditions.checkNotNull(entry,\n        this + \": fdSet contained \" + fd + \", which we were \" +\n        \"not tracking.\");\n    DomainSocket sock \u003d entry.getDomainSocket();\n    if (entry.getHandler().handle(sock)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": closing fd \" + fd +\n            \" at the request of the handler.\");\n      }\n      if (toRemove.remove(fd) !\u003d null) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \": \" + caller + \" : sendCallback processed fd \" +\n            fd  + \" in toRemove.\");\n        }\n      }\n      try {\n        sock.refCount.unreferenceCheckClosed();\n      } catch (IOException e) {\n        Preconditions.checkArgument(false,\n            this + \": file descriptor \" + sock.fd + \" was closed while \" +\n            \"still in the poll(2) loop.\");\n      }\n      IOUtils.cleanup(LOG, sock);\n      entries.remove(fd);\n      fdSet.remove(fd);\n    } else {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + caller + \": sendCallback not \" +\n            \"closing fd \" + fd);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java"
    }
  }
}