{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QuorumJournalManager.java",
  "functionName": "recoverUnclosedSegment",
  "functionId": "recoverUnclosedSegment___segmentTxId-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
  "functionStartLine": 311,
  "functionEndLine": 408,
  "numCommitsSeen": 42,
  "timeTaken": 1770,
  "changeHistory": [
    "663e7484c04c197eed53f10a7808140f1c955277",
    "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
    "8021d9199f278345aca6211f318145342ad036f4",
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
    "f9a0d78ef5889bb1b9510ba15a1a780fcc9560fd",
    "c95a1674b61ef2a6963dc64604986ef90a8c636d",
    "74d4573a23db5586c6e47ff2277aa7c35237da34"
  ],
  "changeHistoryShort": {
    "663e7484c04c197eed53f10a7808140f1c955277": "Ybodychange",
    "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38": "Ybodychange",
    "8021d9199f278345aca6211f318145342ad036f4": "Ybodychange",
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb": "Ybodychange",
    "f9a0d78ef5889bb1b9510ba15a1a780fcc9560fd": "Ybodychange",
    "c95a1674b61ef2a6963dc64604986ef90a8c636d": "Ybodychange",
    "74d4573a23db5586c6e47ff2277aa7c35237da34": "Yintroduced"
  },
  "changeHistoryDetails": {
    "663e7484c04c197eed53f10a7808140f1c955277": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3950. QJM: misc TODO cleanup, improved log messages, etc. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1387704 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/09/12 11:52 AM",
      "commitName": "663e7484c04c197eed53f10a7808140f1c955277",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/09/12 11:31 PM",
      "commitNameOld": "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 8.51,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,98 @@\n   private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n     Preconditions.checkArgument(segmentTxId \u003e 0);\n     LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n         segmentTxId);\n     \n     // Step 1. Prepare recovery\n     QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n         loggers.prepareRecovery(segmentTxId);\n     Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n         loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs,\n             \"prepareRecovery(\" + segmentTxId + \")\");\n     LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n         QuorumCall.mapToString(prepareResponses));\n \n     // Determine the logger who either:\n     // a) Has already accepted a previous proposal that\u0027s higher than any\n     //    other\n     //\n     //  OR, if no such logger exists:\n     //\n     // b) Has the longest log starting at this transaction ID\n     \n     // TODO: we should collect any \"ties\" and pass the URL for all of them\n     // when syncing, so we can tolerate failure during recovery better.\n     Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n         prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n     AsyncLogger bestLogger \u003d bestEntry.getKey();\n     PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n     \n     // Log the above decision, check invariants.\n     if (bestResponse.hasAcceptedInEpoch()) {\n       LOG.info(\"Using already-accepted recovery for segment \" +\n           \"starting at txid \" + segmentTxId + \": \" +\n           bestEntry);\n     } else if (bestResponse.hasSegmentState()) {\n       LOG.info(\"Using longest log: \" + bestEntry);\n     } else {\n       // None of the responses to prepareRecovery() had a segment at the given\n       // txid. This can happen for example in the following situation:\n       // - 3 JNs: JN1, JN2, JN3\n       // - writer starts segment 101 on JN1, then crashes before\n       //   writing to JN2 and JN3\n       // - during newEpoch(), we saw the segment on JN1 and decide to\n       //   recover segment 101\n       // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n       //   neither of which has any entry for this log.\n       // In this case, it is allowed to do nothing for recovery, since the\n       // segment wasn\u0027t started on a quorum of nodes.\n \n       // Sanity check: we should only get here if none of the responses had\n       // a log. This should be a postcondition of the recovery comparator,\n       // but a bug in the comparator might cause us to get here.\n       for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n         assert !resp.hasSegmentState() :\n           \"One of the loggers had a response, but no best logger \" +\n           \"was found.\";\n       }\n \n       LOG.info(\"None of the responders had a log to recover: \" +\n           QuorumCall.mapToString(prepareResponses));\n       return;\n     }\n     \n-    \n-    // TODO: check that md5s match up between any \"tied\" logs\n-    \n     SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n     assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n     \n     // Sanity check: none of the loggers should be aware of a higher\n     // txid than the txid we intend to truncate to\n     for (Map.Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e e :\n          prepareResponses.entrySet()) {\n       AsyncLogger logger \u003d e.getKey();\n       PrepareRecoveryResponseProto resp \u003d e.getValue();\n \n       if (resp.hasLastCommittedTxId() \u0026\u0026\n           resp.getLastCommittedTxId() \u003e logToSync.getEndTxId()) {\n         throw new AssertionError(\"Decided to synchronize log to \" + logToSync +\n             \" but logger \" + logger + \" had seen txid \" +\n             resp.getLastCommittedTxId() + \" committed\");\n       }\n     }\n     \n     URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n     \n     QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n     loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs,\n         \"acceptRecovery(\" + TextFormat.shortDebugString(logToSync) + \")\");\n-    \n-    // TODO:\n-    // we should only try to finalize loggers who successfully synced above\n-    // eg if a logger was down, we don\u0027t want to send the finalize request.\n-    // write a test for this!\n-    \n+\n+    // If one of the loggers above missed the synchronization step above, but\n+    // we send a finalize() here, that\u0027s OK. It validates the log before\n+    // finalizing. Hence, even if it is not \"in sync\", it won\u0027t incorrectly\n+    // finalize.\n     QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n         loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n     loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs,\n         String.format(\"finalizeLogSegment(%s-%s)\",\n             logToSync.getStartTxId(),\n             logToSync.getEndTxId()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs,\n            \"prepareRecovery(\" + segmentTxId + \")\");\n    LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // None of the responses to prepareRecovery() had a segment at the given\n      // txid. This can happen for example in the following situation:\n      // - 3 JNs: JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes before\n      //   writing to JN2 and JN3\n      // - during newEpoch(), we saw the segment on JN1 and decide to\n      //   recover segment 101\n      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // In this case, it is allowed to do nothing for recovery, since the\n      // segment wasn\u0027t started on a quorum of nodes.\n\n      // Sanity check: we should only get here if none of the responses had\n      // a log. This should be a postcondition of the recovery comparator,\n      // but a bug in the comparator might cause us to get here.\n      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n        assert !resp.hasSegmentState() :\n          \"One of the loggers had a response, but no best logger \" +\n          \"was found.\";\n      }\n\n      LOG.info(\"None of the responders had a log to recover: \" +\n          QuorumCall.mapToString(prepareResponses));\n      return;\n    }\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    // Sanity check: none of the loggers should be aware of a higher\n    // txid than the txid we intend to truncate to\n    for (Map.Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e e :\n         prepareResponses.entrySet()) {\n      AsyncLogger logger \u003d e.getKey();\n      PrepareRecoveryResponseProto resp \u003d e.getValue();\n\n      if (resp.hasLastCommittedTxId() \u0026\u0026\n          resp.getLastCommittedTxId() \u003e logToSync.getEndTxId()) {\n        throw new AssertionError(\"Decided to synchronize log to \" + logToSync +\n            \" but logger \" + logger + \" had seen txid \" +\n            resp.getLastCommittedTxId() + \" committed\");\n      }\n    }\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs,\n        \"acceptRecovery(\" + TextFormat.shortDebugString(logToSync) + \")\");\n\n    // If one of the loggers above missed the synchronization step above, but\n    // we send a finalize() here, that\u0027s OK. It validates the log before\n    // finalizing. Hence, even if it is not \"in sync\", it won\u0027t incorrectly\n    // finalize.\n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs,\n        String.format(\"finalizeLogSegment(%s-%s)\",\n            logToSync.getStartTxId(),\n            logToSync.getEndTxId()));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
      "extendedDetails": {}
    },
    "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3906. QJM: quorum timeout on failover with large log segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383251 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/12 11:31 PM",
      "commitName": "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "05/09/12 11:57 PM",
      "commitNameOld": "437948ea1c0c9c61c2b5049b82ffd9525f33be97",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,102 @@\n   private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n     Preconditions.checkArgument(segmentTxId \u003e 0);\n     LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n         segmentTxId);\n     \n     // Step 1. Prepare recovery\n     QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n         loggers.prepareRecovery(segmentTxId);\n     Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n-        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n+        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs,\n+            \"prepareRecovery(\" + segmentTxId + \")\");\n     LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n         QuorumCall.mapToString(prepareResponses));\n \n     // Determine the logger who either:\n     // a) Has already accepted a previous proposal that\u0027s higher than any\n     //    other\n     //\n     //  OR, if no such logger exists:\n     //\n     // b) Has the longest log starting at this transaction ID\n     \n     // TODO: we should collect any \"ties\" and pass the URL for all of them\n     // when syncing, so we can tolerate failure during recovery better.\n     Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n         prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n     AsyncLogger bestLogger \u003d bestEntry.getKey();\n     PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n     \n     // Log the above decision, check invariants.\n     if (bestResponse.hasAcceptedInEpoch()) {\n       LOG.info(\"Using already-accepted recovery for segment \" +\n           \"starting at txid \" + segmentTxId + \": \" +\n           bestEntry);\n     } else if (bestResponse.hasSegmentState()) {\n       LOG.info(\"Using longest log: \" + bestEntry);\n     } else {\n       // None of the responses to prepareRecovery() had a segment at the given\n       // txid. This can happen for example in the following situation:\n       // - 3 JNs: JN1, JN2, JN3\n       // - writer starts segment 101 on JN1, then crashes before\n       //   writing to JN2 and JN3\n       // - during newEpoch(), we saw the segment on JN1 and decide to\n       //   recover segment 101\n       // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n       //   neither of which has any entry for this log.\n       // In this case, it is allowed to do nothing for recovery, since the\n       // segment wasn\u0027t started on a quorum of nodes.\n \n       // Sanity check: we should only get here if none of the responses had\n       // a log. This should be a postcondition of the recovery comparator,\n       // but a bug in the comparator might cause us to get here.\n       for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n         assert !resp.hasSegmentState() :\n           \"One of the loggers had a response, but no best logger \" +\n           \"was found.\";\n       }\n \n       LOG.info(\"None of the responders had a log to recover: \" +\n           QuorumCall.mapToString(prepareResponses));\n       return;\n     }\n     \n     \n     // TODO: check that md5s match up between any \"tied\" logs\n     \n     SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n     assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n     \n     // Sanity check: none of the loggers should be aware of a higher\n     // txid than the txid we intend to truncate to\n     for (Map.Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e e :\n          prepareResponses.entrySet()) {\n       AsyncLogger logger \u003d e.getKey();\n       PrepareRecoveryResponseProto resp \u003d e.getValue();\n \n       if (resp.hasLastCommittedTxId() \u0026\u0026\n           resp.getLastCommittedTxId() \u003e logToSync.getEndTxId()) {\n         throw new AssertionError(\"Decided to synchronize log to \" + logToSync +\n             \" but logger \" + logger + \" had seen txid \" +\n             resp.getLastCommittedTxId() + \" committed\");\n       }\n     }\n     \n     URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n     \n     QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n-    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n+    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs,\n+        \"acceptRecovery(\" + TextFormat.shortDebugString(logToSync) + \")\");\n     \n     // TODO:\n     // we should only try to finalize loggers who successfully synced above\n     // eg if a logger was down, we don\u0027t want to send the finalize request.\n     // write a test for this!\n     \n     QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n         loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n-    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n+    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs,\n+        String.format(\"finalizeLogSegment(%s-%s)\",\n+            logToSync.getStartTxId(),\n+            logToSync.getEndTxId()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs,\n            \"prepareRecovery(\" + segmentTxId + \")\");\n    LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // None of the responses to prepareRecovery() had a segment at the given\n      // txid. This can happen for example in the following situation:\n      // - 3 JNs: JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes before\n      //   writing to JN2 and JN3\n      // - during newEpoch(), we saw the segment on JN1 and decide to\n      //   recover segment 101\n      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // In this case, it is allowed to do nothing for recovery, since the\n      // segment wasn\u0027t started on a quorum of nodes.\n\n      // Sanity check: we should only get here if none of the responses had\n      // a log. This should be a postcondition of the recovery comparator,\n      // but a bug in the comparator might cause us to get here.\n      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n        assert !resp.hasSegmentState() :\n          \"One of the loggers had a response, but no best logger \" +\n          \"was found.\";\n      }\n\n      LOG.info(\"None of the responders had a log to recover: \" +\n          QuorumCall.mapToString(prepareResponses));\n      return;\n    }\n    \n    \n    // TODO: check that md5s match up between any \"tied\" logs\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    // Sanity check: none of the loggers should be aware of a higher\n    // txid than the txid we intend to truncate to\n    for (Map.Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e e :\n         prepareResponses.entrySet()) {\n      AsyncLogger logger \u003d e.getKey();\n      PrepareRecoveryResponseProto resp \u003d e.getValue();\n\n      if (resp.hasLastCommittedTxId() \u0026\u0026\n          resp.getLastCommittedTxId() \u003e logToSync.getEndTxId()) {\n        throw new AssertionError(\"Decided to synchronize log to \" + logToSync +\n            \" but logger \" + logger + \" had seen txid \" +\n            resp.getLastCommittedTxId() + \" committed\");\n      }\n    }\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs,\n        \"acceptRecovery(\" + TextFormat.shortDebugString(logToSync) + \")\");\n    \n    // TODO:\n    // we should only try to finalize loggers who successfully synced above\n    // eg if a logger was down, we don\u0027t want to send the finalize request.\n    // write a test for this!\n    \n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs,\n        String.format(\"finalizeLogSegment(%s-%s)\",\n            logToSync.getStartTxId(),\n            logToSync.getEndTxId()));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
      "extendedDetails": {}
    },
    "8021d9199f278345aca6211f318145342ad036f4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3863. Track last \"committed\" txid in QJM. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1380976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/12 9:13 PM",
      "commitName": "8021d9199f278345aca6211f318145342ad036f4",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/08/12 12:55 PM",
      "commitNameOld": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 8.35,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,97 @@\n   private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n     Preconditions.checkArgument(segmentTxId \u003e 0);\n     LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n         segmentTxId);\n     \n     // Step 1. Prepare recovery\n     QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n         loggers.prepareRecovery(segmentTxId);\n     Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n         loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n     LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n         QuorumCall.mapToString(prepareResponses));\n \n     // Determine the logger who either:\n     // a) Has already accepted a previous proposal that\u0027s higher than any\n     //    other\n     //\n     //  OR, if no such logger exists:\n     //\n     // b) Has the longest log starting at this transaction ID\n     \n     // TODO: we should collect any \"ties\" and pass the URL for all of them\n     // when syncing, so we can tolerate failure during recovery better.\n     Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n         prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n     AsyncLogger bestLogger \u003d bestEntry.getKey();\n     PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n     \n     // Log the above decision, check invariants.\n     if (bestResponse.hasAcceptedInEpoch()) {\n       LOG.info(\"Using already-accepted recovery for segment \" +\n           \"starting at txid \" + segmentTxId + \": \" +\n           bestEntry);\n     } else if (bestResponse.hasSegmentState()) {\n       LOG.info(\"Using longest log: \" + bestEntry);\n     } else {\n       // None of the responses to prepareRecovery() had a segment at the given\n       // txid. This can happen for example in the following situation:\n       // - 3 JNs: JN1, JN2, JN3\n       // - writer starts segment 101 on JN1, then crashes before\n       //   writing to JN2 and JN3\n       // - during newEpoch(), we saw the segment on JN1 and decide to\n       //   recover segment 101\n       // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n       //   neither of which has any entry for this log.\n       // In this case, it is allowed to do nothing for recovery, since the\n       // segment wasn\u0027t started on a quorum of nodes.\n \n       // Sanity check: we should only get here if none of the responses had\n       // a log. This should be a postcondition of the recovery comparator,\n       // but a bug in the comparator might cause us to get here.\n       for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n         assert !resp.hasSegmentState() :\n           \"One of the loggers had a response, but no best logger \" +\n           \"was found.\";\n       }\n \n       LOG.info(\"None of the responders had a log to recover: \" +\n           QuorumCall.mapToString(prepareResponses));\n       return;\n     }\n     \n     \n     // TODO: check that md5s match up between any \"tied\" logs\n     \n     SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n     assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n     \n+    // Sanity check: none of the loggers should be aware of a higher\n+    // txid than the txid we intend to truncate to\n+    for (Map.Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e e :\n+         prepareResponses.entrySet()) {\n+      AsyncLogger logger \u003d e.getKey();\n+      PrepareRecoveryResponseProto resp \u003d e.getValue();\n+\n+      if (resp.hasLastCommittedTxId() \u0026\u0026\n+          resp.getLastCommittedTxId() \u003e logToSync.getEndTxId()) {\n+        throw new AssertionError(\"Decided to synchronize log to \" + logToSync +\n+            \" but logger \" + logger + \" had seen txid \" +\n+            resp.getLastCommittedTxId() + \" committed\");\n+      }\n+    }\n+    \n     URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n     \n     QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n     loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n     \n     // TODO:\n     // we should only try to finalize loggers who successfully synced above\n     // eg if a logger was down, we don\u0027t want to send the finalize request.\n     // write a test for this!\n     \n     QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n         loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n     loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n    LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // None of the responses to prepareRecovery() had a segment at the given\n      // txid. This can happen for example in the following situation:\n      // - 3 JNs: JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes before\n      //   writing to JN2 and JN3\n      // - during newEpoch(), we saw the segment on JN1 and decide to\n      //   recover segment 101\n      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // In this case, it is allowed to do nothing for recovery, since the\n      // segment wasn\u0027t started on a quorum of nodes.\n\n      // Sanity check: we should only get here if none of the responses had\n      // a log. This should be a postcondition of the recovery comparator,\n      // but a bug in the comparator might cause us to get here.\n      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n        assert !resp.hasSegmentState() :\n          \"One of the loggers had a response, but no best logger \" +\n          \"was found.\";\n      }\n\n      LOG.info(\"None of the responders had a log to recover: \" +\n          QuorumCall.mapToString(prepareResponses));\n      return;\n    }\n    \n    \n    // TODO: check that md5s match up between any \"tied\" logs\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    // Sanity check: none of the loggers should be aware of a higher\n    // txid than the txid we intend to truncate to\n    for (Map.Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e e :\n         prepareResponses.entrySet()) {\n      AsyncLogger logger \u003d e.getKey();\n      PrepareRecoveryResponseProto resp \u003d e.getValue();\n\n      if (resp.hasLastCommittedTxId() \u0026\u0026\n          resp.getLastCommittedTxId() \u003e logToSync.getEndTxId()) {\n        throw new AssertionError(\"Decided to synchronize log to \" + logToSync +\n            \" but logger \" + logger + \" had seen txid \" +\n            resp.getLastCommittedTxId() + \" committed\");\n      }\n    }\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n    \n    // TODO:\n    // we should only try to finalize loggers who successfully synced above\n    // eg if a logger was down, we don\u0027t want to send the finalize request.\n    // write a test for this!\n    \n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
      "extendedDetails": {}
    },
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3845. Fixes for edge cases in QJM recovery protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1377809 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/08/12 12:55 PM",
      "commitName": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "20/08/12 5:48 PM",
      "commitNameOld": "f9a0d78ef5889bb1b9510ba15a1a780fcc9560fd",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n     Preconditions.checkArgument(segmentTxId \u003e 0);\n     LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n         segmentTxId);\n     \n     // Step 1. Prepare recovery\n     QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n         loggers.prepareRecovery(segmentTxId);\n     Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n         loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n     LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n         QuorumCall.mapToString(prepareResponses));\n \n     // Determine the logger who either:\n     // a) Has already accepted a previous proposal that\u0027s higher than any\n     //    other\n     //\n     //  OR, if no such logger exists:\n     //\n     // b) Has the longest log starting at this transaction ID\n     \n     // TODO: we should collect any \"ties\" and pass the URL for all of them\n     // when syncing, so we can tolerate failure during recovery better.\n     Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n-        prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n+        prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n     AsyncLogger bestLogger \u003d bestEntry.getKey();\n     PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n     \n     // Log the above decision, check invariants.\n     if (bestResponse.hasAcceptedInEpoch()) {\n       LOG.info(\"Using already-accepted recovery for segment \" +\n           \"starting at txid \" + segmentTxId + \": \" +\n           bestEntry);\n     } else if (bestResponse.hasSegmentState()) {\n       LOG.info(\"Using longest log: \" + bestEntry);\n     } else {\n       // None of the responses to prepareRecovery() had a segment at the given\n       // txid. This can happen for example in the following situation:\n       // - 3 JNs: JN1, JN2, JN3\n       // - writer starts segment 101 on JN1, then crashes before\n       //   writing to JN2 and JN3\n       // - during newEpoch(), we saw the segment on JN1 and decide to\n       //   recover segment 101\n       // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n       //   neither of which has any entry for this log.\n       // In this case, it is allowed to do nothing for recovery, since the\n       // segment wasn\u0027t started on a quorum of nodes.\n \n       // Sanity check: we should only get here if none of the responses had\n       // a log. This should be a postcondition of the recovery comparator,\n       // but a bug in the comparator might cause us to get here.\n       for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n         assert !resp.hasSegmentState() :\n           \"One of the loggers had a response, but no best logger \" +\n           \"was found.\";\n       }\n \n       LOG.info(\"None of the responders had a log to recover: \" +\n           QuorumCall.mapToString(prepareResponses));\n       return;\n     }\n     \n     \n     // TODO: check that md5s match up between any \"tied\" logs\n     \n     SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n     assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n     \n     URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n     \n     QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n     loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n     \n     // TODO:\n     // we should only try to finalize loggers who successfully synced above\n     // eg if a logger was down, we don\u0027t want to send the finalize request.\n     // write a test for this!\n     \n     QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n         loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n     loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n    LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), SegmentRecoveryComparator.INSTANCE); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // None of the responses to prepareRecovery() had a segment at the given\n      // txid. This can happen for example in the following situation:\n      // - 3 JNs: JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes before\n      //   writing to JN2 and JN3\n      // - during newEpoch(), we saw the segment on JN1 and decide to\n      //   recover segment 101\n      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // In this case, it is allowed to do nothing for recovery, since the\n      // segment wasn\u0027t started on a quorum of nodes.\n\n      // Sanity check: we should only get here if none of the responses had\n      // a log. This should be a postcondition of the recovery comparator,\n      // but a bug in the comparator might cause us to get here.\n      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n        assert !resp.hasSegmentState() :\n          \"One of the loggers had a response, but no best logger \" +\n          \"was found.\";\n      }\n\n      LOG.info(\"None of the responders had a log to recover: \" +\n          QuorumCall.mapToString(prepareResponses));\n      return;\n    }\n    \n    \n    // TODO: check that md5s match up between any \"tied\" logs\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n    \n    // TODO:\n    // we should only try to finalize loggers who successfully synced above\n    // eg if a logger was down, we don\u0027t want to send the finalize request.\n    // write a test for this!\n    \n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
      "extendedDetails": {}
    },
    "f9a0d78ef5889bb1b9510ba15a1a780fcc9560fd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3826. QJM: Some trivial logging / exception text improvements. Contributed by Todd Lipcon and Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1375356 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/08/12 5:48 PM",
      "commitName": "f9a0d78ef5889bb1b9510ba15a1a780fcc9560fd",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "15/08/12 11:58 AM",
      "commitNameOld": "42cdc1b0835abb4a331d40f30f2c210143b747bc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.24,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n     Preconditions.checkArgument(segmentTxId \u003e 0);\n     LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n         segmentTxId);\n     \n     // Step 1. Prepare recovery\n     QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n         loggers.prepareRecovery(segmentTxId);\n     Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n         loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n-    LOG.info(\"Recovery prepare phase complete. Responses: \" +\n+    LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n         QuorumCall.mapToString(prepareResponses));\n \n     // Determine the logger who either:\n     // a) Has already accepted a previous proposal that\u0027s higher than any\n     //    other\n     //\n     //  OR, if no such logger exists:\n     //\n     // b) Has the longest log starting at this transaction ID\n     \n     // TODO: we should collect any \"ties\" and pass the URL for all of them\n     // when syncing, so we can tolerate failure during recovery better.\n     Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n         prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n     AsyncLogger bestLogger \u003d bestEntry.getKey();\n     PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n     \n     // Log the above decision, check invariants.\n     if (bestResponse.hasAcceptedInEpoch()) {\n       LOG.info(\"Using already-accepted recovery for segment \" +\n           \"starting at txid \" + segmentTxId + \": \" +\n           bestEntry);\n     } else if (bestResponse.hasSegmentState()) {\n       LOG.info(\"Using longest log: \" + bestEntry);\n     } else {\n       // None of the responses to prepareRecovery() had a segment at the given\n       // txid. This can happen for example in the following situation:\n       // - 3 JNs: JN1, JN2, JN3\n       // - writer starts segment 101 on JN1, then crashes before\n       //   writing to JN2 and JN3\n       // - during newEpoch(), we saw the segment on JN1 and decide to\n       //   recover segment 101\n       // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n       //   neither of which has any entry for this log.\n       // In this case, it is allowed to do nothing for recovery, since the\n       // segment wasn\u0027t started on a quorum of nodes.\n \n       // Sanity check: we should only get here if none of the responses had\n       // a log. This should be a postcondition of the recovery comparator,\n       // but a bug in the comparator might cause us to get here.\n       for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n         assert !resp.hasSegmentState() :\n           \"One of the loggers had a response, but no best logger \" +\n           \"was found.\";\n       }\n \n       LOG.info(\"None of the responders had a log to recover: \" +\n           QuorumCall.mapToString(prepareResponses));\n       return;\n     }\n     \n     \n     // TODO: check that md5s match up between any \"tied\" logs\n     \n     SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n     assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n     \n     URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n     \n     QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n     loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n     \n     // TODO:\n     // we should only try to finalize loggers who successfully synced above\n     // eg if a logger was down, we don\u0027t want to send the finalize request.\n     // write a test for this!\n     \n     QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n         loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n     loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n    LOG.info(\"Recovery prepare phase complete. Responses:\\n\" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // None of the responses to prepareRecovery() had a segment at the given\n      // txid. This can happen for example in the following situation:\n      // - 3 JNs: JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes before\n      //   writing to JN2 and JN3\n      // - during newEpoch(), we saw the segment on JN1 and decide to\n      //   recover segment 101\n      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // In this case, it is allowed to do nothing for recovery, since the\n      // segment wasn\u0027t started on a quorum of nodes.\n\n      // Sanity check: we should only get here if none of the responses had\n      // a log. This should be a postcondition of the recovery comparator,\n      // but a bug in the comparator might cause us to get here.\n      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n        assert !resp.hasSegmentState() :\n          \"One of the loggers had a response, but no best logger \" +\n          \"was found.\";\n      }\n\n      LOG.info(\"None of the responders had a log to recover: \" +\n          QuorumCall.mapToString(prepareResponses));\n      return;\n    }\n    \n    \n    // TODO: check that md5s match up between any \"tied\" logs\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n    \n    // TODO:\n    // we should only try to finalize loggers who successfully synced above\n    // eg if a logger was down, we don\u0027t want to send the finalize request.\n    // write a test for this!\n    \n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
      "extendedDetails": {}
    },
    "c95a1674b61ef2a6963dc64604986ef90a8c636d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3799. QJM: handle empty log segments during recovery. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1373183 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:57 PM",
      "commitName": "c95a1674b61ef2a6963dc64604986ef90a8c636d",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "14/08/12 5:48 PM",
      "commitNameOld": "f765fdb65701e61887daedb2b369af4be12cb432",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,82 @@\n   private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n     Preconditions.checkArgument(segmentTxId \u003e 0);\n     LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n         segmentTxId);\n     \n     // Step 1. Prepare recovery\n     QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n         loggers.prepareRecovery(segmentTxId);\n     Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n         loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n     LOG.info(\"Recovery prepare phase complete. Responses: \" +\n         QuorumCall.mapToString(prepareResponses));\n \n     // Determine the logger who either:\n     // a) Has already accepted a previous proposal that\u0027s higher than any\n     //    other\n     //\n     //  OR, if no such logger exists:\n     //\n     // b) Has the longest log starting at this transaction ID\n     \n     // TODO: we should collect any \"ties\" and pass the URL for all of them\n     // when syncing, so we can tolerate failure during recovery better.\n     Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n         prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n     AsyncLogger bestLogger \u003d bestEntry.getKey();\n     PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n     \n     // Log the above decision, check invariants.\n     if (bestResponse.hasAcceptedInEpoch()) {\n       LOG.info(\"Using already-accepted recovery for segment \" +\n           \"starting at txid \" + segmentTxId + \": \" +\n           bestEntry);\n     } else if (bestResponse.hasSegmentState()) {\n       LOG.info(\"Using longest log: \" + bestEntry);\n     } else {\n-      // TODO: can we get here? what about the following case:\n-      // - 3 JNs, JN1, JN2, JN3\n-      // - writer starts segment 101 on JN1, then crashes\n-      // - during newEpoch(), we saw the segment on JN1 and decide to recover segment 101\n-      // - during prepare(), JN1 has actually crashed, and we only talk to JN2 and JN3,\n+      // None of the responses to prepareRecovery() had a segment at the given\n+      // txid. This can happen for example in the following situation:\n+      // - 3 JNs: JN1, JN2, JN3\n+      // - writer starts segment 101 on JN1, then crashes before\n+      //   writing to JN2 and JN3\n+      // - during newEpoch(), we saw the segment on JN1 and decide to\n+      //   recover segment 101\n+      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n       //   neither of which has any entry for this log.\n-      // Write a test case.\n-      throw new AssertionError(\"None of the responses \" +\n-          \"had a log to recover: \" + QuorumCall.mapToString(prepareResponses));\n+      // In this case, it is allowed to do nothing for recovery, since the\n+      // segment wasn\u0027t started on a quorum of nodes.\n+\n+      // Sanity check: we should only get here if none of the responses had\n+      // a log. This should be a postcondition of the recovery comparator,\n+      // but a bug in the comparator might cause us to get here.\n+      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n+        assert !resp.hasSegmentState() :\n+          \"One of the loggers had a response, but no best logger \" +\n+          \"was found.\";\n+      }\n+\n+      LOG.info(\"None of the responders had a log to recover: \" +\n+          QuorumCall.mapToString(prepareResponses));\n+      return;\n     }\n     \n     \n     // TODO: check that md5s match up between any \"tied\" logs\n     \n     SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n     assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n     \n     URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n     \n     QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n     loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n     \n     // TODO:\n     // we should only try to finalize loggers who successfully synced above\n     // eg if a logger was down, we don\u0027t want to send the finalize request.\n     // write a test for this!\n     \n     QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n         loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n     loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n    LOG.info(\"Recovery prepare phase complete. Responses: \" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // None of the responses to prepareRecovery() had a segment at the given\n      // txid. This can happen for example in the following situation:\n      // - 3 JNs: JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes before\n      //   writing to JN2 and JN3\n      // - during newEpoch(), we saw the segment on JN1 and decide to\n      //   recover segment 101\n      // - before prepare(), JN1 crashes, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // In this case, it is allowed to do nothing for recovery, since the\n      // segment wasn\u0027t started on a quorum of nodes.\n\n      // Sanity check: we should only get here if none of the responses had\n      // a log. This should be a postcondition of the recovery comparator,\n      // but a bug in the comparator might cause us to get here.\n      for (PrepareRecoveryResponseProto resp : prepareResponses.values()) {\n        assert !resp.hasSegmentState() :\n          \"One of the loggers had a response, but no best logger \" +\n          \"was found.\";\n      }\n\n      LOG.info(\"None of the responders had a log to recover: \" +\n          QuorumCall.mapToString(prepareResponses));\n      return;\n    }\n    \n    \n    // TODO: check that md5s match up between any \"tied\" logs\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n    \n    // TODO:\n    // we should only try to finalize loggers who successfully synced above\n    // eg if a logger was down, we don\u0027t want to send the finalize request.\n    // write a test for this!\n    \n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
      "extendedDetails": {}
    },
    "74d4573a23db5586c6e47ff2277aa7c35237da34": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/12 5:25 PM",
      "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,67 @@\n+  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n+    Preconditions.checkArgument(segmentTxId \u003e 0);\n+    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n+        segmentTxId);\n+    \n+    // Step 1. Prepare recovery\n+    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n+        loggers.prepareRecovery(segmentTxId);\n+    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n+        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n+    LOG.info(\"Recovery prepare phase complete. Responses: \" +\n+        QuorumCall.mapToString(prepareResponses));\n+\n+    // Determine the logger who either:\n+    // a) Has already accepted a previous proposal that\u0027s higher than any\n+    //    other\n+    //\n+    //  OR, if no such logger exists:\n+    //\n+    // b) Has the longest log starting at this transaction ID\n+    \n+    // TODO: we should collect any \"ties\" and pass the URL for all of them\n+    // when syncing, so we can tolerate failure during recovery better.\n+    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n+        prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n+    AsyncLogger bestLogger \u003d bestEntry.getKey();\n+    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n+    \n+    // Log the above decision, check invariants.\n+    if (bestResponse.hasAcceptedInEpoch()) {\n+      LOG.info(\"Using already-accepted recovery for segment \" +\n+          \"starting at txid \" + segmentTxId + \": \" +\n+          bestEntry);\n+    } else if (bestResponse.hasSegmentState()) {\n+      LOG.info(\"Using longest log: \" + bestEntry);\n+    } else {\n+      // TODO: can we get here? what about the following case:\n+      // - 3 JNs, JN1, JN2, JN3\n+      // - writer starts segment 101 on JN1, then crashes\n+      // - during newEpoch(), we saw the segment on JN1 and decide to recover segment 101\n+      // - during prepare(), JN1 has actually crashed, and we only talk to JN2 and JN3,\n+      //   neither of which has any entry for this log.\n+      // Write a test case.\n+      throw new AssertionError(\"None of the responses \" +\n+          \"had a log to recover: \" + QuorumCall.mapToString(prepareResponses));\n+    }\n+    \n+    \n+    // TODO: check that md5s match up between any \"tied\" logs\n+    \n+    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n+    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n+    \n+    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n+    \n+    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n+    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n+    \n+    // TODO:\n+    // we should only try to finalize loggers who successfully synced above\n+    // eg if a logger was down, we don\u0027t want to send the finalize request.\n+    // write a test for this!\n+    \n+    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n+        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n+    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverUnclosedSegment(long segmentTxId) throws IOException {\n    Preconditions.checkArgument(segmentTxId \u003e 0);\n    LOG.info(\"Beginning recovery of unclosed segment starting at txid \" +\n        segmentTxId);\n    \n    // Step 1. Prepare recovery\n    QuorumCall\u003cAsyncLogger,PrepareRecoveryResponseProto\u003e prepare \u003d\n        loggers.prepareRecovery(segmentTxId);\n    Map\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e prepareResponses\u003d\n        loggers.waitForWriteQuorum(prepare, prepareRecoveryTimeoutMs);\n    LOG.info(\"Recovery prepare phase complete. Responses: \" +\n        QuorumCall.mapToString(prepareResponses));\n\n    // Determine the logger who either:\n    // a) Has already accepted a previous proposal that\u0027s higher than any\n    //    other\n    //\n    //  OR, if no such logger exists:\n    //\n    // b) Has the longest log starting at this transaction ID\n    \n    // TODO: we should collect any \"ties\" and pass the URL for all of them\n    // when syncing, so we can tolerate failure during recovery better.\n    Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e bestEntry \u003d Collections.max(\n        prepareResponses.entrySet(), RECOVERY_COMPARATOR); \n    AsyncLogger bestLogger \u003d bestEntry.getKey();\n    PrepareRecoveryResponseProto bestResponse \u003d bestEntry.getValue();\n    \n    // Log the above decision, check invariants.\n    if (bestResponse.hasAcceptedInEpoch()) {\n      LOG.info(\"Using already-accepted recovery for segment \" +\n          \"starting at txid \" + segmentTxId + \": \" +\n          bestEntry);\n    } else if (bestResponse.hasSegmentState()) {\n      LOG.info(\"Using longest log: \" + bestEntry);\n    } else {\n      // TODO: can we get here? what about the following case:\n      // - 3 JNs, JN1, JN2, JN3\n      // - writer starts segment 101 on JN1, then crashes\n      // - during newEpoch(), we saw the segment on JN1 and decide to recover segment 101\n      // - during prepare(), JN1 has actually crashed, and we only talk to JN2 and JN3,\n      //   neither of which has any entry for this log.\n      // Write a test case.\n      throw new AssertionError(\"None of the responses \" +\n          \"had a log to recover: \" + QuorumCall.mapToString(prepareResponses));\n    }\n    \n    \n    // TODO: check that md5s match up between any \"tied\" logs\n    \n    SegmentStateProto logToSync \u003d bestResponse.getSegmentState();\n    assert segmentTxId \u003d\u003d logToSync.getStartTxId();\n    \n    URL syncFromUrl \u003d bestLogger.buildURLToFetchLogs(segmentTxId);\n    \n    QuorumCall\u003cAsyncLogger,Void\u003e accept \u003d loggers.acceptRecovery(logToSync, syncFromUrl);\n    loggers.waitForWriteQuorum(accept, acceptRecoveryTimeoutMs);\n    \n    // TODO:\n    // we should only try to finalize loggers who successfully synced above\n    // eg if a logger was down, we don\u0027t want to send the finalize request.\n    // write a test for this!\n    \n    QuorumCall\u003cAsyncLogger, Void\u003e finalize \u003d\n        loggers.finalizeLogSegment(logToSync.getStartTxId(), logToSync.getEndTxId()); \n    loggers.waitForWriteQuorum(finalize, finalizeSegmentTimeoutMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java"
    }
  }
}