{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingLevelDBTimelineStore.java",
  "functionName": "put",
  "functionId": "put___domain-TimelineDomain",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
  "functionStartLine": 1623,
  "functionEndLine": 1707,
  "numCommitsSeen": 12,
  "timeTaken": 1384,
  "changeHistory": [
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f"
  ],
  "changeHistoryShort": {
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": "Ybodychange",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5368. Memory leak in timeline server (Jonathan Eagles via Varun Saxena)\n",
      "commitDate": "28/03/17 1:23 PM",
      "commitName": "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "20/07/16 8:36 AM",
      "commitNameOld": "1c9d2ab503ea5a3f16757351af9603041059b390",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 251.2,
      "commitsBetweenForRepo": 1583,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,85 @@\n   public void put(TimelineDomain domain) throws IOException {\n-    WriteBatch domainWriteBatch \u003d null;\n-    WriteBatch ownerWriteBatch \u003d null;\n-    try {\n-      domainWriteBatch \u003d domaindb.createWriteBatch();\n-      ownerWriteBatch \u003d ownerdb.createWriteBatch();\n+    try (WriteBatch domainWriteBatch \u003d domaindb.createWriteBatch();\n+         WriteBatch ownerWriteBatch \u003d ownerdb.createWriteBatch();) {\n+\n       if (domain.getId() \u003d\u003d null || domain.getId().length() \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"Domain doesn\u0027t have an ID\");\n       }\n       if (domain.getOwner() \u003d\u003d null || domain.getOwner().length() \u003d\u003d 0) {\n         throw new IllegalArgumentException(\"Domain doesn\u0027t have an owner.\");\n       }\n \n       // Write description\n       byte[] domainEntryKey \u003d createDomainEntryKey(domain.getId(),\n           DESCRIPTION_COLUMN);\n       byte[] ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n           domain.getId(), DESCRIPTION_COLUMN);\n       if (domain.getDescription() !\u003d null) {\n         domainWriteBatch.put(domainEntryKey,\n             domain.getDescription().getBytes(UTF_8));\n         ownerWriteBatch.put(ownerLookupEntryKey, domain.getDescription()\n             .getBytes(UTF_8));\n       } else {\n         domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n         ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n       }\n \n       // Write owner\n       domainEntryKey \u003d createDomainEntryKey(domain.getId(), OWNER_COLUMN);\n       ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n           domain.getId(), OWNER_COLUMN);\n       // Null check for owner is done before\n       domainWriteBatch.put(domainEntryKey, domain.getOwner().getBytes(UTF_8));\n       ownerWriteBatch.put(ownerLookupEntryKey, domain.getOwner()\n           .getBytes(UTF_8));\n \n       // Write readers\n       domainEntryKey \u003d createDomainEntryKey(domain.getId(), READER_COLUMN);\n       ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n           domain.getId(), READER_COLUMN);\n       if (domain.getReaders() !\u003d null \u0026\u0026 domain.getReaders().length() \u003e 0) {\n         domainWriteBatch.put(domainEntryKey, domain.getReaders()\n             .getBytes(UTF_8));\n         ownerWriteBatch.put(ownerLookupEntryKey,\n             domain.getReaders().getBytes(UTF_8));\n       } else {\n         domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n         ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n       }\n \n       // Write writers\n       domainEntryKey \u003d createDomainEntryKey(domain.getId(), WRITER_COLUMN);\n       ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n           domain.getId(), WRITER_COLUMN);\n       if (domain.getWriters() !\u003d null \u0026\u0026 domain.getWriters().length() \u003e 0) {\n         domainWriteBatch.put(domainEntryKey, domain.getWriters()\n             .getBytes(UTF_8));\n         ownerWriteBatch.put(ownerLookupEntryKey,\n             domain.getWriters().getBytes(UTF_8));\n       } else {\n         domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n         ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n       }\n \n       // Write creation time and modification time\n       // We put both timestamps together because they are always retrieved\n       // together, and store them in the same way as we did for the entity\u0027s\n       // start time and insert time.\n       domainEntryKey \u003d createDomainEntryKey(domain.getId(), TIMESTAMP_COLUMN);\n       ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n           domain.getId(), TIMESTAMP_COLUMN);\n       long currentTimestamp \u003d System.currentTimeMillis();\n       byte[] timestamps \u003d domaindb.get(domainEntryKey);\n       if (timestamps \u003d\u003d null) {\n         timestamps \u003d new byte[16];\n         writeReverseOrderedLong(currentTimestamp, timestamps, 0);\n         writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n       } else {\n         writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n       }\n       domainWriteBatch.put(domainEntryKey, timestamps);\n       ownerWriteBatch.put(ownerLookupEntryKey, timestamps);\n       domaindb.write(domainWriteBatch);\n       ownerdb.write(ownerWriteBatch);\n-    } finally {\n-      IOUtils.cleanup(LOG, domainWriteBatch);\n-      IOUtils.cleanup(LOG, ownerWriteBatch);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(TimelineDomain domain) throws IOException {\n    try (WriteBatch domainWriteBatch \u003d domaindb.createWriteBatch();\n         WriteBatch ownerWriteBatch \u003d ownerdb.createWriteBatch();) {\n\n      if (domain.getId() \u003d\u003d null || domain.getId().length() \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"Domain doesn\u0027t have an ID\");\n      }\n      if (domain.getOwner() \u003d\u003d null || domain.getOwner().length() \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"Domain doesn\u0027t have an owner.\");\n      }\n\n      // Write description\n      byte[] domainEntryKey \u003d createDomainEntryKey(domain.getId(),\n          DESCRIPTION_COLUMN);\n      byte[] ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), DESCRIPTION_COLUMN);\n      if (domain.getDescription() !\u003d null) {\n        domainWriteBatch.put(domainEntryKey,\n            domain.getDescription().getBytes(UTF_8));\n        ownerWriteBatch.put(ownerLookupEntryKey, domain.getDescription()\n            .getBytes(UTF_8));\n      } else {\n        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write owner\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), OWNER_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), OWNER_COLUMN);\n      // Null check for owner is done before\n      domainWriteBatch.put(domainEntryKey, domain.getOwner().getBytes(UTF_8));\n      ownerWriteBatch.put(ownerLookupEntryKey, domain.getOwner()\n          .getBytes(UTF_8));\n\n      // Write readers\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), READER_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), READER_COLUMN);\n      if (domain.getReaders() !\u003d null \u0026\u0026 domain.getReaders().length() \u003e 0) {\n        domainWriteBatch.put(domainEntryKey, domain.getReaders()\n            .getBytes(UTF_8));\n        ownerWriteBatch.put(ownerLookupEntryKey,\n            domain.getReaders().getBytes(UTF_8));\n      } else {\n        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write writers\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), WRITER_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), WRITER_COLUMN);\n      if (domain.getWriters() !\u003d null \u0026\u0026 domain.getWriters().length() \u003e 0) {\n        domainWriteBatch.put(domainEntryKey, domain.getWriters()\n            .getBytes(UTF_8));\n        ownerWriteBatch.put(ownerLookupEntryKey,\n            domain.getWriters().getBytes(UTF_8));\n      } else {\n        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write creation time and modification time\n      // We put both timestamps together because they are always retrieved\n      // together, and store them in the same way as we did for the entity\u0027s\n      // start time and insert time.\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), TIMESTAMP_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), TIMESTAMP_COLUMN);\n      long currentTimestamp \u003d System.currentTimeMillis();\n      byte[] timestamps \u003d domaindb.get(domainEntryKey);\n      if (timestamps \u003d\u003d null) {\n        timestamps \u003d new byte[16];\n        writeReverseOrderedLong(currentTimestamp, timestamps, 0);\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      } else {\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      }\n      domainWriteBatch.put(domainEntryKey, timestamps);\n      ownerWriteBatch.put(ownerLookupEntryKey, timestamps);\n      domaindb.write(domainWriteBatch);\n      ownerdb.write(ownerWriteBatch);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,90 @@\n+  public void put(TimelineDomain domain) throws IOException {\n+    WriteBatch domainWriteBatch \u003d null;\n+    WriteBatch ownerWriteBatch \u003d null;\n+    try {\n+      domainWriteBatch \u003d domaindb.createWriteBatch();\n+      ownerWriteBatch \u003d ownerdb.createWriteBatch();\n+      if (domain.getId() \u003d\u003d null || domain.getId().length() \u003d\u003d 0) {\n+        throw new IllegalArgumentException(\"Domain doesn\u0027t have an ID\");\n+      }\n+      if (domain.getOwner() \u003d\u003d null || domain.getOwner().length() \u003d\u003d 0) {\n+        throw new IllegalArgumentException(\"Domain doesn\u0027t have an owner.\");\n+      }\n+\n+      // Write description\n+      byte[] domainEntryKey \u003d createDomainEntryKey(domain.getId(),\n+          DESCRIPTION_COLUMN);\n+      byte[] ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n+          domain.getId(), DESCRIPTION_COLUMN);\n+      if (domain.getDescription() !\u003d null) {\n+        domainWriteBatch.put(domainEntryKey,\n+            domain.getDescription().getBytes(UTF_8));\n+        ownerWriteBatch.put(ownerLookupEntryKey, domain.getDescription()\n+            .getBytes(UTF_8));\n+      } else {\n+        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n+        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n+      }\n+\n+      // Write owner\n+      domainEntryKey \u003d createDomainEntryKey(domain.getId(), OWNER_COLUMN);\n+      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n+          domain.getId(), OWNER_COLUMN);\n+      // Null check for owner is done before\n+      domainWriteBatch.put(domainEntryKey, domain.getOwner().getBytes(UTF_8));\n+      ownerWriteBatch.put(ownerLookupEntryKey, domain.getOwner()\n+          .getBytes(UTF_8));\n+\n+      // Write readers\n+      domainEntryKey \u003d createDomainEntryKey(domain.getId(), READER_COLUMN);\n+      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n+          domain.getId(), READER_COLUMN);\n+      if (domain.getReaders() !\u003d null \u0026\u0026 domain.getReaders().length() \u003e 0) {\n+        domainWriteBatch.put(domainEntryKey, domain.getReaders()\n+            .getBytes(UTF_8));\n+        ownerWriteBatch.put(ownerLookupEntryKey,\n+            domain.getReaders().getBytes(UTF_8));\n+      } else {\n+        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n+        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n+      }\n+\n+      // Write writers\n+      domainEntryKey \u003d createDomainEntryKey(domain.getId(), WRITER_COLUMN);\n+      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n+          domain.getId(), WRITER_COLUMN);\n+      if (domain.getWriters() !\u003d null \u0026\u0026 domain.getWriters().length() \u003e 0) {\n+        domainWriteBatch.put(domainEntryKey, domain.getWriters()\n+            .getBytes(UTF_8));\n+        ownerWriteBatch.put(ownerLookupEntryKey,\n+            domain.getWriters().getBytes(UTF_8));\n+      } else {\n+        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n+        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n+      }\n+\n+      // Write creation time and modification time\n+      // We put both timestamps together because they are always retrieved\n+      // together, and store them in the same way as we did for the entity\u0027s\n+      // start time and insert time.\n+      domainEntryKey \u003d createDomainEntryKey(domain.getId(), TIMESTAMP_COLUMN);\n+      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n+          domain.getId(), TIMESTAMP_COLUMN);\n+      long currentTimestamp \u003d System.currentTimeMillis();\n+      byte[] timestamps \u003d domaindb.get(domainEntryKey);\n+      if (timestamps \u003d\u003d null) {\n+        timestamps \u003d new byte[16];\n+        writeReverseOrderedLong(currentTimestamp, timestamps, 0);\n+        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n+      } else {\n+        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n+      }\n+      domainWriteBatch.put(domainEntryKey, timestamps);\n+      ownerWriteBatch.put(ownerLookupEntryKey, timestamps);\n+      domaindb.write(domainWriteBatch);\n+      ownerdb.write(ownerWriteBatch);\n+    } finally {\n+      IOUtils.cleanup(LOG, domainWriteBatch);\n+      IOUtils.cleanup(LOG, ownerWriteBatch);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(TimelineDomain domain) throws IOException {\n    WriteBatch domainWriteBatch \u003d null;\n    WriteBatch ownerWriteBatch \u003d null;\n    try {\n      domainWriteBatch \u003d domaindb.createWriteBatch();\n      ownerWriteBatch \u003d ownerdb.createWriteBatch();\n      if (domain.getId() \u003d\u003d null || domain.getId().length() \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"Domain doesn\u0027t have an ID\");\n      }\n      if (domain.getOwner() \u003d\u003d null || domain.getOwner().length() \u003d\u003d 0) {\n        throw new IllegalArgumentException(\"Domain doesn\u0027t have an owner.\");\n      }\n\n      // Write description\n      byte[] domainEntryKey \u003d createDomainEntryKey(domain.getId(),\n          DESCRIPTION_COLUMN);\n      byte[] ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), DESCRIPTION_COLUMN);\n      if (domain.getDescription() !\u003d null) {\n        domainWriteBatch.put(domainEntryKey,\n            domain.getDescription().getBytes(UTF_8));\n        ownerWriteBatch.put(ownerLookupEntryKey, domain.getDescription()\n            .getBytes(UTF_8));\n      } else {\n        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write owner\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), OWNER_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), OWNER_COLUMN);\n      // Null check for owner is done before\n      domainWriteBatch.put(domainEntryKey, domain.getOwner().getBytes(UTF_8));\n      ownerWriteBatch.put(ownerLookupEntryKey, domain.getOwner()\n          .getBytes(UTF_8));\n\n      // Write readers\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), READER_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), READER_COLUMN);\n      if (domain.getReaders() !\u003d null \u0026\u0026 domain.getReaders().length() \u003e 0) {\n        domainWriteBatch.put(domainEntryKey, domain.getReaders()\n            .getBytes(UTF_8));\n        ownerWriteBatch.put(ownerLookupEntryKey,\n            domain.getReaders().getBytes(UTF_8));\n      } else {\n        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write writers\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), WRITER_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), WRITER_COLUMN);\n      if (domain.getWriters() !\u003d null \u0026\u0026 domain.getWriters().length() \u003e 0) {\n        domainWriteBatch.put(domainEntryKey, domain.getWriters()\n            .getBytes(UTF_8));\n        ownerWriteBatch.put(ownerLookupEntryKey,\n            domain.getWriters().getBytes(UTF_8));\n      } else {\n        domainWriteBatch.put(domainEntryKey, EMPTY_BYTES);\n        ownerWriteBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write creation time and modification time\n      // We put both timestamps together because they are always retrieved\n      // together, and store them in the same way as we did for the entity\u0027s\n      // start time and insert time.\n      domainEntryKey \u003d createDomainEntryKey(domain.getId(), TIMESTAMP_COLUMN);\n      ownerLookupEntryKey \u003d createOwnerLookupKey(domain.getOwner(),\n          domain.getId(), TIMESTAMP_COLUMN);\n      long currentTimestamp \u003d System.currentTimeMillis();\n      byte[] timestamps \u003d domaindb.get(domainEntryKey);\n      if (timestamps \u003d\u003d null) {\n        timestamps \u003d new byte[16];\n        writeReverseOrderedLong(currentTimestamp, timestamps, 0);\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      } else {\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      }\n      domainWriteBatch.put(domainEntryKey, timestamps);\n      ownerWriteBatch.put(ownerLookupEntryKey, timestamps);\n      domaindb.write(domainWriteBatch);\n      ownerdb.write(ownerWriteBatch);\n    } finally {\n      IOUtils.cleanup(LOG, domainWriteBatch);\n      IOUtils.cleanup(LOG, ownerWriteBatch);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java"
    }
  }
}