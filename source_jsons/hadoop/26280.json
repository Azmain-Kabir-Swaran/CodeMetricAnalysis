{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultSpeculator.java",
  "functionName": "speculationValue",
  "functionId": "speculationValue___taskID-TaskId__now-long",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
  "functionStartLine": 368,
  "functionEndLine": 464,
  "numCommitsSeen": 19,
  "timeTaken": 7374,
  "changeHistory": [
    "ed302f1fed6d124d682486d24dae958946dba9be",
    "d4324eef14782d3cde6570ee910c45d8fdfce6ba",
    "022f7b4a25c73b8c43985e8d1bac717b96373ac6",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "ed302f1fed6d124d682486d24dae958946dba9be": "Ybodychange",
    "d4324eef14782d3cde6570ee910c45d8fdfce6ba": "Ybodychange",
    "022f7b4a25c73b8c43985e8d1bac717b96373ac6": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ed302f1fed6d124d682486d24dae958946dba9be": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7208. Tuning TaskRuntimeEstimator. (Ahmed Hussein via jeagles)\n\nSigned-off-by: Jonathan Eagles \u003cjeagles@gmail.com\u003e\n",
      "commitDate": "05/11/19 12:55 PM",
      "commitName": "ed302f1fed6d124d682486d24dae958946dba9be",
      "commitAuthor": "Ahmed Hussein",
      "commitDateOld": "18/09/18 1:26 PM",
      "commitNameOld": "2cf8927683d49f4cdc3cba038480128c473c5461",
      "commitAuthorOld": "Eric E Payne",
      "daysBetweenCommits": 413.02,
      "commitsBetweenForRepo": 3102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,97 @@\n   private long speculationValue(TaskId taskID, long now) {\n     Job job \u003d context.getJob(taskID.getJobId());\n     Task task \u003d job.getTask(taskID);\n     Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n     long acceptableRuntime \u003d Long.MIN_VALUE;\n     long result \u003d Long.MIN_VALUE;\n \n     if (!mayHaveSpeculated.contains(taskID)) {\n       acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n       if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n         return ON_SCHEDULE;\n       }\n     }\n \n     TaskAttemptId runningTaskAttemptID \u003d null;\n \n     int numberRunningAttempts \u003d 0;\n \n     for (TaskAttempt taskAttempt : attempts.values()) {\n       if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n           || taskAttempt.getState() \u003d\u003d TaskAttemptState.STARTING) {\n         if (++numberRunningAttempts \u003e 1) {\n           return ALREADY_SPECULATING;\n         }\n         runningTaskAttemptID \u003d taskAttempt.getID();\n \n         long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n \n         long taskAttemptStartTime\n             \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n         if (taskAttemptStartTime \u003e now) {\n           // This background process ran before we could process the task\n           //  attempt status change that chronicles the attempt start\n           return TOO_NEW;\n         }\n \n         long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n \n         long estimatedReplacementEndTime\n             \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n \n         float progress \u003d taskAttempt.getProgress();\n         TaskAttemptHistoryStatistics data \u003d\n             runningTaskAttemptStatistics.get(runningTaskAttemptID);\n         if (data \u003d\u003d null) {\n           runningTaskAttemptStatistics.put(runningTaskAttemptID,\n             new TaskAttemptHistoryStatistics(estimatedRunTime, progress, now));\n         } else {\n           if (estimatedRunTime \u003d\u003d data.getEstimatedRunTime()\n               \u0026\u0026 progress \u003d\u003d data.getProgress()) {\n             // Previous stats are same as same stats\n-            if (data.notHeartbeatedInAWhile(now)) {\n+            if (data.notHeartbeatedInAWhile(now)\n+                || estimator.hasStagnatedProgress(runningTaskAttemptID, now)) {\n               // Stats have stagnated for a while, simulate heart-beat.\n               TaskAttemptStatus taskAttemptStatus \u003d new TaskAttemptStatus();\n               taskAttemptStatus.id \u003d runningTaskAttemptID;\n               taskAttemptStatus.progress \u003d progress;\n               taskAttemptStatus.taskState \u003d taskAttempt.getState();\n               // Now simulate the heart-beat\n               handleAttempt(taskAttemptStatus);\n             }\n           } else {\n             // Stats have changed - update our data structure\n             data.setEstimatedRunTime(estimatedRunTime);\n             data.setProgress(progress);\n             data.resetHeartBeatTime(now);\n           }\n         }\n \n         if (estimatedEndTime \u003c now) {\n           return PROGRESS_IS_GOOD;\n         }\n \n         if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n           return TOO_LATE_TO_SPECULATE;\n         }\n \n         result \u003d estimatedEndTime - estimatedReplacementEndTime;\n       }\n     }\n \n     // If we are here, there\u0027s at most one task attempt.\n     if (numberRunningAttempts \u003d\u003d 0) {\n       return NOT_RUNNING;\n     }\n \n \n \n     if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n       acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n       if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n         return ON_SCHEDULE;\n       }\n     }\n \n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long speculationValue(TaskId taskID, long now) {\n    Job job \u003d context.getJob(taskID.getJobId());\n    Task task \u003d job.getTask(taskID);\n    Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n    long acceptableRuntime \u003d Long.MIN_VALUE;\n    long result \u003d Long.MIN_VALUE;\n\n    if (!mayHaveSpeculated.contains(taskID)) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    TaskAttemptId runningTaskAttemptID \u003d null;\n\n    int numberRunningAttempts \u003d 0;\n\n    for (TaskAttempt taskAttempt : attempts.values()) {\n      if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n          || taskAttempt.getState() \u003d\u003d TaskAttemptState.STARTING) {\n        if (++numberRunningAttempts \u003e 1) {\n          return ALREADY_SPECULATING;\n        }\n        runningTaskAttemptID \u003d taskAttempt.getID();\n\n        long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n\n        long taskAttemptStartTime\n            \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n        if (taskAttemptStartTime \u003e now) {\n          // This background process ran before we could process the task\n          //  attempt status change that chronicles the attempt start\n          return TOO_NEW;\n        }\n\n        long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n\n        long estimatedReplacementEndTime\n            \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n\n        float progress \u003d taskAttempt.getProgress();\n        TaskAttemptHistoryStatistics data \u003d\n            runningTaskAttemptStatistics.get(runningTaskAttemptID);\n        if (data \u003d\u003d null) {\n          runningTaskAttemptStatistics.put(runningTaskAttemptID,\n            new TaskAttemptHistoryStatistics(estimatedRunTime, progress, now));\n        } else {\n          if (estimatedRunTime \u003d\u003d data.getEstimatedRunTime()\n              \u0026\u0026 progress \u003d\u003d data.getProgress()) {\n            // Previous stats are same as same stats\n            if (data.notHeartbeatedInAWhile(now)\n                || estimator.hasStagnatedProgress(runningTaskAttemptID, now)) {\n              // Stats have stagnated for a while, simulate heart-beat.\n              TaskAttemptStatus taskAttemptStatus \u003d new TaskAttemptStatus();\n              taskAttemptStatus.id \u003d runningTaskAttemptID;\n              taskAttemptStatus.progress \u003d progress;\n              taskAttemptStatus.taskState \u003d taskAttempt.getState();\n              // Now simulate the heart-beat\n              handleAttempt(taskAttemptStatus);\n            }\n          } else {\n            // Stats have changed - update our data structure\n            data.setEstimatedRunTime(estimatedRunTime);\n            data.setProgress(progress);\n            data.resetHeartBeatTime(now);\n          }\n        }\n\n        if (estimatedEndTime \u003c now) {\n          return PROGRESS_IS_GOOD;\n        }\n\n        if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n          return TOO_LATE_TO_SPECULATE;\n        }\n\n        result \u003d estimatedEndTime - estimatedReplacementEndTime;\n      }\n    }\n\n    // If we are here, there\u0027s at most one task attempt.\n    if (numberRunningAttempts \u003d\u003d 0) {\n      return NOT_RUNNING;\n    }\n\n\n\n    if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    return result;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
      "extendedDetails": {}
    },
    "d4324eef14782d3cde6570ee910c45d8fdfce6ba": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5533. Fixed MR speculation code to track any TaskAttempts that aren\u0027t heart-beating for a while, so that we can aggressively speculate instead of waiting for task-timeout. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529229 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/10/13 10:26 AM",
      "commitName": "d4324eef14782d3cde6570ee910c45d8fdfce6ba",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 109.45,
      "commitsBetweenForRepo": 641,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,96 @@\n   private long speculationValue(TaskId taskID, long now) {\n     Job job \u003d context.getJob(taskID.getJobId());\n     Task task \u003d job.getTask(taskID);\n     Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n     long acceptableRuntime \u003d Long.MIN_VALUE;\n     long result \u003d Long.MIN_VALUE;\n \n     if (!mayHaveSpeculated.contains(taskID)) {\n       acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n       if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n         return ON_SCHEDULE;\n       }\n     }\n \n     TaskAttemptId runningTaskAttemptID \u003d null;\n \n     int numberRunningAttempts \u003d 0;\n \n     for (TaskAttempt taskAttempt : attempts.values()) {\n       if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n           || taskAttempt.getState() \u003d\u003d TaskAttemptState.STARTING) {\n         if (++numberRunningAttempts \u003e 1) {\n           return ALREADY_SPECULATING;\n         }\n         runningTaskAttemptID \u003d taskAttempt.getID();\n \n         long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n \n         long taskAttemptStartTime\n             \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n         if (taskAttemptStartTime \u003e now) {\n           // This background process ran before we could process the task\n           //  attempt status change that chronicles the attempt start\n           return TOO_NEW;\n         }\n \n         long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n \n         long estimatedReplacementEndTime\n             \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n \n+        float progress \u003d taskAttempt.getProgress();\n+        TaskAttemptHistoryStatistics data \u003d\n+            runningTaskAttemptStatistics.get(runningTaskAttemptID);\n+        if (data \u003d\u003d null) {\n+          runningTaskAttemptStatistics.put(runningTaskAttemptID,\n+            new TaskAttemptHistoryStatistics(estimatedRunTime, progress, now));\n+        } else {\n+          if (estimatedRunTime \u003d\u003d data.getEstimatedRunTime()\n+              \u0026\u0026 progress \u003d\u003d data.getProgress()) {\n+            // Previous stats are same as same stats\n+            if (data.notHeartbeatedInAWhile(now)) {\n+              // Stats have stagnated for a while, simulate heart-beat.\n+              TaskAttemptStatus taskAttemptStatus \u003d new TaskAttemptStatus();\n+              taskAttemptStatus.id \u003d runningTaskAttemptID;\n+              taskAttemptStatus.progress \u003d progress;\n+              taskAttemptStatus.taskState \u003d taskAttempt.getState();\n+              // Now simulate the heart-beat\n+              handleAttempt(taskAttemptStatus);\n+            }\n+          } else {\n+            // Stats have changed - update our data structure\n+            data.setEstimatedRunTime(estimatedRunTime);\n+            data.setProgress(progress);\n+            data.resetHeartBeatTime(now);\n+          }\n+        }\n+\n         if (estimatedEndTime \u003c now) {\n           return PROGRESS_IS_GOOD;\n         }\n \n         if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n           return TOO_LATE_TO_SPECULATE;\n         }\n \n         result \u003d estimatedEndTime - estimatedReplacementEndTime;\n       }\n     }\n \n     // If we are here, there\u0027s at most one task attempt.\n     if (numberRunningAttempts \u003d\u003d 0) {\n       return NOT_RUNNING;\n     }\n \n \n \n     if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n       acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n       if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n         return ON_SCHEDULE;\n       }\n     }\n \n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long speculationValue(TaskId taskID, long now) {\n    Job job \u003d context.getJob(taskID.getJobId());\n    Task task \u003d job.getTask(taskID);\n    Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n    long acceptableRuntime \u003d Long.MIN_VALUE;\n    long result \u003d Long.MIN_VALUE;\n\n    if (!mayHaveSpeculated.contains(taskID)) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    TaskAttemptId runningTaskAttemptID \u003d null;\n\n    int numberRunningAttempts \u003d 0;\n\n    for (TaskAttempt taskAttempt : attempts.values()) {\n      if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n          || taskAttempt.getState() \u003d\u003d TaskAttemptState.STARTING) {\n        if (++numberRunningAttempts \u003e 1) {\n          return ALREADY_SPECULATING;\n        }\n        runningTaskAttemptID \u003d taskAttempt.getID();\n\n        long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n\n        long taskAttemptStartTime\n            \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n        if (taskAttemptStartTime \u003e now) {\n          // This background process ran before we could process the task\n          //  attempt status change that chronicles the attempt start\n          return TOO_NEW;\n        }\n\n        long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n\n        long estimatedReplacementEndTime\n            \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n\n        float progress \u003d taskAttempt.getProgress();\n        TaskAttemptHistoryStatistics data \u003d\n            runningTaskAttemptStatistics.get(runningTaskAttemptID);\n        if (data \u003d\u003d null) {\n          runningTaskAttemptStatistics.put(runningTaskAttemptID,\n            new TaskAttemptHistoryStatistics(estimatedRunTime, progress, now));\n        } else {\n          if (estimatedRunTime \u003d\u003d data.getEstimatedRunTime()\n              \u0026\u0026 progress \u003d\u003d data.getProgress()) {\n            // Previous stats are same as same stats\n            if (data.notHeartbeatedInAWhile(now)) {\n              // Stats have stagnated for a while, simulate heart-beat.\n              TaskAttemptStatus taskAttemptStatus \u003d new TaskAttemptStatus();\n              taskAttemptStatus.id \u003d runningTaskAttemptID;\n              taskAttemptStatus.progress \u003d progress;\n              taskAttemptStatus.taskState \u003d taskAttempt.getState();\n              // Now simulate the heart-beat\n              handleAttempt(taskAttemptStatus);\n            }\n          } else {\n            // Stats have changed - update our data structure\n            data.setEstimatedRunTime(estimatedRunTime);\n            data.setProgress(progress);\n            data.resetHeartBeatTime(now);\n          }\n        }\n\n        if (estimatedEndTime \u003c now) {\n          return PROGRESS_IS_GOOD;\n        }\n\n        if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n          return TOO_LATE_TO_SPECULATE;\n        }\n\n        result \u003d estimatedEndTime - estimatedReplacementEndTime;\n      }\n    }\n\n    // If we are here, there\u0027s at most one task attempt.\n    if (numberRunningAttempts \u003d\u003d 0) {\n      return NOT_RUNNING;\n    }\n\n\n\n    if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    return result;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
      "extendedDetails": {}
    },
    "022f7b4a25c73b8c43985e8d1bac717b96373ac6": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4596. Split StateMachine state from states seen by MRClientProtocol for Job, Task and TaskAttempt. Contributed by Siddarth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1399976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/12 10:57 PM",
      "commitName": "022f7b4a25c73b8c43985e8d1bac717b96373ac6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/09/11 11:28 AM",
      "commitNameOld": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 393.48,
      "commitsBetweenForRepo": 2618,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   private long speculationValue(TaskId taskID, long now) {\n     Job job \u003d context.getJob(taskID.getJobId());\n     Task task \u003d job.getTask(taskID);\n     Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n     long acceptableRuntime \u003d Long.MIN_VALUE;\n     long result \u003d Long.MIN_VALUE;\n \n     if (!mayHaveSpeculated.contains(taskID)) {\n       acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n       if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n         return ON_SCHEDULE;\n       }\n     }\n \n     TaskAttemptId runningTaskAttemptID \u003d null;\n \n     int numberRunningAttempts \u003d 0;\n \n     for (TaskAttempt taskAttempt : attempts.values()) {\n       if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n-          || taskAttempt.getState() \u003d\u003d TaskAttemptState.ASSIGNED) {\n+          || taskAttempt.getState() \u003d\u003d TaskAttemptState.STARTING) {\n         if (++numberRunningAttempts \u003e 1) {\n           return ALREADY_SPECULATING;\n         }\n         runningTaskAttemptID \u003d taskAttempt.getID();\n \n         long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n \n         long taskAttemptStartTime\n             \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n         if (taskAttemptStartTime \u003e now) {\n           // This background process ran before we could process the task\n           //  attempt status change that chronicles the attempt start\n           return TOO_NEW;\n         }\n \n         long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n \n         long estimatedReplacementEndTime\n             \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n \n         if (estimatedEndTime \u003c now) {\n           return PROGRESS_IS_GOOD;\n         }\n \n         if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n           return TOO_LATE_TO_SPECULATE;\n         }\n \n         result \u003d estimatedEndTime - estimatedReplacementEndTime;\n       }\n     }\n \n     // If we are here, there\u0027s at most one task attempt.\n     if (numberRunningAttempts \u003d\u003d 0) {\n       return NOT_RUNNING;\n     }\n \n \n \n     if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n       acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n       if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n         return ON_SCHEDULE;\n       }\n     }\n \n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long speculationValue(TaskId taskID, long now) {\n    Job job \u003d context.getJob(taskID.getJobId());\n    Task task \u003d job.getTask(taskID);\n    Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n    long acceptableRuntime \u003d Long.MIN_VALUE;\n    long result \u003d Long.MIN_VALUE;\n\n    if (!mayHaveSpeculated.contains(taskID)) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    TaskAttemptId runningTaskAttemptID \u003d null;\n\n    int numberRunningAttempts \u003d 0;\n\n    for (TaskAttempt taskAttempt : attempts.values()) {\n      if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n          || taskAttempt.getState() \u003d\u003d TaskAttemptState.STARTING) {\n        if (++numberRunningAttempts \u003e 1) {\n          return ALREADY_SPECULATING;\n        }\n        runningTaskAttemptID \u003d taskAttempt.getID();\n\n        long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n\n        long taskAttemptStartTime\n            \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n        if (taskAttemptStartTime \u003e now) {\n          // This background process ran before we could process the task\n          //  attempt status change that chronicles the attempt start\n          return TOO_NEW;\n        }\n\n        long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n\n        long estimatedReplacementEndTime\n            \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n\n        if (estimatedEndTime \u003c now) {\n          return PROGRESS_IS_GOOD;\n        }\n\n        if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n          return TOO_LATE_TO_SPECULATE;\n        }\n\n        result \u003d estimatedEndTime - estimatedReplacementEndTime;\n      }\n    }\n\n    // If we are here, there\u0027s at most one task attempt.\n    if (numberRunningAttempts \u003d\u003d 0) {\n      return NOT_RUNNING;\n    }\n\n\n\n    if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    return result;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private long speculationValue(TaskId taskID, long now) {\n    Job job \u003d context.getJob(taskID.getJobId());\n    Task task \u003d job.getTask(taskID);\n    Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n    long acceptableRuntime \u003d Long.MIN_VALUE;\n    long result \u003d Long.MIN_VALUE;\n\n    if (!mayHaveSpeculated.contains(taskID)) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    TaskAttemptId runningTaskAttemptID \u003d null;\n\n    int numberRunningAttempts \u003d 0;\n\n    for (TaskAttempt taskAttempt : attempts.values()) {\n      if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n          || taskAttempt.getState() \u003d\u003d TaskAttemptState.ASSIGNED) {\n        if (++numberRunningAttempts \u003e 1) {\n          return ALREADY_SPECULATING;\n        }\n        runningTaskAttemptID \u003d taskAttempt.getID();\n\n        long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n\n        long taskAttemptStartTime\n            \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n        if (taskAttemptStartTime \u003e now) {\n          // This background process ran before we could process the task\n          //  attempt status change that chronicles the attempt start\n          return TOO_NEW;\n        }\n\n        long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n\n        long estimatedReplacementEndTime\n            \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n\n        if (estimatedEndTime \u003c now) {\n          return PROGRESS_IS_GOOD;\n        }\n\n        if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n          return TOO_LATE_TO_SPECULATE;\n        }\n\n        result \u003d estimatedEndTime - estimatedReplacementEndTime;\n      }\n    }\n\n    // If we are here, there\u0027s at most one task attempt.\n    if (numberRunningAttempts \u003d\u003d 0) {\n      return NOT_RUNNING;\n    }\n\n\n\n    if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    return result;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,69 @@\n+  private long speculationValue(TaskId taskID, long now) {\n+    Job job \u003d context.getJob(taskID.getJobId());\n+    Task task \u003d job.getTask(taskID);\n+    Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n+    long acceptableRuntime \u003d Long.MIN_VALUE;\n+    long result \u003d Long.MIN_VALUE;\n+\n+    if (!mayHaveSpeculated.contains(taskID)) {\n+      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n+      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n+        return ON_SCHEDULE;\n+      }\n+    }\n+\n+    TaskAttemptId runningTaskAttemptID \u003d null;\n+\n+    int numberRunningAttempts \u003d 0;\n+\n+    for (TaskAttempt taskAttempt : attempts.values()) {\n+      if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n+          || taskAttempt.getState() \u003d\u003d TaskAttemptState.ASSIGNED) {\n+        if (++numberRunningAttempts \u003e 1) {\n+          return ALREADY_SPECULATING;\n+        }\n+        runningTaskAttemptID \u003d taskAttempt.getID();\n+\n+        long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n+\n+        long taskAttemptStartTime\n+            \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n+        if (taskAttemptStartTime \u003e now) {\n+          // This background process ran before we could process the task\n+          //  attempt status change that chronicles the attempt start\n+          return TOO_NEW;\n+        }\n+\n+        long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n+\n+        long estimatedReplacementEndTime\n+            \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n+\n+        if (estimatedEndTime \u003c now) {\n+          return PROGRESS_IS_GOOD;\n+        }\n+\n+        if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n+          return TOO_LATE_TO_SPECULATE;\n+        }\n+\n+        result \u003d estimatedEndTime - estimatedReplacementEndTime;\n+      }\n+    }\n+\n+    // If we are here, there\u0027s at most one task attempt.\n+    if (numberRunningAttempts \u003d\u003d 0) {\n+      return NOT_RUNNING;\n+    }\n+\n+\n+\n+    if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n+      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n+      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n+        return ON_SCHEDULE;\n+      }\n+    }\n+\n+    return result;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long speculationValue(TaskId taskID, long now) {\n    Job job \u003d context.getJob(taskID.getJobId());\n    Task task \u003d job.getTask(taskID);\n    Map\u003cTaskAttemptId, TaskAttempt\u003e attempts \u003d task.getAttempts();\n    long acceptableRuntime \u003d Long.MIN_VALUE;\n    long result \u003d Long.MIN_VALUE;\n\n    if (!mayHaveSpeculated.contains(taskID)) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    TaskAttemptId runningTaskAttemptID \u003d null;\n\n    int numberRunningAttempts \u003d 0;\n\n    for (TaskAttempt taskAttempt : attempts.values()) {\n      if (taskAttempt.getState() \u003d\u003d TaskAttemptState.RUNNING\n          || taskAttempt.getState() \u003d\u003d TaskAttemptState.ASSIGNED) {\n        if (++numberRunningAttempts \u003e 1) {\n          return ALREADY_SPECULATING;\n        }\n        runningTaskAttemptID \u003d taskAttempt.getID();\n\n        long estimatedRunTime \u003d estimator.estimatedRuntime(runningTaskAttemptID);\n\n        long taskAttemptStartTime\n            \u003d estimator.attemptEnrolledTime(runningTaskAttemptID);\n        if (taskAttemptStartTime \u003e now) {\n          // This background process ran before we could process the task\n          //  attempt status change that chronicles the attempt start\n          return TOO_NEW;\n        }\n\n        long estimatedEndTime \u003d estimatedRunTime + taskAttemptStartTime;\n\n        long estimatedReplacementEndTime\n            \u003d now + estimator.estimatedNewAttemptRuntime(taskID);\n\n        if (estimatedEndTime \u003c now) {\n          return PROGRESS_IS_GOOD;\n        }\n\n        if (estimatedReplacementEndTime \u003e\u003d estimatedEndTime) {\n          return TOO_LATE_TO_SPECULATE;\n        }\n\n        result \u003d estimatedEndTime - estimatedReplacementEndTime;\n      }\n    }\n\n    // If we are here, there\u0027s at most one task attempt.\n    if (numberRunningAttempts \u003d\u003d 0) {\n      return NOT_RUNNING;\n    }\n\n\n\n    if (acceptableRuntime \u003d\u003d Long.MIN_VALUE) {\n      acceptableRuntime \u003d estimator.thresholdRuntime(taskID);\n      if (acceptableRuntime \u003d\u003d Long.MAX_VALUE) {\n        return ON_SCHEDULE;\n      }\n    }\n\n    return result;\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java"
    }
  }
}