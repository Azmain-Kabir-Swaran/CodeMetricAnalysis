{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "readAndProcess",
  "functionId": "readAndProcess",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 2233,
  "functionEndLine": 2319,
  "numCommitsSeen": 205,
  "timeTaken": 8487,
  "changeHistory": [
    "93d7630062247793a4860704fad4a31437693de1",
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
    "580a8334963709e728ed677c815fb7fef9bca70e",
    "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
    "c03c8fe199429a43c6aa944016566738abd9b193",
    "63a1273f2a8e0b668ff70330262adedee63112d9",
    "65be21267587f04a2c33af65b951211cc9085b15",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
    "eb2a60338715e517ba8e4d32ecfe28691a882188",
    "805e9b5b6d835d1b7a50af18967afb8eebdf8606",
    "5f9b4c14a175873b4f82654513e289c657c694eb",
    "a841be808a780db0653b17bb702037f422c5b1ec",
    "5319818487d5c139de06155834deecb18c10b7a1",
    "4755ef989ac771ad3c2c40f9914455725c931447",
    "1594dd6965c412a08339a0079ee1416dd6f595f9",
    "a7d4f30131b374baaa1efba22c7ae8e80c000f45",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9",
    "a11f67fb7885f934de926bfe960ce77879b3cd8e",
    "0c77d705be11b0e5844aaa2b96ef9660f02cb53a",
    "3e6d128c83c76ed53c8eb643b2b7aca34ae1ba88",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "90a926261184cbdbea4bd487918990d5875da440",
    "8fa094ad6ad3b4f8a3102b79d4e36146f53abea8",
    "4b9c956bc56cec2c5b669102340d0912e0db3517",
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
    "940389afce6a1b9b9e1519aed528cbc444786756",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "93d7630062247793a4860704fad4a31437693de1": "Ybodychange",
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "580a8334963709e728ed677c815fb7fef9bca70e": "Ybodychange",
    "a4819e70dbf88b0905a6669078afa1ff0924ad4f": "Ybodychange",
    "c03c8fe199429a43c6aa944016566738abd9b193": "Ybodychange",
    "63a1273f2a8e0b668ff70330262adedee63112d9": "Ybodychange",
    "65be21267587f04a2c33af65b951211cc9085b15": "Yexceptionschange",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": "Ybodychange",
    "eb2a60338715e517ba8e4d32ecfe28691a882188": "Ybodychange",
    "805e9b5b6d835d1b7a50af18967afb8eebdf8606": "Ybodychange",
    "5f9b4c14a175873b4f82654513e289c657c694eb": "Ybodychange",
    "a841be808a780db0653b17bb702037f422c5b1ec": "Ybodychange",
    "5319818487d5c139de06155834deecb18c10b7a1": "Ybodychange",
    "4755ef989ac771ad3c2c40f9914455725c931447": "Ybodychange",
    "1594dd6965c412a08339a0079ee1416dd6f595f9": "Ybodychange",
    "a7d4f30131b374baaa1efba22c7ae8e80c000f45": "Ybodychange",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": "Ybodychange",
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9": "Ybodychange",
    "a11f67fb7885f934de926bfe960ce77879b3cd8e": "Ybodychange",
    "0c77d705be11b0e5844aaa2b96ef9660f02cb53a": "Ybodychange",
    "3e6d128c83c76ed53c8eb643b2b7aca34ae1ba88": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "90a926261184cbdbea4bd487918990d5875da440": "Ybodychange",
    "8fa094ad6ad3b4f8a3102b79d4e36146f53abea8": "Ybodychange",
    "4b9c956bc56cec2c5b669102340d0912e0db3517": "Ybodychange",
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf": "Ybodychange",
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539": "Ybodychange",
    "940389afce6a1b9b9e1519aed528cbc444786756": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "93d7630062247793a4860704fad4a31437693de1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14451. Incorrect header or version mismatch log message. Contributed by Shweta.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "24/05/19 9:42 AM",
      "commitName": "93d7630062247793a4860704fad4a31437693de1",
      "commitAuthor": "Shweta",
      "commitDateOld": "23/05/19 10:28 AM",
      "commitNameOld": "f96a2df38d889f29314c57f4d94227b2e419a11f",
      "commitAuthorOld": "Christopher Gregorian",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,87 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (!shouldClose()) { // stop if a fatal response has been sent.\n         // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           // Every connection is expected to send the header;\n           // so far we read \"hrpc\" of the connection header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             // for the bytes that follow \"hrpc\", in the connection header\n             connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n-          \n-          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n-              || version !\u003d CURRENT_VERSION) {\n+\n+          if(!RpcConstants.HEADER.equals(dataLengthBuffer)) {\n+            LOG.warn(\"Incorrect RPC Header length from {}:{} \"\n+                + \"expected length: {} got length: {}\",\n+                hostAddress, remotePort, RpcConstants.HEADER, dataLengthBuffer);\n+            setupBadVersionResponse(version);\n+            return -1;\n+          }\n+          if (version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n-            LOG.warn(\"Incorrect header or version mismatch from \" + \n+            LOG.warn(\"Version mismatch from \" +\n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear(); // clear to next read rpc packet len\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue; // connection header read, now read  4 bytes rpc packet len\n         }\n         \n         if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           checkDataLength(dataLength);\n           // Set buffer for reading EXACTLY the RPC-packet length and no more.\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         // Now read the RPC packet\n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear(); // to read length of future rpc packets\n           data.flip();\n           ByteBuffer requestData \u003d data;\n           data \u003d null; // null out in case processOneRpc throws.\n           boolean isHeaderRead \u003d connectionContextRead;\n           processOneRpc(requestData);\n           // the last rpc-request we processed could have simply been the\n           // connectionContext; if so continue to read the first RPC.\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n       return -1;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (!shouldClose()) { // stop if a fatal response has been sent.\n        // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          // Every connection is expected to send the header;\n          // so far we read \"hrpc\" of the connection header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            // for the bytes that follow \"hrpc\", in the connection header\n            connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n\n          if(!RpcConstants.HEADER.equals(dataLengthBuffer)) {\n            LOG.warn(\"Incorrect RPC Header length from {}:{} \"\n                + \"expected length: {} got length: {}\",\n                hostAddress, remotePort, RpcConstants.HEADER, dataLengthBuffer);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          if (version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Version mismatch from \" +\n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear(); // clear to next read rpc packet len\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue; // connection header read, now read  4 bytes rpc packet len\n        }\n        \n        if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          // Set buffer for reading EXACTLY the RPC-packet length and no more.\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        // Now read the RPC packet\n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear(); // to read length of future rpc packets\n          data.flip();\n          ByteBuffer requestData \u003d data;\n          data \u003d null; // null out in case processOneRpc throws.\n          boolean isHeaderRead \u003d connectionContextRead;\n          processOneRpc(requestData);\n          // the last rpc-request we processed could have simply been the\n          // connectionContext; if so continue to read the first RPC.\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n      return -1;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
      "commitDate": "09/02/17 8:47 AM",
      "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,81 @@\n-    public int readAndProcess()\n-        throws WrappedRpcServerException, IOException, InterruptedException {\n-      while (true) {\n+    public int readAndProcess() throws IOException, InterruptedException {\n+      while (!shouldClose()) { // stop if a fatal response has been sent.\n         // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           // Every connection is expected to send the header;\n           // so far we read \"hrpc\" of the connection header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             // for the bytes that follow \"hrpc\", in the connection header\n             connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear(); // clear to next read rpc packet len\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue; // connection header read, now read  4 bytes rpc packet len\n         }\n         \n         if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           checkDataLength(dataLength);\n           // Set buffer for reading EXACTLY the RPC-packet length and no more.\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         // Now read the RPC packet\n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear(); // to read length of future rpc packets\n           data.flip();\n+          ByteBuffer requestData \u003d data;\n+          data \u003d null; // null out in case processOneRpc throws.\n           boolean isHeaderRead \u003d connectionContextRead;\n-          processOneRpc(data);\n-          data \u003d null;\n+          processOneRpc(requestData);\n           // the last rpc-request we processed could have simply been the\n           // connectionContext; if so continue to read the first RPC.\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n+      return -1;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (!shouldClose()) { // stop if a fatal response has been sent.\n        // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          // Every connection is expected to send the header;\n          // so far we read \"hrpc\" of the connection header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            // for the bytes that follow \"hrpc\", in the connection header\n            connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear(); // clear to next read rpc packet len\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue; // connection header read, now read  4 bytes rpc packet len\n        }\n        \n        if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          // Set buffer for reading EXACTLY the RPC-packet length and no more.\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        // Now read the RPC packet\n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear(); // to read length of future rpc packets\n          data.flip();\n          ByteBuffer requestData \u003d data;\n          data \u003d null; // null out in case processOneRpc throws.\n          boolean isHeaderRead \u003d connectionContextRead;\n          processOneRpc(requestData);\n          // the last rpc-request we processed could have simply been the\n          // connectionContext; if so continue to read the first RPC.\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n      return -1;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[WrappedRpcServerException, IOException, InterruptedException]",
            "newValue": "[IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,81 @@\n-    public int readAndProcess()\n-        throws WrappedRpcServerException, IOException, InterruptedException {\n-      while (true) {\n+    public int readAndProcess() throws IOException, InterruptedException {\n+      while (!shouldClose()) { // stop if a fatal response has been sent.\n         // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           // Every connection is expected to send the header;\n           // so far we read \"hrpc\" of the connection header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             // for the bytes that follow \"hrpc\", in the connection header\n             connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear(); // clear to next read rpc packet len\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue; // connection header read, now read  4 bytes rpc packet len\n         }\n         \n         if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           checkDataLength(dataLength);\n           // Set buffer for reading EXACTLY the RPC-packet length and no more.\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         // Now read the RPC packet\n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear(); // to read length of future rpc packets\n           data.flip();\n+          ByteBuffer requestData \u003d data;\n+          data \u003d null; // null out in case processOneRpc throws.\n           boolean isHeaderRead \u003d connectionContextRead;\n-          processOneRpc(data);\n-          data \u003d null;\n+          processOneRpc(requestData);\n           // the last rpc-request we processed could have simply been the\n           // connectionContext; if so continue to read the first RPC.\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n+      return -1;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (!shouldClose()) { // stop if a fatal response has been sent.\n        // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          // Every connection is expected to send the header;\n          // so far we read \"hrpc\" of the connection header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            // for the bytes that follow \"hrpc\", in the connection header\n            connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear(); // clear to next read rpc packet len\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue; // connection header read, now read  4 bytes rpc packet len\n        }\n        \n        if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          // Set buffer for reading EXACTLY the RPC-packet length and no more.\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        // Now read the RPC packet\n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear(); // to read length of future rpc packets\n          data.flip();\n          ByteBuffer requestData \u003d data;\n          data \u003d null; // null out in case processOneRpc throws.\n          boolean isHeaderRead \u003d connectionContextRead;\n          processOneRpc(requestData);\n          // the last rpc-request we processed could have simply been the\n          // connectionContext; if so continue to read the first RPC.\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n      return -1;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "580a8334963709e728ed677c815fb7fef9bca70e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "03/08/16 11:22 AM",
      "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "03/08/16 7:31 AM",
      "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n     public int readAndProcess()\n         throws WrappedRpcServerException, IOException, InterruptedException {\n       while (true) {\n         // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           // Every connection is expected to send the header;\n           // so far we read \"hrpc\" of the connection header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             // for the bytes that follow \"hrpc\", in the connection header\n             connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear(); // clear to next read rpc packet len\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue; // connection header read, now read  4 bytes rpc packet len\n         }\n         \n         if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           checkDataLength(dataLength);\n           // Set buffer for reading EXACTLY the RPC-packet length and no more.\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         // Now read the RPC packet\n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear(); // to read length of future rpc packets\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n-          processOneRpc(data.array());\n+          processOneRpc(data);\n           data \u003d null;\n           // the last rpc-request we processed could have simply been the\n           // connectionContext; if so continue to read the first RPC.\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess()\n        throws WrappedRpcServerException, IOException, InterruptedException {\n      while (true) {\n        // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          // Every connection is expected to send the header;\n          // so far we read \"hrpc\" of the connection header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            // for the bytes that follow \"hrpc\", in the connection header\n            connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear(); // clear to next read rpc packet len\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue; // connection header read, now read  4 bytes rpc packet len\n        }\n        \n        if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          // Set buffer for reading EXACTLY the RPC-packet length and no more.\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        // Now read the RPC packet\n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear(); // to read length of future rpc packets\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          processOneRpc(data);\n          data \u003d null;\n          // the last rpc-request we processed could have simply been the\n          // connectionContext; if so continue to read the first RPC.\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a4819e70dbf88b0905a6669078afa1ff0924ad4f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10044 Improve the javadoc of rpc code (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 10:56 AM",
      "commitName": "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "18/11/13 11:42 PM",
      "commitNameOld": "229472cea7920194c48f5294bf763a8bee2ade63",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 23.47,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,80 @@\n     public int readAndProcess()\n         throws WrappedRpcServerException, IOException, InterruptedException {\n       while (true) {\n-        /* Read at most one RPC. If the header is not read completely yet\n-         * then iterate until we read first RPC or until there is no data left.\n-         */    \n+        // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n-          //Every connection is expected to send the header.\n+          // Every connection is expected to send the header;\n+          // so far we read \"hrpc\" of the connection header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n-            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n+            // for the bytes that follow \"hrpc\", in the connection header\n+            connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n-          dataLengthBuffer.clear();\n+          dataLengthBuffer.clear(); // clear to next read rpc packet len\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n-          continue;\n+          continue; // connection header read, now read  4 bytes rpc packet len\n         }\n         \n-        if (data \u003d\u003d null) {\n+        if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           checkDataLength(dataLength);\n+          // Set buffer for reading EXACTLY the RPC-packet length and no more.\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n-        \n+        // Now read the RPC packet\n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n-          dataLengthBuffer.clear();\n+          dataLengthBuffer.clear(); // to read length of future rpc packets\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n           processOneRpc(data.array());\n           data \u003d null;\n+          // the last rpc-request we processed could have simply been the\n+          // connectionContext; if so continue to read the first RPC.\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess()\n        throws WrappedRpcServerException, IOException, InterruptedException {\n      while (true) {\n        // dataLengthBuffer is used to read \"hrpc\" or the rpc-packet length\n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          // Every connection is expected to send the header;\n          // so far we read \"hrpc\" of the connection header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            // for the bytes that follow \"hrpc\", in the connection header\n            connectionHeaderBuf \u003d ByteBuffer.allocate(HEADER_LEN_AFTER_HRPC_PART);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear(); // clear to next read rpc packet len\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue; // connection header read, now read  4 bytes rpc packet len\n        }\n        \n        if (data \u003d\u003d null) { // just read 4 bytes -  length of RPC packet\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          // Set buffer for reading EXACTLY the RPC-packet length and no more.\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        // Now read the RPC packet\n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear(); // to read length of future rpc packets\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          processOneRpc(data.array());\n          data \u003d null;\n          // the last rpc-request we processed could have simply been the\n          // connectionContext; if so continue to read the first RPC.\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "c03c8fe199429a43c6aa944016566738abd9b193": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9820. RPCv9 wire protocol is insufficient to support multiplexing. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/13 4:02 PM",
      "commitName": "c03c8fe199429a43c6aa944016566738abd9b193",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "05/08/13 4:01 PM",
      "commitNameOld": "63a1273f2a8e0b668ff70330262adedee63112d9",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n     public int readAndProcess()\n         throws WrappedRpcServerException, IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           checkDataLength(dataLength);\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n-          processRpcRequestPacket(data.array());\n+          processOneRpc(data.array());\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess()\n        throws WrappedRpcServerException, IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          processOneRpc(data.array());\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "63a1273f2a8e0b668ff70330262adedee63112d9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9832. Add RPC header to client ping (daryn)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510793 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/08/13 4:01 PM",
      "commitName": "63a1273f2a8e0b668ff70330262adedee63112d9",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "05/08/13 3:02 PM",
      "commitNameOld": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,77 @@\n     public int readAndProcess()\n         throws WrappedRpcServerException, IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n-          if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n-            // covers the !useSasl too\n-            dataLengthBuffer.clear();\n-            return 0; // ping message\n-          }\n           checkDataLength(dataLength);\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n           processRpcRequestPacket(data.array());\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess()\n        throws WrappedRpcServerException, IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          checkDataLength(dataLength);\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          processRpcRequestPacket(data.array());\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Yexceptionschange",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "24/07/13 12:48 AM",
      "commitNameOld": "a0a986dda77ea03dac9cfc7e0631bae611034ef4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.29,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,82 @@\n-    public int readAndProcess() throws IOException, InterruptedException {\n+    public int readAndProcess()\n+        throws WrappedRpcServerException, IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           checkDataLength(dataLength);\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n           processRpcRequestPacket(data.array());\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess()\n        throws WrappedRpcServerException, IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          checkDataLength(dataLength);\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          processRpcRequestPacket(data.array());\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldValue": "[IOException, InterruptedException]",
        "newValue": "[WrappedRpcServerException, IOException, InterruptedException]"
      }
    },
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 10:59 AM",
      "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "09/07/13 4:45 PM",
      "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 6.76,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,81 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n           \n           if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n               || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           checkDataLength(dataLength);\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n-          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n-            // switch to simple must ignore next negotiate or initiate\n-            if (skipInitialSaslHandshake) {\n-              authProtocol \u003d AuthProtocol.NONE;\n-            } else {\n-              saslReadAndProcess(data.array());\n-            }\n-          } else {\n-            processOneRpc(data.array());\n-          }\n+          processRpcRequestPacket(data.array());\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          checkDataLength(dataLength);\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          processRpcRequestPacket(data.array());\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "eb2a60338715e517ba8e4d32ecfe28691a882188": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9688. Add globally unique Client ID to RPC requests. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500843 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/07/13 10:08 AM",
      "commitName": "eb2a60338715e517ba8e4d32ecfe28691a882188",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "01/07/13 4:17 PM",
      "commitNameOld": "805e9b5b6d835d1b7a50af18967afb8eebdf8606",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,90 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n-        \n-          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n+          \n+          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n+              || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n-          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n+          if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           checkDataLength(dataLength);\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             // switch to simple must ignore next negotiate or initiate\n             if (skipInitialSaslHandshake) {\n               authProtocol \u003d AuthProtocol.NONE;\n             } else {\n               saslReadAndProcess(data.array());\n             }\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n          \n          if (!RpcConstants.HEADER.equals(dataLengthBuffer)\n              || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d RpcConstants.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          checkDataLength(dataLength);\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            // switch to simple must ignore next negotiate or initiate\n            if (skipInitialSaslHandshake) {\n              authProtocol \u003d AuthProtocol.NONE;\n            } else {\n              saslReadAndProcess(data.array());\n            }\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "805e9b5b6d835d1b7a50af18967afb8eebdf8606": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9676.  Make maximum RPC buffer size configurable (Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1498737 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/07/13 4:17 PM",
      "commitName": "805e9b5b6d835d1b7a50af18967afb8eebdf8606",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "25/06/13 5:42 PM",
      "commitNameOld": "b3a8d99817dcceb4d1125dec0c3ecbb0f15f6c76",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.94,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,89 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           // this may switch us into SIMPLE\n           authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n           dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n-          \n-          if (dataLength \u003c 0) {\n-            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n-                getHostAddress());\n-          }\n+          checkDataLength(dataLength);\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             // switch to simple must ignore next negotiate or initiate\n             if (skipInitialSaslHandshake) {\n               authProtocol \u003d AuthProtocol.NONE;\n             } else {\n               saslReadAndProcess(data.array());\n             }\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          checkDataLength(dataLength);\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            // switch to simple must ignore next negotiate or initiate\n            if (skipInitialSaslHandshake) {\n              authProtocol \u003d AuthProtocol.NONE;\n            } else {\n              saslReadAndProcess(data.array());\n            }\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "5f9b4c14a175873b4f82654513e289c657c694eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9421. [RPC v9] Convert SASL to use ProtoBuf and provide negotiation capabilities (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1495577 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/13 1:09 PM",
      "commitName": "5f9b4c14a175873b4f82654513e289c657c694eb",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "10/06/13 8:30 PM",
      "commitNameOld": "a841be808a780db0653b17bb702037f422c5b1ec",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 10.69,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,93 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n-\n-          byte[] method \u003d new byte[] {connectionHeaderBuf.get(2)};\n-          authMethod \u003d AuthMethod.read(new DataInputStream(\n-              new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n-          dataLengthBuffer.clear();\n-          if (authMethod \u003d\u003d null) {\n-            throw new IOException(\"Unable to read authentication method\");\n-          }\n-  \n-          // this may create a SASL server, or switch us into SIMPLE\n-          authMethod \u003d initializeAuthContext(authMethod);\n+          // this may switch us into SIMPLE\n+          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n           \n+          dataLengthBuffer.clear();\n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n-          if (skipInitialSaslHandshake) {\n-            data \u003d null;\n-            skipInitialSaslHandshake \u003d false;\n-            continue;\n-          }\n           boolean isHeaderRead \u003d connectionContextRead;\n-          if (saslServer !\u003d null) {\n-            saslReadAndProcess(data.array());\n+          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n+            // switch to simple must ignore next negotiate or initiate\n+            if (skipInitialSaslHandshake) {\n+              authProtocol \u003d AuthProtocol.NONE;\n+            } else {\n+              saslReadAndProcess(data.array());\n+            }\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          // this may switch us into SIMPLE\n          authProtocol \u003d initializeAuthContext(connectionHeaderBuf.get(2));          \n          \n          dataLengthBuffer.clear();\n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            // switch to simple must ignore next negotiate or initiate\n            if (skipInitialSaslHandshake) {\n              authProtocol \u003d AuthProtocol.NONE;\n            } else {\n              saslReadAndProcess(data.array());\n            }\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a841be808a780db0653b17bb702037f422c5b1ec": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9630. [RPC v9] Remove IpcSerializationType. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1491682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/13 8:30 PM",
      "commitName": "a841be808a780db0653b17bb702037f422c5b1ec",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "04/05/13 10:51 AM",
      "commitNameOld": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 37.4,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,101 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n-            connectionHeaderBuf \u003d ByteBuffer.allocate(4);\n+            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           // TODO we should add handler for service class later\n           this.setServiceClass(connectionHeaderBuf.get(1));\n \n           byte[] method \u003d new byte[] {connectionHeaderBuf.get(2)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n-          IpcSerializationType serializationType \u003d IpcSerializationType\n-              .fromByte(connectionHeaderBuf.get(3));\n-          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n-            respondUnsupportedSerialization(serializationType);\n-            return -1;\n-          }\n-          \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n   \n           // this may create a SASL server, or switch us into SIMPLE\n           authMethod \u003d initializeAuthContext(authMethod);\n           \n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (saslServer !\u003d null) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(2)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n  \n          // this may create a SASL server, or switch us into SIMPLE\n          authMethod \u003d initializeAuthContext(authMethod);\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (saslServer !\u003d null) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "5319818487d5c139de06155834deecb18c10b7a1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9194. RPC Support for QoS. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461370 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/13 4:29 PM",
      "commitName": "5319818487d5c139de06155834deecb18c10b7a1",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "21/03/13 9:41 AM",
      "commitNameOld": "357472001725e786f28b27560bac8aca54c3c983",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 5.28,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,108 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n-            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n+            connectionHeaderBuf \u003d ByteBuffer.allocate(4);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n-          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n+          // TODO we should add handler for service class later\n+          this.setServiceClass(connectionHeaderBuf.get(1));\n+\n+          byte[] method \u003d new byte[] {connectionHeaderBuf.get(2)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           IpcSerializationType serializationType \u003d IpcSerializationType\n-              .fromByte(connectionHeaderBuf.get(2));\n+              .fromByte(connectionHeaderBuf.get(3));\n           if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n             respondUnsupportedSerialization(serializationType);\n             return -1;\n           }\n           \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n   \n           // this may create a SASL server, or switch us into SIMPLE\n           authMethod \u003d initializeAuthContext(authMethod);\n           \n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (saslServer !\u003d null) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(4);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          // TODO we should add handler for service class later\n          this.setServiceClass(connectionHeaderBuf.get(1));\n\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(2)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          IpcSerializationType serializationType \u003d IpcSerializationType\n              .fromByte(connectionHeaderBuf.get(3));\n          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n            respondUnsupportedSerialization(serializationType);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n  \n          // this may create a SASL server, or switch us into SIMPLE\n          authMethod \u003d initializeAuthContext(authMethod);\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (saslServer !\u003d null) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "4755ef989ac771ad3c2c40f9914455725c931447": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9021. Enforce configured SASL method on the server (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1408473 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/11/12 2:13 PM",
      "commitName": "4755ef989ac771ad3c2c40f9914455725c931447",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "07/11/12 2:50 PM",
      "commitNameOld": "1594dd6965c412a08339a0079ee1416dd6f595f9",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,105 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           IpcSerializationType serializationType \u003d IpcSerializationType\n               .fromByte(connectionHeaderBuf.get(2));\n           if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n             respondUnsupportedSerialization(serializationType);\n             return -1;\n           }\n           \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n-          boolean useSaslServer \u003d isSecurityEnabled;\n-          final boolean clientUsingSasl;\n-          switch (authMethod) {\n-            case SIMPLE: { // no sasl for simple\n-              clientUsingSasl \u003d false;\n-              break;\n-            }\n-            case DIGEST: { // always allow tokens if there\u0027s a secret manager\n-              useSaslServer |\u003d (secretManager !\u003d null);\n-              clientUsingSasl \u003d true;\n-              break;\n-            }\n-            default: {\n-              clientUsingSasl \u003d true;\n-              break;\n-            }\n-          }\n-          if (useSaslServer) {\n-            saslServer \u003d createSaslServer(authMethod);\n-          } else if (clientUsingSasl) { // security is off\n-            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n-                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n-            authMethod \u003d AuthMethod.SIMPLE;\n-            // client has already sent the initial Sasl message and we\n-            // should ignore it. Both client and server should fall back\n-            // to simple auth from now on.\n-            skipInitialSaslHandshake \u003d true;\n-          }\n+  \n+          // this may create a SASL server, or switch us into SIMPLE\n+          authMethod \u003d initializeAuthContext(authMethod);\n           \n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (saslServer !\u003d null) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          IpcSerializationType serializationType \u003d IpcSerializationType\n              .fromByte(connectionHeaderBuf.get(2));\n          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n            respondUnsupportedSerialization(serializationType);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n  \n          // this may create a SASL server, or switch us into SIMPLE\n          authMethod \u003d initializeAuthContext(authMethod);\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (saslServer !\u003d null) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "1594dd6965c412a08339a0079ee1416dd6f595f9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9015. Standardize creation of SaslRpcServers (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/12 2:50 PM",
      "commitName": "1594dd6965c412a08339a0079ee1416dd6f595f9",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "05/11/12 10:37 AM",
      "commitNameOld": "b1aa62a848646f78e019c74186d9696e9101afcf",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,130 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           IpcSerializationType serializationType \u003d IpcSerializationType\n               .fromByte(connectionHeaderBuf.get(2));\n           if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n             respondUnsupportedSerialization(serializationType);\n             return -1;\n           }\n           \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n-          }          \n+          }\n+          boolean useSaslServer \u003d isSecurityEnabled;\n           final boolean clientUsingSasl;\n           switch (authMethod) {\n             case SIMPLE: { // no sasl for simple\n-              if (isSecurityEnabled) {\n-                AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n-                    + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n-                    + \") is enabled but authentication (\"\n-                    + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n-                    + \") is configured as simple. Please configure another method \"\n-                    + \"like kerberos or digest.\");\n-                setupResponse(authFailedResponse, authFailedCall, RpcStatusProto.FATAL,\n-                    null, ae.getClass().getName(), ae.getMessage());\n-                responder.doRespond(authFailedCall);\n-                throw ae;\n-              }\n               clientUsingSasl \u003d false;\n-              useSasl \u003d false; \n               break;\n             }\n-            case DIGEST: {\n+            case DIGEST: { // always allow tokens if there\u0027s a secret manager\n+              useSaslServer |\u003d (secretManager !\u003d null);\n               clientUsingSasl \u003d true;\n-              useSasl \u003d (secretManager !\u003d null);\n               break;\n             }\n             default: {\n               clientUsingSasl \u003d true;\n-              useSasl \u003d isSecurityEnabled; \n               break;\n             }\n-          }          \n-          if (clientUsingSasl \u0026\u0026 !useSasl) {\n+          }\n+          if (useSaslServer) {\n+            saslServer \u003d createSaslServer(authMethod);\n+          } else if (clientUsingSasl) { // security is off\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           \n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d connectionContextRead;\n-          if (useSasl) {\n+          if (saslServer !\u003d null) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          IpcSerializationType serializationType \u003d IpcSerializationType\n              .fromByte(connectionHeaderBuf.get(2));\n          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n            respondUnsupportedSerialization(serializationType);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          boolean useSaslServer \u003d isSecurityEnabled;\n          final boolean clientUsingSasl;\n          switch (authMethod) {\n            case SIMPLE: { // no sasl for simple\n              clientUsingSasl \u003d false;\n              break;\n            }\n            case DIGEST: { // always allow tokens if there\u0027s a secret manager\n              useSaslServer |\u003d (secretManager !\u003d null);\n              clientUsingSasl \u003d true;\n              break;\n            }\n            default: {\n              clientUsingSasl \u003d true;\n              break;\n            }\n          }\n          if (useSaslServer) {\n            saslServer \u003d createSaslServer(authMethod);\n          } else if (clientUsingSasl) { // security is off\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (saslServer !\u003d null) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a7d4f30131b374baaa1efba22c7ae8e80c000f45": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8783. Improve RPC.Server\u0027s digest auth (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1393483 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/12 6:43 AM",
      "commitName": "a7d4f30131b374baaa1efba22c7ae8e80c000f45",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "24/09/12 4:16 PM",
      "commitNameOld": "5308a0ecd5d2d31ac92122ed517e24449137184c",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 8.6,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,141 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           IpcSerializationType serializationType \u003d IpcSerializationType\n               .fromByte(connectionHeaderBuf.get(2));\n           if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n             respondUnsupportedSerialization(serializationType);\n             return -1;\n           }\n           \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n-          }\n-          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n-            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n-              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n-              + \") is enabled but authentication (\"\n-              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n-              + \") is configured as simple. Please configure another method \"\n-              + \"like kerberos or digest.\");\n-            setupResponse(authFailedResponse, authFailedCall, RpcStatusProto.FATAL,\n-                null, ae.getClass().getName(), ae.getMessage());\n-            responder.doRespond(authFailedCall);\n-            throw ae;\n-          }\n-          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n+          }          \n+          final boolean clientUsingSasl;\n+          switch (authMethod) {\n+            case SIMPLE: { // no sasl for simple\n+              if (isSecurityEnabled) {\n+                AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n+                    + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n+                    + \") is enabled but authentication (\"\n+                    + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n+                    + \") is configured as simple. Please configure another method \"\n+                    + \"like kerberos or digest.\");\n+                setupResponse(authFailedResponse, authFailedCall, RpcStatusProto.FATAL,\n+                    null, ae.getClass().getName(), ae.getMessage());\n+                responder.doRespond(authFailedCall);\n+                throw ae;\n+              }\n+              clientUsingSasl \u003d false;\n+              useSasl \u003d false; \n+              break;\n+            }\n+            case DIGEST: {\n+              clientUsingSasl \u003d true;\n+              useSasl \u003d (secretManager !\u003d null);\n+              break;\n+            }\n+            default: {\n+              clientUsingSasl \u003d true;\n+              useSasl \u003d isSecurityEnabled; \n+              break;\n+            }\n+          }          \n+          if (clientUsingSasl \u0026\u0026 !useSasl) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n-          if (authMethod !\u003d AuthMethod.SIMPLE) {\n-            useSasl \u003d true;\n-          }\n           \n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          IpcSerializationType serializationType \u003d IpcSerializationType\n              .fromByte(connectionHeaderBuf.get(2));\n          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n            respondUnsupportedSerialization(serializationType);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }          \n          final boolean clientUsingSasl;\n          switch (authMethod) {\n            case SIMPLE: { // no sasl for simple\n              if (isSecurityEnabled) {\n                AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n                    + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n                    + \") is enabled but authentication (\"\n                    + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n                    + \") is configured as simple. Please configure another method \"\n                    + \"like kerberos or digest.\");\n                setupResponse(authFailedResponse, authFailedCall, RpcStatusProto.FATAL,\n                    null, ae.getClass().getName(), ae.getMessage());\n                responder.doRespond(authFailedCall);\n                throw ae;\n              }\n              clientUsingSasl \u003d false;\n              useSasl \u003d false; \n              break;\n            }\n            case DIGEST: {\n              clientUsingSasl \u003d true;\n              useSasl \u003d (secretManager !\u003d null);\n              break;\n            }\n            default: {\n              clientUsingSasl \u003d true;\n              useSasl \u003d isSecurityEnabled; \n              break;\n            }\n          }          \n          if (clientUsingSasl \u0026\u0026 !useSasl) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8366 Use ProtoBuf for RpcResponseHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1337283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/05/12 9:56 AM",
      "commitName": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "02/05/12 11:35 PM",
      "commitNameOld": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 8.43,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,126 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n         if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n           if (connectionHeaderBuf \u003d\u003d null) {\n             connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n           count \u003d channelRead(channel, connectionHeaderBuf);\n           if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d connectionHeaderBuf.get(0);\n           byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           \n           IpcSerializationType serializationType \u003d IpcSerializationType\n               .fromByte(connectionHeaderBuf.get(2));\n           if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n             respondUnsupportedSerialization(serializationType);\n             return -1;\n           }\n           \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n               + \") is enabled but authentication (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n               + \") is configured as simple. Please configure another method \"\n               + \"like kerberos or digest.\");\n-            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n+            setupResponse(authFailedResponse, authFailedCall, RpcStatusProto.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           connectionHeaderBuf \u003d null;\n           connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d connectionContextRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          IpcSerializationType serializationType \u003d IpcSerializationType\n              .fromByte(connectionHeaderBuf.get(2));\n          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n            respondUnsupportedSerialization(serializationType);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n              + \") is enabled but authentication (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n              + \") is configured as simple. Please configure another method \"\n              + \"like kerberos or digest.\");\n            setupResponse(authFailedResponse, authFailedCall, RpcStatusProto.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7557 Make IPC header be extensible (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1295261 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/02/12 12:43 PM",
      "commitName": "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "23/02/12 8:05 PM",
      "commitNameOld": "22d5944c42b4bef5144a9f6426751b15717c5a3e",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 5.69,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,127 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n         \n-        if (!rpcHeaderRead) {\n+        if (!connectionHeaderRead) {\n           //Every connection is expected to send the header.\n-          if (rpcHeaderBuffer \u003d\u003d null) {\n-            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n+          if (connectionHeaderBuf \u003d\u003d null) {\n+            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n           }\n-          count \u003d channelRead(channel, rpcHeaderBuffer);\n-          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n+          count \u003d channelRead(channel, connectionHeaderBuf);\n+          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n             return count;\n           }\n-          int version \u003d rpcHeaderBuffer.get(0);\n-          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n+          int version \u003d connectionHeaderBuf.get(0);\n+          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();\n           \n           // Check if it looks like the user is hitting an IPC port\n           // with an HTTP GET - this is a common error, so we can\n           // send back a simple string indicating as much.\n           if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n             setupHttpRequestOnIpcPortResponse();\n             return -1;\n           }\n         \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n+          \n+          IpcSerializationType serializationType \u003d IpcSerializationType\n+              .fromByte(connectionHeaderBuf.get(2));\n+          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n+            respondUnsupportedSerialization(serializationType);\n+            return -1;\n+          }\n+          \n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n               + \") is enabled but authentication (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n               + \") is configured as simple. Please configure another method \"\n               + \"like kerberos or digest.\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n-          rpcHeaderBuffer \u003d null;\n-          rpcHeaderRead \u003d true;\n+          connectionHeaderBuf \u003d null;\n+          connectionHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n-          boolean isHeaderRead \u003d headerRead;\n+          boolean isHeaderRead \u003d connectionContextRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!connectionHeaderRead) {\n          //Every connection is expected to send the header.\n          if (connectionHeaderBuf \u003d\u003d null) {\n            connectionHeaderBuf \u003d ByteBuffer.allocate(3);\n          }\n          count \u003d channelRead(channel, connectionHeaderBuf);\n          if (count \u003c 0 || connectionHeaderBuf.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d connectionHeaderBuf.get(0);\n          byte[] method \u003d new byte[] {connectionHeaderBuf.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          \n          IpcSerializationType serializationType \u003d IpcSerializationType\n              .fromByte(connectionHeaderBuf.get(2));\n          if (serializationType !\u003d IpcSerializationType.PROTOBUF) {\n            respondUnsupportedSerialization(serializationType);\n            return -1;\n          }\n          \n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n              + \") is enabled but authentication (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n              + \") is configured as simple. Please configure another method \"\n              + \"like kerberos or digest.\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          connectionHeaderBuf \u003d null;\n          connectionHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d connectionContextRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a11f67fb7885f934de926bfe960ce77879b3cd8e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7729. Send back valid HTTP response if user hits IPC port with HTTP GET. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1183512 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/10/11 2:44 PM",
      "commitName": "a11f67fb7885f934de926bfe960ce77879b3cd8e",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/10/11 3:05 PM",
      "commitNameOld": "0c77d705be11b0e5844aaa2b96ef9660f02cb53a",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,119 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n-      \n+        \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n-          dataLengthBuffer.flip();          \n+          dataLengthBuffer.flip();\n+          \n+          // Check if it looks like the user is hitting an IPC port\n+          // with an HTTP GET - this is a common error, so we can\n+          // send back a simple string indicating as much.\n+          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n+            setupHttpRequestOnIpcPortResponse();\n+            return -1;\n+          }\n+        \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n               + \") is enabled but authentication (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n               + \") is configured as simple. Please configure another method \"\n               + \"like kerberos or digest.\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n        \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          \n          // Check if it looks like the user is hitting an IPC port\n          // with an HTTP GET - this is a common error, so we can\n          // send back a simple string indicating as much.\n          if (HTTP_GET_BYTES.equals(dataLengthBuffer)) {\n            setupHttpRequestOnIpcPortResponse();\n            return -1;\n          }\n        \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n              + \") is enabled but authentication (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n              + \") is configured as simple. Please configure another method \"\n              + \"like kerberos or digest.\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "0c77d705be11b0e5844aaa2b96ef9660f02cb53a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7545. Fix wrong variable name in exception message introduced in HADOOP-7509. Contributed by Ravi Prakash.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1183132 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/10/11 3:05 PM",
      "commitName": "0c77d705be11b0e5844aaa2b96ef9660f02cb53a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "12/10/11 8:23 PM",
      "commitNameOld": "3e6d128c83c76ed53c8eb643b2b7aca34ae1ba88",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n-              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n-              + \") is enabled but authentication (\"\n               + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n+              + \") is enabled but authentication (\"\n+              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n               + \") is configured as simple. Please configure another method \"\n               + \"like kerberos or digest.\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n              + \") is enabled but authentication (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n              + \") is configured as simple. Please configure another method \"\n              + \"like kerberos or digest.\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "3e6d128c83c76ed53c8eb643b2b7aca34ae1ba88": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7509. Improve exception message thrown when Authentication is required. Contributed by Ravi Prakash.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1182641 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/10/11 8:23 PM",
      "commitName": "3e6d128c83c76ed53c8eb643b2b7aca34ae1ba88",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "30/09/11 6:22 AM",
      "commitNameOld": "ebdc7f800a6c161696adb161b623a80ebaa743d7",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 12.58,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,110 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             setupBadVersionResponse(version);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n-            AccessControlException ae \u003d new AccessControlException(\n-                \"Authentication is required\");\n+            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n+              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n+              + \") is enabled but authentication (\"\n+              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n+              + \") is configured as simple. Please configure another method \"\n+              + \"like kerberos or digest.\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\"Authorization (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION\n              + \") is enabled but authentication (\"\n              + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION\n              + \") is configured as simple. Please configure another method \"\n              + \"like kerberos or digest.\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "90a926261184cbdbea4bd487918990d5875da440": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7346. Send back nicer error message to clients using outdated IPC version. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1131254 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/11 2:36 PM",
      "commitName": "90a926261184cbdbea4bd487918990d5875da440",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/05/11 7:00 PM",
      "commitNameOld": "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 2.82,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,106 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n+            setupBadVersionResponse(version);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\n                 \"Authentication is required\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            setupBadVersionResponse(version);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "8fa094ad6ad3b4f8a3102b79d4e36146f53abea8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6613. Moves the RPC version check ahead of the AuthMethod check. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@953910 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/10 5:13 PM",
      "commitName": "8fa094ad6ad3b4f8a3102b79d4e36146f53abea8",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "04/06/10 5:34 PM",
      "commitNameOld": "4b9c956bc56cec2c5b669102340d0912e0db3517",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 6.99,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,105 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n+          dataLengthBuffer.flip();          \n+          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n+            //Warning is ok since this is not supposed to happen.\n+            LOG.warn(\"Incorrect header or version mismatch from \" + \n+                     hostAddress + \":\" + remotePort +\n+                     \" got version \" + version + \n+                     \" expected version \" + CURRENT_VERSION);\n+            return -1;\n+          }\n+          dataLengthBuffer.clear();\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\n                 \"Authentication is required\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n-          dataLengthBuffer.flip();          \n-          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n-            //Warning is ok since this is not supposed to happen.\n-            LOG.warn(\"Incorrect header or version mismatch from \" + \n-                     hostAddress + \":\" + remotePort +\n-                     \" got version \" + version + \n-                     \" expected version \" + CURRENT_VERSION);\n-            return -1;\n-          }\n-          dataLengthBuffer.clear();\n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n             // covers the !useSasl too\n             dataLengthBuffer.clear();\n             return 0; // ping message\n           }\n           \n           if (dataLength \u003c 0) {\n             LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                 getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "4b9c956bc56cec2c5b669102340d0912e0db3517": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6674. Makes use of the SASL authentication options in the SASL RPC. Contributed by Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@951624 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/06/10 5:34 PM",
      "commitName": "4b9c956bc56cec2c5b669102340d0912e0db3517",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "26/05/10 1:31 PM",
      "commitNameOld": "24a2f1fafe2e13963c510cc04b3177c300af8aae",
      "commitAuthorOld": "Jakob Homan",
      "daysBetweenCommits": 9.17,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,105 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             AccessControlException ae \u003d new AccessControlException(\n                 \"Authentication is required\");\n             setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                 null, ae.getClass().getName(), ae.getMessage());\n             responder.doRespond(authFailedCall);\n             throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n             doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                 SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n-          if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n+          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n+            // covers the !useSasl too\n             dataLengthBuffer.clear();\n-            return 0;  //ping message\n+            return 0; // ping message\n+          }\n+          \n+          if (dataLength \u003c 0) {\n+            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n+                getHostAddress());\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if ((dataLength \u003d\u003d Client.PING_CALL_ID) \u0026\u0026 (!useWrap)) {\n            // covers the !useSasl too\n            dataLengthBuffer.clear();\n            return 0; // ping message\n          }\n          \n          if (dataLength \u003c 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" + \n                getHostAddress());\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6589. Provide better error messages when RPC authentication fails.\n(Kan Zhang via omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@916915 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/10 10:17 PM",
      "commitName": "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
      "commitAuthor": "Owen O\u0027Malley",
      "commitDateOld": "26/02/10 10:35 AM",
      "commitNameOld": "c4c122a0def592136e03a653c9fdc4f464ed0854",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,99 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n           if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n-            throw new IOException(\"Authentication is required\");\n+            AccessControlException ae \u003d new AccessControlException(\n+                \"Authentication is required\");\n+            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n+                null, ae.getClass().getName(), ae.getMessage());\n+            responder.doRespond(authFailedCall);\n+            throw ae;\n           }\n           if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n-            askClientToUseSimpleAuth();\n+            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n+                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n             authMethod \u003d AuthMethod.SIMPLE;\n             // client has already sent the initial Sasl message and we\n             // should ignore it. Both client and server should fall back\n             // to simple auth from now on.\n             skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n             dataLengthBuffer.clear();\n             return 0;  //ping message\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n           if (skipInitialSaslHandshake) {\n             data \u003d null;\n             skipInitialSaslHandshake \u003d false;\n             continue;\n           }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            AccessControlException ae \u003d new AccessControlException(\n                \"Authentication is required\");\n            setupResponse(authFailedResponse, authFailedCall, Status.FATAL,\n                null, ae.getClass().getName(), ae.getMessage());\n            responder.doRespond(authFailedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n            dataLengthBuffer.clear();\n            return 0;  //ping message\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6543. Allows secure clients to talk to unsecure clusters. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/10 2:28 PM",
      "commitName": "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "22/02/10 2:26 PM",
      "commitNameOld": "ffdde40b9f189cb30dee4c5187d63b61809f2d62",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,93 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n         if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n           if (rpcHeaderBuffer \u003d\u003d null) {\n             rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n           }\n           count \u003d channelRead(channel, rpcHeaderBuffer);\n           if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n           int version \u003d rpcHeaderBuffer.get(0);\n           byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n           authMethod \u003d AuthMethod.read(new DataInputStream(\n               new ByteArrayInputStream(method)));\n           if (authMethod \u003d\u003d null) {\n             throw new IOException(\"Unable to read authentication method\");\n           }\n-          if (UserGroupInformation.isSecurityEnabled()\n-              \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n+          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n             throw new IOException(\"Authentication is required\");\n-          } \n-          if (!UserGroupInformation.isSecurityEnabled()\n-              \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n-            throw new IOException(\"Authentication is not supported\");\n+          }\n+          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n+            askClientToUseSimpleAuth();\n+            authMethod \u003d AuthMethod.SIMPLE;\n+            // client has already sent the initial Sasl message and we\n+            // should ignore it. Both client and server should fall back\n+            // to simple auth from now on.\n+            skipInitialSaslHandshake \u003d true;\n           }\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             useSasl \u003d true;\n           }\n           \n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n           rpcHeaderBuffer \u003d null;\n           rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n           if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n             dataLengthBuffer.clear();\n             return 0;  //ping message\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n+          if (skipInitialSaslHandshake) {\n+            data \u003d null;\n+            skipInitialSaslHandshake \u003d false;\n+            continue;\n+          }\n           boolean isHeaderRead \u003d headerRead;\n           if (useSasl) {\n             saslReadAndProcess(data.array());\n           } else {\n             processOneRpc(data.array());\n           }\n           data \u003d null;\n           if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            throw new IOException(\"Authentication is required\");\n          }\n          if (!isSecurityEnabled \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            askClientToUseSimpleAuth();\n            authMethod \u003d AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake \u003d true;\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n            dataLengthBuffer.clear();\n            return 0;  //ping message\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data \u003d null;\n            skipInitialSaslHandshake \u003d false;\n            continue;\n          }\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "940389afce6a1b9b9e1519aed528cbc444786756": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/10 5:30 PM",
      "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "27/01/10 12:08 AM",
      "commitNameOld": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 6.72,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n     public int readAndProcess() throws IOException, InterruptedException {\n       while (true) {\n         /* Read at most one RPC. If the header is not read completely yet\n          * then iterate until we read first RPC or until there is no data left.\n          */    \n         int count \u003d -1;\n         if (dataLengthBuffer.remaining() \u003e 0) {\n           count \u003d channelRead(channel, dataLengthBuffer);       \n           if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n             return count;\n         }\n       \n-        if (!versionRead) {\n+        if (!rpcHeaderRead) {\n           //Every connection is expected to send the header.\n-          ByteBuffer versionBuffer \u003d ByteBuffer.allocate(1);\n-          count \u003d channelRead(channel, versionBuffer);\n-          if (count \u003c\u003d 0) {\n+          if (rpcHeaderBuffer \u003d\u003d null) {\n+            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n+          }\n+          count \u003d channelRead(channel, rpcHeaderBuffer);\n+          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n             return count;\n           }\n-          int version \u003d versionBuffer.get(0);\n+          int version \u003d rpcHeaderBuffer.get(0);\n+          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n+          authMethod \u003d AuthMethod.read(new DataInputStream(\n+              new ByteArrayInputStream(method)));\n+          if (authMethod \u003d\u003d null) {\n+            throw new IOException(\"Unable to read authentication method\");\n+          }\n+          if (UserGroupInformation.isSecurityEnabled()\n+              \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n+            throw new IOException(\"Authentication is required\");\n+          } \n+          if (!UserGroupInformation.isSecurityEnabled()\n+              \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n+            throw new IOException(\"Authentication is not supported\");\n+          }\n+          if (authMethod !\u003d AuthMethod.SIMPLE) {\n+            useSasl \u003d true;\n+          }\n           \n           dataLengthBuffer.flip();          \n           if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n             //Warning is ok since this is not supposed to happen.\n             LOG.warn(\"Incorrect header or version mismatch from \" + \n                      hostAddress + \":\" + remotePort +\n                      \" got version \" + version + \n                      \" expected version \" + CURRENT_VERSION);\n             return -1;\n           }\n           dataLengthBuffer.clear();\n-          versionRead \u003d true;\n+          rpcHeaderBuffer \u003d null;\n+          rpcHeaderRead \u003d true;\n           continue;\n         }\n         \n         if (data \u003d\u003d null) {\n           dataLengthBuffer.flip();\n           dataLength \u003d dataLengthBuffer.getInt();\n        \n-          if (dataLength \u003d\u003d Client.PING_CALL_ID) {\n+          if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n             dataLengthBuffer.clear();\n             return 0;  //ping message\n           }\n           data \u003d ByteBuffer.allocate(dataLength);\n-          incRpcCount();  // Increment the rpc count\n         }\n         \n         count \u003d channelRead(channel, data);\n         \n         if (data.remaining() \u003d\u003d 0) {\n           dataLengthBuffer.clear();\n           data.flip();\n-          if (headerRead) {\n-            processData();\n-            data \u003d null;\n-            return count;\n+          boolean isHeaderRead \u003d headerRead;\n+          if (useSasl) {\n+            saslReadAndProcess(data.array());\n           } else {\n-            processHeader();\n-            headerRead \u003d true;\n-            data \u003d null;\n-            \n-            // Authorize the connection\n-            try {\n-              authorize(user, header);\n-              \n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Successfully authorized \" + header);\n-              }\n-            } catch (AuthorizationException ae) {\n-              authFailedCall.connection \u003d this;\n-              setupResponse(authFailedResponse, authFailedCall, \n-                            Status.FATAL, null, \n-                            ae.getClass().getName(), ae.getMessage());\n-              responder.doRespond(authFailedCall);\n-              \n-              // Close this connection\n-              return -1;\n-            }\n-\n+            processOneRpc(data.array());\n+          }\n+          data \u003d null;\n+          if (!isHeaderRead) {\n             continue;\n           }\n         } \n         return count;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer \u003d\u003d null) {\n            rpcHeaderBuffer \u003d ByteBuffer.allocate(2);\n          }\n          count \u003d channelRead(channel, rpcHeaderBuffer);\n          if (count \u003c 0 || rpcHeaderBuffer.remaining() \u003e 0) {\n            return count;\n          }\n          int version \u003d rpcHeaderBuffer.get(0);\n          byte[] method \u003d new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod \u003d AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          if (authMethod \u003d\u003d null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (UserGroupInformation.isSecurityEnabled()\n              \u0026\u0026 authMethod \u003d\u003d AuthMethod.SIMPLE) {\n            throw new IOException(\"Authentication is required\");\n          } \n          if (!UserGroupInformation.isSecurityEnabled()\n              \u0026\u0026 authMethod !\u003d AuthMethod.SIMPLE) {\n            throw new IOException(\"Authentication is not supported\");\n          }\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            useSasl \u003d true;\n          }\n          \n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          rpcHeaderBuffer \u003d null;\n          rpcHeaderRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if (!useSasl \u0026\u0026 dataLength \u003d\u003d Client.PING_CALL_ID) {\n            dataLengthBuffer.clear();\n            return 0;  //ping message\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          boolean isHeaderRead \u003d headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data \u003d null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,85 @@\n+    public int readAndProcess() throws IOException, InterruptedException {\n+      while (true) {\n+        /* Read at most one RPC. If the header is not read completely yet\n+         * then iterate until we read first RPC or until there is no data left.\n+         */    \n+        int count \u003d -1;\n+        if (dataLengthBuffer.remaining() \u003e 0) {\n+          count \u003d channelRead(channel, dataLengthBuffer);       \n+          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n+            return count;\n+        }\n+      \n+        if (!versionRead) {\n+          //Every connection is expected to send the header.\n+          ByteBuffer versionBuffer \u003d ByteBuffer.allocate(1);\n+          count \u003d channelRead(channel, versionBuffer);\n+          if (count \u003c\u003d 0) {\n+            return count;\n+          }\n+          int version \u003d versionBuffer.get(0);\n+          \n+          dataLengthBuffer.flip();          \n+          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n+            //Warning is ok since this is not supposed to happen.\n+            LOG.warn(\"Incorrect header or version mismatch from \" + \n+                     hostAddress + \":\" + remotePort +\n+                     \" got version \" + version + \n+                     \" expected version \" + CURRENT_VERSION);\n+            return -1;\n+          }\n+          dataLengthBuffer.clear();\n+          versionRead \u003d true;\n+          continue;\n+        }\n+        \n+        if (data \u003d\u003d null) {\n+          dataLengthBuffer.flip();\n+          dataLength \u003d dataLengthBuffer.getInt();\n+       \n+          if (dataLength \u003d\u003d Client.PING_CALL_ID) {\n+            dataLengthBuffer.clear();\n+            return 0;  //ping message\n+          }\n+          data \u003d ByteBuffer.allocate(dataLength);\n+          incRpcCount();  // Increment the rpc count\n+        }\n+        \n+        count \u003d channelRead(channel, data);\n+        \n+        if (data.remaining() \u003d\u003d 0) {\n+          dataLengthBuffer.clear();\n+          data.flip();\n+          if (headerRead) {\n+            processData();\n+            data \u003d null;\n+            return count;\n+          } else {\n+            processHeader();\n+            headerRead \u003d true;\n+            data \u003d null;\n+            \n+            // Authorize the connection\n+            try {\n+              authorize(user, header);\n+              \n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Successfully authorized \" + header);\n+              }\n+            } catch (AuthorizationException ae) {\n+              authFailedCall.connection \u003d this;\n+              setupResponse(authFailedResponse, authFailedCall, \n+                            Status.FATAL, null, \n+                            ae.getClass().getName(), ae.getMessage());\n+              responder.doRespond(authFailedCall);\n+              \n+              // Close this connection\n+              return -1;\n+            }\n+\n+            continue;\n+          }\n+        } \n+        return count;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */    \n        int count \u003d -1;\n        if (dataLengthBuffer.remaining() \u003e 0) {\n          count \u003d channelRead(channel, dataLengthBuffer);       \n          if (count \u003c 0 || dataLengthBuffer.remaining() \u003e 0) \n            return count;\n        }\n      \n        if (!versionRead) {\n          //Every connection is expected to send the header.\n          ByteBuffer versionBuffer \u003d ByteBuffer.allocate(1);\n          count \u003d channelRead(channel, versionBuffer);\n          if (count \u003c\u003d 0) {\n            return count;\n          }\n          int version \u003d versionBuffer.get(0);\n          \n          dataLengthBuffer.flip();          \n          if (!HEADER.equals(dataLengthBuffer) || version !\u003d CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" + \n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version + \n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          versionRead \u003d true;\n          continue;\n        }\n        \n        if (data \u003d\u003d null) {\n          dataLengthBuffer.flip();\n          dataLength \u003d dataLengthBuffer.getInt();\n       \n          if (dataLength \u003d\u003d Client.PING_CALL_ID) {\n            dataLengthBuffer.clear();\n            return 0;  //ping message\n          }\n          data \u003d ByteBuffer.allocate(dataLength);\n          incRpcCount();  // Increment the rpc count\n        }\n        \n        count \u003d channelRead(channel, data);\n        \n        if (data.remaining() \u003d\u003d 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (headerRead) {\n            processData();\n            data \u003d null;\n            return count;\n          } else {\n            processHeader();\n            headerRead \u003d true;\n            data \u003d null;\n            \n            // Authorize the connection\n            try {\n              authorize(user, header);\n              \n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Successfully authorized \" + header);\n              }\n            } catch (AuthorizationException ae) {\n              authFailedCall.connection \u003d this;\n              setupResponse(authFailedResponse, authFailedCall, \n                            Status.FATAL, null, \n                            ae.getClass().getName(), ae.getMessage());\n              responder.doRespond(authFailedCall);\n              \n              // Close this connection\n              return -1;\n            }\n\n            continue;\n          }\n        } \n        return count;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}