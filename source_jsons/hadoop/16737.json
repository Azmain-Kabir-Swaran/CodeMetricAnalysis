{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterQuotaUpdateService.java",
  "functionName": "periodicInvoke",
  "functionId": "periodicInvoke",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
  "functionStartLine": 81,
  "functionEndLine": 140,
  "numCommitsSeen": 10,
  "timeTaken": 4685,
  "changeHistory": [
    "8730a7bf6025a3b2b7d6e6686533283b854af192",
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
    "12617fad2eb32108412dac9ecee286de6641d060",
    "761594549ec0c6bab50a28a7eb6c741aec7239d7",
    "b3fee1d2bfe5d289b8f279071589f21ace99e04c",
    "17a87977f29ced49724f561a68565217c8cb4e94",
    "3b637155a47d2aa93284969a96208347a647083d",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "d98a2e6e2383f8b66def346409b0517aa32d298d"
  ],
  "changeHistoryShort": {
    "8730a7bf6025a3b2b7d6e6686533283b854af192": "Ybodychange",
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619": "Ybodychange",
    "12617fad2eb32108412dac9ecee286de6641d060": "Ybodychange",
    "761594549ec0c6bab50a28a7eb6c741aec7239d7": "Ybodychange",
    "b3fee1d2bfe5d289b8f279071589f21ace99e04c": "Ybodychange",
    "17a87977f29ced49724f561a68565217c8cb4e94": "Ybodychange",
    "3b637155a47d2aa93284969a96208347a647083d": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "d98a2e6e2383f8b66def346409b0517aa32d298d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8730a7bf6025a3b2b7d6e6686533283b854af192": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15003. RBF: Make Router support storage type quota. Contributed by Jinglun.\n",
      "commitDate": "26/12/19 7:52 PM",
      "commitName": "8730a7bf6025a3b2b7d6e6686533283b854af192",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "04/12/19 2:19 AM",
      "commitNameOld": "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 22.73,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,60 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n       Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n+        long[] typeQuota \u003d new long[StorageType.values().length];\n+        Quota.eachByStorageType(\n+            t -\u003e typeQuota[t.ordinal()] \u003d oldQuota.getTypeQuota(t));\n \n         QuotaUsage currentQuotaUsage \u003d null;\n \n         // Check whether destination path exists in filesystem. When the\n         // mtime is zero, the destination is not present and reset the usage.\n         // This is because mount table does not have mtime.\n         // For other mount entry get current quota usage\n         HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n         if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n-          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n-              .fileAndDirectoryCount(0)\n-              .quota(nsQuota)\n-              .spaceConsumed(0)\n-              .spaceQuota(ssQuota).build();\n+          long[] zeroConsume \u003d new long[StorageType.values().length];\n+          currentQuotaUsage \u003d\n+              new RouterQuotaUsage.Builder().fileAndDirectoryCount(0)\n+                  .quota(nsQuota).spaceConsumed(0).spaceQuota(ssQuota)\n+                  .typeConsumed(zeroConsume)\n+                  .typeQuota(typeQuota).build();\n         } else {\n           // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n           // If any exception occurs catch it and proceed with other entries.\n           try {\n             Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n             Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                 quotaModule.getEachQuotaUsage(src);\n             currentQuotaUsage \u003d quotaModule.aggregateQuota(src, usageMap);\n             remoteQuotaUsage.putAll(usageMap);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to get quota usage for \" + src, ioe);\n             continue;\n           }\n         }\n \n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n       }\n \n       // Fix inconsistent quota.\n       for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n           .entrySet()) {\n         RemoteLocation remoteLocation \u003d en.getKey();\n         QuotaUsage currentQuota \u003d en.getValue();\n         fixGlobalQuota(remoteLocation, currentQuota);\n       }\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n        long[] typeQuota \u003d new long[StorageType.values().length];\n        Quota.eachByStorageType(\n            t -\u003e typeQuota[t.ordinal()] \u003d oldQuota.getTypeQuota(t));\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. When the\n        // mtime is zero, the destination is not present and reset the usage.\n        // This is because mount table does not have mtime.\n        // For other mount entry get current quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n          long[] zeroConsume \u003d new long[StorageType.values().length];\n          currentQuotaUsage \u003d\n              new RouterQuotaUsage.Builder().fileAndDirectoryCount(0)\n                  .quota(nsQuota).spaceConsumed(0).spaceQuota(ssQuota)\n                  .typeConsumed(zeroConsume)\n                  .typeQuota(typeQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n            Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                quotaModule.getEachQuotaUsage(src);\n            currentQuotaUsage \u003d quotaModule.aggregateQuota(src, usageMap);\n            remoteQuotaUsage.putAll(usageMap);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n      }\n\n      // Fix inconsistent quota.\n      for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n          .entrySet()) {\n        RemoteLocation remoteLocation \u003d en.getKey();\n        QuotaUsage currentQuota \u003d en.getValue();\n        fixGlobalQuota(remoteLocation, currentQuota);\n      }\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13811. RBF: Race condition between router admin quota update and periodic quota update service. Contributed by Jinglun.\n",
      "commitDate": "04/12/19 2:19 AM",
      "commitName": "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "18/11/19 2:34 AM",
      "commitNameOld": "12617fad2eb32108412dac9ecee286de6641d060",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 15.99,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,56 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n-      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n       Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n \n         QuotaUsage currentQuotaUsage \u003d null;\n \n         // Check whether destination path exists in filesystem. When the\n         // mtime is zero, the destination is not present and reset the usage.\n         // This is because mount table does not have mtime.\n         // For other mount entry get current quota usage\n         HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n         if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n           currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n               .fileAndDirectoryCount(0)\n               .quota(nsQuota)\n               .spaceConsumed(0)\n               .spaceQuota(ssQuota).build();\n         } else {\n           // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n           // If any exception occurs catch it and proceed with other entries.\n           try {\n             Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n             Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                 quotaModule.getEachQuotaUsage(src);\n             currentQuotaUsage \u003d quotaModule.aggregateQuota(src, usageMap);\n             remoteQuotaUsage.putAll(usageMap);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to get quota usage for \" + src, ioe);\n             continue;\n           }\n         }\n \n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n-\n-        // only update mount tables which quota was changed\n-        if (!oldQuota.equals(newQuota)) {\n-          updateMountTables.add(entry);\n-\n-          LOG.debug(\n-              \"Update quota usage entity of path: {}, nsCount: {},\"\n-                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n-              src, newQuota.getFileAndDirectoryCount(),\n-              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n-              newQuota.getSpaceQuota());\n-        }\n       }\n \n       // Fix inconsistent quota.\n       for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n           .entrySet()) {\n         RemoteLocation remoteLocation \u003d en.getKey();\n         QuotaUsage currentQuota \u003d en.getValue();\n         fixGlobalQuota(remoteLocation, currentQuota);\n       }\n-\n-      updateMountTableEntries(updateMountTables);\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. When the\n        // mtime is zero, the destination is not present and reset the usage.\n        // This is because mount table does not have mtime.\n        // For other mount entry get current quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n              .fileAndDirectoryCount(0)\n              .quota(nsQuota)\n              .spaceConsumed(0)\n              .spaceQuota(ssQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n            Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                quotaModule.getEachQuotaUsage(src);\n            currentQuotaUsage \u003d quotaModule.aggregateQuota(src, usageMap);\n            remoteQuotaUsage.putAll(usageMap);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n      }\n\n      // Fix inconsistent quota.\n      for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n          .entrySet()) {\n        RemoteLocation remoteLocation \u003d en.getKey();\n        QuotaUsage currentQuota \u003d en.getValue();\n        fixGlobalQuota(remoteLocation, currentQuota);\n      }\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "12617fad2eb32108412dac9ecee286de6641d060": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14955. RBF: getQuotaUsage() on mount point should return global quota. Contributed by Jinglun.\n",
      "commitDate": "18/11/19 2:34 AM",
      "commitName": "12617fad2eb32108412dac9ecee286de6641d060",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "08/10/19 1:31 AM",
      "commitNameOld": "761594549ec0c6bab50a28a7eb6c741aec7239d7",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 41.09,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n       List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n       Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n \n         QuotaUsage currentQuotaUsage \u003d null;\n \n         // Check whether destination path exists in filesystem. When the\n         // mtime is zero, the destination is not present and reset the usage.\n         // This is because mount table does not have mtime.\n         // For other mount entry get current quota usage\n         HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n         if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n           currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n               .fileAndDirectoryCount(0)\n               .quota(nsQuota)\n               .spaceConsumed(0)\n               .spaceQuota(ssQuota).build();\n         } else {\n           // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n           // If any exception occurs catch it and proceed with other entries.\n           try {\n             Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n             Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                 quotaModule.getEachQuotaUsage(src);\n-            currentQuotaUsage \u003d quotaModule.aggregateQuota(usageMap);\n+            currentQuotaUsage \u003d quotaModule.aggregateQuota(src, usageMap);\n             remoteQuotaUsage.putAll(usageMap);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to get quota usage for \" + src, ioe);\n             continue;\n           }\n         }\n \n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n \n         // only update mount tables which quota was changed\n         if (!oldQuota.equals(newQuota)) {\n           updateMountTables.add(entry);\n \n           LOG.debug(\n               \"Update quota usage entity of path: {}, nsCount: {},\"\n                   + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n               src, newQuota.getFileAndDirectoryCount(),\n               newQuota.getQuota(), newQuota.getSpaceConsumed(),\n               newQuota.getSpaceQuota());\n         }\n       }\n \n       // Fix inconsistent quota.\n       for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n           .entrySet()) {\n         RemoteLocation remoteLocation \u003d en.getKey();\n         QuotaUsage currentQuota \u003d en.getValue();\n         fixGlobalQuota(remoteLocation, currentQuota);\n       }\n \n       updateMountTableEntries(updateMountTables);\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. When the\n        // mtime is zero, the destination is not present and reset the usage.\n        // This is because mount table does not have mtime.\n        // For other mount entry get current quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n              .fileAndDirectoryCount(0)\n              .quota(nsQuota)\n              .spaceConsumed(0)\n              .spaceQuota(ssQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n            Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                quotaModule.getEachQuotaUsage(src);\n            currentQuotaUsage \u003d quotaModule.aggregateQuota(src, usageMap);\n            remoteQuotaUsage.putAll(usageMap);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      // Fix inconsistent quota.\n      for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n          .entrySet()) {\n        RemoteLocation remoteLocation \u003d en.getKey();\n        QuotaUsage currentQuota \u003d en.getValue();\n        fixGlobalQuota(remoteLocation, currentQuota);\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "761594549ec0c6bab50a28a7eb6c741aec7239d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14814. RBF: RouterQuotaUpdateService supports inherited rule. Contributed by Jinglun.\n",
      "commitDate": "08/10/19 1:31 AM",
      "commitName": "761594549ec0c6bab50a28a7eb6c741aec7239d7",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "221f24cbdc7e6477ec11bb9d98c9298d6fccf3ad",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 105.67,
      "commitsBetweenForRepo": 929,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n       List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n+      Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n \n         QuotaUsage currentQuotaUsage \u003d null;\n \n         // Check whether destination path exists in filesystem. When the\n         // mtime is zero, the destination is not present and reset the usage.\n         // This is because mount table does not have mtime.\n         // For other mount entry get current quota usage\n         HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n         if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n           currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n               .fileAndDirectoryCount(0)\n               .quota(nsQuota)\n               .spaceConsumed(0)\n               .spaceQuota(ssQuota).build();\n         } else {\n           // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n           // If any exception occurs catch it and proceed with other entries.\n           try {\n-            currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n-                .getQuotaUsage(src);\n+            Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n+            Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n+                quotaModule.getEachQuotaUsage(src);\n+            currentQuotaUsage \u003d quotaModule.aggregateQuota(usageMap);\n+            remoteQuotaUsage.putAll(usageMap);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to get quota usage for \" + src, ioe);\n             continue;\n           }\n         }\n \n-        // If quota is not set in some subclusters under federation path,\n-        // set quota for this path.\n-        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_RESET) {\n-          try {\n-            this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n-          } catch (IOException ioe) {\n-            LOG.error(\"Unable to set quota at remote location for \"\n-                + src, ioe);\n-          }\n-        }\n-\n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n \n         // only update mount tables which quota was changed\n         if (!oldQuota.equals(newQuota)) {\n           updateMountTables.add(entry);\n \n           LOG.debug(\n               \"Update quota usage entity of path: {}, nsCount: {},\"\n                   + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n               src, newQuota.getFileAndDirectoryCount(),\n               newQuota.getQuota(), newQuota.getSpaceConsumed(),\n               newQuota.getSpaceQuota());\n         }\n       }\n \n+      // Fix inconsistent quota.\n+      for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n+          .entrySet()) {\n+        RemoteLocation remoteLocation \u003d en.getKey();\n+        QuotaUsage currentQuota \u003d en.getValue();\n+        fixGlobalQuota(remoteLocation, currentQuota);\n+      }\n+\n       updateMountTableEntries(updateMountTables);\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      Map\u003cRemoteLocation, QuotaUsage\u003e remoteQuotaUsage \u003d new HashMap\u003c\u003e();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. When the\n        // mtime is zero, the destination is not present and reset the usage.\n        // This is because mount table does not have mtime.\n        // For other mount entry get current quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n              .fileAndDirectoryCount(0)\n              .quota(nsQuota)\n              .spaceConsumed(0)\n              .spaceQuota(ssQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            Quota quotaModule \u003d this.rpcServer.getQuotaModule();\n            Map\u003cRemoteLocation, QuotaUsage\u003e usageMap \u003d\n                quotaModule.getEachQuotaUsage(src);\n            currentQuotaUsage \u003d quotaModule.aggregateQuota(usageMap);\n            remoteQuotaUsage.putAll(usageMap);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      // Fix inconsistent quota.\n      for (Entry\u003cRemoteLocation, QuotaUsage\u003e en : remoteQuotaUsage\n          .entrySet()) {\n        RemoteLocation remoteLocation \u003d en.getKey();\n        QuotaUsage currentQuota \u003d en.getValue();\n        fixGlobalQuota(remoteLocation, currentQuota);\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "b3fee1d2bfe5d289b8f279071589f21ace99e04c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14011. RBF: Add more information to HdfsFileStatus for a mount point. Contributed by Akira Ajisaka.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "b3fee1d2bfe5d289b8f279071589f21ace99e04c",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "23/07/18 8:15 PM",
      "commitNameOld": "17a87977f29ced49724f561a68565217c8cb4e94",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 335.55,
      "commitsBetweenForRepo": 2554,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,70 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n       List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n \n         QuotaUsage currentQuotaUsage \u003d null;\n \n-        // Check whether destination path exists in filesystem. If destination\n-        // is not present, reset the usage. For other mount entry get current\n-        // quota usage\n+        // Check whether destination path exists in filesystem. When the\n+        // mtime is zero, the destination is not present and reset the usage.\n+        // This is because mount table does not have mtime.\n+        // For other mount entry get current quota usage\n         HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n-        if (ret \u003d\u003d null) {\n+        if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n           currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n               .fileAndDirectoryCount(0)\n               .quota(nsQuota)\n               .spaceConsumed(0)\n               .spaceQuota(ssQuota).build();\n         } else {\n           // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n           // If any exception occurs catch it and proceed with other entries.\n           try {\n             currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n                 .getQuotaUsage(src);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to get quota usage for \" + src, ioe);\n             continue;\n           }\n         }\n \n         // If quota is not set in some subclusters under federation path,\n         // set quota for this path.\n         if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_RESET) {\n           try {\n             this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to set quota at remote location for \"\n                 + src, ioe);\n           }\n         }\n \n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n \n         // only update mount tables which quota was changed\n         if (!oldQuota.equals(newQuota)) {\n           updateMountTables.add(entry);\n \n           LOG.debug(\n               \"Update quota usage entity of path: {}, nsCount: {},\"\n                   + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n               src, newQuota.getFileAndDirectoryCount(),\n               newQuota.getQuota(), newQuota.getSpaceConsumed(),\n               newQuota.getSpaceQuota());\n         }\n       }\n \n       updateMountTableEntries(updateMountTables);\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. When the\n        // mtime is zero, the destination is not present and reset the usage.\n        // This is because mount table does not have mtime.\n        // For other mount entry get current quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null || ret.getModificationTime() \u003d\u003d 0) {\n          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n              .fileAndDirectoryCount(0)\n              .quota(nsQuota)\n              .spaceConsumed(0)\n              .spaceQuota(ssQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n                .getQuotaUsage(src);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        // If quota is not set in some subclusters under federation path,\n        // set quota for this path.\n        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_RESET) {\n          try {\n            this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to set quota at remote location for \"\n                + src, ioe);\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "17a87977f29ced49724f561a68565217c8cb4e94": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13583. RBF: Router admin clrQuota is not synchronized with nameservice. Contributed by Dibyendu Karmakar.\n",
      "commitDate": "23/07/18 8:15 PM",
      "commitName": "17a87977f29ced49724f561a68565217c8cb4e94",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "04/07/18 12:03 AM",
      "commitNameOld": "3b637155a47d2aa93284969a96208347a647083d",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 19.84,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n       List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n \n         QuotaUsage currentQuotaUsage \u003d null;\n \n         // Check whether destination path exists in filesystem. If destination\n         // is not present, reset the usage. For other mount entry get current\n         // quota usage\n         HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n         if (ret \u003d\u003d null) {\n           currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n               .fileAndDirectoryCount(0)\n               .quota(nsQuota)\n               .spaceConsumed(0)\n               .spaceQuota(ssQuota).build();\n         } else {\n           // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n           // If any exception occurs catch it and proceed with other entries.\n           try {\n             currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n                 .getQuotaUsage(src);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to get quota usage for \" + src, ioe);\n             continue;\n           }\n         }\n \n         // If quota is not set in some subclusters under federation path,\n         // set quota for this path.\n-        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_DONT_SET) {\n+        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_RESET) {\n           try {\n             this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n           } catch (IOException ioe) {\n             LOG.error(\"Unable to set quota at remote location for \"\n                 + src, ioe);\n           }\n         }\n \n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n \n         // only update mount tables which quota was changed\n         if (!oldQuota.equals(newQuota)) {\n           updateMountTables.add(entry);\n \n           LOG.debug(\n               \"Update quota usage entity of path: {}, nsCount: {},\"\n                   + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n               src, newQuota.getFileAndDirectoryCount(),\n               newQuota.getQuota(), newQuota.getSpaceConsumed(),\n               newQuota.getSpaceQuota());\n         }\n       }\n \n       updateMountTableEntries(updateMountTables);\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. If destination\n        // is not present, reset the usage. For other mount entry get current\n        // quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null) {\n          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n              .fileAndDirectoryCount(0)\n              .quota(nsQuota)\n              .spaceConsumed(0)\n              .spaceQuota(ssQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n                .getQuotaUsage(src);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        // If quota is not set in some subclusters under federation path,\n        // set quota for this path.\n        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_RESET) {\n          try {\n            this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to set quota at remote location for \"\n                + src, ioe);\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "3b637155a47d2aa93284969a96208347a647083d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13528. RBF: If a directory exceeds quota limit then quota usage is not refreshed for other mount entries. Contributed by Dibyendu Karmakar.\n",
      "commitDate": "04/07/18 12:03 AM",
      "commitName": "3b637155a47d2aa93284969a96208347a647083d",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "19/03/18 10:13 PM",
      "commitNameOld": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthorOld": "weiy",
      "daysBetweenCommits": 106.08,
      "commitsBetweenForRepo": 1368,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,69 @@\n   protected void periodicInvoke() {\n     LOG.debug(\"Start to update quota cache.\");\n     try {\n       List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n       List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n       for (MountTable entry : mountTables) {\n         String src \u003d entry.getSourcePath();\n         RouterQuotaUsage oldQuota \u003d entry.getQuota();\n         long nsQuota \u003d oldQuota.getQuota();\n         long ssQuota \u003d oldQuota.getSpaceQuota();\n-        // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n-        QuotaUsage currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n-            .getQuotaUsage(src);\n+\n+        QuotaUsage currentQuotaUsage \u003d null;\n+\n+        // Check whether destination path exists in filesystem. If destination\n+        // is not present, reset the usage. For other mount entry get current\n+        // quota usage\n+        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n+        if (ret \u003d\u003d null) {\n+          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n+              .fileAndDirectoryCount(0)\n+              .quota(nsQuota)\n+              .spaceConsumed(0)\n+              .spaceQuota(ssQuota).build();\n+        } else {\n+          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n+          // If any exception occurs catch it and proceed with other entries.\n+          try {\n+            currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n+                .getQuotaUsage(src);\n+          } catch (IOException ioe) {\n+            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n+            continue;\n+          }\n+        }\n+\n         // If quota is not set in some subclusters under federation path,\n         // set quota for this path.\n         if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_DONT_SET) {\n-          this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n+          try {\n+            this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n+          } catch (IOException ioe) {\n+            LOG.error(\"Unable to set quota at remote location for \"\n+                + src, ioe);\n+          }\n         }\n \n         RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n             currentQuotaUsage);\n         this.quotaManager.put(src, newQuota);\n         entry.setQuota(newQuota);\n \n         // only update mount tables which quota was changed\n         if (!oldQuota.equals(newQuota)) {\n           updateMountTables.add(entry);\n \n           LOG.debug(\n               \"Update quota usage entity of path: {}, nsCount: {},\"\n                   + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n               src, newQuota.getFileAndDirectoryCount(),\n               newQuota.getQuota(), newQuota.getSpaceConsumed(),\n               newQuota.getSpaceQuota());\n         }\n       }\n \n       updateMountTableEntries(updateMountTables);\n     } catch (IOException e) {\n       LOG.error(\"Quota cache updated error.\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n\n        QuotaUsage currentQuotaUsage \u003d null;\n\n        // Check whether destination path exists in filesystem. If destination\n        // is not present, reset the usage. For other mount entry get current\n        // quota usage\n        HdfsFileStatus ret \u003d this.rpcServer.getFileInfo(src);\n        if (ret \u003d\u003d null) {\n          currentQuotaUsage \u003d new RouterQuotaUsage.Builder()\n              .fileAndDirectoryCount(0)\n              .quota(nsQuota)\n              .spaceConsumed(0)\n              .spaceQuota(ssQuota).build();\n        } else {\n          // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n          // If any exception occurs catch it and proceed with other entries.\n          try {\n            currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n                .getQuotaUsage(src);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to get quota usage for \" + src, ioe);\n            continue;\n          }\n        }\n\n        // If quota is not set in some subclusters under federation path,\n        // set quota for this path.\n        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_DONT_SET) {\n          try {\n            this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n          } catch (IOException ioe) {\n            LOG.error(\"Unable to set quota at remote location for \"\n                + src, ioe);\n          }\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n        // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n        QuotaUsage currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n            .getQuotaUsage(src);\n        // If quota is not set in some subclusters under federation path,\n        // set quota for this path.\n        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_DONT_SET) {\n          this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java"
      }
    },
    "d98a2e6e2383f8b66def346409b0517aa32d298d": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12934. RBF: Federation supports global quota. Contributed by Yiqun Lin.\n",
      "commitDate": "09/01/18 9:59 PM",
      "commitName": "d98a2e6e2383f8b66def346409b0517aa32d298d",
      "commitAuthor": "Yiqun Lin",
      "diff": "@@ -0,0 +1,42 @@\n+  protected void periodicInvoke() {\n+    LOG.debug(\"Start to update quota cache.\");\n+    try {\n+      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n+      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n+      for (MountTable entry : mountTables) {\n+        String src \u003d entry.getSourcePath();\n+        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n+        long nsQuota \u003d oldQuota.getQuota();\n+        long ssQuota \u003d oldQuota.getSpaceQuota();\n+        // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n+        QuotaUsage currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n+            .getQuotaUsage(src);\n+        // If quota is not set in some subclusters under federation path,\n+        // set quota for this path.\n+        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_DONT_SET) {\n+          this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n+        }\n+\n+        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n+            currentQuotaUsage);\n+        this.quotaManager.put(src, newQuota);\n+        entry.setQuota(newQuota);\n+\n+        // only update mount tables which quota was changed\n+        if (!oldQuota.equals(newQuota)) {\n+          updateMountTables.add(entry);\n+\n+          LOG.debug(\n+              \"Update quota usage entity of path: {}, nsCount: {},\"\n+                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n+              src, newQuota.getFileAndDirectoryCount(),\n+              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n+              newQuota.getSpaceQuota());\n+        }\n+      }\n+\n+      updateMountTableEntries(updateMountTables);\n+    } catch (IOException e) {\n+      LOG.error(\"Quota cache updated error.\", e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void periodicInvoke() {\n    LOG.debug(\"Start to update quota cache.\");\n    try {\n      List\u003cMountTable\u003e updateMountTables \u003d new LinkedList\u003c\u003e();\n      List\u003cMountTable\u003e mountTables \u003d getQuotaSetMountTables();\n      for (MountTable entry : mountTables) {\n        String src \u003d entry.getSourcePath();\n        RouterQuotaUsage oldQuota \u003d entry.getQuota();\n        long nsQuota \u003d oldQuota.getQuota();\n        long ssQuota \u003d oldQuota.getSpaceQuota();\n        // Call RouterRpcServer#getQuotaUsage for getting current quota usage.\n        QuotaUsage currentQuotaUsage \u003d this.rpcServer.getQuotaModule()\n            .getQuotaUsage(src);\n        // If quota is not set in some subclusters under federation path,\n        // set quota for this path.\n        if (currentQuotaUsage.getQuota() \u003d\u003d HdfsConstants.QUOTA_DONT_SET) {\n          this.rpcServer.setQuota(src, nsQuota, ssQuota, null);\n        }\n\n        RouterQuotaUsage newQuota \u003d generateNewQuota(oldQuota,\n            currentQuotaUsage);\n        this.quotaManager.put(src, newQuota);\n        entry.setQuota(newQuota);\n\n        // only update mount tables which quota was changed\n        if (!oldQuota.equals(newQuota)) {\n          updateMountTables.add(entry);\n\n          LOG.debug(\n              \"Update quota usage entity of path: {}, nsCount: {},\"\n                  + \" nsQuota: {}, ssCount: {}, ssQuota: {}.\",\n              src, newQuota.getFileAndDirectoryCount(),\n              newQuota.getQuota(), newQuota.getSpaceConsumed(),\n              newQuota.getSpaceQuota());\n        }\n      }\n\n      updateMountTableEntries(updateMountTables);\n    } catch (IOException e) {\n      LOG.error(\"Quota cache updated error.\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterQuotaUpdateService.java"
    }
  }
}