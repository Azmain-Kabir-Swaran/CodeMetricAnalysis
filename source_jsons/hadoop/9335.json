{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "createEncryptionZone",
  "functionId": "createEncryptionZone___src-String(modifiers-final)__keyName-String(modifiers-final)__logRetryCache-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 7786,
  "functionEndLine": 7814,
  "numCommitsSeen": 1340,
  "timeTaken": 34111,
  "changeHistory": [
    "1824aee9da4056de0fb638906b2172e486bbebe7",
    "4b95c242eca540455a4d5d0899aaf73b6064b5ea",
    "6020505943fbb6133f7c2747e6d85d79cde788ea",
    "5527d79adb9b1e2f2779c283f81d6a3d5447babc",
    "be6c8014e66be919388269b70cb2966c35b8c578",
    "84a1321f6aa0af6895564a7c47f8f264656f0294",
    "9b90e52f1ec22c18cd535af2a569defcef65b093",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "71a81b6257c0000475ad62eb69292a20d45d269c",
    "e97f8e44af9dffc42c030278425cffe0c9da723b",
    "8e253cb93030642f5a7324bad0f161cd0ad33206",
    "d3d3d47202a18749eeebec22db759c19dd3e232c",
    "1737950d0fc83c68f386881b843c41b0b1e342de"
  ],
  "changeHistoryShort": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": "Ybodychange",
    "4b95c242eca540455a4d5d0899aaf73b6064b5ea": "Ybodychange",
    "6020505943fbb6133f7c2747e6d85d79cde788ea": "Ybodychange",
    "5527d79adb9b1e2f2779c283f81d6a3d5447babc": "Ybodychange",
    "be6c8014e66be919388269b70cb2966c35b8c578": "Ybodychange",
    "84a1321f6aa0af6895564a7c47f8f264656f0294": "Ybodychange",
    "9b90e52f1ec22c18cd535af2a569defcef65b093": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ybodychange",
    "71a81b6257c0000475ad62eb69292a20d45d269c": "Ybodychange",
    "e97f8e44af9dffc42c030278425cffe0c9da723b": "Ybodychange",
    "8e253cb93030642f5a7324bad0f161cd0ad33206": "Ymultichange(Yparameterchange,Ybodychange)",
    "d3d3d47202a18749eeebec22db759c19dd3e232c": "Ybodychange",
    "1737950d0fc83c68f386881b843c41b0b1e342de": "Ybodychange"
  },
  "changeHistoryDetails": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15217 Add more information to longest write/read lock held log\n\n",
      "commitDate": "18/04/20 1:52 PM",
      "commitName": "1824aee9da4056de0fb638906b2172e486bbebe7",
      "commitAuthor": "Toshihiro Suzuki",
      "commitDateOld": "25/03/20 10:28 AM",
      "commitNameOld": "a700803a18fb957d2799001a2ce1dcb70f75c080",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 24.14,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n-    final FileStatus resultingStat;\n+    FileStatus resultingStat \u003d null;\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       final FSPermissionChecker pc \u003d getPermissionChecker();\n       FSPermissionChecker.setOperationType(operationName);\n       checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       writeLock();\n       try {\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n-        writeUnlock(operationName);\n+        writeUnlock(operationName,\n+            getLockReportInfoSupplier(src, null, resultingStat));\n       }\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n     getEditLog().logSync();\n     logAuditEvent(true, operationName, src, null, resultingStat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    FileStatus resultingStat \u003d null;\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      final FSPermissionChecker pc \u003d getPermissionChecker();\n      FSPermissionChecker.setOperationType(operationName);\n      checkSuperuserPrivilege(pc);\n      checkOperation(OperationCategory.WRITE);\n      writeLock();\n      try {\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName,\n            getLockReportInfoSupplier(src, null, resultingStat));\n      }\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n    getEditLog().logSync();\n    logAuditEvent(true, operationName, src, null, resultingStat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "4b95c242eca540455a4d5d0899aaf73b6064b5ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14743. Enhance INodeAttributeProvider/ AccessControlEnforcer Interface in HDFS to support Authorization of mkdir, rm, rmdir, copy, move etc... (#1829)\n\nReviewed-by: Xiaoyu Yao \u003cxyao@apache.org\u003e",
      "commitDate": "13/03/20 11:29 AM",
      "commitName": "4b95c242eca540455a4d5d0899aaf73b6064b5ea",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "27/02/20 8:49 AM",
      "commitNameOld": "cd2c6b1aac470991b9b90339ce2721ba179e7c48",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 15.07,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,28 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n     final FileStatus resultingStat;\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       final FSPermissionChecker pc \u003d getPermissionChecker();\n+      FSPermissionChecker.setOperationType(operationName);\n       checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       writeLock();\n       try {\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n         writeUnlock(operationName);\n       }\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n     getEditLog().logSync();\n     logAuditEvent(true, operationName, src, null, resultingStat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    final FileStatus resultingStat;\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      final FSPermissionChecker pc \u003d getPermissionChecker();\n      FSPermissionChecker.setOperationType(operationName);\n      checkSuperuserPrivilege(pc);\n      checkOperation(OperationCategory.WRITE);\n      writeLock();\n      try {\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n    getEditLog().logSync();\n    logAuditEvent(true, operationName, src, null, resultingStat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "6020505943fbb6133f7c2747e6d85d79cde788ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14915. Move Superuser Check Before Taking Lock For Encryption API. Contributed by Ayush Saxena.\n",
      "commitDate": "22/10/19 6:14 AM",
      "commitName": "6020505943fbb6133f7c2747e6d85d79cde788ea",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "21/10/19 5:31 PM",
      "commitNameOld": "72003b19bf4c652b53625984d109542abd0cf20e",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n     final FileStatus resultingStat;\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       final FSPermissionChecker pc \u003d getPermissionChecker();\n+      checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       writeLock();\n       try {\n-        checkSuperuserPrivilege(pc);\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n         writeUnlock(operationName);\n       }\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n     getEditLog().logSync();\n     logAuditEvent(true, operationName, src, null, resultingStat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    final FileStatus resultingStat;\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      final FSPermissionChecker pc \u003d getPermissionChecker();\n      checkSuperuserPrivilege(pc);\n      checkOperation(OperationCategory.WRITE);\n      writeLock();\n      try {\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n    getEditLog().logSync();\n    logAuditEvent(true, operationName, src, null, resultingStat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5527d79adb9b1e2f2779c283f81d6a3d5447babc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14810. Review FSNameSystem editlog sync. Contributed by Xiaoqiao He.\n",
      "commitDate": "17/10/19 9:26 AM",
      "commitName": "5527d79adb9b1e2f2779c283f81d6a3d5447babc",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "06/09/19 5:42 AM",
      "commitNameOld": "d98c54816d21d59c4d877ae4b1917b22268ffcef",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 41.16,
      "commitsBetweenForRepo": 321,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,27 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n+    final FileStatus resultingStat;\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       final FSPermissionChecker pc \u003d getPermissionChecker();\n       checkOperation(OperationCategory.WRITE);\n-      final FileStatus resultingStat;\n       writeLock();\n       try {\n         checkSuperuserPrivilege(pc);\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n         writeUnlock(operationName);\n       }\n-\n-      getEditLog().logSync();\n-      logAuditEvent(true, operationName, src, null, resultingStat);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n+    getEditLog().logSync();\n+    logAuditEvent(true, operationName, src, null, resultingStat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    final FileStatus resultingStat;\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      final FSPermissionChecker pc \u003d getPermissionChecker();\n      checkOperation(OperationCategory.WRITE);\n      writeLock();\n      try {\n        checkSuperuserPrivilege(pc);\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n    getEditLog().logSync();\n    logAuditEvent(true, operationName, src, null, resultingStat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "be6c8014e66be919388269b70cb2966c35b8c578": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14418. Remove redundant super user priveledge checks from namenode. Contributed by Ayush Saxena.\n",
      "commitDate": "16/04/19 10:34 AM",
      "commitName": "be6c8014e66be919388269b70cb2966c35b8c578",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "05/04/19 4:09 PM",
      "commitNameOld": "e9b859f749103dc15fb4b4fc677f5586fceb20b3",
      "commitAuthorOld": "Shweta",
      "daysBetweenCommits": 10.77,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,28 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       final FSPermissionChecker pc \u003d getPermissionChecker();\n-      checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       final FileStatus resultingStat;\n       writeLock();\n       try {\n         checkSuperuserPrivilege(pc);\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n         writeUnlock(operationName);\n       }\n \n       getEditLog().logSync();\n       logAuditEvent(true, operationName, src, null, resultingStat);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      final FSPermissionChecker pc \u003d getPermissionChecker();\n      checkOperation(OperationCategory.WRITE);\n      final FileStatus resultingStat;\n      writeLock();\n      try {\n        checkSuperuserPrivilege(pc);\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n\n      getEditLog().logSync();\n      logAuditEvent(true, operationName, src, null, resultingStat);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "84a1321f6aa0af6895564a7c47f8f264656f0294": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13136. Avoid taking FSN lock while doing group member lookup for FSD permission check. Contributed by Xiaoyu Yao.\n",
      "commitDate": "22/02/18 11:32 AM",
      "commitName": "84a1321f6aa0af6895564a7c47f8f264656f0294",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "15/02/18 1:32 PM",
      "commitNameOld": "47473952e56b0380147d42f4110ad03c2276c961",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n-      checkSuperuserPrivilege();\n-      FSPermissionChecker pc \u003d getPermissionChecker();\n+      final FSPermissionChecker pc \u003d getPermissionChecker();\n+      checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       final FileStatus resultingStat;\n       writeLock();\n       try {\n-        checkSuperuserPrivilege();\n+        checkSuperuserPrivilege(pc);\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n         writeUnlock(operationName);\n       }\n \n       getEditLog().logSync();\n       logAuditEvent(true, operationName, src, null, resultingStat);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      final FSPermissionChecker pc \u003d getPermissionChecker();\n      checkSuperuserPrivilege(pc);\n      checkOperation(OperationCategory.WRITE);\n      final FileStatus resultingStat;\n      writeLock();\n      try {\n        checkSuperuserPrivilege(pc);\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n\n      getEditLog().logSync();\n      logAuditEvent(true, operationName, src, null, resultingStat);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9b90e52f1ec22c18cd535af2a569defcef65b093": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11641. Reduce cost of audit logging by using FileStatus instead of HdfsFileStatus. Contributed by Daryn Sharp.\n",
      "commitDate": "16/05/17 9:28 AM",
      "commitName": "9b90e52f1ec22c18cd535af2a569defcef65b093",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/05/17 11:39 AM",
      "commitNameOld": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 11.91,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n     final String operationName \u003d \"createEncryptionZone\";\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       checkSuperuserPrivilege();\n       FSPermissionChecker pc \u003d getPermissionChecker();\n       checkOperation(OperationCategory.WRITE);\n-      final HdfsFileStatus resultingStat;\n+      final FileStatus resultingStat;\n       writeLock();\n       try {\n         checkSuperuserPrivilege();\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n         writeUnlock(operationName);\n       }\n \n       getEditLog().logSync();\n       logAuditEvent(true, operationName, src, null, resultingStat);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, operationName, src);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      checkSuperuserPrivilege();\n      FSPermissionChecker pc \u003d getPermissionChecker();\n      checkOperation(OperationCategory.WRITE);\n      final FileStatus resultingStat;\n      writeLock();\n      try {\n        checkSuperuserPrivilege();\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n\n      getEditLog().logSync();\n      logAuditEvent(true, operationName, src, null, resultingStat);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "08/11/16 6:17 PM",
      "commitNameOld": "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n   void createEncryptionZone(final String src, final String keyName,\n       boolean logRetryCache) throws IOException, UnresolvedLinkException,\n           SafeModeException, AccessControlException {\n+    final String operationName \u003d \"createEncryptionZone\";\n     try {\n       Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n           keyName, src);\n       checkSuperuserPrivilege();\n       FSPermissionChecker pc \u003d getPermissionChecker();\n       checkOperation(OperationCategory.WRITE);\n       final HdfsFileStatus resultingStat;\n       writeLock();\n       try {\n         checkSuperuserPrivilege();\n         checkOperation(OperationCategory.WRITE);\n         checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n         resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n             pc, metadata.getCipher(), keyName, logRetryCache);\n       } finally {\n-        writeUnlock();\n+        writeUnlock(operationName);\n       }\n \n       getEditLog().logSync();\n-      logAuditEvent(true, \"createEncryptionZone\", src, null, resultingStat);\n+      logAuditEvent(true, operationName, src, null, resultingStat);\n     } catch (AccessControlException e) {\n-      logAuditEvent(false, \"createEncryptionZone\", src);\n+      logAuditEvent(false, operationName, src);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    final String operationName \u003d \"createEncryptionZone\";\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      checkSuperuserPrivilege();\n      FSPermissionChecker pc \u003d getPermissionChecker();\n      checkOperation(OperationCategory.WRITE);\n      final HdfsFileStatus resultingStat;\n      writeLock();\n      try {\n        checkSuperuserPrivilege();\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock(operationName);\n      }\n\n      getEditLog().logSync();\n      logAuditEvent(true, operationName, src, null, resultingStat);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, operationName, src);\n      throw e;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "71a81b6257c0000475ad62eb69292a20d45d269c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7529. Consolidate encryption zone related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "24/09/15 8:34 AM",
      "commitName": "71a81b6257c0000475ad62eb69292a20d45d269c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "23/09/15 2:58 AM",
      "commitNameOld": "a2c76e5f26301d4b01e56b347442f3dec171591d",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,28 @@\n   void createEncryptionZone(final String src, final String keyName,\n-                            boolean logRetryCache)\n-    throws IOException, UnresolvedLinkException,\n-      SafeModeException, AccessControlException {\n+      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n+          SafeModeException, AccessControlException {\n     try {\n-      if (provider \u003d\u003d null) {\n-        throw new IOException(\n-            \"Can\u0027t create an encryption zone for \" + src +\n-            \" since no key provider is available.\");\n+      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n+          keyName, src);\n+      checkSuperuserPrivilege();\n+      FSPermissionChecker pc \u003d getPermissionChecker();\n+      checkOperation(OperationCategory.WRITE);\n+      final HdfsFileStatus resultingStat;\n+      writeLock();\n+      try {\n+        checkSuperuserPrivilege();\n+        checkOperation(OperationCategory.WRITE);\n+        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n+        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n+            pc, metadata.getCipher(), keyName, logRetryCache);\n+      } finally {\n+        writeUnlock();\n       }\n-      if (keyName \u003d\u003d null || keyName.isEmpty()) {\n-        throw new IOException(\"Must specify a key name when creating an \" +\n-            \"encryption zone\");\n-      }\n-      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n-      if (metadata \u003d\u003d null) {\n-        /*\n-         * It would be nice if we threw something more specific than\n-         * IOException when the key is not found, but the KeyProvider API\n-         * doesn\u0027t provide for that. If that API is ever changed to throw\n-         * something more specific (e.g. UnknownKeyException) then we can\n-         * update this to match it, or better yet, just rethrow the\n-         * KeyProvider\u0027s exception.\n-         */\n-        throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n-      }\n-      // If the provider supports pool for EDEKs, this will fill in the pool\n-      provider.warmUpEncryptedKeys(keyName);\n-      createEncryptionZoneInt(src, metadata.getCipher(),\n-          keyName, logRetryCache);\n+\n+      getEditLog().logSync();\n+      logAuditEvent(true, \"createEncryptionZone\", src, null, resultingStat);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, \"createEncryptionZone\", src);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n      boolean logRetryCache) throws IOException, UnresolvedLinkException,\n          SafeModeException, AccessControlException {\n    try {\n      Metadata metadata \u003d FSDirEncryptionZoneOp.ensureKeyIsInitialized(dir,\n          keyName, src);\n      checkSuperuserPrivilege();\n      FSPermissionChecker pc \u003d getPermissionChecker();\n      checkOperation(OperationCategory.WRITE);\n      final HdfsFileStatus resultingStat;\n      writeLock();\n      try {\n        checkSuperuserPrivilege();\n        checkOperation(OperationCategory.WRITE);\n        checkNameNodeSafeMode(\"Cannot create encryption zone on \" + src);\n        resultingStat \u003d FSDirEncryptionZoneOp.createEncryptionZone(dir, src,\n            pc, metadata.getCipher(), keyName, logRetryCache);\n      } finally {\n        writeUnlock();\n      }\n\n      getEditLog().logSync();\n      logAuditEvent(true, \"createEncryptionZone\", src, null, resultingStat);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, \"createEncryptionZone\", src);\n      throw e;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "e97f8e44af9dffc42c030278425cffe0c9da723b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8004. Use KeyProviderCryptoExtension#warmUpEncryptedKeys when creating an encryption zone. (awang via asuresh)\n",
      "commitDate": "27/03/15 7:23 PM",
      "commitName": "e97f8e44af9dffc42c030278425cffe0c9da723b",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "25/03/15 10:38 AM",
      "commitNameOld": "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.37,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   void createEncryptionZone(final String src, final String keyName,\n                             boolean logRetryCache)\n     throws IOException, UnresolvedLinkException,\n       SafeModeException, AccessControlException {\n     try {\n       if (provider \u003d\u003d null) {\n         throw new IOException(\n             \"Can\u0027t create an encryption zone for \" + src +\n             \" since no key provider is available.\");\n       }\n       if (keyName \u003d\u003d null || keyName.isEmpty()) {\n         throw new IOException(\"Must specify a key name when creating an \" +\n             \"encryption zone\");\n       }\n       KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n       if (metadata \u003d\u003d null) {\n         /*\n          * It would be nice if we threw something more specific than\n          * IOException when the key is not found, but the KeyProvider API\n          * doesn\u0027t provide for that. If that API is ever changed to throw\n          * something more specific (e.g. UnknownKeyException) then we can\n          * update this to match it, or better yet, just rethrow the\n          * KeyProvider\u0027s exception.\n          */\n         throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n       }\n       // If the provider supports pool for EDEKs, this will fill in the pool\n-      generateEncryptedDataEncryptionKey(keyName);\n+      provider.warmUpEncryptedKeys(keyName);\n       createEncryptionZoneInt(src, metadata.getCipher(),\n           keyName, logRetryCache);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, \"createEncryptionZone\", src);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n                            boolean logRetryCache)\n    throws IOException, UnresolvedLinkException,\n      SafeModeException, AccessControlException {\n    try {\n      if (provider \u003d\u003d null) {\n        throw new IOException(\n            \"Can\u0027t create an encryption zone for \" + src +\n            \" since no key provider is available.\");\n      }\n      if (keyName \u003d\u003d null || keyName.isEmpty()) {\n        throw new IOException(\"Must specify a key name when creating an \" +\n            \"encryption zone\");\n      }\n      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n      if (metadata \u003d\u003d null) {\n        /*\n         * It would be nice if we threw something more specific than\n         * IOException when the key is not found, but the KeyProvider API\n         * doesn\u0027t provide for that. If that API is ever changed to throw\n         * something more specific (e.g. UnknownKeyException) then we can\n         * update this to match it, or better yet, just rethrow the\n         * KeyProvider\u0027s exception.\n         */\n        throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n      }\n      // If the provider supports pool for EDEKs, this will fill in the pool\n      provider.warmUpEncryptedKeys(keyName);\n      createEncryptionZoneInt(src, metadata.getCipher(),\n          keyName, logRetryCache);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, \"createEncryptionZone\", src);\n      throw e;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "8e253cb93030642f5a7324bad0f161cd0ad33206": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7412. Move RetryCache to NameNodeRpcServer. Contributed by Haohui Mai.\n",
      "commitDate": "24/11/14 11:11 AM",
      "commitName": "8e253cb93030642f5a7324bad0f161cd0ad33206",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7412. Move RetryCache to NameNodeRpcServer. Contributed by Haohui Mai.\n",
          "commitDate": "24/11/14 11:11 AM",
          "commitName": "8e253cb93030642f5a7324bad0f161cd0ad33206",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "24/11/14 10:46 AM",
          "commitNameOld": "daacbc18d739d030822df0b75205eeb067f89850",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,35 @@\n-  void createEncryptionZone(final String src, final String keyName)\n+  void createEncryptionZone(final String src, final String keyName,\n+                            boolean logRetryCache)\n     throws IOException, UnresolvedLinkException,\n       SafeModeException, AccessControlException {\n-    final CacheEntry cacheEntry \u003d RetryCache.waitForCompletion(retryCache);\n-    if (cacheEntry !\u003d null \u0026\u0026 cacheEntry.isSuccess()) {\n-      return; // Return previous response\n-    }\n-\n-    boolean success \u003d false;\n     try {\n       if (provider \u003d\u003d null) {\n         throw new IOException(\n             \"Can\u0027t create an encryption zone for \" + src +\n             \" since no key provider is available.\");\n       }\n       if (keyName \u003d\u003d null || keyName.isEmpty()) {\n         throw new IOException(\"Must specify a key name when creating an \" +\n             \"encryption zone\");\n       }\n       KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n       if (metadata \u003d\u003d null) {\n         /*\n          * It would be nice if we threw something more specific than\n          * IOException when the key is not found, but the KeyProvider API\n          * doesn\u0027t provide for that. If that API is ever changed to throw\n          * something more specific (e.g. UnknownKeyException) then we can\n          * update this to match it, or better yet, just rethrow the\n          * KeyProvider\u0027s exception.\n          */\n         throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n       }\n       // If the provider supports pool for EDEKs, this will fill in the pool\n       generateEncryptedDataEncryptionKey(keyName);\n       createEncryptionZoneInt(src, metadata.getCipher(),\n-          keyName, cacheEntry !\u003d null);\n-      success \u003d true;\n+          keyName, logRetryCache);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, \"createEncryptionZone\", src);\n       throw e;\n-    } finally {\n-      RetryCache.setState(cacheEntry, success);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n                            boolean logRetryCache)\n    throws IOException, UnresolvedLinkException,\n      SafeModeException, AccessControlException {\n    try {\n      if (provider \u003d\u003d null) {\n        throw new IOException(\n            \"Can\u0027t create an encryption zone for \" + src +\n            \" since no key provider is available.\");\n      }\n      if (keyName \u003d\u003d null || keyName.isEmpty()) {\n        throw new IOException(\"Must specify a key name when creating an \" +\n            \"encryption zone\");\n      }\n      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n      if (metadata \u003d\u003d null) {\n        /*\n         * It would be nice if we threw something more specific than\n         * IOException when the key is not found, but the KeyProvider API\n         * doesn\u0027t provide for that. If that API is ever changed to throw\n         * something more specific (e.g. UnknownKeyException) then we can\n         * update this to match it, or better yet, just rethrow the\n         * KeyProvider\u0027s exception.\n         */\n        throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n      }\n      // If the provider supports pool for EDEKs, this will fill in the pool\n      generateEncryptedDataEncryptionKey(keyName);\n      createEncryptionZoneInt(src, metadata.getCipher(),\n          keyName, logRetryCache);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, \"createEncryptionZone\", src);\n      throw e;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[src-String(modifiers-final), keyName-String(modifiers-final)]",
            "newValue": "[src-String(modifiers-final), keyName-String(modifiers-final), logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7412. Move RetryCache to NameNodeRpcServer. Contributed by Haohui Mai.\n",
          "commitDate": "24/11/14 11:11 AM",
          "commitName": "8e253cb93030642f5a7324bad0f161cd0ad33206",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "24/11/14 10:46 AM",
          "commitNameOld": "daacbc18d739d030822df0b75205eeb067f89850",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,35 @@\n-  void createEncryptionZone(final String src, final String keyName)\n+  void createEncryptionZone(final String src, final String keyName,\n+                            boolean logRetryCache)\n     throws IOException, UnresolvedLinkException,\n       SafeModeException, AccessControlException {\n-    final CacheEntry cacheEntry \u003d RetryCache.waitForCompletion(retryCache);\n-    if (cacheEntry !\u003d null \u0026\u0026 cacheEntry.isSuccess()) {\n-      return; // Return previous response\n-    }\n-\n-    boolean success \u003d false;\n     try {\n       if (provider \u003d\u003d null) {\n         throw new IOException(\n             \"Can\u0027t create an encryption zone for \" + src +\n             \" since no key provider is available.\");\n       }\n       if (keyName \u003d\u003d null || keyName.isEmpty()) {\n         throw new IOException(\"Must specify a key name when creating an \" +\n             \"encryption zone\");\n       }\n       KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n       if (metadata \u003d\u003d null) {\n         /*\n          * It would be nice if we threw something more specific than\n          * IOException when the key is not found, but the KeyProvider API\n          * doesn\u0027t provide for that. If that API is ever changed to throw\n          * something more specific (e.g. UnknownKeyException) then we can\n          * update this to match it, or better yet, just rethrow the\n          * KeyProvider\u0027s exception.\n          */\n         throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n       }\n       // If the provider supports pool for EDEKs, this will fill in the pool\n       generateEncryptedDataEncryptionKey(keyName);\n       createEncryptionZoneInt(src, metadata.getCipher(),\n-          keyName, cacheEntry !\u003d null);\n-      success \u003d true;\n+          keyName, logRetryCache);\n     } catch (AccessControlException e) {\n       logAuditEvent(false, \"createEncryptionZone\", src);\n       throw e;\n-    } finally {\n-      RetryCache.setState(cacheEntry, success);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void createEncryptionZone(final String src, final String keyName,\n                            boolean logRetryCache)\n    throws IOException, UnresolvedLinkException,\n      SafeModeException, AccessControlException {\n    try {\n      if (provider \u003d\u003d null) {\n        throw new IOException(\n            \"Can\u0027t create an encryption zone for \" + src +\n            \" since no key provider is available.\");\n      }\n      if (keyName \u003d\u003d null || keyName.isEmpty()) {\n        throw new IOException(\"Must specify a key name when creating an \" +\n            \"encryption zone\");\n      }\n      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n      if (metadata \u003d\u003d null) {\n        /*\n         * It would be nice if we threw something more specific than\n         * IOException when the key is not found, but the KeyProvider API\n         * doesn\u0027t provide for that. If that API is ever changed to throw\n         * something more specific (e.g. UnknownKeyException) then we can\n         * update this to match it, or better yet, just rethrow the\n         * KeyProvider\u0027s exception.\n         */\n        throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n      }\n      // If the provider supports pool for EDEKs, this will fill in the pool\n      generateEncryptedDataEncryptionKey(keyName);\n      createEncryptionZoneInt(src, metadata.getCipher(),\n          keyName, logRetryCache);\n    } catch (AccessControlException e) {\n      logAuditEvent(false, \"createEncryptionZone\", src);\n      throw e;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "d3d3d47202a18749eeebec22db759c19dd3e232c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7209. Populate EDEK cache when creating encryption zone. (Yi Liu via wang)\n",
      "commitDate": "10/10/14 1:40 PM",
      "commitName": "d3d3d47202a18749eeebec22db759c19dd3e232c",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "06/10/14 2:01 AM",
      "commitNameOld": "ed841dd9a96e54cb84d9cae5507e47ff1c8cdf6e",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 4.49,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,43 @@\n   void createEncryptionZone(final String src, final String keyName)\n     throws IOException, UnresolvedLinkException,\n       SafeModeException, AccessControlException {\n     final CacheEntry cacheEntry \u003d RetryCache.waitForCompletion(retryCache);\n     if (cacheEntry !\u003d null \u0026\u0026 cacheEntry.isSuccess()) {\n       return; // Return previous response\n     }\n \n     boolean success \u003d false;\n     try {\n       if (provider \u003d\u003d null) {\n         throw new IOException(\n             \"Can\u0027t create an encryption zone for \" + src +\n             \" since no key provider is available.\");\n       }\n       if (keyName \u003d\u003d null || keyName.isEmpty()) {\n         throw new IOException(\"Must specify a key name when creating an \" +\n             \"encryption zone\");\n       }\n       KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n       if (metadata \u003d\u003d null) {\n         /*\n          * It would be nice if we threw something more specific than\n          * IOException when the key is not found, but the KeyProvider API\n          * doesn\u0027t provide for that. If that API is ever changed to throw\n          * something more specific (e.g. UnknownKeyException) then we can\n          * update this to match it, or better yet, just rethrow the\n          * KeyProvider\u0027s exception.\n          */\n         throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n       }\n+      // If the provider supports pool for EDEKs, this will fill in the pool\n+      generateEncryptedDataEncryptionKey(keyName);\n       createEncryptionZoneInt(src, metadata.getCipher(),\n           keyName, cacheEntry !\u003d null);\n       success \u003d true;\n     } catch (AccessControlException e) {\n       logAuditEvent(false, \"createEncryptionZone\", src);\n       throw e;\n     } finally {\n       RetryCache.setState(cacheEntry, success);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName)\n    throws IOException, UnresolvedLinkException,\n      SafeModeException, AccessControlException {\n    final CacheEntry cacheEntry \u003d RetryCache.waitForCompletion(retryCache);\n    if (cacheEntry !\u003d null \u0026\u0026 cacheEntry.isSuccess()) {\n      return; // Return previous response\n    }\n\n    boolean success \u003d false;\n    try {\n      if (provider \u003d\u003d null) {\n        throw new IOException(\n            \"Can\u0027t create an encryption zone for \" + src +\n            \" since no key provider is available.\");\n      }\n      if (keyName \u003d\u003d null || keyName.isEmpty()) {\n        throw new IOException(\"Must specify a key name when creating an \" +\n            \"encryption zone\");\n      }\n      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n      if (metadata \u003d\u003d null) {\n        /*\n         * It would be nice if we threw something more specific than\n         * IOException when the key is not found, but the KeyProvider API\n         * doesn\u0027t provide for that. If that API is ever changed to throw\n         * something more specific (e.g. UnknownKeyException) then we can\n         * update this to match it, or better yet, just rethrow the\n         * KeyProvider\u0027s exception.\n         */\n        throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n      }\n      // If the provider supports pool for EDEKs, this will fill in the pool\n      generateEncryptedDataEncryptionKey(keyName);\n      createEncryptionZoneInt(src, metadata.getCipher(),\n          keyName, cacheEntry !\u003d null);\n      success \u003d true;\n    } catch (AccessControlException e) {\n      logAuditEvent(false, \"createEncryptionZone\", src);\n      throw e;\n    } finally {\n      RetryCache.setState(cacheEntry, success);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1737950d0fc83c68f386881b843c41b0b1e342de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6987. Move CipherSuite xattr information up to the encryption zone root. Contributed by Zhe Zhang.\n",
      "commitDate": "21/09/14 9:29 PM",
      "commitName": "1737950d0fc83c68f386881b843c41b0b1e342de",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/09/14 3:07 PM",
      "commitNameOld": "9e355719653c5e7b48b601090634882e4f29a743",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.27,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   void createEncryptionZone(final String src, final String keyName)\n     throws IOException, UnresolvedLinkException,\n       SafeModeException, AccessControlException {\n     final CacheEntry cacheEntry \u003d RetryCache.waitForCompletion(retryCache);\n     if (cacheEntry !\u003d null \u0026\u0026 cacheEntry.isSuccess()) {\n       return; // Return previous response\n     }\n \n     boolean success \u003d false;\n     try {\n       if (provider \u003d\u003d null) {\n         throw new IOException(\n             \"Can\u0027t create an encryption zone for \" + src +\n             \" since no key provider is available.\");\n       }\n       if (keyName \u003d\u003d null || keyName.isEmpty()) {\n         throw new IOException(\"Must specify a key name when creating an \" +\n             \"encryption zone\");\n       }\n-      KeyVersion keyVersion \u003d provider.getCurrentKey(keyName);\n-      if (keyVersion \u003d\u003d null) {\n+      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n+      if (metadata \u003d\u003d null) {\n         /*\n          * It would be nice if we threw something more specific than\n          * IOException when the key is not found, but the KeyProvider API\n          * doesn\u0027t provide for that. If that API is ever changed to throw\n          * something more specific (e.g. UnknownKeyException) then we can\n          * update this to match it, or better yet, just rethrow the\n          * KeyProvider\u0027s exception.\n          */\n         throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n       }\n-      createEncryptionZoneInt(src, keyName, cacheEntry !\u003d null);\n+      createEncryptionZoneInt(src, metadata.getCipher(),\n+          keyName, cacheEntry !\u003d null);\n       success \u003d true;\n     } catch (AccessControlException e) {\n       logAuditEvent(false, \"createEncryptionZone\", src);\n       throw e;\n     } finally {\n       RetryCache.setState(cacheEntry, success);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createEncryptionZone(final String src, final String keyName)\n    throws IOException, UnresolvedLinkException,\n      SafeModeException, AccessControlException {\n    final CacheEntry cacheEntry \u003d RetryCache.waitForCompletion(retryCache);\n    if (cacheEntry !\u003d null \u0026\u0026 cacheEntry.isSuccess()) {\n      return; // Return previous response\n    }\n\n    boolean success \u003d false;\n    try {\n      if (provider \u003d\u003d null) {\n        throw new IOException(\n            \"Can\u0027t create an encryption zone for \" + src +\n            \" since no key provider is available.\");\n      }\n      if (keyName \u003d\u003d null || keyName.isEmpty()) {\n        throw new IOException(\"Must specify a key name when creating an \" +\n            \"encryption zone\");\n      }\n      KeyProvider.Metadata metadata \u003d provider.getMetadata(keyName);\n      if (metadata \u003d\u003d null) {\n        /*\n         * It would be nice if we threw something more specific than\n         * IOException when the key is not found, but the KeyProvider API\n         * doesn\u0027t provide for that. If that API is ever changed to throw\n         * something more specific (e.g. UnknownKeyException) then we can\n         * update this to match it, or better yet, just rethrow the\n         * KeyProvider\u0027s exception.\n         */\n        throw new IOException(\"Key \" + keyName + \" doesn\u0027t exist.\");\n      }\n      createEncryptionZoneInt(src, metadata.getCipher(),\n          keyName, cacheEntry !\u003d null);\n      success \u003d true;\n    } catch (AccessControlException e) {\n      logAuditEvent(false, \"createEncryptionZone\", src);\n      throw e;\n    } finally {\n      RetryCache.setState(cacheEntry, success);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    }
  }
}