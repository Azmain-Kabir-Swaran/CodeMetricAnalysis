{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeRpcServer.java",
  "functionName": "getEditsFromTxid",
  "functionId": "getEditsFromTxid___txid-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
  "functionStartLine": 2364,
  "functionEndLine": 2396,
  "numCommitsSeen": 296,
  "timeTaken": 6747,
  "changeHistory": [
    "c75105f07b4cdbc2773435fc1125446233113c15",
    "e01c6ea688e62f25c4310e771a0cd85b53a5fb87",
    "db334bb8625da97c7e518cbcf477530c7ba7001e",
    "75a326aaff8c92349701d9b3473c3070b8c2be44",
    "faa4455be512e070fa420084be8d1be5c72f3b08"
  ],
  "changeHistoryShort": {
    "c75105f07b4cdbc2773435fc1125446233113c15": "Ybodychange",
    "e01c6ea688e62f25c4310e771a0cd85b53a5fb87": "Ybodychange",
    "db334bb8625da97c7e518cbcf477530c7ba7001e": "Ybodychange",
    "75a326aaff8c92349701d9b3473c3070b8c2be44": "Ymultichange(Yreturntypechange,Ybodychange)",
    "faa4455be512e070fa420084be8d1be5c72f3b08": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c75105f07b4cdbc2773435fc1125446233113c15": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13040. Kerberized inotify client fails despite kinit properly. Contributed by Istvan Fajth, Wei-Chiu Chuang, Xiao Chen.\n",
      "commitDate": "02/03/18 4:46 PM",
      "commitName": "c75105f07b4cdbc2773435fc1125446233113c15",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "05/01/18 10:31 PM",
      "commitNameOld": "bf5c94899537011465350d5d999fad9ffaeb605d",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 55.76,
      "commitsBetweenForRepo": 348,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,33 @@\n   public EventBatchList getEditsFromTxid(long txid) throws IOException {\n     checkNNStartup();\n     namesystem.checkOperation(OperationCategory.READ); // only active\n     namesystem.checkSuperuserPrivilege();\n     int maxEventsPerRPC \u003d nn.getConf().getInt(\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n     FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n     long syncTxid \u003d log.getSyncTxId();\n     // If we haven\u0027t synced anything yet, we can only read finalized\n     // segments since we can\u0027t reliably determine which txns in in-progress\n     // segments have actually been committed (e.g. written to a quorum of JNs).\n     // If we have synced txns, we can definitely read up to syncTxid since\n     // syncTxid is only updated after a transaction is committed to all\n     // journals. (In-progress segments written by old writers are already\n     // discarded for us, so if we read any in-progress segments they are\n     // guaranteed to have been written by this NameNode.)\n     boolean readInProgress \u003d syncTxid \u003e 0;\n \n-    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n-    int totalEvents \u003d 0;\n-    long maxSeenTxid \u003d -1;\n-    long firstSeenTxid \u003d -1;\n-\n-    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n-      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n-      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n-    }\n-\n-    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n-    try {\n-      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n-    } catch (IllegalStateException e) { // can happen if we have\n-      // transitioned out of active and haven\u0027t yet transitioned to standby\n-      // and are using QJM -- the edit log will be closed and this exception\n-      // will result\n-      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n-      \"is closed -- could not read edits\");\n-      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n-    }\n-\n-    boolean breakOuter \u003d false;\n-    for (EditLogInputStream elis : streams) {\n-      // our assumption in this code is the EditLogInputStreams are ordered by\n-      // starting txid\n-      try {\n-        FSEditLogOp op \u003d null;\n-        while ((op \u003d readOp(elis)) !\u003d null) {\n-          // break out of here in the unlikely event that syncTxid is so\n-          // out of date that its segment has already been deleted, so the first\n-          // txid we get is greater than syncTxid\n-          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n-            breakOuter \u003d true;\n-            break;\n+    // doas the NN login user for the actual operations to get edits.\n+    // Notably this is necessary when polling from the remote edits via https.\n+    // We have validated the client is a superuser from the NN RPC, so this\n+    // running as the login user here is safe.\n+    EventBatchList ret \u003d SecurityUtil.doAsLoginUser(\n+        new PrivilegedExceptionAction\u003cEventBatchList\u003e() {\n+          @Override\n+          public EventBatchList run() throws IOException {\n+            return getEventBatchList(syncTxid, txid, log, readInProgress,\n+                maxEventsPerRPC);\n           }\n-\n-          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n-          if (eventBatch !\u003d null) {\n-            batches.add(eventBatch);\n-            totalEvents +\u003d eventBatch.getEvents().length;\n-          }\n-          if (op.getTransactionId() \u003e maxSeenTxid) {\n-            maxSeenTxid \u003d op.getTransactionId();\n-          }\n-          if (firstSeenTxid \u003d\u003d -1) {\n-            firstSeenTxid \u003d op.getTransactionId();\n-          }\n-          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n-              op.getTransactionId() \u003d\u003d syncTxid)) {\n-            // we\u0027re done\n-            breakOuter \u003d true;\n-            break;\n-          }\n-        }\n-      } finally {\n-        elis.close();\n-      }\n-      if (breakOuter) {\n-        break;\n-      }\n-    }\n-\n-    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n+        });\n+    return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n    checkNNStartup();\n    namesystem.checkOperation(OperationCategory.READ); // only active\n    namesystem.checkSuperuserPrivilege();\n    int maxEventsPerRPC \u003d nn.getConf().getInt(\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n    long syncTxid \u003d log.getSyncTxId();\n    // If we haven\u0027t synced anything yet, we can only read finalized\n    // segments since we can\u0027t reliably determine which txns in in-progress\n    // segments have actually been committed (e.g. written to a quorum of JNs).\n    // If we have synced txns, we can definitely read up to syncTxid since\n    // syncTxid is only updated after a transaction is committed to all\n    // journals. (In-progress segments written by old writers are already\n    // discarded for us, so if we read any in-progress segments they are\n    // guaranteed to have been written by this NameNode.)\n    boolean readInProgress \u003d syncTxid \u003e 0;\n\n    // doas the NN login user for the actual operations to get edits.\n    // Notably this is necessary when polling from the remote edits via https.\n    // We have validated the client is a superuser from the NN RPC, so this\n    // running as the login user here is safe.\n    EventBatchList ret \u003d SecurityUtil.doAsLoginUser(\n        new PrivilegedExceptionAction\u003cEventBatchList\u003e() {\n          @Override\n          public EventBatchList run() throws IOException {\n            return getEventBatchList(syncTxid, txid, log, readInProgress,\n                maxEventsPerRPC);\n          }\n        });\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "e01c6ea688e62f25c4310e771a0cd85b53a5fb87": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1477. Support reconfiguring dfs.heartbeat.interval and dfs.namenode.heartbeat.recheck-interval without NN restart. (Contributed by Xiaobing Zhou)\n",
      "commitDate": "10/03/16 7:03 PM",
      "commitName": "e01c6ea688e62f25c4310e771a0cd85b53a5fb87",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "04/03/16 3:29 PM",
      "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 6.15,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   public EventBatchList getEditsFromTxid(long txid) throws IOException {\n     checkNNStartup();\n     namesystem.checkOperation(OperationCategory.READ); // only active\n     namesystem.checkSuperuserPrivilege();\n-    int maxEventsPerRPC \u003d nn.conf.getInt(\n+    int maxEventsPerRPC \u003d nn.getConf().getInt(\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n     FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n     long syncTxid \u003d log.getSyncTxId();\n     // If we haven\u0027t synced anything yet, we can only read finalized\n     // segments since we can\u0027t reliably determine which txns in in-progress\n     // segments have actually been committed (e.g. written to a quorum of JNs).\n     // If we have synced txns, we can definitely read up to syncTxid since\n     // syncTxid is only updated after a transaction is committed to all\n     // journals. (In-progress segments written by old writers are already\n     // discarded for us, so if we read any in-progress segments they are\n     // guaranteed to have been written by this NameNode.)\n     boolean readInProgress \u003d syncTxid \u003e 0;\n \n     List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n     int totalEvents \u003d 0;\n     long maxSeenTxid \u003d -1;\n     long firstSeenTxid \u003d -1;\n \n     if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n       // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n       return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     Collection\u003cEditLogInputStream\u003e streams \u003d null;\n     try {\n       streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n     } catch (IllegalStateException e) { // can happen if we have\n       // transitioned out of active and haven\u0027t yet transitioned to standby\n       // and are using QJM -- the edit log will be closed and this exception\n       // will result\n       LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n       \"is closed -- could not read edits\");\n       return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     boolean breakOuter \u003d false;\n     for (EditLogInputStream elis : streams) {\n       // our assumption in this code is the EditLogInputStreams are ordered by\n       // starting txid\n       try {\n         FSEditLogOp op \u003d null;\n         while ((op \u003d readOp(elis)) !\u003d null) {\n           // break out of here in the unlikely event that syncTxid is so\n           // out of date that its segment has already been deleted, so the first\n           // txid we get is greater than syncTxid\n           if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n             breakOuter \u003d true;\n             break;\n           }\n \n           EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n           if (eventBatch !\u003d null) {\n             batches.add(eventBatch);\n             totalEvents +\u003d eventBatch.getEvents().length;\n           }\n           if (op.getTransactionId() \u003e maxSeenTxid) {\n             maxSeenTxid \u003d op.getTransactionId();\n           }\n           if (firstSeenTxid \u003d\u003d -1) {\n             firstSeenTxid \u003d op.getTransactionId();\n           }\n           if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n               op.getTransactionId() \u003d\u003d syncTxid)) {\n             // we\u0027re done\n             breakOuter \u003d true;\n             break;\n           }\n         }\n       } finally {\n         elis.close();\n       }\n       if (breakOuter) {\n         break;\n       }\n     }\n \n     return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n    checkNNStartup();\n    namesystem.checkOperation(OperationCategory.READ); // only active\n    namesystem.checkSuperuserPrivilege();\n    int maxEventsPerRPC \u003d nn.getConf().getInt(\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n    long syncTxid \u003d log.getSyncTxId();\n    // If we haven\u0027t synced anything yet, we can only read finalized\n    // segments since we can\u0027t reliably determine which txns in in-progress\n    // segments have actually been committed (e.g. written to a quorum of JNs).\n    // If we have synced txns, we can definitely read up to syncTxid since\n    // syncTxid is only updated after a transaction is committed to all\n    // journals. (In-progress segments written by old writers are already\n    // discarded for us, so if we read any in-progress segments they are\n    // guaranteed to have been written by this NameNode.)\n    boolean readInProgress \u003d syncTxid \u003e 0;\n\n    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n    int totalEvents \u003d 0;\n    long maxSeenTxid \u003d -1;\n    long firstSeenTxid \u003d -1;\n\n    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n    try {\n      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n    } catch (IllegalStateException e) { // can happen if we have\n      // transitioned out of active and haven\u0027t yet transitioned to standby\n      // and are using QJM -- the edit log will be closed and this exception\n      // will result\n      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n      \"is closed -- could not read edits\");\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    boolean breakOuter \u003d false;\n    for (EditLogInputStream elis : streams) {\n      // our assumption in this code is the EditLogInputStreams are ordered by\n      // starting txid\n      try {\n        FSEditLogOp op \u003d null;\n        while ((op \u003d readOp(elis)) !\u003d null) {\n          // break out of here in the unlikely event that syncTxid is so\n          // out of date that its segment has already been deleted, so the first\n          // txid we get is greater than syncTxid\n          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n            breakOuter \u003d true;\n            break;\n          }\n\n          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n          if (eventBatch !\u003d null) {\n            batches.add(eventBatch);\n            totalEvents +\u003d eventBatch.getEvents().length;\n          }\n          if (op.getTransactionId() \u003e maxSeenTxid) {\n            maxSeenTxid \u003d op.getTransactionId();\n          }\n          if (firstSeenTxid \u003d\u003d -1) {\n            firstSeenTxid \u003d op.getTransactionId();\n          }\n          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n              op.getTransactionId() \u003d\u003d syncTxid)) {\n            // we\u0027re done\n            breakOuter \u003d true;\n            break;\n          }\n        }\n      } finally {\n        elis.close();\n      }\n      if (breakOuter) {\n        break;\n      }\n    }\n\n    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "db334bb8625da97c7e518cbcf477530c7ba7001e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3443. Fix NPE when namenode transition to active during startup by adding checkNNStartup() in NameNodeRpcServer.  Contributed by Vinayakumar B\n",
      "commitDate": "21/01/15 11:33 AM",
      "commitName": "db334bb8625da97c7e518cbcf477530c7ba7001e",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "12/01/15 10:50 PM",
      "commitNameOld": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 8.53,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   public EventBatchList getEditsFromTxid(long txid) throws IOException {\n+    checkNNStartup();\n     namesystem.checkOperation(OperationCategory.READ); // only active\n     namesystem.checkSuperuserPrivilege();\n     int maxEventsPerRPC \u003d nn.conf.getInt(\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n     FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n     long syncTxid \u003d log.getSyncTxId();\n     // If we haven\u0027t synced anything yet, we can only read finalized\n     // segments since we can\u0027t reliably determine which txns in in-progress\n     // segments have actually been committed (e.g. written to a quorum of JNs).\n     // If we have synced txns, we can definitely read up to syncTxid since\n     // syncTxid is only updated after a transaction is committed to all\n     // journals. (In-progress segments written by old writers are already\n     // discarded for us, so if we read any in-progress segments they are\n     // guaranteed to have been written by this NameNode.)\n     boolean readInProgress \u003d syncTxid \u003e 0;\n \n     List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n     int totalEvents \u003d 0;\n     long maxSeenTxid \u003d -1;\n     long firstSeenTxid \u003d -1;\n \n     if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n       // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n       return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     Collection\u003cEditLogInputStream\u003e streams \u003d null;\n     try {\n       streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n     } catch (IllegalStateException e) { // can happen if we have\n       // transitioned out of active and haven\u0027t yet transitioned to standby\n       // and are using QJM -- the edit log will be closed and this exception\n       // will result\n       LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n       \"is closed -- could not read edits\");\n       return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     boolean breakOuter \u003d false;\n     for (EditLogInputStream elis : streams) {\n       // our assumption in this code is the EditLogInputStreams are ordered by\n       // starting txid\n       try {\n         FSEditLogOp op \u003d null;\n         while ((op \u003d readOp(elis)) !\u003d null) {\n           // break out of here in the unlikely event that syncTxid is so\n           // out of date that its segment has already been deleted, so the first\n           // txid we get is greater than syncTxid\n           if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n             breakOuter \u003d true;\n             break;\n           }\n \n           EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n           if (eventBatch !\u003d null) {\n             batches.add(eventBatch);\n             totalEvents +\u003d eventBatch.getEvents().length;\n           }\n           if (op.getTransactionId() \u003e maxSeenTxid) {\n             maxSeenTxid \u003d op.getTransactionId();\n           }\n           if (firstSeenTxid \u003d\u003d -1) {\n             firstSeenTxid \u003d op.getTransactionId();\n           }\n           if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n               op.getTransactionId() \u003d\u003d syncTxid)) {\n             // we\u0027re done\n             breakOuter \u003d true;\n             break;\n           }\n         }\n       } finally {\n         elis.close();\n       }\n       if (breakOuter) {\n         break;\n       }\n     }\n \n     return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n    checkNNStartup();\n    namesystem.checkOperation(OperationCategory.READ); // only active\n    namesystem.checkSuperuserPrivilege();\n    int maxEventsPerRPC \u003d nn.conf.getInt(\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n    long syncTxid \u003d log.getSyncTxId();\n    // If we haven\u0027t synced anything yet, we can only read finalized\n    // segments since we can\u0027t reliably determine which txns in in-progress\n    // segments have actually been committed (e.g. written to a quorum of JNs).\n    // If we have synced txns, we can definitely read up to syncTxid since\n    // syncTxid is only updated after a transaction is committed to all\n    // journals. (In-progress segments written by old writers are already\n    // discarded for us, so if we read any in-progress segments they are\n    // guaranteed to have been written by this NameNode.)\n    boolean readInProgress \u003d syncTxid \u003e 0;\n\n    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n    int totalEvents \u003d 0;\n    long maxSeenTxid \u003d -1;\n    long firstSeenTxid \u003d -1;\n\n    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n    try {\n      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n    } catch (IllegalStateException e) { // can happen if we have\n      // transitioned out of active and haven\u0027t yet transitioned to standby\n      // and are using QJM -- the edit log will be closed and this exception\n      // will result\n      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n      \"is closed -- could not read edits\");\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    boolean breakOuter \u003d false;\n    for (EditLogInputStream elis : streams) {\n      // our assumption in this code is the EditLogInputStreams are ordered by\n      // starting txid\n      try {\n        FSEditLogOp op \u003d null;\n        while ((op \u003d readOp(elis)) !\u003d null) {\n          // break out of here in the unlikely event that syncTxid is so\n          // out of date that its segment has already been deleted, so the first\n          // txid we get is greater than syncTxid\n          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n            breakOuter \u003d true;\n            break;\n          }\n\n          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n          if (eventBatch !\u003d null) {\n            batches.add(eventBatch);\n            totalEvents +\u003d eventBatch.getEvents().length;\n          }\n          if (op.getTransactionId() \u003e maxSeenTxid) {\n            maxSeenTxid \u003d op.getTransactionId();\n          }\n          if (firstSeenTxid \u003d\u003d -1) {\n            firstSeenTxid \u003d op.getTransactionId();\n          }\n          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n              op.getTransactionId() \u003d\u003d syncTxid)) {\n            // we\u0027re done\n            breakOuter \u003d true;\n            break;\n          }\n        }\n      } finally {\n        elis.close();\n      }\n      if (breakOuter) {\n        break;\n      }\n    }\n\n    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "75a326aaff8c92349701d9b3473c3070b8c2be44": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7446. HDFS inotify should have the ability to determine what txid it has read up to (cmccabe)\n",
      "commitDate": "02/12/14 5:15 PM",
      "commitName": "75a326aaff8c92349701d9b3473c3070b8c2be44",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7446. HDFS inotify should have the ability to determine what txid it has read up to (cmccabe)\n",
          "commitDate": "02/12/14 5:15 PM",
          "commitName": "75a326aaff8c92349701d9b3473c3070b8c2be44",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "28/11/14 7:39 AM",
          "commitNameOld": "1556f86a31a54733d6550363aa0e027acca7823b",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 4.4,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,83 @@\n-  public EventsList getEditsFromTxid(long txid) throws IOException {\n+  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n     namesystem.checkOperation(OperationCategory.READ); // only active\n     namesystem.checkSuperuserPrivilege();\n     int maxEventsPerRPC \u003d nn.conf.getInt(\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n     FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n     long syncTxid \u003d log.getSyncTxId();\n     // If we haven\u0027t synced anything yet, we can only read finalized\n     // segments since we can\u0027t reliably determine which txns in in-progress\n     // segments have actually been committed (e.g. written to a quorum of JNs).\n     // If we have synced txns, we can definitely read up to syncTxid since\n     // syncTxid is only updated after a transaction is committed to all\n     // journals. (In-progress segments written by old writers are already\n     // discarded for us, so if we read any in-progress segments they are\n     // guaranteed to have been written by this NameNode.)\n     boolean readInProgress \u003d syncTxid \u003e 0;\n \n-    List\u003cEvent\u003e events \u003d Lists.newArrayList();\n+    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n+    int totalEvents \u003d 0;\n     long maxSeenTxid \u003d -1;\n     long firstSeenTxid \u003d -1;\n \n     if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n       // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n-      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     Collection\u003cEditLogInputStream\u003e streams \u003d null;\n     try {\n       streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n     } catch (IllegalStateException e) { // can happen if we have\n       // transitioned out of active and haven\u0027t yet transitioned to standby\n       // and are using QJM -- the edit log will be closed and this exception\n       // will result\n       LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n       \"is closed -- could not read edits\");\n-      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     boolean breakOuter \u003d false;\n     for (EditLogInputStream elis : streams) {\n       // our assumption in this code is the EditLogInputStreams are ordered by\n       // starting txid\n       try {\n         FSEditLogOp op \u003d null;\n         while ((op \u003d readOp(elis)) !\u003d null) {\n           // break out of here in the unlikely event that syncTxid is so\n           // out of date that its segment has already been deleted, so the first\n           // txid we get is greater than syncTxid\n           if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n             breakOuter \u003d true;\n             break;\n           }\n \n-          Event[] eventsFromOp \u003d InotifyFSEditLogOpTranslator.translate(op);\n-          if (eventsFromOp !\u003d null) {\n-            events.addAll(Arrays.asList(eventsFromOp));\n+          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n+          if (eventBatch !\u003d null) {\n+            batches.add(eventBatch);\n+            totalEvents +\u003d eventBatch.getEvents().length;\n           }\n           if (op.getTransactionId() \u003e maxSeenTxid) {\n             maxSeenTxid \u003d op.getTransactionId();\n           }\n           if (firstSeenTxid \u003d\u003d -1) {\n             firstSeenTxid \u003d op.getTransactionId();\n           }\n-          if (events.size() \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n+          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n               op.getTransactionId() \u003d\u003d syncTxid)) {\n             // we\u0027re done\n             breakOuter \u003d true;\n             break;\n           }\n         }\n       } finally {\n         elis.close();\n       }\n       if (breakOuter) {\n         break;\n       }\n     }\n \n-    return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n    namesystem.checkOperation(OperationCategory.READ); // only active\n    namesystem.checkSuperuserPrivilege();\n    int maxEventsPerRPC \u003d nn.conf.getInt(\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n    long syncTxid \u003d log.getSyncTxId();\n    // If we haven\u0027t synced anything yet, we can only read finalized\n    // segments since we can\u0027t reliably determine which txns in in-progress\n    // segments have actually been committed (e.g. written to a quorum of JNs).\n    // If we have synced txns, we can definitely read up to syncTxid since\n    // syncTxid is only updated after a transaction is committed to all\n    // journals. (In-progress segments written by old writers are already\n    // discarded for us, so if we read any in-progress segments they are\n    // guaranteed to have been written by this NameNode.)\n    boolean readInProgress \u003d syncTxid \u003e 0;\n\n    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n    int totalEvents \u003d 0;\n    long maxSeenTxid \u003d -1;\n    long firstSeenTxid \u003d -1;\n\n    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n    try {\n      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n    } catch (IllegalStateException e) { // can happen if we have\n      // transitioned out of active and haven\u0027t yet transitioned to standby\n      // and are using QJM -- the edit log will be closed and this exception\n      // will result\n      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n      \"is closed -- could not read edits\");\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    boolean breakOuter \u003d false;\n    for (EditLogInputStream elis : streams) {\n      // our assumption in this code is the EditLogInputStreams are ordered by\n      // starting txid\n      try {\n        FSEditLogOp op \u003d null;\n        while ((op \u003d readOp(elis)) !\u003d null) {\n          // break out of here in the unlikely event that syncTxid is so\n          // out of date that its segment has already been deleted, so the first\n          // txid we get is greater than syncTxid\n          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n            breakOuter \u003d true;\n            break;\n          }\n\n          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n          if (eventBatch !\u003d null) {\n            batches.add(eventBatch);\n            totalEvents +\u003d eventBatch.getEvents().length;\n          }\n          if (op.getTransactionId() \u003e maxSeenTxid) {\n            maxSeenTxid \u003d op.getTransactionId();\n          }\n          if (firstSeenTxid \u003d\u003d -1) {\n            firstSeenTxid \u003d op.getTransactionId();\n          }\n          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n              op.getTransactionId() \u003d\u003d syncTxid)) {\n            // we\u0027re done\n            breakOuter \u003d true;\n            break;\n          }\n        }\n      } finally {\n        elis.close();\n      }\n      if (breakOuter) {\n        break;\n      }\n    }\n\n    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
          "extendedDetails": {
            "oldValue": "EventsList",
            "newValue": "EventBatchList"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7446. HDFS inotify should have the ability to determine what txid it has read up to (cmccabe)\n",
          "commitDate": "02/12/14 5:15 PM",
          "commitName": "75a326aaff8c92349701d9b3473c3070b8c2be44",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "28/11/14 7:39 AM",
          "commitNameOld": "1556f86a31a54733d6550363aa0e027acca7823b",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 4.4,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,83 @@\n-  public EventsList getEditsFromTxid(long txid) throws IOException {\n+  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n     namesystem.checkOperation(OperationCategory.READ); // only active\n     namesystem.checkSuperuserPrivilege();\n     int maxEventsPerRPC \u003d nn.conf.getInt(\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n         DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n     FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n     long syncTxid \u003d log.getSyncTxId();\n     // If we haven\u0027t synced anything yet, we can only read finalized\n     // segments since we can\u0027t reliably determine which txns in in-progress\n     // segments have actually been committed (e.g. written to a quorum of JNs).\n     // If we have synced txns, we can definitely read up to syncTxid since\n     // syncTxid is only updated after a transaction is committed to all\n     // journals. (In-progress segments written by old writers are already\n     // discarded for us, so if we read any in-progress segments they are\n     // guaranteed to have been written by this NameNode.)\n     boolean readInProgress \u003d syncTxid \u003e 0;\n \n-    List\u003cEvent\u003e events \u003d Lists.newArrayList();\n+    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n+    int totalEvents \u003d 0;\n     long maxSeenTxid \u003d -1;\n     long firstSeenTxid \u003d -1;\n \n     if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n       // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n-      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     Collection\u003cEditLogInputStream\u003e streams \u003d null;\n     try {\n       streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n     } catch (IllegalStateException e) { // can happen if we have\n       // transitioned out of active and haven\u0027t yet transitioned to standby\n       // and are using QJM -- the edit log will be closed and this exception\n       // will result\n       LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n       \"is closed -- could not read edits\");\n-      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n     }\n \n     boolean breakOuter \u003d false;\n     for (EditLogInputStream elis : streams) {\n       // our assumption in this code is the EditLogInputStreams are ordered by\n       // starting txid\n       try {\n         FSEditLogOp op \u003d null;\n         while ((op \u003d readOp(elis)) !\u003d null) {\n           // break out of here in the unlikely event that syncTxid is so\n           // out of date that its segment has already been deleted, so the first\n           // txid we get is greater than syncTxid\n           if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n             breakOuter \u003d true;\n             break;\n           }\n \n-          Event[] eventsFromOp \u003d InotifyFSEditLogOpTranslator.translate(op);\n-          if (eventsFromOp !\u003d null) {\n-            events.addAll(Arrays.asList(eventsFromOp));\n+          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n+          if (eventBatch !\u003d null) {\n+            batches.add(eventBatch);\n+            totalEvents +\u003d eventBatch.getEvents().length;\n           }\n           if (op.getTransactionId() \u003e maxSeenTxid) {\n             maxSeenTxid \u003d op.getTransactionId();\n           }\n           if (firstSeenTxid \u003d\u003d -1) {\n             firstSeenTxid \u003d op.getTransactionId();\n           }\n-          if (events.size() \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n+          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n               op.getTransactionId() \u003d\u003d syncTxid)) {\n             // we\u0027re done\n             breakOuter \u003d true;\n             break;\n           }\n         }\n       } finally {\n         elis.close();\n       }\n       if (breakOuter) {\n         break;\n       }\n     }\n \n-    return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public EventBatchList getEditsFromTxid(long txid) throws IOException {\n    namesystem.checkOperation(OperationCategory.READ); // only active\n    namesystem.checkSuperuserPrivilege();\n    int maxEventsPerRPC \u003d nn.conf.getInt(\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n    long syncTxid \u003d log.getSyncTxId();\n    // If we haven\u0027t synced anything yet, we can only read finalized\n    // segments since we can\u0027t reliably determine which txns in in-progress\n    // segments have actually been committed (e.g. written to a quorum of JNs).\n    // If we have synced txns, we can definitely read up to syncTxid since\n    // syncTxid is only updated after a transaction is committed to all\n    // journals. (In-progress segments written by old writers are already\n    // discarded for us, so if we read any in-progress segments they are\n    // guaranteed to have been written by this NameNode.)\n    boolean readInProgress \u003d syncTxid \u003e 0;\n\n    List\u003cEventBatch\u003e batches \u003d Lists.newArrayList();\n    int totalEvents \u003d 0;\n    long maxSeenTxid \u003d -1;\n    long firstSeenTxid \u003d -1;\n\n    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n    try {\n      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n    } catch (IllegalStateException e) { // can happen if we have\n      // transitioned out of active and haven\u0027t yet transitioned to standby\n      // and are using QJM -- the edit log will be closed and this exception\n      // will result\n      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n      \"is closed -- could not read edits\");\n      return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    boolean breakOuter \u003d false;\n    for (EditLogInputStream elis : streams) {\n      // our assumption in this code is the EditLogInputStreams are ordered by\n      // starting txid\n      try {\n        FSEditLogOp op \u003d null;\n        while ((op \u003d readOp(elis)) !\u003d null) {\n          // break out of here in the unlikely event that syncTxid is so\n          // out of date that its segment has already been deleted, so the first\n          // txid we get is greater than syncTxid\n          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n            breakOuter \u003d true;\n            break;\n          }\n\n          EventBatch eventBatch \u003d InotifyFSEditLogOpTranslator.translate(op);\n          if (eventBatch !\u003d null) {\n            batches.add(eventBatch);\n            totalEvents +\u003d eventBatch.getEvents().length;\n          }\n          if (op.getTransactionId() \u003e maxSeenTxid) {\n            maxSeenTxid \u003d op.getTransactionId();\n          }\n          if (firstSeenTxid \u003d\u003d -1) {\n            firstSeenTxid \u003d op.getTransactionId();\n          }\n          if (totalEvents \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n              op.getTransactionId() \u003d\u003d syncTxid)) {\n            // we\u0027re done\n            breakOuter \u003d true;\n            break;\n          }\n        }\n      } finally {\n        elis.close();\n      }\n      if (breakOuter) {\n        break;\n      }\n    }\n\n    return new EventBatchList(batches, firstSeenTxid, maxSeenTxid, syncTxid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "faa4455be512e070fa420084be8d1be5c72f3b08": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6634. inotify in HDFS. Contributed by James Thomas.\n",
      "commitDate": "02/09/14 2:02 PM",
      "commitName": "faa4455be512e070fa420084be8d1be5c72f3b08",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,81 @@\n+  public EventsList getEditsFromTxid(long txid) throws IOException {\n+    namesystem.checkOperation(OperationCategory.READ); // only active\n+    namesystem.checkSuperuserPrivilege();\n+    int maxEventsPerRPC \u003d nn.conf.getInt(\n+        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n+        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n+    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n+    long syncTxid \u003d log.getSyncTxId();\n+    // If we haven\u0027t synced anything yet, we can only read finalized\n+    // segments since we can\u0027t reliably determine which txns in in-progress\n+    // segments have actually been committed (e.g. written to a quorum of JNs).\n+    // If we have synced txns, we can definitely read up to syncTxid since\n+    // syncTxid is only updated after a transaction is committed to all\n+    // journals. (In-progress segments written by old writers are already\n+    // discarded for us, so if we read any in-progress segments they are\n+    // guaranteed to have been written by this NameNode.)\n+    boolean readInProgress \u003d syncTxid \u003e 0;\n+\n+    List\u003cEvent\u003e events \u003d Lists.newArrayList();\n+    long maxSeenTxid \u003d -1;\n+    long firstSeenTxid \u003d -1;\n+\n+    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n+      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n+      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+    }\n+\n+    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n+    try {\n+      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n+    } catch (IllegalStateException e) { // can happen if we have\n+      // transitioned out of active and haven\u0027t yet transitioned to standby\n+      // and are using QJM -- the edit log will be closed and this exception\n+      // will result\n+      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n+      \"is closed -- could not read edits\");\n+      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+    }\n+\n+    boolean breakOuter \u003d false;\n+    for (EditLogInputStream elis : streams) {\n+      // our assumption in this code is the EditLogInputStreams are ordered by\n+      // starting txid\n+      try {\n+        FSEditLogOp op \u003d null;\n+        while ((op \u003d readOp(elis)) !\u003d null) {\n+          // break out of here in the unlikely event that syncTxid is so\n+          // out of date that its segment has already been deleted, so the first\n+          // txid we get is greater than syncTxid\n+          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n+            breakOuter \u003d true;\n+            break;\n+          }\n+\n+          Event[] eventsFromOp \u003d InotifyFSEditLogOpTranslator.translate(op);\n+          if (eventsFromOp !\u003d null) {\n+            events.addAll(Arrays.asList(eventsFromOp));\n+          }\n+          if (op.getTransactionId() \u003e maxSeenTxid) {\n+            maxSeenTxid \u003d op.getTransactionId();\n+          }\n+          if (firstSeenTxid \u003d\u003d -1) {\n+            firstSeenTxid \u003d op.getTransactionId();\n+          }\n+          if (events.size() \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n+              op.getTransactionId() \u003d\u003d syncTxid)) {\n+            // we\u0027re done\n+            breakOuter \u003d true;\n+            break;\n+          }\n+        }\n+      } finally {\n+        elis.close();\n+      }\n+      if (breakOuter) {\n+        break;\n+      }\n+    }\n+\n+    return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public EventsList getEditsFromTxid(long txid) throws IOException {\n    namesystem.checkOperation(OperationCategory.READ); // only active\n    namesystem.checkSuperuserPrivilege();\n    int maxEventsPerRPC \u003d nn.conf.getInt(\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_KEY,\n        DFSConfigKeys.DFS_NAMENODE_INOTIFY_MAX_EVENTS_PER_RPC_DEFAULT);\n    FSEditLog log \u003d namesystem.getFSImage().getEditLog();\n    long syncTxid \u003d log.getSyncTxId();\n    // If we haven\u0027t synced anything yet, we can only read finalized\n    // segments since we can\u0027t reliably determine which txns in in-progress\n    // segments have actually been committed (e.g. written to a quorum of JNs).\n    // If we have synced txns, we can definitely read up to syncTxid since\n    // syncTxid is only updated after a transaction is committed to all\n    // journals. (In-progress segments written by old writers are already\n    // discarded for us, so if we read any in-progress segments they are\n    // guaranteed to have been written by this NameNode.)\n    boolean readInProgress \u003d syncTxid \u003e 0;\n\n    List\u003cEvent\u003e events \u003d Lists.newArrayList();\n    long maxSeenTxid \u003d -1;\n    long firstSeenTxid \u003d -1;\n\n    if (syncTxid \u003e 0 \u0026\u0026 txid \u003e syncTxid) {\n      // we can\u0027t read past syncTxid, so there\u0027s no point in going any further\n      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    Collection\u003cEditLogInputStream\u003e streams \u003d null;\n    try {\n      streams \u003d log.selectInputStreams(txid, 0, null, readInProgress);\n    } catch (IllegalStateException e) { // can happen if we have\n      // transitioned out of active and haven\u0027t yet transitioned to standby\n      // and are using QJM -- the edit log will be closed and this exception\n      // will result\n      LOG.info(\"NN is transitioning from active to standby and FSEditLog \" +\n      \"is closed -- could not read edits\");\n      return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n    }\n\n    boolean breakOuter \u003d false;\n    for (EditLogInputStream elis : streams) {\n      // our assumption in this code is the EditLogInputStreams are ordered by\n      // starting txid\n      try {\n        FSEditLogOp op \u003d null;\n        while ((op \u003d readOp(elis)) !\u003d null) {\n          // break out of here in the unlikely event that syncTxid is so\n          // out of date that its segment has already been deleted, so the first\n          // txid we get is greater than syncTxid\n          if (syncTxid \u003e 0 \u0026\u0026 op.getTransactionId() \u003e syncTxid) {\n            breakOuter \u003d true;\n            break;\n          }\n\n          Event[] eventsFromOp \u003d InotifyFSEditLogOpTranslator.translate(op);\n          if (eventsFromOp !\u003d null) {\n            events.addAll(Arrays.asList(eventsFromOp));\n          }\n          if (op.getTransactionId() \u003e maxSeenTxid) {\n            maxSeenTxid \u003d op.getTransactionId();\n          }\n          if (firstSeenTxid \u003d\u003d -1) {\n            firstSeenTxid \u003d op.getTransactionId();\n          }\n          if (events.size() \u003e\u003d maxEventsPerRPC || (syncTxid \u003e 0 \u0026\u0026\n              op.getTransactionId() \u003d\u003d syncTxid)) {\n            // we\u0027re done\n            breakOuter \u003d true;\n            break;\n          }\n        }\n      } finally {\n        elis.close();\n      }\n      if (breakOuter) {\n        break;\n      }\n    }\n\n    return new EventsList(events, firstSeenTxid, maxSeenTxid, syncTxid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java"
    }
  }
}