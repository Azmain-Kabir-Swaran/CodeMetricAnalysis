{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DominantResourceFairnessPolicy.java",
  "functionName": "compare",
  "functionId": "compare___s1-Schedulable__s2-Schedulable",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/DominantResourceFairnessPolicy.java",
  "functionStartLine": 371,
  "functionEndLine": 430,
  "numCommitsSeen": 20,
  "timeTaken": 2678,
  "changeHistory": [
    "9711b78998ca3a1f7734058a78c7baddd130ce0f",
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
    "b10e962224a8ae1c6031a05322b0cc5e564bd078",
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650"
  ],
  "changeHistoryShort": {
    "9711b78998ca3a1f7734058a78c7baddd130ce0f": "Ybodychange",
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750": "Ybodychange",
    "b10e962224a8ae1c6031a05322b0cc5e564bd078": "Ybodychange",
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf": "Ybodychange",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9711b78998ca3a1f7734058a78c7baddd130ce0f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7374. Improve performance of DRF comparisons for resource types in fair scheduler\n",
      "commitDate": "29/10/17 6:54 PM",
      "commitName": "9711b78998ca3a1f7734058a78c7baddd130ce0f",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "14/09/17 11:23 AM",
      "commitNameOld": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 45.31,
      "commitsBetweenForRepo": 334,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,60 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n-      ResourceInformation[] info \u003d ResourceUtils.getResourceTypesArray();\n-      Resource usage1 \u003d s1.getResourceUsage();\n-      Resource usage2 \u003d s2.getResourceUsage();\n-      Resource minShare1 \u003d s1.getMinShare();\n-      Resource minShare2 \u003d s2.getMinShare();\n-      Resource clusterCapacity \u003d fsContext.getClusterResource();\n+      ResourceInformation[] resourceInfo1 \u003d\n+          s1.getResourceUsage().getResources();\n+      ResourceInformation[] resourceInfo2 \u003d\n+          s2.getResourceUsage().getResources();\n+      ResourceInformation[] minShareInfo1 \u003d s1.getMinShare().getResources();\n+      ResourceInformation[] minShareInfo2 \u003d s2.getMinShare().getResources();\n+      ResourceInformation[] clusterInfo \u003d\n+          fsContext.getClusterResource().getResources();\n+      double[] shares1 \u003d new double[2];\n+      double[] shares2 \u003d new double[2];\n \n-      // These arrays hold the usage, fair, and min share ratios for each\n-      // resource type. ratios[0][x] are the usage ratios, ratios[1][x] are\n-      // the fair share ratios, and ratios[2][x] are the min share ratios.\n-      float[][] ratios1 \u003d new float[info.length][3];\n-      float[][] ratios2 \u003d new float[info.length][3];\n-\n-      // Calculate cluster shares and approximate fair shares for each\n-      // resource type of both schedulables.\n-      int dominant1 \u003d calculateClusterAndFairRatios(usage1, clusterCapacity,\n-          ratios1, s1.getWeight());\n-      int dominant2 \u003d calculateClusterAndFairRatios(usage2, clusterCapacity,\n-          ratios2, s2.getWeight());\n+      int dominant1 \u003d calculateClusterAndFairRatios(resourceInfo1,\n+          s1.getWeight(), clusterInfo, shares1);\n+      int dominant2 \u003d calculateClusterAndFairRatios(resourceInfo2,\n+          s2.getWeight(), clusterInfo, shares2);\n \n       // A queue is needy for its min share if its dominant resource\n       // (with respect to the cluster capacity) is below its configured min\n       // share for that resource\n-      boolean s1Needy \u003d\n-          usage1.getResources()[dominant1].getValue() \u003c\n-          minShare1.getResources()[dominant1].getValue();\n-      boolean s2Needy \u003d\n-          usage2.getResources()[dominant2].getValue() \u003c\n-          minShare2.getResources()[dominant2].getValue();\n-      \n-      int res \u003d 0;\n+      boolean s1Needy \u003d resourceInfo1[dominant1].getValue() \u003c\n+          minShareInfo1[dominant1].getValue();\n+      boolean s2Needy \u003d resourceInfo1[dominant2].getValue() \u003c\n+          minShareInfo2[dominant2].getValue();\n+\n+      int res;\n \n       if (!s2Needy \u0026\u0026 !s1Needy) {\n-        // Sort shares by usage ratio and compare them by approximate fair share\n-        // ratio\n-        sortRatios(ratios1, ratios2);\n-        res \u003d compareRatios(ratios1, ratios2, 1);\n+        res \u003d (int) Math.signum(shares1[dominant1] - shares2[dominant2]);\n+\n+        if (res \u003d\u003d 0) {\n+          // Because memory and CPU are indices 0 and 1, we can find the\n+          // non-dominant index by subtracting the dominant index from 1.\n+          res \u003d (int) Math.signum(shares1[1 - dominant1] -\n+              shares2[1 - dominant2]);\n+        }\n       } else if (s1Needy \u0026\u0026 !s2Needy) {\n         res \u003d -1;\n       } else if (s2Needy \u0026\u0026 !s1Needy) {\n         res \u003d 1;\n-      } else { // both are needy below min share\n-        // Calculate the min share ratios, then sort by usage ratio, and compare\n-        // by min share ratio\n-        calculateMinShareRatios(usage1, minShare1, ratios1);\n-        calculateMinShareRatios(usage2, minShare2, ratios2);\n-        sortRatios(ratios1, ratios2);\n-        res \u003d compareRatios(ratios1, ratios2, 2);\n+      } else {\n+        double[] minShares1 \u003d\n+            calculateMinShareRatios(resourceInfo1, minShareInfo1);\n+        double[] minShares2 \u003d\n+            calculateMinShareRatios(resourceInfo2, minShareInfo2);\n+\n+        res \u003d (int) Math.signum(minShares1[dominant1] - minShares2[dominant2]);\n+\n+        if (res \u003d\u003d 0) {\n+          res \u003d (int) Math.signum(minShares1[1 - dominant1] -\n+              minShares2[1 - dominant2]);\n+        }\n       }\n \n       if (res \u003d\u003d 0) {\n-        // Apps are tied in fairness ratio. Break the tie by submit time and job\n-        // name to get a deterministic ordering, which is useful for unit tests.\n-        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n-\n-        if (res \u003d\u003d 0) {\n-          res \u003d s1.getName().compareTo(s2.getName());\n-        }\n+        res \u003d compareAttribrutes(s1, s2);\n       }\n \n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      ResourceInformation[] resourceInfo1 \u003d\n          s1.getResourceUsage().getResources();\n      ResourceInformation[] resourceInfo2 \u003d\n          s2.getResourceUsage().getResources();\n      ResourceInformation[] minShareInfo1 \u003d s1.getMinShare().getResources();\n      ResourceInformation[] minShareInfo2 \u003d s2.getMinShare().getResources();\n      ResourceInformation[] clusterInfo \u003d\n          fsContext.getClusterResource().getResources();\n      double[] shares1 \u003d new double[2];\n      double[] shares2 \u003d new double[2];\n\n      int dominant1 \u003d calculateClusterAndFairRatios(resourceInfo1,\n          s1.getWeight(), clusterInfo, shares1);\n      int dominant2 \u003d calculateClusterAndFairRatios(resourceInfo2,\n          s2.getWeight(), clusterInfo, shares2);\n\n      // A queue is needy for its min share if its dominant resource\n      // (with respect to the cluster capacity) is below its configured min\n      // share for that resource\n      boolean s1Needy \u003d resourceInfo1[dominant1].getValue() \u003c\n          minShareInfo1[dominant1].getValue();\n      boolean s2Needy \u003d resourceInfo1[dominant2].getValue() \u003c\n          minShareInfo2[dominant2].getValue();\n\n      int res;\n\n      if (!s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d (int) Math.signum(shares1[dominant1] - shares2[dominant2]);\n\n        if (res \u003d\u003d 0) {\n          // Because memory and CPU are indices 0 and 1, we can find the\n          // non-dominant index by subtracting the dominant index from 1.\n          res \u003d (int) Math.signum(shares1[1 - dominant1] -\n              shares2[1 - dominant2]);\n        }\n      } else if (s1Needy \u0026\u0026 !s2Needy) {\n        res \u003d -1;\n      } else if (s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d 1;\n      } else {\n        double[] minShares1 \u003d\n            calculateMinShareRatios(resourceInfo1, minShareInfo1);\n        double[] minShares2 \u003d\n            calculateMinShareRatios(resourceInfo2, minShareInfo2);\n\n        res \u003d (int) Math.signum(minShares1[dominant1] - minShares2[dominant2]);\n\n        if (res \u003d\u003d 0) {\n          res \u003d (int) Math.signum(minShares1[1 - dominant1] -\n              minShares2[1 - dominant2]);\n        }\n      }\n\n      if (res \u003d\u003d 0) {\n        res \u003d compareAttribrutes(s1, s2);\n      }\n\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/DominantResourceFairnessPolicy.java",
      "extendedDetails": {}
    },
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6612. Update fair scheduler policies to be aware of resource types. (Contributed by Daniel Templeton via Yufei Gu)\n",
      "commitDate": "14/09/17 11:23 AM",
      "commitName": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "24/07/17 12:13 PM",
      "commitNameOld": "bb30bd3771442df253cbe55c448379580bd5ad07",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 51.97,
      "commitsBetweenForRepo": 500,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,63 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n-      ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n-      ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n-      ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n-      ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n-      ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n-      ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n+      ResourceInformation[] info \u003d ResourceUtils.getResourceTypesArray();\n+      Resource usage1 \u003d s1.getResourceUsage();\n+      Resource usage2 \u003d s2.getResourceUsage();\n+      Resource minShare1 \u003d s1.getMinShare();\n+      Resource minShare2 \u003d s2.getMinShare();\n       Resource clusterCapacity \u003d fsContext.getClusterResource();\n \n-      // Calculate shares of the cluster for each resource both schedulables.\n-      calculateShares(s1.getResourceUsage(),\n-          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n-      calculateShares(s1.getResourceUsage(),\n-          s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n-      calculateShares(s2.getResourceUsage(),\n-          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n-      calculateShares(s2.getResourceUsage(),\n-          s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n-      \n+      // These arrays hold the usage, fair, and min share ratios for each\n+      // resource type. ratios[0][x] are the usage ratios, ratios[1][x] are\n+      // the fair share ratios, and ratios[2][x] are the min share ratios.\n+      float[][] ratios1 \u003d new float[info.length][3];\n+      float[][] ratios2 \u003d new float[info.length][3];\n+\n+      // Calculate cluster shares and approximate fair shares for each\n+      // resource type of both schedulables.\n+      int dominant1 \u003d calculateClusterAndFairRatios(usage1, clusterCapacity,\n+          ratios1, s1.getWeight());\n+      int dominant2 \u003d calculateClusterAndFairRatios(usage2, clusterCapacity,\n+          ratios2, s2.getWeight());\n+\n       // A queue is needy for its min share if its dominant resource\n-      // (with respect to the cluster capacity) is below its configured min share\n-      // for that resource\n-      boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n-      boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n+      // (with respect to the cluster capacity) is below its configured min\n+      // share for that resource\n+      boolean s1Needy \u003d\n+          usage1.getResources()[dominant1].getValue() \u003c\n+          minShare1.getResources()[dominant1].getValue();\n+      boolean s2Needy \u003d\n+          usage2.getResources()[dominant2].getValue() \u003c\n+          minShare2.getResources()[dominant2].getValue();\n       \n       int res \u003d 0;\n+\n       if (!s2Needy \u0026\u0026 !s1Needy) {\n-        res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n-            resourceOrder1, resourceOrder2);\n+        // Sort shares by usage ratio and compare them by approximate fair share\n+        // ratio\n+        sortRatios(ratios1, ratios2);\n+        res \u003d compareRatios(ratios1, ratios2, 1);\n       } else if (s1Needy \u0026\u0026 !s2Needy) {\n         res \u003d -1;\n       } else if (s2Needy \u0026\u0026 !s1Needy) {\n         res \u003d 1;\n       } else { // both are needy below min share\n-        res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n-            resourceOrder1, resourceOrder2);\n+        // Calculate the min share ratios, then sort by usage ratio, and compare\n+        // by min share ratio\n+        calculateMinShareRatios(usage1, minShare1, ratios1);\n+        calculateMinShareRatios(usage2, minShare2, ratios2);\n+        sortRatios(ratios1, ratios2);\n+        res \u003d compareRatios(ratios1, ratios2, 2);\n       }\n+\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n+\n         if (res \u003d\u003d 0) {\n           res \u003d s1.getName().compareTo(s2.getName());\n         }\n       }\n+\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      ResourceInformation[] info \u003d ResourceUtils.getResourceTypesArray();\n      Resource usage1 \u003d s1.getResourceUsage();\n      Resource usage2 \u003d s2.getResourceUsage();\n      Resource minShare1 \u003d s1.getMinShare();\n      Resource minShare2 \u003d s2.getMinShare();\n      Resource clusterCapacity \u003d fsContext.getClusterResource();\n\n      // These arrays hold the usage, fair, and min share ratios for each\n      // resource type. ratios[0][x] are the usage ratios, ratios[1][x] are\n      // the fair share ratios, and ratios[2][x] are the min share ratios.\n      float[][] ratios1 \u003d new float[info.length][3];\n      float[][] ratios2 \u003d new float[info.length][3];\n\n      // Calculate cluster shares and approximate fair shares for each\n      // resource type of both schedulables.\n      int dominant1 \u003d calculateClusterAndFairRatios(usage1, clusterCapacity,\n          ratios1, s1.getWeight());\n      int dominant2 \u003d calculateClusterAndFairRatios(usage2, clusterCapacity,\n          ratios2, s2.getWeight());\n\n      // A queue is needy for its min share if its dominant resource\n      // (with respect to the cluster capacity) is below its configured min\n      // share for that resource\n      boolean s1Needy \u003d\n          usage1.getResources()[dominant1].getValue() \u003c\n          minShare1.getResources()[dominant1].getValue();\n      boolean s2Needy \u003d\n          usage2.getResources()[dominant2].getValue() \u003c\n          minShare2.getResources()[dominant2].getValue();\n      \n      int res \u003d 0;\n\n      if (!s2Needy \u0026\u0026 !s1Needy) {\n        // Sort shares by usage ratio and compare them by approximate fair share\n        // ratio\n        sortRatios(ratios1, ratios2);\n        res \u003d compareRatios(ratios1, ratios2, 1);\n      } else if (s1Needy \u0026\u0026 !s2Needy) {\n        res \u003d -1;\n      } else if (s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d 1;\n      } else { // both are needy below min share\n        // Calculate the min share ratios, then sort by usage ratio, and compare\n        // by min share ratio\n        calculateMinShareRatios(usage1, minShare1, ratios1);\n        calculateMinShareRatios(usage2, minShare2, ratios2);\n        sortRatios(ratios1, ratios2);\n        res \u003d compareRatios(ratios1, ratios2, 2);\n      }\n\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n\n        if (res \u003d\u003d 0) {\n          res \u003d s1.getName().compareTo(s2.getName());\n        }\n      }\n\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/DominantResourceFairnessPolicy.java",
      "extendedDetails": {}
    },
    "b10e962224a8ae1c6031a05322b0cc5e564bd078": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6194. Cluster capacity in SchedulingPolicy is updated only on allocation file reload. (Yufei Gu via kasha)\n",
      "commitDate": "22/02/17 3:58 PM",
      "commitName": "b10e962224a8ae1c6031a05322b0cc5e564bd078",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "22/02/17 3:46 PM",
      "commitNameOld": "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,47 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n       ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n       ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n       ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n       ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n       ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n-      \n+      Resource clusterCapacity \u003d fsContext.getClusterResource();\n+\n       // Calculate shares of the cluster for each resource both schedulables.\n       calculateShares(s1.getResourceUsage(),\n           clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n       calculateShares(s1.getResourceUsage(),\n           s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n       calculateShares(s2.getResourceUsage(),\n           clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n       calculateShares(s2.getResourceUsage(),\n           s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n       \n       // A queue is needy for its min share if its dominant resource\n       // (with respect to the cluster capacity) is below its configured min share\n       // for that resource\n       boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n       boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n       \n       int res \u003d 0;\n       if (!s2Needy \u0026\u0026 !s1Needy) {\n         res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n             resourceOrder1, resourceOrder2);\n       } else if (s1Needy \u0026\u0026 !s2Needy) {\n         res \u003d -1;\n       } else if (s2Needy \u0026\u0026 !s1Needy) {\n         res \u003d 1;\n       } else { // both are needy below min share\n         res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n             resourceOrder1, resourceOrder2);\n       }\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0) {\n           res \u003d s1.getName().compareTo(s2.getName());\n         }\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n      ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n      ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n      ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n      ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n      ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n      Resource clusterCapacity \u003d fsContext.getClusterResource();\n\n      // Calculate shares of the cluster for each resource both schedulables.\n      calculateShares(s1.getResourceUsage(),\n          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n      calculateShares(s1.getResourceUsage(),\n          s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n      calculateShares(s2.getResourceUsage(),\n          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n      calculateShares(s2.getResourceUsage(),\n          s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n      \n      // A queue is needy for its min share if its dominant resource\n      // (with respect to the cluster capacity) is below its configured min share\n      // for that resource\n      boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n      boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n      \n      int res \u003d 0;\n      if (!s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n            resourceOrder1, resourceOrder2);\n      } else if (s1Needy \u0026\u0026 !s2Needy) {\n        res \u003d -1;\n      } else if (s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d 1;\n      } else { // both are needy below min share\n        res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n            resourceOrder1, resourceOrder2);\n      }\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0) {\n          res \u003d s1.getName().compareTo(s2.getName());\n        }\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/DominantResourceFairnessPolicy.java",
      "extendedDetails": {}
    },
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6210. FairScheduler: Node reservations can interfere with preemption. (kasha)\n",
      "commitDate": "22/02/17 3:46 PM",
      "commitName": "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "15/02/17 11:51 PM",
      "commitNameOld": "11be3f70e029c2324b167563168c8a254d234aef",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.66,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,46 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n       ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n       ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n       ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n       ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n       ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n       \n       // Calculate shares of the cluster for each resource both schedulables.\n       calculateShares(s1.getResourceUsage(),\n           clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n       calculateShares(s1.getResourceUsage(),\n           s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n       calculateShares(s2.getResourceUsage(),\n           clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n       calculateShares(s2.getResourceUsage(),\n           s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n       \n       // A queue is needy for its min share if its dominant resource\n       // (with respect to the cluster capacity) is below its configured min share\n       // for that resource\n       boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n       boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n       \n       int res \u003d 0;\n       if (!s2Needy \u0026\u0026 !s1Needy) {\n         res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n             resourceOrder1, resourceOrder2);\n       } else if (s1Needy \u0026\u0026 !s2Needy) {\n         res \u003d -1;\n       } else if (s2Needy \u0026\u0026 !s1Needy) {\n         res \u003d 1;\n       } else { // both are needy below min share\n         res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n             resourceOrder1, resourceOrder2);\n       }\n       if (res \u003d\u003d 0) {\n-        // Apps are tied in fairness ratio. Break the tie by submit time.\n-        res \u003d (int)(s1.getStartTime() - s2.getStartTime());\n+        // Apps are tied in fairness ratio. Break the tie by submit time and job\n+        // name to get a deterministic ordering, which is useful for unit tests.\n+        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n+        if (res \u003d\u003d 0) {\n+          res \u003d s1.getName().compareTo(s2.getName());\n+        }\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n      ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n      ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n      ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n      ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n      ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n      \n      // Calculate shares of the cluster for each resource both schedulables.\n      calculateShares(s1.getResourceUsage(),\n          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n      calculateShares(s1.getResourceUsage(),\n          s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n      calculateShares(s2.getResourceUsage(),\n          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n      calculateShares(s2.getResourceUsage(),\n          s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n      \n      // A queue is needy for its min share if its dominant resource\n      // (with respect to the cluster capacity) is below its configured min share\n      // for that resource\n      boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n      boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n      \n      int res \u003d 0;\n      if (!s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n            resourceOrder1, resourceOrder2);\n      } else if (s1Needy \u0026\u0026 !s2Needy) {\n        res \u003d -1;\n      } else if (s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d 1;\n      } else { // both are needy below min share\n        res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n            resourceOrder1, resourceOrder2);\n      }\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0) {\n          res \u003d s1.getName().compareTo(s2.getName());\n        }\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/DominantResourceFairnessPolicy.java",
      "extendedDetails": {}
    },
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": {
      "type": "Yintroduced",
      "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:33 AM",
      "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,42 @@\n+    public int compare(Schedulable s1, Schedulable s2) {\n+      ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n+      ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n+      ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n+      ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n+      ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n+      ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n+      \n+      // Calculate shares of the cluster for each resource both schedulables.\n+      calculateShares(s1.getResourceUsage(),\n+          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n+      calculateShares(s1.getResourceUsage(),\n+          s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n+      calculateShares(s2.getResourceUsage(),\n+          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n+      calculateShares(s2.getResourceUsage(),\n+          s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n+      \n+      // A queue is needy for its min share if its dominant resource\n+      // (with respect to the cluster capacity) is below its configured min share\n+      // for that resource\n+      boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n+      boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n+      \n+      int res \u003d 0;\n+      if (!s2Needy \u0026\u0026 !s1Needy) {\n+        res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n+            resourceOrder1, resourceOrder2);\n+      } else if (s1Needy \u0026\u0026 !s2Needy) {\n+        res \u003d -1;\n+      } else if (s2Needy \u0026\u0026 !s1Needy) {\n+        res \u003d 1;\n+      } else { // both are needy below min share\n+        res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n+            resourceOrder1, resourceOrder2);\n+      }\n+      if (res \u003d\u003d 0) {\n+        // Apps are tied in fairness ratio. Break the tie by submit time.\n+        res \u003d (int)(s1.getStartTime() - s2.getStartTime());\n+      }\n+      return res;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      ResourceWeights sharesOfCluster1 \u003d new ResourceWeights();\n      ResourceWeights sharesOfCluster2 \u003d new ResourceWeights();\n      ResourceWeights sharesOfMinShare1 \u003d new ResourceWeights();\n      ResourceWeights sharesOfMinShare2 \u003d new ResourceWeights();\n      ResourceType[] resourceOrder1 \u003d new ResourceType[NUM_RESOURCES];\n      ResourceType[] resourceOrder2 \u003d new ResourceType[NUM_RESOURCES];\n      \n      // Calculate shares of the cluster for each resource both schedulables.\n      calculateShares(s1.getResourceUsage(),\n          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());\n      calculateShares(s1.getResourceUsage(),\n          s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);\n      calculateShares(s2.getResourceUsage(),\n          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());\n      calculateShares(s2.getResourceUsage(),\n          s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);\n      \n      // A queue is needy for its min share if its dominant resource\n      // (with respect to the cluster capacity) is below its configured min share\n      // for that resource\n      boolean s1Needy \u003d sharesOfMinShare1.getWeight(resourceOrder1[0]) \u003c 1.0f;\n      boolean s2Needy \u003d sharesOfMinShare2.getWeight(resourceOrder2[0]) \u003c 1.0f;\n      \n      int res \u003d 0;\n      if (!s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d compareShares(sharesOfCluster1, sharesOfCluster2,\n            resourceOrder1, resourceOrder2);\n      } else if (s1Needy \u0026\u0026 !s2Needy) {\n        res \u003d -1;\n      } else if (s2Needy \u0026\u0026 !s1Needy) {\n        res \u003d 1;\n      } else { // both are needy below min share\n        res \u003d compareShares(sharesOfMinShare1, sharesOfMinShare2,\n            resourceOrder1, resourceOrder2);\n      }\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time.\n        res \u003d (int)(s1.getStartTime() - s2.getStartTime());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/DominantResourceFairnessPolicy.java"
    }
  }
}