{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LocalMetadataStore.java",
  "functionName": "move",
  "functionId": "move___pathsToDelete-Collection__Path__(annotations-@Nullable)__pathsToCreate-Collection__PathMetadata__(annotations-@Nullable)__operationState-BulkOperationState(annotations-@Nullable__modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
  "functionStartLine": 225,
  "functionEndLine": 264,
  "numCommitsSeen": 60,
  "timeTaken": 6400,
  "changeHistory": [
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "c58e11bf521d746842ce16724211a2a0339d7b61",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "c687a6617d73293019d8d91ac48bbfd2ccca3b40",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ybodychange",
    "c58e11bf521d746842ce16724211a2a0339d7b61": "Ymultichange(Yparameterchange,Ybodychange)",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ymultichange(Yparameterchange,Ybodychange)",
    "c687a6617d73293019d8d91ac48bbfd2ccca3b40": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "02/08/19 2:30 PM",
      "commitNameOld": "b01efe5cf6e756baae650bc568a764e28ccfa858",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 33.66,
      "commitsBetweenForRepo": 327,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n     if (pathsToCreate \u003d\u003d null) {\n       pathsToCreate \u003d Collections.emptyList();\n     }\n     if (pathsToDelete \u003d\u003d null) {\n       pathsToDelete \u003d Collections.emptyList();\n     }\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n-        delete(meta);\n+        delete(meta, null);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n         put(meta, null);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    if (pathsToCreate \u003d\u003d null) {\n      pathsToCreate \u003d Collections.emptyList();\n    }\n    if (pathsToDelete \u003d\u003d null) {\n      pathsToDelete \u003d Collections.emptyList();\n    }\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta, null);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta, null);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
      "extendedDetails": {}
    },
    "c58e11bf521d746842ce16724211a2a0339d7b61": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
      "commitDate": "17/07/19 7:24 AM",
      "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
          "commitDate": "17/07/19 7:24 AM",
          "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "20/06/19 1:56 AM",
          "commitNameOld": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 27.23,
          "commitsBetweenForRepo": 235,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,40 @@\n-  public void move(\n-      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n-        ITtlTimeProvider ttlTimeProvider,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n     if (pathsToCreate \u003d\u003d null) {\n       pathsToCreate \u003d Collections.emptyList();\n     }\n     if (pathsToDelete \u003d\u003d null) {\n       pathsToDelete \u003d Collections.emptyList();\n     }\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n-        delete(meta, ttlTimeProvider);\n+        delete(meta);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n         put(meta, null);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    if (pathsToCreate \u003d\u003d null) {\n      pathsToCreate \u003d Collections.emptyList();\n    }\n    if (pathsToDelete \u003d\u003d null) {\n      pathsToDelete \u003d Collections.emptyList();\n    }\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta, null);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), ttlTimeProvider-ITtlTimeProvider, operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
          "commitDate": "17/07/19 7:24 AM",
          "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "20/06/19 1:56 AM",
          "commitNameOld": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 27.23,
          "commitsBetweenForRepo": 235,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,40 @@\n-  public void move(\n-      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n       @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n-        ITtlTimeProvider ttlTimeProvider,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n     if (pathsToCreate \u003d\u003d null) {\n       pathsToCreate \u003d Collections.emptyList();\n     }\n     if (pathsToDelete \u003d\u003d null) {\n       pathsToDelete \u003d Collections.emptyList();\n     }\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n-        delete(meta, ttlTimeProvider);\n+        delete(meta);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n         put(meta, null);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(@Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    if (pathsToCreate \u003d\u003d null) {\n      pathsToCreate \u003d Collections.emptyList();\n    }\n    if (pathsToDelete \u003d\u003d null) {\n      pathsToDelete \u003d Collections.emptyList();\n    }\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta, null);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,42 @@\n-  public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate,\n-      ITtlTimeProvider ttlTimeProvider) throws IOException {\n+  public void move(\n+      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n+        ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n-    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n-    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n-    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n-        \"Must supply same number of paths to delete/create.\");\n+    if (pathsToCreate \u003d\u003d null) {\n+      pathsToCreate \u003d Collections.emptyList();\n+    }\n+    if (pathsToDelete \u003d\u003d null) {\n+      pathsToDelete \u003d Collections.emptyList();\n+    }\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n         delete(meta, ttlTimeProvider);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n-        put(meta);\n+        put(meta, null);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n        ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    if (pathsToCreate \u003d\u003d null) {\n      pathsToCreate \u003d Collections.emptyList();\n    }\n    if (pathsToDelete \u003d\u003d null) {\n      pathsToDelete \u003d Collections.emptyList();\n    }\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta, ttlTimeProvider);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta, null);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), ttlTimeProvider-ITtlTimeProvider, operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,42 @@\n-  public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate,\n-      ITtlTimeProvider ttlTimeProvider) throws IOException {\n+  public void move(\n+      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n+        ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n-    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n-    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n-    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n-        \"Must supply same number of paths to delete/create.\");\n+    if (pathsToCreate \u003d\u003d null) {\n+      pathsToCreate \u003d Collections.emptyList();\n+    }\n+    if (pathsToDelete \u003d\u003d null) {\n+      pathsToDelete \u003d Collections.emptyList();\n+    }\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n         delete(meta, ttlTimeProvider);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n-        put(meta);\n+        put(meta, null);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n        ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    if (pathsToCreate \u003d\u003d null) {\n      pathsToCreate \u003d Collections.emptyList();\n    }\n    if (pathsToDelete \u003d\u003d null) {\n      pathsToDelete \u003d Collections.emptyList();\n    }\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta, ttlTimeProvider);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta, null);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,42 @@\n-  public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate,\n-      ITtlTimeProvider ttlTimeProvider) throws IOException {\n+  public void move(\n+      @Nullable Collection\u003cPath\u003e pathsToDelete,\n+      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n+        ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n-    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n-    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n-    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n-        \"Must supply same number of paths to delete/create.\");\n+    if (pathsToCreate \u003d\u003d null) {\n+      pathsToCreate \u003d Collections.emptyList();\n+    }\n+    if (pathsToDelete \u003d\u003d null) {\n+      pathsToDelete \u003d Collections.emptyList();\n+    }\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n         delete(meta, ttlTimeProvider);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n-        put(meta);\n+        put(meta, null);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(\n      @Nullable Collection\u003cPath\u003e pathsToDelete,\n      @Nullable Collection\u003cPathMetadata\u003e pathsToCreate,\n        ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    if (pathsToCreate \u003d\u003d null) {\n      pathsToCreate \u003d Collections.emptyList();\n    }\n    if (pathsToDelete \u003d\u003d null) {\n      pathsToDelete \u003d Collections.emptyList();\n    }\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta, ttlTimeProvider);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta, null);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e(annotations-@Nullable), pathsToCreate-Collection\u003cPathMetadata\u003e(annotations-@Nullable), ttlTimeProvider-ITtlTimeProvider, operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        }
      ]
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "19/05/19 2:29 PM",
          "commitNameOld": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 27.77,
          "commitsBetweenForRepo": 198,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,38 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+      Collection\u003cPathMetadata\u003e pathsToCreate,\n+      ITtlTimeProvider ttlTimeProvider) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n     Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n     Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n     Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n         \"Must supply same number of paths to delete/create.\");\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n-        delete(meta);\n+        delete(meta, ttlTimeProvider);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n         put(meta);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate,\n      ITtlTimeProvider ttlTimeProvider) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n        \"Must supply same number of paths to delete/create.\");\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta, ttlTimeProvider);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e]",
            "newValue": "[pathsToDelete-Collection\u003cPath\u003e, pathsToCreate-Collection\u003cPathMetadata\u003e, ttlTimeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "19/05/19 2:29 PM",
          "commitNameOld": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 27.77,
          "commitsBetweenForRepo": 198,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,38 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n-      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+      Collection\u003cPathMetadata\u003e pathsToCreate,\n+      ITtlTimeProvider ttlTimeProvider) throws IOException {\n     LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n     Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n     Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n     Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n         \"Must supply same number of paths to delete/create.\");\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n-        delete(meta);\n+        delete(meta, ttlTimeProvider);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n         put(meta);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate,\n      ITtlTimeProvider ttlTimeProvider) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n        \"Must supply same number of paths to delete/create.\");\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta, ttlTimeProvider);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "c687a6617d73293019d8d91ac48bbfd2ccca3b40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15423. Merge fileCache and dirCache into ine single cache in LocalMetadataStore. Contributed by Gabor Bota.\n",
      "commitDate": "25/06/18 1:59 PM",
      "commitName": "c687a6617d73293019d8d91ac48bbfd2ccca3b40",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "08/05/18 6:58 PM",
      "commitNameOld": "8981674bbcff0663af820f3e87a3eaea5789968a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 47.79,
      "commitsBetweenForRepo": 363,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n   public void move(Collection\u003cPath\u003e pathsToDelete,\n       Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n \n     Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n     Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n     Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n         \"Must supply same number of paths to delete/create.\");\n \n     // I feel dirty for using reentrant lock. :-|\n     synchronized (this) {\n \n       // 1. Delete pathsToDelete\n       for (Path meta : pathsToDelete) {\n         LOG.debug(\"move: deleting metadata {}\", meta);\n         delete(meta);\n       }\n \n       // 2. Create new destination path metadata\n       for (PathMetadata meta : pathsToCreate) {\n         LOG.debug(\"move: adding metadata {}\", meta);\n         put(meta);\n       }\n \n       // 3. We now know full contents of all dirs in destination subtree\n       for (PathMetadata meta : pathsToCreate) {\n         FileStatus status \u003d meta.getFileStatus();\n         if (status \u003d\u003d null || status.isDirectory()) {\n           continue;\n         }\n         DirListingMetadata dir \u003d listChildren(status.getPath());\n         if (dir !\u003d null) {  // could be evicted already\n           dir.setAuthoritative(true);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n    LOG.info(\"Move {} to {}\", pathsToDelete, pathsToCreate);\n\n    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n        \"Must supply same number of paths to delete/create.\");\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,36 @@\n+  public void move(Collection\u003cPath\u003e pathsToDelete,\n+      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n+\n+    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n+    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n+    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n+        \"Must supply same number of paths to delete/create.\");\n+\n+    // I feel dirty for using reentrant lock. :-|\n+    synchronized (this) {\n+\n+      // 1. Delete pathsToDelete\n+      for (Path meta : pathsToDelete) {\n+        LOG.debug(\"move: deleting metadata {}\", meta);\n+        delete(meta);\n+      }\n+\n+      // 2. Create new destination path metadata\n+      for (PathMetadata meta : pathsToCreate) {\n+        LOG.debug(\"move: adding metadata {}\", meta);\n+        put(meta);\n+      }\n+\n+      // 3. We now know full contents of all dirs in destination subtree\n+      for (PathMetadata meta : pathsToCreate) {\n+        FileStatus status \u003d meta.getFileStatus();\n+        if (status \u003d\u003d null || status.isDirectory()) {\n+          continue;\n+        }\n+        DirListingMetadata dir \u003d listChildren(status.getPath());\n+        if (dir !\u003d null) {  // could be evicted already\n+          dir.setAuthoritative(true);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void move(Collection\u003cPath\u003e pathsToDelete,\n      Collection\u003cPathMetadata\u003e pathsToCreate) throws IOException {\n\n    Preconditions.checkNotNull(pathsToDelete, \"pathsToDelete is null\");\n    Preconditions.checkNotNull(pathsToCreate, \"pathsToCreate is null\");\n    Preconditions.checkArgument(pathsToDelete.size() \u003d\u003d pathsToCreate.size(),\n        \"Must supply same number of paths to delete/create.\");\n\n    // I feel dirty for using reentrant lock. :-|\n    synchronized (this) {\n\n      // 1. Delete pathsToDelete\n      for (Path meta : pathsToDelete) {\n        LOG.debug(\"move: deleting metadata {}\", meta);\n        delete(meta);\n      }\n\n      // 2. Create new destination path metadata\n      for (PathMetadata meta : pathsToCreate) {\n        LOG.debug(\"move: adding metadata {}\", meta);\n        put(meta);\n      }\n\n      // 3. We now know full contents of all dirs in destination subtree\n      for (PathMetadata meta : pathsToCreate) {\n        FileStatus status \u003d meta.getFileStatus();\n        if (status \u003d\u003d null || status.isDirectory()) {\n          continue;\n        }\n        DirListingMetadata dir \u003d listChildren(status.getPath());\n        if (dir !\u003d null) {  // could be evicted already\n          dir.setAuthoritative(true);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java"
    }
  }
}