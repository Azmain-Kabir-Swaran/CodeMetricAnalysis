{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Find.java",
  "functionName": "buildDescription",
  "functionId": "buildDescription___factory-ExpressionFactory",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/find/Find.java",
  "functionStartLine": 109,
  "functionEndLine": 159,
  "numCommitsSeen": 3,
  "timeTaken": 1037,
  "changeHistory": [
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
    "ba879a5dadbb0f33bba7e05ebc329a9942f34276"
  ],
  "changeHistoryShort": {
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": "Ybodychange",
    "ba879a5dadbb0f33bba7e05ebc329a9942f34276": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16029. Consecutive StringBuilder.append can be reused. Contributed by Ayush Saxena.\n",
      "commitDate": "11/01/19 10:54 AM",
      "commitName": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "24/02/15 11:25 PM",
      "commitNameOld": "ad8ed3e802782a7a3fb3d21c5862673a8f695372",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 1416.48,
      "commitsBetweenForRepo": 10786,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private static String buildDescription(ExpressionFactory factory) {\n     ArrayList\u003cExpression\u003e operators \u003d new ArrayList\u003cExpression\u003e();\n     ArrayList\u003cExpression\u003e primaries \u003d new ArrayList\u003cExpression\u003e();\n     for (Class\u003c? extends Expression\u003e exprClass : EXPRESSIONS) {\n       Expression expr \u003d factory.createExpression(exprClass, null);\n       if (expr.isOperator()) {\n         operators.add(expr);\n       } else {\n         primaries.add(expr);\n       }\n     }\n     Collections.sort(operators, new Comparator\u003cExpression\u003e() {\n       @Override\n       public int compare(Expression arg0, Expression arg1) {\n         return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n       }\n     });\n     Collections.sort(primaries, new Comparator\u003cExpression\u003e() {\n       @Override\n       public int compare(Expression arg0, Expression arg1) {\n         return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n       }\n     });\n \n     StringBuilder sb \u003d new StringBuilder();\n     for (String line : HELP) {\n       sb.append(line).append(\"\\n\");\n     }\n-    sb.append(\"\\n\");\n-    sb.append(\"The following primary expressions are recognised:\\n\");\n+    sb.append(\"\\n\")\n+        .append(\"The following primary expressions are recognised:\\n\");\n     for (Expression expr : primaries) {\n       for (String line : expr.getUsage()) {\n         sb.append(\"  \").append(line).append(\"\\n\");\n       }\n       for (String line : expr.getHelp()) {\n         sb.append(\"    \").append(line).append(\"\\n\");\n       }\n       sb.append(\"\\n\");\n     }\n     sb.append(\"The following operators are recognised:\\n\");\n     for (Expression expr : operators) {\n       for (String line : expr.getUsage()) {\n         sb.append(\"  \").append(line).append(\"\\n\");\n       }\n       for (String line : expr.getHelp()) {\n         sb.append(\"    \").append(line).append(\"\\n\");\n       }\n       sb.append(\"\\n\");\n     }\n     return sb.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static String buildDescription(ExpressionFactory factory) {\n    ArrayList\u003cExpression\u003e operators \u003d new ArrayList\u003cExpression\u003e();\n    ArrayList\u003cExpression\u003e primaries \u003d new ArrayList\u003cExpression\u003e();\n    for (Class\u003c? extends Expression\u003e exprClass : EXPRESSIONS) {\n      Expression expr \u003d factory.createExpression(exprClass, null);\n      if (expr.isOperator()) {\n        operators.add(expr);\n      } else {\n        primaries.add(expr);\n      }\n    }\n    Collections.sort(operators, new Comparator\u003cExpression\u003e() {\n      @Override\n      public int compare(Expression arg0, Expression arg1) {\n        return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n      }\n    });\n    Collections.sort(primaries, new Comparator\u003cExpression\u003e() {\n      @Override\n      public int compare(Expression arg0, Expression arg1) {\n        return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n      }\n    });\n\n    StringBuilder sb \u003d new StringBuilder();\n    for (String line : HELP) {\n      sb.append(line).append(\"\\n\");\n    }\n    sb.append(\"\\n\")\n        .append(\"The following primary expressions are recognised:\\n\");\n    for (Expression expr : primaries) {\n      for (String line : expr.getUsage()) {\n        sb.append(\"  \").append(line).append(\"\\n\");\n      }\n      for (String line : expr.getHelp()) {\n        sb.append(\"    \").append(line).append(\"\\n\");\n      }\n      sb.append(\"\\n\");\n    }\n    sb.append(\"The following operators are recognised:\\n\");\n    for (Expression expr : operators) {\n      for (String line : expr.getUsage()) {\n        sb.append(\"  \").append(line).append(\"\\n\");\n      }\n      for (String line : expr.getHelp()) {\n        sb.append(\"    \").append(line).append(\"\\n\");\n      }\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/find/Find.java",
      "extendedDetails": {}
    },
    "ba879a5dadbb0f33bba7e05ebc329a9942f34276": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8989. hadoop fs -find feature (Jonathan Allen via aw)\n",
      "commitDate": "13/11/14 11:52 AM",
      "commitName": "ba879a5dadbb0f33bba7e05ebc329a9942f34276",
      "commitAuthor": "Allen Wittenauer",
      "diff": "@@ -0,0 +1,51 @@\n+  private static String buildDescription(ExpressionFactory factory) {\n+    ArrayList\u003cExpression\u003e operators \u003d new ArrayList\u003cExpression\u003e();\n+    ArrayList\u003cExpression\u003e primaries \u003d new ArrayList\u003cExpression\u003e();\n+    for (Class\u003c? extends Expression\u003e exprClass : EXPRESSIONS) {\n+      Expression expr \u003d factory.createExpression(exprClass, null);\n+      if (expr.isOperator()) {\n+        operators.add(expr);\n+      } else {\n+        primaries.add(expr);\n+      }\n+    }\n+    Collections.sort(operators, new Comparator\u003cExpression\u003e() {\n+      @Override\n+      public int compare(Expression arg0, Expression arg1) {\n+        return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n+      }\n+    });\n+    Collections.sort(primaries, new Comparator\u003cExpression\u003e() {\n+      @Override\n+      public int compare(Expression arg0, Expression arg1) {\n+        return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n+      }\n+    });\n+\n+    StringBuilder sb \u003d new StringBuilder();\n+    for (String line : HELP) {\n+      sb.append(line).append(\"\\n\");\n+    }\n+    sb.append(\"\\n\");\n+    sb.append(\"The following primary expressions are recognised:\\n\");\n+    for (Expression expr : primaries) {\n+      for (String line : expr.getUsage()) {\n+        sb.append(\"  \").append(line).append(\"\\n\");\n+      }\n+      for (String line : expr.getHelp()) {\n+        sb.append(\"    \").append(line).append(\"\\n\");\n+      }\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"The following operators are recognised:\\n\");\n+    for (Expression expr : operators) {\n+      for (String line : expr.getUsage()) {\n+        sb.append(\"  \").append(line).append(\"\\n\");\n+      }\n+      for (String line : expr.getHelp()) {\n+        sb.append(\"    \").append(line).append(\"\\n\");\n+      }\n+      sb.append(\"\\n\");\n+    }\n+    return sb.toString();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static String buildDescription(ExpressionFactory factory) {\n    ArrayList\u003cExpression\u003e operators \u003d new ArrayList\u003cExpression\u003e();\n    ArrayList\u003cExpression\u003e primaries \u003d new ArrayList\u003cExpression\u003e();\n    for (Class\u003c? extends Expression\u003e exprClass : EXPRESSIONS) {\n      Expression expr \u003d factory.createExpression(exprClass, null);\n      if (expr.isOperator()) {\n        operators.add(expr);\n      } else {\n        primaries.add(expr);\n      }\n    }\n    Collections.sort(operators, new Comparator\u003cExpression\u003e() {\n      @Override\n      public int compare(Expression arg0, Expression arg1) {\n        return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n      }\n    });\n    Collections.sort(primaries, new Comparator\u003cExpression\u003e() {\n      @Override\n      public int compare(Expression arg0, Expression arg1) {\n        return arg0.getClass().getName().compareTo(arg1.getClass().getName());\n      }\n    });\n\n    StringBuilder sb \u003d new StringBuilder();\n    for (String line : HELP) {\n      sb.append(line).append(\"\\n\");\n    }\n    sb.append(\"\\n\");\n    sb.append(\"The following primary expressions are recognised:\\n\");\n    for (Expression expr : primaries) {\n      for (String line : expr.getUsage()) {\n        sb.append(\"  \").append(line).append(\"\\n\");\n      }\n      for (String line : expr.getHelp()) {\n        sb.append(\"    \").append(line).append(\"\\n\");\n      }\n      sb.append(\"\\n\");\n    }\n    sb.append(\"The following operators are recognised:\\n\");\n    for (Expression expr : operators) {\n      for (String line : expr.getUsage()) {\n        sb.append(\"  \").append(line).append(\"\\n\");\n      }\n      for (String line : expr.getHelp()) {\n        sb.append(\"    \").append(line).append(\"\\n\");\n      }\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/find/Find.java"
    }
  }
}