{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SecondaryNameNode.java",
  "functionName": "doCheckpoint",
  "functionId": "doCheckpoint",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
  "functionStartLine": 525,
  "functionEndLine": 597,
  "numCommitsSeen": 98,
  "timeTaken": 7342,
  "changeHistory": [
    "97f58955a6045b373ab73653bf26ab5922b00cf3",
    "94a1632fcb677fda6f4d812614026417f1d0a360",
    "dbd22b23c2d68b97b4da47215897906f06f978e3",
    "0f595915a388305edbb3ce928415571811d304e8",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "00067895a01c66d53715b50bbcb3605efd6425f2",
    "75a162ff92d365d88ed253335b52aaa3709f6365",
    "cfa86e611077e19064568a35a191250a57c75db7",
    "a8e39feed2642dbfedb8fd22648904ad4bb6af97",
    "92cb6b093c7e3a39083c0497d80bd7e4eeae9c7f",
    "9833468302bd2fa235d9d1f40517631f9dfff517",
    "cbc242429093ccabf76248f857de5e587a9682b0",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "97f58955a6045b373ab73653bf26ab5922b00cf3": "Ybodychange",
    "94a1632fcb677fda6f4d812614026417f1d0a360": "Ybodychange",
    "dbd22b23c2d68b97b4da47215897906f06f978e3": "Ybodychange",
    "0f595915a388305edbb3ce928415571811d304e8": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "00067895a01c66d53715b50bbcb3605efd6425f2": "Ybodychange",
    "75a162ff92d365d88ed253335b52aaa3709f6365": "Ymodifierchange",
    "cfa86e611077e19064568a35a191250a57c75db7": "Ybodychange",
    "a8e39feed2642dbfedb8fd22648904ad4bb6af97": "Ybodychange",
    "92cb6b093c7e3a39083c0497d80bd7e4eeae9c7f": "Ybodychange",
    "9833468302bd2fa235d9d1f40517631f9dfff517": "Ybodychange",
    "cbc242429093ccabf76248f857de5e587a9682b0": "Ybodychange",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "97f58955a6045b373ab73653bf26ab5922b00cf3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6293. Issues with OIV processing PB-based fsimages. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594439 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 6:15 PM",
      "commitName": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/04/14 4:49 PM",
      "commitNameOld": "b8a3e2bb20674b81215ae6d038053e2cd716e7e5",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 18.06,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,73 @@\n   public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n         NameNodeFile.IMAGE, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n-    \n+\n+    if (legacyOivImageDir !\u003d null \u0026\u0026 !legacyOivImageDir.isEmpty()) {\n+      try {\n+        checkpointImage.saveLegacyOIVImage(namesystem, legacyOivImageDir,\n+            new Canceler());\n+      } catch (IOException e) {\n+        LOG.warn(\"Failed to write legacy OIV image: \", e);\n+      }\n+    }\n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n        NameNodeFile.IMAGE, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n\n    if (legacyOivImageDir !\u003d null \u0026\u0026 !legacyOivImageDir.isEmpty()) {\n      try {\n        checkpointImage.saveLegacyOIVImage(namesystem, legacyOivImageDir,\n            new Canceler());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to write legacy OIV image: \", e);\n      }\n    }\n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "94a1632fcb677fda6f4d812614026417f1d0a360": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:25 PM",
      "commitName": "94a1632fcb677fda6f4d812614026417f1d0a360",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "08/03/14 1:15 PM",
      "commitNameOld": "dbd22b23c2d68b97b4da47215897906f06f978e3",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n-    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n-        dstStorage, NameNodeFile.IMAGE, txid);\n+    TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n+        NameNodeFile.IMAGE, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n        NameNodeFile.IMAGE, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "dbd22b23c2d68b97b4da47215897906f06f978e3": {
      "type": "Ybodychange",
      "commitMessage": "Revert HDFS-3405 for recommit with correct renamed files\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575610 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:15 PM",
      "commitName": "dbd22b23c2d68b97b4da47215897906f06f978e3",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/03/14 4:39 PM",
      "commitNameOld": "0f595915a388305edbb3ce928415571811d304e8",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.86,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n-    TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n-        NameNodeFile.IMAGE, txid);\n+    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n+        dstStorage, NameNodeFile.IMAGE, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, NameNodeFile.IMAGE, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "0f595915a388305edbb3ce928415571811d304e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575457 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 4:39 PM",
      "commitName": "0f595915a388305edbb3ce928415571811d304e8",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/02/14 5:21 PM",
      "commitNameOld": "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 7.97,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n-    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n-        dstStorage, NameNodeFile.IMAGE, txid);\n+    TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n+        NameNodeFile.IMAGE, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, conf, dstStorage,\n        NameNodeFile.IMAGE, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/01/14 7:24 PM",
      "commitNameOld": "f2972402b78b75874599666482332fa5f51351fa",
      "commitAuthorOld": "",
      "daysBetweenCommits": 25.77,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n             \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n-        dstStorage, txid);\n+        dstStorage, NameNodeFile.IMAGE, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, NameNodeFile.IMAGE, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "00067895a01c66d53715b50bbcb3605efd6425f2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5754. Split LayoutVerion into NameNodeLayoutVersion and DataNodeLayoutVersion. Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1563041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 7:21 PM",
      "commitName": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/01/14 9:09 PM",
      "commitNameOld": "b8776ee65b5b2d57b1904caf0c79840123eba48b",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.92,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n-        (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n-        (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n+        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n+            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n+        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n+            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation(NameNodeLayoutVersion.FEATURES)\n            \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "75a162ff92d365d88ed253335b52aaa3709f6365": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-5433. When reloading fsimage during checkpointing, we should clear existing snapshottable directories. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1537192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/13 10:27 AM",
      "commitName": "75a162ff92d365d88ed253335b52aaa3709f6365",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "05/09/13 9:21 AM",
      "commitNameOld": "8aea748ec37b8e66c222f704eacedb47d9c73cfd",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 55.05,
      "commitsBetweenForRepo": 367,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n-  boolean doCheckpoint() throws IOException {\n+  public boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest) |\n         checkpointImage.hasMergeError();\n     try {\n       doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     } catch (IOException ioe) {\n       // A merge error occurred. The in-memory file system state may be\n       // inconsistent, so the image and edits need to be reloaded.\n       checkpointImage.setMergeError();\n       throw ioe;\n     }\n     // Clear any error since merge was successful.\n     checkpointImage.clearMergeError();\n \n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[public]"
      }
    },
    "cfa86e611077e19064568a35a191250a57c75db7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4128. 2NN gets stuck in inconsistent state if edit log replay fails in the middle (kihwal via daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1452384 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/13 8:44 AM",
      "commitName": "cfa86e611077e19064568a35a191250a57c75db7",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "04/02/13 1:29 PM",
      "commitNameOld": "a8e39feed2642dbfedb8fd22648904ad4bb6af97",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 27.8,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,63 @@\n   boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     boolean loadImage \u003d false;\n     boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n     boolean isSameCluster \u003d\n         (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n         (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n     if (isFreshCheckpointer ||\n         (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n       loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n+    // Fetch fsimage and edits. Reload the image if previous merge failed.\n     loadImage |\u003d downloadCheckpointFiles(\n-        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n-    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n+        fsName, checkpointImage, sig, manifest) |\n+        checkpointImage.hasMergeError();\n+    try {\n+      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n+    } catch (IOException ioe) {\n+      // A merge error occurred. The in-memory file system state may be\n+      // inconsistent, so the image and edits need to be reloaded.\n+      checkpointImage.setMergeError();\n+      throw ioe;\n+    }\n+    // Clear any error since merge was successful.\n+    checkpointImage.clearMergeError();\n+\n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    // Fetch fsimage and edits. Reload the image if previous merge failed.\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest) |\n        checkpointImage.hasMergeError();\n    try {\n      doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    } catch (IOException ioe) {\n      // A merge error occurred. The in-memory file system state may be\n      // inconsistent, so the image and edits need to be reloaded.\n      checkpointImage.setMergeError();\n      throw ioe;\n    }\n    // Clear any error since merge was successful.\n    checkpointImage.clearMergeError();\n\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "a8e39feed2642dbfedb8fd22648904ad4bb6af97": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4462. 2NN will fail to checkpoint after an HDFS upgrade from a pre-federation version of HDFS. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1442375 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/13 1:29 PM",
      "commitName": "a8e39feed2642dbfedb8fd22648904ad4bb6af97",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "23/01/13 11:00 AM",
      "commitNameOld": "a1e6df6bc4e26a29a05d5d292f2a68bf8919c237",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 12.1,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,51 @@\n   boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n-    if ((checkpointImage.getNamespaceID() \u003d\u003d 0) ||\n-        (sig.isSameCluster(checkpointImage) \u0026\u0026\n+    boolean loadImage \u003d false;\n+    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n+    boolean isSameCluster \u003d\n+        (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n+        (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n+    if (isFreshCheckpointer ||\n+        (isSameCluster \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n+      loadImage \u003d true;\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n-    boolean loadImage \u003d downloadCheckpointFiles(\n+    loadImage |\u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n     doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    boolean loadImage \u003d false;\n    boolean isFreshCheckpointer \u003d (checkpointImage.getNamespaceID() \u003d\u003d 0);\n    boolean isSameCluster \u003d\n        (dstStorage.versionSupportsFederation() \u0026\u0026 sig.isSameCluster(checkpointImage)) ||\n        (!dstStorage.versionSupportsFederation() \u0026\u0026 sig.namespaceIdMatches(checkpointImage));\n    if (isFreshCheckpointer ||\n        (isSameCluster \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n      loadImage \u003d true;\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    loadImage |\u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "92cb6b093c7e3a39083c0497d80bd7e4eeae9c7f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3678. Edit log files are never being purged from 2NN. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377046 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 11:52 AM",
      "commitName": "92cb6b093c7e3a39083c0497d80bd7e4eeae9c7f",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "22/08/12 11:47 AM",
      "commitNameOld": "de8b34a70e7ed4aef4675dbbef90df9f596efa12",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,45 @@\n   boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     if ((checkpointImage.getNamespaceID() \u003d\u003d 0) ||\n         (sig.isSameCluster(checkpointImage) \u0026\u0026\n          !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n       // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n       // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n     }\n     sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     boolean loadImage \u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n     doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n-    // Since we\u0027ve successfully checkpointed, we can remove some old\n-    // image files\n-    checkpointImage.purgeOldStorage();\n-    \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    if ((checkpointImage.getNamespaceID() \u003d\u003d 0) ||\n        (sig.isSameCluster(checkpointImage) \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "9833468302bd2fa235d9d1f40517631f9dfff517": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3597. SNN fails to start after DFS upgrade. Contributed by Andy Isaacson.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1363899 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/07/12 11:58 AM",
      "commitName": "9833468302bd2fa235d9d1f40517631f9dfff517",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "16/07/12 2:26 PM",
      "commitNameOld": "527933f4f351a3df5e369c8bb6e2cfc4937e0836",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 3.9,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,49 @@\n   boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n-    // Make sure we\u0027re talking to the same NN!\n-    if (checkpointImage.getNamespaceID() !\u003d 0) {\n-      // If the image actually has some data, make sure we\u0027re talking\n-      // to the same NN as we did before.\n-      sig.validateStorageInfo(checkpointImage);\n-    } else {\n-      // if we\u0027re a fresh 2NN, just take the storage info from the server\n-      // we first talk to.\n+    if ((checkpointImage.getNamespaceID() \u003d\u003d 0) ||\n+        (sig.isSameCluster(checkpointImage) \u0026\u0026\n+         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n+      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n+      // needs an upgrade, just take the storage info from the server.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n     }\n+    sig.validateStorageInfo(checkpointImage);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     boolean loadImage \u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n     doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     // Since we\u0027ve successfully checkpointed, we can remove some old\n     // image files\n     checkpointImage.purgeOldStorage();\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    if ((checkpointImage.getNamespaceID() \u003d\u003d 0) ||\n        (sig.isSameCluster(checkpointImage) \u0026\u0026\n         !sig.storageVersionMatches(checkpointImage.getStorage()))) {\n      // if we\u0027re a fresh 2NN, or if we\u0027re on the same cluster and our storage\n      // needs an upgrade, just take the storage info from the server.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n    sig.validateStorageInfo(checkpointImage);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    // Since we\u0027ve successfully checkpointed, we can remove some old\n    // image files\n    checkpointImage.purgeOldStorage();\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "cbc242429093ccabf76248f857de5e587a9682b0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3330. If GetImageServlet throws an Error or RTE, response should not have HTTP \"OK\" status. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1333286 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/12 6:44 PM",
      "commitName": "cbc242429093ccabf76248f857de5e587a9682b0",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "15/03/12 2:51 PM",
      "commitNameOld": "65425b0961d6634f0fc0d798bbd12f02d40a8578",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 48.16,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,51 @@\n   boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     // Make sure we\u0027re talking to the same NN!\n     if (checkpointImage.getNamespaceID() !\u003d 0) {\n       // If the image actually has some data, make sure we\u0027re talking\n       // to the same NN as we did before.\n       sig.validateStorageInfo(checkpointImage);\n     } else {\n       // if we\u0027re a fresh 2NN, just take the storage info from the server\n       // we first talk to.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n     }\n \n     // error simulation code for junit test\n-    if (ErrorSimulator.getErrorSimulation(0)) {\n-      throw new IOException(\"Simulating error0 \" +\n-                            \"after creating edits.new\");\n-    }\n+    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     boolean loadImage \u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n     doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n-    if (ErrorSimulator.getErrorSimulation(1)) {\n-      throw new IOException(\"Simulating error1 \" +\n-                            \"after uploading new image to NameNode\");\n-    }\n+    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     // Since we\u0027ve successfully checkpointed, we can remove some old\n     // image files\n     checkpointImage.purgeOldStorage();\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    // Make sure we\u0027re talking to the same NN!\n    if (checkpointImage.getNamespaceID() !\u003d 0) {\n      // If the image actually has some data, make sure we\u0027re talking\n      // to the same NN as we did before.\n      sig.validateStorageInfo(checkpointImage);\n    } else {\n      // if we\u0027re a fresh 2NN, just take the storage info from the server\n      // we first talk to.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryCallsRollEditLog();\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    CheckpointFaultInjector.getInstance().afterSecondaryUploadsNewImage();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    // Since we\u0027ve successfully checkpointed, we can remove some old\n    // image files\n    checkpointImage.purgeOldStorage();\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/11 4:23 PM",
      "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/09/11 12:30 PM",
      "commitNameOld": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 3.16,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   boolean doCheckpoint() throws IOException {\n     checkpointImage.ensureCurrentDirExists();\n     NNStorage dstStorage \u003d checkpointImage.getStorage();\n     \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n     \n     // Make sure we\u0027re talking to the same NN!\n     if (checkpointImage.getNamespaceID() !\u003d 0) {\n       // If the image actually has some data, make sure we\u0027re talking\n       // to the same NN as we did before.\n       sig.validateStorageInfo(checkpointImage);\n     } else {\n       // if we\u0027re a fresh 2NN, just take the storage info from the server\n       // we first talk to.\n       dstStorage.setStorageInfo(sig);\n       dstStorage.setClusterID(sig.getClusterID());\n       dstStorage.setBlockPoolID(sig.getBlockpoolID());\n     }\n \n     // error simulation code for junit test\n     if (ErrorSimulator.getErrorSimulation(0)) {\n       throw new IOException(\"Simulating error0 \" +\n                             \"after creating edits.new\");\n     }\n \n     RemoteEditLogManifest manifest \u003d\n       namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n \n     boolean loadImage \u003d downloadCheckpointFiles(\n         fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n-    doMerge(sig, manifest, loadImage, checkpointImage);\n+    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n     \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n     long txid \u003d checkpointImage.getLastAppliedTxId();\n     TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n         dstStorage, txid);\n \n     // error simulation code for junit test\n     if (ErrorSimulator.getErrorSimulation(1)) {\n       throw new IOException(\"Simulating error1 \" +\n                             \"after uploading new image to NameNode\");\n     }\n \n     LOG.warn(\"Checkpoint done. New Image Size: \" \n              + dstStorage.getFsImageName(txid).length());\n     \n     // Since we\u0027ve successfully checkpointed, we can remove some old\n     // image files\n     checkpointImage.purgeOldStorage();\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    // Make sure we\u0027re talking to the same NN!\n    if (checkpointImage.getNamespaceID() !\u003d 0) {\n      // If the image actually has some data, make sure we\u0027re talking\n      // to the same NN as we did before.\n      sig.validateStorageInfo(checkpointImage);\n    } else {\n      // if we\u0027re a fresh 2NN, just take the storage info from the server\n      // we first talk to.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(0)) {\n      throw new IOException(\"Simulating error0 \" +\n                            \"after creating edits.new\");\n    }\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage, namesystem);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(1)) {\n      throw new IOException(\"Simulating error1 \" +\n                            \"after uploading new image to NameNode\");\n    }\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    // Since we\u0027ve successfully checkpointed, we can remove some old\n    // image files\n    checkpointImage.purgeOldStorage();\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    // Make sure we\u0027re talking to the same NN!\n    if (checkpointImage.getNamespaceID() !\u003d 0) {\n      // If the image actually has some data, make sure we\u0027re talking\n      // to the same NN as we did before.\n      sig.validateStorageInfo(checkpointImage);\n    } else {\n      // if we\u0027re a fresh 2NN, just take the storage info from the server\n      // we first talk to.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(0)) {\n      throw new IOException(\"Simulating error0 \" +\n                            \"after creating edits.new\");\n    }\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(1)) {\n      throw new IOException(\"Simulating error1 \" +\n                            \"after uploading new image to NameNode\");\n    }\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    // Since we\u0027ve successfully checkpointed, we can remove some old\n    // image files\n    checkpointImage.purgeOldStorage();\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    // Make sure we\u0027re talking to the same NN!\n    if (checkpointImage.getNamespaceID() !\u003d 0) {\n      // If the image actually has some data, make sure we\u0027re talking\n      // to the same NN as we did before.\n      sig.validateStorageInfo(checkpointImage);\n    } else {\n      // if we\u0027re a fresh 2NN, just take the storage info from the server\n      // we first talk to.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(0)) {\n      throw new IOException(\"Simulating error0 \" +\n                            \"after creating edits.new\");\n    }\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(1)) {\n      throw new IOException(\"Simulating error1 \" +\n                            \"after uploading new image to NameNode\");\n    }\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    // Since we\u0027ve successfully checkpointed, we can remove some old\n    // image files\n    checkpointImage.purgeOldStorage();\n    \n    return loadImage;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/07/11 8:19 PM",
      "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.55,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,57 @@\n   boolean doCheckpoint() throws IOException {\n-\n-    // Do the required initialization of the merge work area.\n-    startCheckpoint();\n-\n+    checkpointImage.ensureCurrentDirExists();\n+    NNStorage dstStorage \u003d checkpointImage.getStorage();\n+    \n     // Tell the namenode to start logging transactions in a new edit file\n     // Returns a token that would be used to upload the merged image.\n     CheckpointSignature sig \u003d namenode.rollEditLog();\n+    \n+    // Make sure we\u0027re talking to the same NN!\n+    if (checkpointImage.getNamespaceID() !\u003d 0) {\n+      // If the image actually has some data, make sure we\u0027re talking\n+      // to the same NN as we did before.\n+      sig.validateStorageInfo(checkpointImage);\n+    } else {\n+      // if we\u0027re a fresh 2NN, just take the storage info from the server\n+      // we first talk to.\n+      dstStorage.setStorageInfo(sig);\n+      dstStorage.setClusterID(sig.getClusterID());\n+      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n+    }\n \n     // error simulation code for junit test\n     if (ErrorSimulator.getErrorSimulation(0)) {\n       throw new IOException(\"Simulating error0 \" +\n                             \"after creating edits.new\");\n     }\n \n-    boolean loadImage \u003d downloadCheckpointFiles(sig);   // Fetch fsimage and edits\n-    doMerge(sig, loadImage);                   // Do the merge\n-  \n+    RemoteEditLogManifest manifest \u003d\n+      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n+\n+    boolean loadImage \u003d downloadCheckpointFiles(\n+        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n+    doMerge(sig, manifest, loadImage, checkpointImage);\n+    \n     //\n     // Upload the new image into the NameNode. Then tell the Namenode\n     // to make this new uploaded image as the most current image.\n     //\n-    putFSImage(sig);\n+    long txid \u003d checkpointImage.getLastAppliedTxId();\n+    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n+        dstStorage, txid);\n \n     // error simulation code for junit test\n     if (ErrorSimulator.getErrorSimulation(1)) {\n       throw new IOException(\"Simulating error1 \" +\n                             \"after uploading new image to NameNode\");\n     }\n \n-    namenode.rollFsImage(sig);\n-    checkpointImage.endCheckpoint();\n-\n     LOG.warn(\"Checkpoint done. New Image Size: \" \n-             + checkpointImage.getStorage().getFsImageName().length());\n+             + dstStorage.getFsImageName(txid).length());\n+    \n+    // Since we\u0027ve successfully checkpointed, we can remove some old\n+    // image files\n+    checkpointImage.purgeOldStorage();\n     \n     return loadImage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n    checkpointImage.ensureCurrentDirExists();\n    NNStorage dstStorage \u003d checkpointImage.getStorage();\n    \n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n    \n    // Make sure we\u0027re talking to the same NN!\n    if (checkpointImage.getNamespaceID() !\u003d 0) {\n      // If the image actually has some data, make sure we\u0027re talking\n      // to the same NN as we did before.\n      sig.validateStorageInfo(checkpointImage);\n    } else {\n      // if we\u0027re a fresh 2NN, just take the storage info from the server\n      // we first talk to.\n      dstStorage.setStorageInfo(sig);\n      dstStorage.setClusterID(sig.getClusterID());\n      dstStorage.setBlockPoolID(sig.getBlockpoolID());\n    }\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(0)) {\n      throw new IOException(\"Simulating error0 \" +\n                            \"after creating edits.new\");\n    }\n\n    RemoteEditLogManifest manifest \u003d\n      namenode.getEditLogManifest(sig.mostRecentCheckpointTxId + 1);\n\n    boolean loadImage \u003d downloadCheckpointFiles(\n        fsName, checkpointImage, sig, manifest);   // Fetch fsimage and edits\n    doMerge(sig, manifest, loadImage, checkpointImage);\n    \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    long txid \u003d checkpointImage.getLastAppliedTxId();\n    TransferFsImage.uploadImageFromStorage(fsName, getImageListenAddress(),\n        dstStorage, txid);\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(1)) {\n      throw new IOException(\"Simulating error1 \" +\n                            \"after uploading new image to NameNode\");\n    }\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + dstStorage.getFsImageName(txid).length());\n    \n    // Since we\u0027ve successfully checkpointed, we can remove some old\n    // image files\n    checkpointImage.purgeOldStorage();\n    \n    return loadImage;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,38 @@\n+  boolean doCheckpoint() throws IOException {\n+\n+    // Do the required initialization of the merge work area.\n+    startCheckpoint();\n+\n+    // Tell the namenode to start logging transactions in a new edit file\n+    // Returns a token that would be used to upload the merged image.\n+    CheckpointSignature sig \u003d namenode.rollEditLog();\n+\n+    // error simulation code for junit test\n+    if (ErrorSimulator.getErrorSimulation(0)) {\n+      throw new IOException(\"Simulating error0 \" +\n+                            \"after creating edits.new\");\n+    }\n+\n+    boolean loadImage \u003d downloadCheckpointFiles(sig);   // Fetch fsimage and edits\n+    doMerge(sig, loadImage);                   // Do the merge\n+  \n+    //\n+    // Upload the new image into the NameNode. Then tell the Namenode\n+    // to make this new uploaded image as the most current image.\n+    //\n+    putFSImage(sig);\n+\n+    // error simulation code for junit test\n+    if (ErrorSimulator.getErrorSimulation(1)) {\n+      throw new IOException(\"Simulating error1 \" +\n+                            \"after uploading new image to NameNode\");\n+    }\n+\n+    namenode.rollFsImage(sig);\n+    checkpointImage.endCheckpoint();\n+\n+    LOG.warn(\"Checkpoint done. New Image Size: \" \n+             + checkpointImage.getStorage().getFsImageName().length());\n+    \n+    return loadImage;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean doCheckpoint() throws IOException {\n\n    // Do the required initialization of the merge work area.\n    startCheckpoint();\n\n    // Tell the namenode to start logging transactions in a new edit file\n    // Returns a token that would be used to upload the merged image.\n    CheckpointSignature sig \u003d namenode.rollEditLog();\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(0)) {\n      throw new IOException(\"Simulating error0 \" +\n                            \"after creating edits.new\");\n    }\n\n    boolean loadImage \u003d downloadCheckpointFiles(sig);   // Fetch fsimage and edits\n    doMerge(sig, loadImage);                   // Do the merge\n  \n    //\n    // Upload the new image into the NameNode. Then tell the Namenode\n    // to make this new uploaded image as the most current image.\n    //\n    putFSImage(sig);\n\n    // error simulation code for junit test\n    if (ErrorSimulator.getErrorSimulation(1)) {\n      throw new IOException(\"Simulating error1 \" +\n                            \"after uploading new image to NameNode\");\n    }\n\n    namenode.rollFsImage(sig);\n    checkpointImage.endCheckpoint();\n\n    LOG.warn(\"Checkpoint done. New Image Size: \" \n             + checkpointImage.getStorage().getFsImageName().length());\n    \n    return loadImage;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java"
    }
  }
}