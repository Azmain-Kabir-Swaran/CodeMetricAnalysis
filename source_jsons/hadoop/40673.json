{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AllocationTagsManager.java",
  "functionName": "addContainer",
  "functionId": "addContainer___nodeId-NodeId__containerId-ContainerId__allocationTags-Set__String__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
  "functionStartLine": 345,
  "functionEndLine": 358,
  "numCommitsSeen": 15,
  "timeTaken": 4366,
  "changeHistory": [
    "adbe87abf8b2814e0e2988d09ef8a8569190c80e",
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
    "37f1a7b64fcc93191367330cd59d4d71d7b29ac7",
    "06eb63e64b05e2e8bb8a76c15360ab0495f11317",
    "801c0988b5ad1eff1e896a2635c2937721c96b04"
  ],
  "changeHistoryShort": {
    "adbe87abf8b2814e0e2988d09ef8a8569190c80e": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ybodychange",
    "a52d11fb8c103f14e42692600a058ba3b56e2ecf": "Ymultichange(Yparameterchange,Ybodychange)",
    "37f1a7b64fcc93191367330cd59d4d71d7b29ac7": "Ybodychange",
    "06eb63e64b05e2e8bb8a76c15360ab0495f11317": "Yfilerename",
    "801c0988b5ad1eff1e896a2635c2937721c96b04": "Yintroduced"
  },
  "changeHistoryDetails": {
    "adbe87abf8b2814e0e2988d09ef8a8569190c80e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7788. Factor out management of temp tags from AllocationTagsManager. (Arun Suresh via kkaranasos)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "adbe87abf8b2814e0e2988d09ef8a8569190c80e",
      "commitAuthor": "Konstantinos Karanasos",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,14 @@\n   public void addContainer(NodeId nodeId, ContainerId containerId,\n       Set\u003cString\u003e allocationTags) {\n     // Do nothing for empty allocation tags.\n     if (allocationTags \u003d\u003d null || allocationTags.isEmpty()) {\n       return;\n     }\n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n-    writeLock.lock();\n-    try {\n-      TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n-          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n-      TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n-          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n-      // Covering test-cases where context is mocked\n-      String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n-          \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n-              ? rmContext.getRMNodes().get(nodeId).getRackName() :\n-          \"default-rack\";\n-      perAppTagsMapping.addTags(nodeId, allocationTags);\n-      perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n-      globalNodeMapping.addTags(nodeId, allocationTags);\n-      globalRackMapping.addTags(nodeRack, allocationTags);\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n-            + StringUtils.join(allocationTags, \",\") + \"]\");\n-      }\n-    } finally {\n-      writeLock.unlock();\n+    addTags(nodeId, applicationId, allocationTags);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n+          + StringUtils.join(allocationTags, \",\") + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addContainer(NodeId nodeId, ContainerId containerId,\n      Set\u003cString\u003e allocationTags) {\n    // Do nothing for empty allocation tags.\n    if (allocationTags \u003d\u003d null || allocationTags.isEmpty()) {\n      return;\n    }\n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    addTags(nodeId, applicationId, allocationTags);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n          + StringUtils.join(allocationTags, \",\") + \"]\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,32 @@\n   public void addContainer(NodeId nodeId, ContainerId containerId,\n       Set\u003cString\u003e allocationTags) {\n+    // Do nothing for empty allocation tags.\n+    if (allocationTags \u003d\u003d null || allocationTags.isEmpty()) {\n+      return;\n+    }\n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n-    String applicationIdTag \u003d\n-        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n-\n-    boolean useSet \u003d false;\n-    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n-      // Copy before edit it.\n-      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n-      allocationTags.add(applicationIdTag);\n-      useSet \u003d true;\n-    }\n-\n     writeLock.lock();\n     try {\n       TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n           .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n       TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n           .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n       // Covering test-cases where context is mocked\n       String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n           \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n-              ? rmContext.getRMNodes().get(nodeId).getRackName()\n-              : \"default-rack\";\n-      if (useSet) {\n-        perAppTagsMapping.addTags(nodeId, allocationTags);\n-        perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n-        globalNodeMapping.addTags(nodeId, allocationTags);\n-        globalRackMapping.addTags(nodeRack, allocationTags);\n-      } else {\n-        perAppTagsMapping.addTag(nodeId, applicationIdTag);\n-        perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n-        globalNodeMapping.addTag(nodeId, applicationIdTag);\n-        globalRackMapping.addTag(nodeRack, applicationIdTag);\n-      }\n+              ? rmContext.getRMNodes().get(nodeId).getRackName() :\n+          \"default-rack\";\n+      perAppTagsMapping.addTags(nodeId, allocationTags);\n+      perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n+      globalNodeMapping.addTags(nodeId, allocationTags);\n+      globalRackMapping.addTags(nodeRack, allocationTags);\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n             + StringUtils.join(allocationTags, \",\") + \"]\");\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addContainer(NodeId nodeId, ContainerId containerId,\n      Set\u003cString\u003e allocationTags) {\n    // Do nothing for empty allocation tags.\n    if (allocationTags \u003d\u003d null || allocationTags.isEmpty()) {\n      return;\n    }\n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    writeLock.lock();\n    try {\n      TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n      TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n      // Covering test-cases where context is mocked\n      String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n          \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n              ? rmContext.getRMNodes().get(nodeId).getRackName() :\n          \"default-rack\";\n      perAppTagsMapping.addTags(nodeId, allocationTags);\n      perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n      globalNodeMapping.addTags(nodeId, allocationTags);\n      globalRackMapping.addTags(nodeRack, allocationTags);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n            + StringUtils.join(allocationTags, \",\") + \"]\");\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
      "extendedDetails": {}
    },
    "a52d11fb8c103f14e42692600a058ba3b56e2ecf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7613. Implement Basic algorithm for constraint based placement. (Panagiotis Garefalakis via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7613. Implement Basic algorithm for constraint based placement. (Panagiotis Garefalakis via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "37f1a7b64fcc93191367330cd59d4d71d7b29ac7",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,46 @@\n-  public void addContainer(NodeId nodeId, ApplicationId applicationId,\n-      ContainerId containerId, Set\u003cString\u003e allocationTags) {\n+  public void addContainer(NodeId nodeId, ContainerId containerId,\n+      Set\u003cString\u003e allocationTags) {\n+    ApplicationId applicationId \u003d\n+        containerId.getApplicationAttemptId().getApplicationId();\n     String applicationIdTag \u003d\n         AllocationTagsNamespaces.APP_ID + applicationId.toString();\n \n     boolean useSet \u003d false;\n     if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n       // Copy before edit it.\n       allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n       allocationTags.add(applicationIdTag);\n       useSet \u003d true;\n     }\n \n     writeLock.lock();\n     try {\n-      NodeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n-          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n-      NodeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n-          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n+      TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n+          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n+      TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n+          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n       // Covering test-cases where context is mocked\n       String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n           \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n               ? rmContext.getRMNodes().get(nodeId).getRackName()\n               : \"default-rack\";\n       if (useSet) {\n         perAppTagsMapping.addTags(nodeId, allocationTags);\n         perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n         globalNodeMapping.addTags(nodeId, allocationTags);\n         globalRackMapping.addTags(nodeRack, allocationTags);\n       } else {\n         perAppTagsMapping.addTag(nodeId, applicationIdTag);\n         perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n         globalNodeMapping.addTag(nodeId, applicationIdTag);\n         globalRackMapping.addTag(nodeRack, applicationIdTag);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n             + StringUtils.join(allocationTags, \",\") + \"]\");\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void addContainer(NodeId nodeId, ContainerId containerId,\n      Set\u003cString\u003e allocationTags) {\n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String applicationIdTag \u003d\n        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n\n    boolean useSet \u003d false;\n    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n      // Copy before edit it.\n      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n      allocationTags.add(applicationIdTag);\n      useSet \u003d true;\n    }\n\n    writeLock.lock();\n    try {\n      TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n      TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n      // Covering test-cases where context is mocked\n      String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n          \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n              ? rmContext.getRMNodes().get(nodeId).getRackName()\n              : \"default-rack\";\n      if (useSet) {\n        perAppTagsMapping.addTags(nodeId, allocationTags);\n        perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n        globalNodeMapping.addTags(nodeId, allocationTags);\n        globalRackMapping.addTags(nodeRack, allocationTags);\n      } else {\n        perAppTagsMapping.addTag(nodeId, applicationIdTag);\n        perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n        globalNodeMapping.addTag(nodeId, applicationIdTag);\n        globalRackMapping.addTag(nodeRack, applicationIdTag);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n            + StringUtils.join(allocationTags, \",\") + \"]\");\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
          "extendedDetails": {
            "oldValue": "[nodeId-NodeId, applicationId-ApplicationId, containerId-ContainerId, allocationTags-Set\u003cString\u003e]",
            "newValue": "[nodeId-NodeId, containerId-ContainerId, allocationTags-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7613. Implement Basic algorithm for constraint based placement. (Panagiotis Garefalakis via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "37f1a7b64fcc93191367330cd59d4d71d7b29ac7",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,46 @@\n-  public void addContainer(NodeId nodeId, ApplicationId applicationId,\n-      ContainerId containerId, Set\u003cString\u003e allocationTags) {\n+  public void addContainer(NodeId nodeId, ContainerId containerId,\n+      Set\u003cString\u003e allocationTags) {\n+    ApplicationId applicationId \u003d\n+        containerId.getApplicationAttemptId().getApplicationId();\n     String applicationIdTag \u003d\n         AllocationTagsNamespaces.APP_ID + applicationId.toString();\n \n     boolean useSet \u003d false;\n     if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n       // Copy before edit it.\n       allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n       allocationTags.add(applicationIdTag);\n       useSet \u003d true;\n     }\n \n     writeLock.lock();\n     try {\n-      NodeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n-          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n-      NodeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n-          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n+      TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n+          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n+      TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n+          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n       // Covering test-cases where context is mocked\n       String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n           \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n               ? rmContext.getRMNodes().get(nodeId).getRackName()\n               : \"default-rack\";\n       if (useSet) {\n         perAppTagsMapping.addTags(nodeId, allocationTags);\n         perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n         globalNodeMapping.addTags(nodeId, allocationTags);\n         globalRackMapping.addTags(nodeRack, allocationTags);\n       } else {\n         perAppTagsMapping.addTag(nodeId, applicationIdTag);\n         perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n         globalNodeMapping.addTag(nodeId, applicationIdTag);\n         globalRackMapping.addTag(nodeRack, applicationIdTag);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n             + StringUtils.join(allocationTags, \",\") + \"]\");\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void addContainer(NodeId nodeId, ContainerId containerId,\n      Set\u003cString\u003e allocationTags) {\n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String applicationIdTag \u003d\n        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n\n    boolean useSet \u003d false;\n    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n      // Copy before edit it.\n      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n      allocationTags.add(applicationIdTag);\n      useSet \u003d true;\n    }\n\n    writeLock.lock();\n    try {\n      TypeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n      TypeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n          .computeIfAbsent(applicationId, k -\u003e new TypeToCountedTags());\n      // Covering test-cases where context is mocked\n      String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n          \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n              ? rmContext.getRMNodes().get(nodeId).getRackName()\n              : \"default-rack\";\n      if (useSet) {\n        perAppTagsMapping.addTags(nodeId, allocationTags);\n        perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n        globalNodeMapping.addTags(nodeId, allocationTags);\n        globalRackMapping.addTags(nodeRack, allocationTags);\n      } else {\n        perAppTagsMapping.addTag(nodeId, applicationIdTag);\n        perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n        globalNodeMapping.addTag(nodeId, applicationIdTag);\n        globalRackMapping.addTag(nodeRack, applicationIdTag);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n            + StringUtils.join(allocationTags, \",\") + \"]\");\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "37f1a7b64fcc93191367330cd59d4d71d7b29ac7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7653. Node group support for AllocationTagsManager. (Panagiotis Garefalakis via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "37f1a7b64fcc93191367330cd59d4d71d7b29ac7",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "06eb63e64b05e2e8bb8a76c15360ab0495f11317",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,44 @@\n   public void addContainer(NodeId nodeId, ApplicationId applicationId,\n       ContainerId containerId, Set\u003cString\u003e allocationTags) {\n     String applicationIdTag \u003d\n         AllocationTagsNamespaces.APP_ID + applicationId.toString();\n \n     boolean useSet \u003d false;\n     if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n       // Copy before edit it.\n       allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n       allocationTags.add(applicationIdTag);\n       useSet \u003d true;\n     }\n \n     writeLock.lock();\n     try {\n-      NodeToCountedTags perAppTagsMapping \u003d perAppMappings.computeIfAbsent(\n-          applicationId, k -\u003e new NodeToCountedTags());\n-\n+      NodeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n+          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n+      NodeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n+          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n+      // Covering test-cases where context is mocked\n+      String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n+          \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n+              ? rmContext.getRMNodes().get(nodeId).getRackName()\n+              : \"default-rack\";\n       if (useSet) {\n-        perAppTagsMapping.addTagsToNode(nodeId, allocationTags);\n-        globalMapping.addTagsToNode(nodeId, allocationTags);\n+        perAppTagsMapping.addTags(nodeId, allocationTags);\n+        perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n+        globalNodeMapping.addTags(nodeId, allocationTags);\n+        globalRackMapping.addTags(nodeRack, allocationTags);\n       } else {\n-        perAppTagsMapping.addTagToNode(nodeId, applicationIdTag);\n-        globalMapping.addTagToNode(nodeId, applicationIdTag);\n+        perAppTagsMapping.addTag(nodeId, applicationIdTag);\n+        perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n+        globalNodeMapping.addTag(nodeId, applicationIdTag);\n+        globalRackMapping.addTag(nodeRack, applicationIdTag);\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"Added container\u003d\" + containerId + \" with tags\u003d[\" + StringUtils\n-                .join(allocationTags, \",\") + \"]\");\n+        LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n+            + StringUtils.join(allocationTags, \",\") + \"]\");\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addContainer(NodeId nodeId, ApplicationId applicationId,\n      ContainerId containerId, Set\u003cString\u003e allocationTags) {\n    String applicationIdTag \u003d\n        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n\n    boolean useSet \u003d false;\n    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n      // Copy before edit it.\n      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n      allocationTags.add(applicationIdTag);\n      useSet \u003d true;\n    }\n\n    writeLock.lock();\n    try {\n      NodeToCountedTags perAppTagsMapping \u003d perAppNodeMappings\n          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n      NodeToCountedTags perAppRackTagsMapping \u003d perAppRackMappings\n          .computeIfAbsent(applicationId, k -\u003e new NodeToCountedTags());\n      // Covering test-cases where context is mocked\n      String nodeRack \u003d (rmContext.getRMNodes() !\u003d null\n          \u0026\u0026 rmContext.getRMNodes().get(nodeId) !\u003d null)\n              ? rmContext.getRMNodes().get(nodeId).getRackName()\n              : \"default-rack\";\n      if (useSet) {\n        perAppTagsMapping.addTags(nodeId, allocationTags);\n        perAppRackTagsMapping.addTags(nodeRack, allocationTags);\n        globalNodeMapping.addTags(nodeId, allocationTags);\n        globalRackMapping.addTags(nodeRack, allocationTags);\n      } else {\n        perAppTagsMapping.addTag(nodeId, applicationIdTag);\n        perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);\n        globalNodeMapping.addTag(nodeId, applicationIdTag);\n        globalRackMapping.addTag(nodeRack, applicationIdTag);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Added container\u003d\" + containerId + \" with tags\u003d[\"\n            + StringUtils.join(allocationTags, \",\") + \"]\");\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
      "extendedDetails": {}
    },
    "06eb63e64b05e2e8bb8a76c15360ab0495f11317": {
      "type": "Yfilerename",
      "commitMessage": "YARN-7669. API and interface modifications for placement constraint processor. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "06eb63e64b05e2e8bb8a76c15360ab0495f11317",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void addContainer(NodeId nodeId, ApplicationId applicationId,\n      ContainerId containerId, Set\u003cString\u003e allocationTags) {\n    String applicationIdTag \u003d\n        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n\n    boolean useSet \u003d false;\n    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n      // Copy before edit it.\n      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n      allocationTags.add(applicationIdTag);\n      useSet \u003d true;\n    }\n\n    writeLock.lock();\n    try {\n      NodeToCountedTags perAppTagsMapping \u003d perAppMappings.computeIfAbsent(\n          applicationId, k -\u003e new NodeToCountedTags());\n\n      if (useSet) {\n        perAppTagsMapping.addTagsToNode(nodeId, allocationTags);\n        globalMapping.addTagsToNode(nodeId, allocationTags);\n      } else {\n        perAppTagsMapping.addTagToNode(nodeId, applicationIdTag);\n        globalMapping.addTagToNode(nodeId, applicationIdTag);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Added container\u003d\" + containerId + \" with tags\u003d[\" + StringUtils\n                .join(allocationTags, \",\") + \"]\");\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/constraint/AllocationTagsManager.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java"
      }
    },
    "801c0988b5ad1eff1e896a2635c2937721c96b04": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7522. Introduce AllocationTagsManager to associate allocation tags to nodes. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "801c0988b5ad1eff1e896a2635c2937721c96b04",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,35 @@\n+  public void addContainer(NodeId nodeId, ApplicationId applicationId,\n+      ContainerId containerId, Set\u003cString\u003e allocationTags) {\n+    String applicationIdTag \u003d\n+        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n+\n+    boolean useSet \u003d false;\n+    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n+      // Copy before edit it.\n+      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n+      allocationTags.add(applicationIdTag);\n+      useSet \u003d true;\n+    }\n+\n+    writeLock.lock();\n+    try {\n+      NodeToCountedTags perAppTagsMapping \u003d perAppMappings.computeIfAbsent(\n+          applicationId, k -\u003e new NodeToCountedTags());\n+\n+      if (useSet) {\n+        perAppTagsMapping.addTagsToNode(nodeId, allocationTags);\n+        globalMapping.addTagsToNode(nodeId, allocationTags);\n+      } else {\n+        perAppTagsMapping.addTagToNode(nodeId, applicationIdTag);\n+        globalMapping.addTagToNode(nodeId, applicationIdTag);\n+      }\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"Added container\u003d\" + containerId + \" with tags\u003d[\" + StringUtils\n+                .join(allocationTags, \",\") + \"]\");\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void addContainer(NodeId nodeId, ApplicationId applicationId,\n      ContainerId containerId, Set\u003cString\u003e allocationTags) {\n    String applicationIdTag \u003d\n        AllocationTagsNamespaces.APP_ID + applicationId.toString();\n\n    boolean useSet \u003d false;\n    if (allocationTags !\u003d null \u0026\u0026 !allocationTags.isEmpty()) {\n      // Copy before edit it.\n      allocationTags \u003d new HashSet\u003c\u003e(allocationTags);\n      allocationTags.add(applicationIdTag);\n      useSet \u003d true;\n    }\n\n    writeLock.lock();\n    try {\n      NodeToCountedTags perAppTagsMapping \u003d perAppMappings.computeIfAbsent(\n          applicationId, k -\u003e new NodeToCountedTags());\n\n      if (useSet) {\n        perAppTagsMapping.addTagsToNode(nodeId, allocationTags);\n        globalMapping.addTagsToNode(nodeId, allocationTags);\n      } else {\n        perAppTagsMapping.addTagToNode(nodeId, applicationIdTag);\n        globalMapping.addTagToNode(nodeId, applicationIdTag);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Added container\u003d\" + containerId + \" with tags\u003d[\" + StringUtils\n                .join(allocationTags, \",\") + \"]\");\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/constraint/AllocationTagsManager.java"
    }
  }
}