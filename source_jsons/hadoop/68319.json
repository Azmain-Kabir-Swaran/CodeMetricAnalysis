{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SwiftRestClient.java",
  "functionName": "buildException",
  "functionId": "buildException___uri-URI__req-M__resp-HttpResponse__statusCode-int",
  "sourceFilePath": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
  "functionStartLine": 1459,
  "functionEndLine": 1535,
  "numCommitsSeen": 10,
  "timeTaken": 2834,
  "changeHistory": [
    "62579b69a0a294ba1ea14cf76c650b640f89f331",
    "ecbfd68974691cc9103ae477d10c15c7f21b6dea",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874"
  ],
  "changeHistoryShort": {
    "62579b69a0a294ba1ea14cf76c650b640f89f331": "Ymultichange(Yparameterchange,Ybodychange)",
    "ecbfd68974691cc9103ae477d10c15c7f21b6dea": "Ybodychange",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": "Yintroduced"
  },
  "changeHistoryDetails": {
    "62579b69a0a294ba1ea14cf76c650b640f89f331": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.\n",
      "commitDate": "27/04/17 12:57 AM",
      "commitName": "62579b69a0a294ba1ea14cf76c650b640f89f331",
      "commitAuthor": "Akira Ajisaka",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.\n",
          "commitDate": "27/04/17 12:57 AM",
          "commitName": "62579b69a0a294ba1ea14cf76c650b640f89f331",
          "commitAuthor": "Akira Ajisaka",
          "commitDateOld": "01/10/15 9:25 AM",
          "commitNameOld": "ecbfd68974691cc9103ae477d10c15c7f21b6dea",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 573.65,
          "commitsBetweenForRepo": 3812,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,77 @@\n-  private \u003cM extends HttpMethod\u003e IOException buildException(URI uri,\n-                                                            M method,\n-                                                            int statusCode) {\n+  private \u003cM extends HttpUriRequest\u003e IOException buildException(\n+      URI uri, M req, HttpResponse resp, int statusCode) {\n     IOException fault;\n \n     //log the failure @debug level\n     String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n             \" status line: %s\",\n-            method.getName(),\n+            req.getMethod(),\n             uri,\n             statusCode,\n-            method.getStatusLine()\n+            resp.getStatusLine()\n     );\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(errorMessage);\n     }\n     //send the command\n     switch (statusCode) {\n-      case SC_NOT_FOUND:\n-        fault \u003d new FileNotFoundException(\"Operation \" + method.getName()\n-                + \" on \" + uri);\n-        break;\n+    case SC_NOT_FOUND:\n+      fault \u003d new FileNotFoundException(\"Operation \" + req.getMethod()\n+          + \" on \" + uri);\n+      break;\n \n-      case SC_BAD_REQUEST:\n-        //bad HTTP request\n-        fault \u003d  new SwiftBadRequestException(\n-          \"Bad request against \" + uri,\n-          method.getName(),\n+    case SC_BAD_REQUEST:\n+      //bad HTTP request\n+      fault \u003d  new SwiftBadRequestException(\"Bad request against \" + uri,\n+          req.getMethod(), uri, resp);\n+      break;\n+\n+    case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n+      //out of range\n+      StringBuilder errorText \u003d new StringBuilder(\n+          resp.getStatusLine().getReasonPhrase());\n+      //get the requested length\n+      Header requestContentLen \u003d req.getFirstHeader(HEADER_CONTENT_LENGTH);\n+      if (requestContentLen !\u003d null) {\n+        errorText.append(\" requested \").append(requestContentLen.getValue());\n+      }\n+      //and the result\n+      Header availableContentRange \u003d resp.getFirstHeader(HEADER_CONTENT_RANGE);\n+\n+      if (availableContentRange !\u003d null) {\n+        errorText.append(\" available \")\n+            .append(availableContentRange.getValue());\n+      }\n+      fault \u003d new EOFException(errorText.toString());\n+      break;\n+\n+    case SC_UNAUTHORIZED:\n+      //auth failure; should only happen on the second attempt\n+      fault  \u003d new SwiftAuthenticationFailedException(\n+          \"Operation not authorized- current access token \u003d\" + getToken(),\n+          req.getMethod(),\n           uri,\n-          method);\n-        break;\n+          resp);\n+      break;\n \n-      case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n-        //out of range\n-        StringBuilder errorText \u003d new StringBuilder(method.getStatusText());\n-        //get the requested length\n-        Header requestContentLen \u003d method.getRequestHeader(HEADER_CONTENT_LENGTH);\n-        if (requestContentLen!\u003dnull) {\n-          errorText.append(\" requested \").append(requestContentLen.getValue());\n-        }\n-        //and the result\n-        Header availableContentRange \u003d method.getResponseHeader(\n-          HEADER_CONTENT_RANGE);\n-        if (availableContentRange !\u003d null) {\n-          errorText.append(\" available \").append(availableContentRange.getValue());\n-        }\n-        fault \u003d new EOFException(errorText.toString());\n-        break;\n+    case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n+    case SwiftProtocolConstants.SC_THROTTLED_498:\n+      //response code that may mean the client is being throttled\n+      fault  \u003d new SwiftThrottledRequestException(\n+          \"Client is being throttled: too many requests\",\n+          req.getMethod(),\n+          uri,\n+          resp);\n+      break;\n \n-      case SC_UNAUTHORIZED:\n-        //auth failure; should only happen on the second attempt\n-        fault  \u003d new SwiftAuthenticationFailedException(\n-                        \"Operation not authorized- current access token \u003d\"\n-                            + getToken(),\n-                        method.getName(),\n-                        uri,\n-                        method);\n-        break;\n-\n-      case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n-      case SwiftProtocolConstants.SC_THROTTLED_498:\n-        //response code that may mean the client is being throttled\n-        fault  \u003d new SwiftThrottledRequestException(\n-                        \"Client is being throttled: too many requests\",\n-                        method.getName(),\n-                        uri,\n-                        method);\n-        break;\n-\n-      default:\n-        //return a generic invalid HTTP response\n-        fault \u003d new SwiftInvalidResponseException(\n-                errorMessage,\n-                method.getName(),\n-                uri,\n-                method);\n+    default:\n+      //return a generic invalid HTTP response\n+      fault \u003d new SwiftInvalidResponseException(\n+          errorMessage,\n+          req.getMethod(),\n+          uri,\n+          resp);\n     }\n \n     return fault;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cM extends HttpUriRequest\u003e IOException buildException(\n      URI uri, M req, HttpResponse resp, int statusCode) {\n    IOException fault;\n\n    //log the failure @debug level\n    String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n            \" status line: %s\",\n            req.getMethod(),\n            uri,\n            statusCode,\n            resp.getStatusLine()\n    );\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(errorMessage);\n    }\n    //send the command\n    switch (statusCode) {\n    case SC_NOT_FOUND:\n      fault \u003d new FileNotFoundException(\"Operation \" + req.getMethod()\n          + \" on \" + uri);\n      break;\n\n    case SC_BAD_REQUEST:\n      //bad HTTP request\n      fault \u003d  new SwiftBadRequestException(\"Bad request against \" + uri,\n          req.getMethod(), uri, resp);\n      break;\n\n    case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n      //out of range\n      StringBuilder errorText \u003d new StringBuilder(\n          resp.getStatusLine().getReasonPhrase());\n      //get the requested length\n      Header requestContentLen \u003d req.getFirstHeader(HEADER_CONTENT_LENGTH);\n      if (requestContentLen !\u003d null) {\n        errorText.append(\" requested \").append(requestContentLen.getValue());\n      }\n      //and the result\n      Header availableContentRange \u003d resp.getFirstHeader(HEADER_CONTENT_RANGE);\n\n      if (availableContentRange !\u003d null) {\n        errorText.append(\" available \")\n            .append(availableContentRange.getValue());\n      }\n      fault \u003d new EOFException(errorText.toString());\n      break;\n\n    case SC_UNAUTHORIZED:\n      //auth failure; should only happen on the second attempt\n      fault  \u003d new SwiftAuthenticationFailedException(\n          \"Operation not authorized- current access token \u003d\" + getToken(),\n          req.getMethod(),\n          uri,\n          resp);\n      break;\n\n    case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n    case SwiftProtocolConstants.SC_THROTTLED_498:\n      //response code that may mean the client is being throttled\n      fault  \u003d new SwiftThrottledRequestException(\n          \"Client is being throttled: too many requests\",\n          req.getMethod(),\n          uri,\n          resp);\n      break;\n\n    default:\n      //return a generic invalid HTTP response\n      fault \u003d new SwiftInvalidResponseException(\n          errorMessage,\n          req.getMethod(),\n          uri,\n          resp);\n    }\n\n    return fault;\n  }",
          "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
          "extendedDetails": {
            "oldValue": "[uri-URI, method-M, statusCode-int]",
            "newValue": "[uri-URI, req-M, resp-HttpResponse, statusCode-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.\n",
          "commitDate": "27/04/17 12:57 AM",
          "commitName": "62579b69a0a294ba1ea14cf76c650b640f89f331",
          "commitAuthor": "Akira Ajisaka",
          "commitDateOld": "01/10/15 9:25 AM",
          "commitNameOld": "ecbfd68974691cc9103ae477d10c15c7f21b6dea",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 573.65,
          "commitsBetweenForRepo": 3812,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,77 @@\n-  private \u003cM extends HttpMethod\u003e IOException buildException(URI uri,\n-                                                            M method,\n-                                                            int statusCode) {\n+  private \u003cM extends HttpUriRequest\u003e IOException buildException(\n+      URI uri, M req, HttpResponse resp, int statusCode) {\n     IOException fault;\n \n     //log the failure @debug level\n     String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n             \" status line: %s\",\n-            method.getName(),\n+            req.getMethod(),\n             uri,\n             statusCode,\n-            method.getStatusLine()\n+            resp.getStatusLine()\n     );\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(errorMessage);\n     }\n     //send the command\n     switch (statusCode) {\n-      case SC_NOT_FOUND:\n-        fault \u003d new FileNotFoundException(\"Operation \" + method.getName()\n-                + \" on \" + uri);\n-        break;\n+    case SC_NOT_FOUND:\n+      fault \u003d new FileNotFoundException(\"Operation \" + req.getMethod()\n+          + \" on \" + uri);\n+      break;\n \n-      case SC_BAD_REQUEST:\n-        //bad HTTP request\n-        fault \u003d  new SwiftBadRequestException(\n-          \"Bad request against \" + uri,\n-          method.getName(),\n+    case SC_BAD_REQUEST:\n+      //bad HTTP request\n+      fault \u003d  new SwiftBadRequestException(\"Bad request against \" + uri,\n+          req.getMethod(), uri, resp);\n+      break;\n+\n+    case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n+      //out of range\n+      StringBuilder errorText \u003d new StringBuilder(\n+          resp.getStatusLine().getReasonPhrase());\n+      //get the requested length\n+      Header requestContentLen \u003d req.getFirstHeader(HEADER_CONTENT_LENGTH);\n+      if (requestContentLen !\u003d null) {\n+        errorText.append(\" requested \").append(requestContentLen.getValue());\n+      }\n+      //and the result\n+      Header availableContentRange \u003d resp.getFirstHeader(HEADER_CONTENT_RANGE);\n+\n+      if (availableContentRange !\u003d null) {\n+        errorText.append(\" available \")\n+            .append(availableContentRange.getValue());\n+      }\n+      fault \u003d new EOFException(errorText.toString());\n+      break;\n+\n+    case SC_UNAUTHORIZED:\n+      //auth failure; should only happen on the second attempt\n+      fault  \u003d new SwiftAuthenticationFailedException(\n+          \"Operation not authorized- current access token \u003d\" + getToken(),\n+          req.getMethod(),\n           uri,\n-          method);\n-        break;\n+          resp);\n+      break;\n \n-      case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n-        //out of range\n-        StringBuilder errorText \u003d new StringBuilder(method.getStatusText());\n-        //get the requested length\n-        Header requestContentLen \u003d method.getRequestHeader(HEADER_CONTENT_LENGTH);\n-        if (requestContentLen!\u003dnull) {\n-          errorText.append(\" requested \").append(requestContentLen.getValue());\n-        }\n-        //and the result\n-        Header availableContentRange \u003d method.getResponseHeader(\n-          HEADER_CONTENT_RANGE);\n-        if (availableContentRange !\u003d null) {\n-          errorText.append(\" available \").append(availableContentRange.getValue());\n-        }\n-        fault \u003d new EOFException(errorText.toString());\n-        break;\n+    case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n+    case SwiftProtocolConstants.SC_THROTTLED_498:\n+      //response code that may mean the client is being throttled\n+      fault  \u003d new SwiftThrottledRequestException(\n+          \"Client is being throttled: too many requests\",\n+          req.getMethod(),\n+          uri,\n+          resp);\n+      break;\n \n-      case SC_UNAUTHORIZED:\n-        //auth failure; should only happen on the second attempt\n-        fault  \u003d new SwiftAuthenticationFailedException(\n-                        \"Operation not authorized- current access token \u003d\"\n-                            + getToken(),\n-                        method.getName(),\n-                        uri,\n-                        method);\n-        break;\n-\n-      case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n-      case SwiftProtocolConstants.SC_THROTTLED_498:\n-        //response code that may mean the client is being throttled\n-        fault  \u003d new SwiftThrottledRequestException(\n-                        \"Client is being throttled: too many requests\",\n-                        method.getName(),\n-                        uri,\n-                        method);\n-        break;\n-\n-      default:\n-        //return a generic invalid HTTP response\n-        fault \u003d new SwiftInvalidResponseException(\n-                errorMessage,\n-                method.getName(),\n-                uri,\n-                method);\n+    default:\n+      //return a generic invalid HTTP response\n+      fault \u003d new SwiftInvalidResponseException(\n+          errorMessage,\n+          req.getMethod(),\n+          uri,\n+          resp);\n     }\n \n     return fault;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cM extends HttpUriRequest\u003e IOException buildException(\n      URI uri, M req, HttpResponse resp, int statusCode) {\n    IOException fault;\n\n    //log the failure @debug level\n    String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n            \" status line: %s\",\n            req.getMethod(),\n            uri,\n            statusCode,\n            resp.getStatusLine()\n    );\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(errorMessage);\n    }\n    //send the command\n    switch (statusCode) {\n    case SC_NOT_FOUND:\n      fault \u003d new FileNotFoundException(\"Operation \" + req.getMethod()\n          + \" on \" + uri);\n      break;\n\n    case SC_BAD_REQUEST:\n      //bad HTTP request\n      fault \u003d  new SwiftBadRequestException(\"Bad request against \" + uri,\n          req.getMethod(), uri, resp);\n      break;\n\n    case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n      //out of range\n      StringBuilder errorText \u003d new StringBuilder(\n          resp.getStatusLine().getReasonPhrase());\n      //get the requested length\n      Header requestContentLen \u003d req.getFirstHeader(HEADER_CONTENT_LENGTH);\n      if (requestContentLen !\u003d null) {\n        errorText.append(\" requested \").append(requestContentLen.getValue());\n      }\n      //and the result\n      Header availableContentRange \u003d resp.getFirstHeader(HEADER_CONTENT_RANGE);\n\n      if (availableContentRange !\u003d null) {\n        errorText.append(\" available \")\n            .append(availableContentRange.getValue());\n      }\n      fault \u003d new EOFException(errorText.toString());\n      break;\n\n    case SC_UNAUTHORIZED:\n      //auth failure; should only happen on the second attempt\n      fault  \u003d new SwiftAuthenticationFailedException(\n          \"Operation not authorized- current access token \u003d\" + getToken(),\n          req.getMethod(),\n          uri,\n          resp);\n      break;\n\n    case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n    case SwiftProtocolConstants.SC_THROTTLED_498:\n      //response code that may mean the client is being throttled\n      fault  \u003d new SwiftThrottledRequestException(\n          \"Client is being throttled: too many requests\",\n          req.getMethod(),\n          uri,\n          resp);\n      break;\n\n    default:\n      //return a generic invalid HTTP response\n      fault \u003d new SwiftInvalidResponseException(\n          errorMessage,\n          req.getMethod(),\n          uri,\n          resp);\n    }\n\n    return fault;\n  }",
          "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "ecbfd68974691cc9103ae477d10c15c7f21b6dea": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10296. Incorrect null check in SwiftRestClient#buildException(). Contributed by Rahul Palamuttam and Kanaka Kumar Avvaru.\n",
      "commitDate": "01/10/15 9:25 AM",
      "commitName": "ecbfd68974691cc9103ae477d10c15c7f21b6dea",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "08/05/15 5:01 PM",
      "commitNameOld": "ed0f4db0dd8769d188e28750e5b78aa0d6f50677",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 145.68,
      "commitsBetweenForRepo": 1162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   private \u003cM extends HttpMethod\u003e IOException buildException(URI uri,\n                                                             M method,\n                                                             int statusCode) {\n     IOException fault;\n \n     //log the failure @debug level\n     String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n             \" status line: %s\",\n             method.getName(),\n             uri,\n             statusCode,\n             method.getStatusLine()\n     );\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(errorMessage);\n     }\n     //send the command\n     switch (statusCode) {\n       case SC_NOT_FOUND:\n         fault \u003d new FileNotFoundException(\"Operation \" + method.getName()\n                 + \" on \" + uri);\n         break;\n \n       case SC_BAD_REQUEST:\n         //bad HTTP request\n         fault \u003d  new SwiftBadRequestException(\n           \"Bad request against \" + uri,\n           method.getName(),\n           uri,\n           method);\n         break;\n \n       case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n         //out of range\n         StringBuilder errorText \u003d new StringBuilder(method.getStatusText());\n         //get the requested length\n         Header requestContentLen \u003d method.getRequestHeader(HEADER_CONTENT_LENGTH);\n         if (requestContentLen!\u003dnull) {\n           errorText.append(\" requested \").append(requestContentLen.getValue());\n         }\n         //and the result\n         Header availableContentRange \u003d method.getResponseHeader(\n           HEADER_CONTENT_RANGE);\n-        if (requestContentLen!\u003dnull) {\n+        if (availableContentRange !\u003d null) {\n           errorText.append(\" available \").append(availableContentRange.getValue());\n         }\n         fault \u003d new EOFException(errorText.toString());\n         break;\n \n       case SC_UNAUTHORIZED:\n         //auth failure; should only happen on the second attempt\n         fault  \u003d new SwiftAuthenticationFailedException(\n                         \"Operation not authorized- current access token \u003d\"\n                             + getToken(),\n                         method.getName(),\n                         uri,\n                         method);\n         break;\n \n       case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n       case SwiftProtocolConstants.SC_THROTTLED_498:\n         //response code that may mean the client is being throttled\n         fault  \u003d new SwiftThrottledRequestException(\n                         \"Client is being throttled: too many requests\",\n                         method.getName(),\n                         uri,\n                         method);\n         break;\n \n       default:\n         //return a generic invalid HTTP response\n         fault \u003d new SwiftInvalidResponseException(\n                 errorMessage,\n                 method.getName(),\n                 uri,\n                 method);\n     }\n \n     return fault;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cM extends HttpMethod\u003e IOException buildException(URI uri,\n                                                            M method,\n                                                            int statusCode) {\n    IOException fault;\n\n    //log the failure @debug level\n    String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n            \" status line: %s\",\n            method.getName(),\n            uri,\n            statusCode,\n            method.getStatusLine()\n    );\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(errorMessage);\n    }\n    //send the command\n    switch (statusCode) {\n      case SC_NOT_FOUND:\n        fault \u003d new FileNotFoundException(\"Operation \" + method.getName()\n                + \" on \" + uri);\n        break;\n\n      case SC_BAD_REQUEST:\n        //bad HTTP request\n        fault \u003d  new SwiftBadRequestException(\n          \"Bad request against \" + uri,\n          method.getName(),\n          uri,\n          method);\n        break;\n\n      case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n        //out of range\n        StringBuilder errorText \u003d new StringBuilder(method.getStatusText());\n        //get the requested length\n        Header requestContentLen \u003d method.getRequestHeader(HEADER_CONTENT_LENGTH);\n        if (requestContentLen!\u003dnull) {\n          errorText.append(\" requested \").append(requestContentLen.getValue());\n        }\n        //and the result\n        Header availableContentRange \u003d method.getResponseHeader(\n          HEADER_CONTENT_RANGE);\n        if (availableContentRange !\u003d null) {\n          errorText.append(\" available \").append(availableContentRange.getValue());\n        }\n        fault \u003d new EOFException(errorText.toString());\n        break;\n\n      case SC_UNAUTHORIZED:\n        //auth failure; should only happen on the second attempt\n        fault  \u003d new SwiftAuthenticationFailedException(\n                        \"Operation not authorized- current access token \u003d\"\n                            + getToken(),\n                        method.getName(),\n                        uri,\n                        method);\n        break;\n\n      case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n      case SwiftProtocolConstants.SC_THROTTLED_498:\n        //response code that may mean the client is being throttled\n        fault  \u003d new SwiftThrottledRequestException(\n                        \"Client is being throttled: too many requests\",\n                        method.getName(),\n                        uri,\n                        method);\n        break;\n\n      default:\n        //return a generic invalid HTTP response\n        fault \u003d new SwiftInvalidResponseException(\n                errorMessage,\n                method.getName(),\n                uri,\n                method);\n    }\n\n    return fault;\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
      "extendedDetails": {}
    },
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8545. Filesystem Implementation for OpenStack Swift\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526854 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 4:32 AM",
      "commitName": "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,80 @@\n+  private \u003cM extends HttpMethod\u003e IOException buildException(URI uri,\n+                                                            M method,\n+                                                            int statusCode) {\n+    IOException fault;\n+\n+    //log the failure @debug level\n+    String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n+            \" status line: %s\",\n+            method.getName(),\n+            uri,\n+            statusCode,\n+            method.getStatusLine()\n+    );\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(errorMessage);\n+    }\n+    //send the command\n+    switch (statusCode) {\n+      case SC_NOT_FOUND:\n+        fault \u003d new FileNotFoundException(\"Operation \" + method.getName()\n+                + \" on \" + uri);\n+        break;\n+\n+      case SC_BAD_REQUEST:\n+        //bad HTTP request\n+        fault \u003d  new SwiftBadRequestException(\n+          \"Bad request against \" + uri,\n+          method.getName(),\n+          uri,\n+          method);\n+        break;\n+\n+      case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n+        //out of range\n+        StringBuilder errorText \u003d new StringBuilder(method.getStatusText());\n+        //get the requested length\n+        Header requestContentLen \u003d method.getRequestHeader(HEADER_CONTENT_LENGTH);\n+        if (requestContentLen!\u003dnull) {\n+          errorText.append(\" requested \").append(requestContentLen.getValue());\n+        }\n+        //and the result\n+        Header availableContentRange \u003d method.getResponseHeader(\n+          HEADER_CONTENT_RANGE);\n+        if (requestContentLen!\u003dnull) {\n+          errorText.append(\" available \").append(availableContentRange.getValue());\n+        }\n+        fault \u003d new EOFException(errorText.toString());\n+        break;\n+\n+      case SC_UNAUTHORIZED:\n+        //auth failure; should only happen on the second attempt\n+        fault  \u003d new SwiftAuthenticationFailedException(\n+                        \"Operation not authorized- current access token \u003d\"\n+                            + getToken(),\n+                        method.getName(),\n+                        uri,\n+                        method);\n+        break;\n+\n+      case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n+      case SwiftProtocolConstants.SC_THROTTLED_498:\n+        //response code that may mean the client is being throttled\n+        fault  \u003d new SwiftThrottledRequestException(\n+                        \"Client is being throttled: too many requests\",\n+                        method.getName(),\n+                        uri,\n+                        method);\n+        break;\n+\n+      default:\n+        //return a generic invalid HTTP response\n+        fault \u003d new SwiftInvalidResponseException(\n+                errorMessage,\n+                method.getName(),\n+                uri,\n+                method);\n+    }\n+\n+    return fault;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cM extends HttpMethod\u003e IOException buildException(URI uri,\n                                                            M method,\n                                                            int statusCode) {\n    IOException fault;\n\n    //log the failure @debug level\n    String errorMessage \u003d String.format(\"Method %s on %s failed, status code: %d,\" +\n            \" status line: %s\",\n            method.getName(),\n            uri,\n            statusCode,\n            method.getStatusLine()\n    );\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(errorMessage);\n    }\n    //send the command\n    switch (statusCode) {\n      case SC_NOT_FOUND:\n        fault \u003d new FileNotFoundException(\"Operation \" + method.getName()\n                + \" on \" + uri);\n        break;\n\n      case SC_BAD_REQUEST:\n        //bad HTTP request\n        fault \u003d  new SwiftBadRequestException(\n          \"Bad request against \" + uri,\n          method.getName(),\n          uri,\n          method);\n        break;\n\n      case SC_REQUESTED_RANGE_NOT_SATISFIABLE:\n        //out of range\n        StringBuilder errorText \u003d new StringBuilder(method.getStatusText());\n        //get the requested length\n        Header requestContentLen \u003d method.getRequestHeader(HEADER_CONTENT_LENGTH);\n        if (requestContentLen!\u003dnull) {\n          errorText.append(\" requested \").append(requestContentLen.getValue());\n        }\n        //and the result\n        Header availableContentRange \u003d method.getResponseHeader(\n          HEADER_CONTENT_RANGE);\n        if (requestContentLen!\u003dnull) {\n          errorText.append(\" available \").append(availableContentRange.getValue());\n        }\n        fault \u003d new EOFException(errorText.toString());\n        break;\n\n      case SC_UNAUTHORIZED:\n        //auth failure; should only happen on the second attempt\n        fault  \u003d new SwiftAuthenticationFailedException(\n                        \"Operation not authorized- current access token \u003d\"\n                            + getToken(),\n                        method.getName(),\n                        uri,\n                        method);\n        break;\n\n      case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:\n      case SwiftProtocolConstants.SC_THROTTLED_498:\n        //response code that may mean the client is being throttled\n        fault  \u003d new SwiftThrottledRequestException(\n                        \"Client is being throttled: too many requests\",\n                        method.getName(),\n                        uri,\n                        method);\n        break;\n\n      default:\n        //return a generic invalid HTTP response\n        fault \u003d new SwiftInvalidResponseException(\n                errorMessage,\n                method.getName(),\n                uri,\n                method);\n    }\n\n    return fault;\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java"
    }
  }
}