{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AzureBlobFileSystemStore.java",
  "functionName": "listStatus",
  "functionId": "listStatus___path-Path(modifiers-final)__startFrom-String(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
  "functionStartLine": 700,
  "functionEndLine": 783,
  "numCommitsSeen": 76,
  "timeTaken": 9501,
  "changeHistory": [
    "8f78aeb2500011e568929b585ed5b0987355f88d",
    "b214bbd2d92a0c02b71d352dba85f3b87317933c",
    "6ce5f8734f1864a2d628b23479cf3f6621b2fcb4",
    "b033c681e4fc3ee1a38caa807e130aee481d99d5",
    "3418bbbb597d354bf24cfd610c1ad3adb06d8eae",
    "3988e75ca385aec31ca1fc49d6cffce1ea935825",
    "1f1655028eede24197705a594b6ef19e6737db35",
    "668817a6cefa6025ddfe082ed71d7d317d811381",
    "fa8cd1bf28f5b81849ba351a2d7225fbc580350d",
    "a8302e398c2ca4b0deff062c0e921053351b688e",
    "a383ac47cabe22e563725fae9de73e5e69e51f3e",
    "9c1e4e81399913f180131f4faa95604087c6d962",
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc",
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
    "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
    "f044deedbbfee0812316d587139cb828f27172e9"
  ],
  "changeHistoryShort": {
    "8f78aeb2500011e568929b585ed5b0987355f88d": "Ybodychange",
    "b214bbd2d92a0c02b71d352dba85f3b87317933c": "Ybodychange",
    "6ce5f8734f1864a2d628b23479cf3f6621b2fcb4": "Ybodychange",
    "b033c681e4fc3ee1a38caa807e130aee481d99d5": "Ybodychange",
    "3418bbbb597d354bf24cfd610c1ad3adb06d8eae": "Ymultichange(Yparameterchange,Ybodychange)",
    "3988e75ca385aec31ca1fc49d6cffce1ea935825": "Ybodychange",
    "1f1655028eede24197705a594b6ef19e6737db35": "Ybodychange",
    "668817a6cefa6025ddfe082ed71d7d317d811381": "Ybodychange",
    "fa8cd1bf28f5b81849ba351a2d7225fbc580350d": "Ybodychange",
    "a8302e398c2ca4b0deff062c0e921053351b688e": "Ybodychange",
    "a383ac47cabe22e563725fae9de73e5e69e51f3e": "Ybodychange",
    "9c1e4e81399913f180131f4faa95604087c6d962": "Ybodychange",
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc": "Ybodychange",
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be": "Ybodychange",
    "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange,Yparameterchange)",
    "f044deedbbfee0812316d587139cb828f27172e9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8f78aeb2500011e568929b585ed5b0987355f88d": {
      "type": "Ybodychange",
      "commitMessage": "Hadoop-17015. ABFS: Handling Rename and Delete idempotency \n\nContributed by Sneha Vijayarajan.",
      "commitDate": "19/05/20 12:30 PM",
      "commitName": "8f78aeb2500011e568929b585ed5b0987355f88d",
      "commitAuthor": "Sneha Vijayarajan",
      "commitDateOld": "12/05/20 11:35 AM",
      "commitNameOld": "b214bbd2d92a0c02b71d352dba85f3b87317933c",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 7.04,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n     final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n     long countAggregate \u003d 0;\n     boolean shouldContinue \u003d true;\n \n     LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n             client.getFileSystem(),\n             path,\n             startFrom);\n \n     final String relativePath \u003d getRelativePath(path);\n     String continuation \u003d null;\n \n     // generate continuation token if a valid startFrom is provided.\n     if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n       continuation \u003d getIsNamespaceEnabled()\n               ? generateContinuationTokenForXns(startFrom)\n               : generateContinuationTokenForNonXns(relativePath, startFrom);\n     }\n \n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n     do {\n       try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n         AbfsRestOperation op \u003d client.listPath(relativePath, false,\n             abfsConfiguration.getListMaxResults(), continuation);\n         perfInfo.registerResult(op.getResult());\n         continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n         ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n         if (retrievedSchema \u003d\u003d null) {\n           throw new AbfsRestOperationException(\n                   AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                   AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                   \"listStatusAsync path not found\",\n                   null, op.getResult());\n         }\n \n         long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n         for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n           final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n           final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n           final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                   ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                   : AbfsPermission.valueOf(entry.permissions());\n           final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n           long lastModifiedMillis \u003d 0;\n           long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n           boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n           if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n-            lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n+            lastModifiedMillis \u003d DateTimeUtils.parseLastModifiedTime(\n+                entry.lastModified());\n           }\n \n           Path entryPath \u003d new Path(File.separator + entry.name());\n           entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n           fileStatuses.add(\n                   new VersionedFileStatus(\n                           owner,\n                           group,\n                           fsPermission,\n                           hasAcl,\n                           contentLength,\n                           isDirectory,\n                           1,\n                           blockSize,\n                           lastModifiedMillis,\n                           entryPath,\n                           entry.eTag()));\n         }\n \n         perfInfo.registerSuccess(true);\n         countAggregate++;\n         shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n \n         if (!shouldContinue) {\n           perfInfo.registerAggregates(startAggregate, countAggregate);\n         }\n       }\n     } while (shouldContinue);\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n    final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n    long countAggregate \u003d 0;\n    boolean shouldContinue \u003d true;\n\n    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n            client.getFileSystem(),\n            path,\n            startFrom);\n\n    final String relativePath \u003d getRelativePath(path);\n    String continuation \u003d null;\n\n    // generate continuation token if a valid startFrom is provided.\n    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n      continuation \u003d getIsNamespaceEnabled()\n              ? generateContinuationTokenForXns(startFrom)\n              : generateContinuationTokenForNonXns(relativePath, startFrom);\n    }\n\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n    do {\n      try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n        AbfsRestOperation op \u003d client.listPath(relativePath, false,\n            abfsConfiguration.getListMaxResults(), continuation);\n        perfInfo.registerResult(op.getResult());\n        continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n        ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n        if (retrievedSchema \u003d\u003d null) {\n          throw new AbfsRestOperationException(\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                  \"listStatusAsync path not found\",\n                  null, op.getResult());\n        }\n\n        long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n        for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n          final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n          final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n          final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                  ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                  : AbfsPermission.valueOf(entry.permissions());\n          final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n          long lastModifiedMillis \u003d 0;\n          long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n          boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n          if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n            lastModifiedMillis \u003d DateTimeUtils.parseLastModifiedTime(\n                entry.lastModified());\n          }\n\n          Path entryPath \u003d new Path(File.separator + entry.name());\n          entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n          fileStatuses.add(\n                  new VersionedFileStatus(\n                          owner,\n                          group,\n                          fsPermission,\n                          hasAcl,\n                          contentLength,\n                          isDirectory,\n                          1,\n                          blockSize,\n                          lastModifiedMillis,\n                          entryPath,\n                          entry.eTag()));\n        }\n\n        perfInfo.registerSuccess(true);\n        countAggregate++;\n        shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n\n        if (!shouldContinue) {\n          perfInfo.registerAggregates(startAggregate, countAggregate);\n        }\n      }\n    } while (shouldContinue);\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "b214bbd2d92a0c02b71d352dba85f3b87317933c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16916: ABFS: Delegation SAS generator for integration with Ranger\n\nContributed by Thomas Marquardt.\n\nDETAILS:\n\nPreviously we had a SASGenerator class which generated Service SAS, but we need to add DelegationSASGenerator.\nI separated SASGenerator into a base class and two subclasses ServiceSASGenerator and DelegationSASGenreator.  The\ncode in ServiceSASGenerator is copied from SASGenerator but the DelegationSASGenrator code is new.  The\nDelegationSASGenerator code demonstrates how to use Delegation SAS with minimal permissions, as would be used\nby an authorization service such as Apache Ranger.  Adding this to the tests helps us lock in this behavior.\n\nAdded a MockDelegationSASTokenProvider for testing User Delegation SAS.\n\nFixed the ITestAzureBlobFileSystemCheckAccess tests to assume oauth client ID so that they are ignored when that\nis not configured.\n\nTo improve performance, AbfsInputStream/AbfsOutputStream re-use SAS tokens until the expiry is within 120 seconds.\nAfter this a new SAS will be requested.  The default period of 120 seconds can be changed using the configuration\nsetting \"fs.azure.sas.token.renew.period.for.streams\".\n\nThe SASTokenProvider operation names were updated to correspond better with the ADLS Gen2 REST API, since these\noperations must be provided tokens with appropriate SAS parameters to succeed.\n\nSupport for the version 2.0 AAD authentication endpoint was added to AzureADAuthenticator.\n\nThe getFileStatus method was mistakenly calling the ADLS Gen2 Get Properties API which requires read permission\nwhile the getFileStatus call only requires execute permission.  ADLS Gen2 Get Status API is supposed to be used\nfor this purpose, so the underlying AbfsClient.getPathStatus API was updated with a includeProperties\nparameter which is set to false for getFileStatus and true for getXAttr.\n\nAdded SASTokenProvider support for delete recursive.\n\nFixed bugs in AzureBlobFileSystem where public methods were not validating the Path by calling makeQualified.  This is\nnecessary to avoid passing null paths and to convert relative paths into absolute paths.\n\nCanonicalized the path used for root path internally so that root path can be used with SAS tokens, which requires\nthat the path in the URL and the path in the SAS token match.  Internally the code was using\n\"//\" instead of \"/\" for the root path, sometimes.  Also related to this, the AzureBlobFileSystemStore.getRelativePath\nAPI was updated so that we no longer remove and then add back a preceding forward / to paths.\n\nTo run ITestAzureBlobFileSystemDelegationSAS tests follow the instructions in testing_azure.md under the heading\n\"To run Delegation SAS test cases\".  You also need to set \"fs.azure.enable.check.access\" to true.\n\nTEST RESULTS:\n\nnamespace.enabled\u003dtrue\nauth.type\u003dSharedKey\n-------------------\n$mvn -T 1C -Dparallel-tests\u003dabfs -Dscale -DtestsThreadCount\u003d8 clean verify\nTests run: 63, Failures: 0, Errors: 0, Skipped: 0\nTests run: 432, Failures: 0, Errors: 0, Skipped: 41\nTests run: 206, Failures: 0, Errors: 0, Skipped: 24\n\nnamespace.enabled\u003dfalse\nauth.type\u003dSharedKey\n-------------------\n$mvn -T 1C -Dparallel-tests\u003dabfs -Dscale -DtestsThreadCount\u003d8 clean verify\nTests run: 63, Failures: 0, Errors: 0, Skipped: 0\nTests run: 432, Failures: 0, Errors: 0, Skipped: 244\nTests run: 206, Failures: 0, Errors: 0, Skipped: 24\n\nnamespace.enabled\u003dtrue\nauth.type\u003dSharedKey\nsas.token.provider.type\u003dMockDelegationSASTokenProvider\nenable.check.access\u003dtrue\n-------------------\n$mvn -T 1C -Dparallel-tests\u003dabfs -Dscale -DtestsThreadCount\u003d8 clean verify\nTests run: 63, Failures: 0, Errors: 0, Skipped: 0\nTests run: 432, Failures: 0, Errors: 0, Skipped: 33\nTests run: 206, Failures: 0, Errors: 0, Skipped: 24\n\nnamespace.enabled\u003dtrue\nauth.type\u003dOAuth\n-------------------\n$mvn -T 1C -Dparallel-tests\u003dabfs -Dscale -DtestsThreadCount\u003d8 clean verify\nTests run: 63, Failures: 0, Errors: 0, Skipped: 0\nTests run: 432, Failures: 0, Errors: 1, Skipped: 74\nTests run: 206, Failures: 0, Errors: 0, Skipped: 140\n",
      "commitDate": "12/05/20 11:35 AM",
      "commitName": "b214bbd2d92a0c02b71d352dba85f3b87317933c",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "23/04/20 5:46 PM",
      "commitNameOld": "30ef8d0f1a1463931fe581a46c739dad4c8260e4",
      "commitAuthorOld": "bilaharith",
      "daysBetweenCommits": 18.74,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n     final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n     long countAggregate \u003d 0;\n     boolean shouldContinue \u003d true;\n \n     LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n             client.getFileSystem(),\n             path,\n             startFrom);\n \n-    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n+    final String relativePath \u003d getRelativePath(path);\n     String continuation \u003d null;\n \n     // generate continuation token if a valid startFrom is provided.\n     if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n       continuation \u003d getIsNamespaceEnabled()\n               ? generateContinuationTokenForXns(startFrom)\n-              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n+              : generateContinuationTokenForNonXns(relativePath, startFrom);\n     }\n \n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n     do {\n       try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n         AbfsRestOperation op \u003d client.listPath(relativePath, false,\n             abfsConfiguration.getListMaxResults(), continuation);\n         perfInfo.registerResult(op.getResult());\n         continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n         ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n         if (retrievedSchema \u003d\u003d null) {\n           throw new AbfsRestOperationException(\n                   AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                   AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                   \"listStatusAsync path not found\",\n                   null, op.getResult());\n         }\n \n         long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n         for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n           final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n           final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n           final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                   ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                   : AbfsPermission.valueOf(entry.permissions());\n           final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n           long lastModifiedMillis \u003d 0;\n           long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n           boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n           if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n             lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n           }\n \n           Path entryPath \u003d new Path(File.separator + entry.name());\n           entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n           fileStatuses.add(\n                   new VersionedFileStatus(\n                           owner,\n                           group,\n                           fsPermission,\n                           hasAcl,\n                           contentLength,\n                           isDirectory,\n                           1,\n                           blockSize,\n                           lastModifiedMillis,\n                           entryPath,\n                           entry.eTag()));\n         }\n \n         perfInfo.registerSuccess(true);\n         countAggregate++;\n         shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n \n         if (!shouldContinue) {\n           perfInfo.registerAggregates(startAggregate, countAggregate);\n         }\n       }\n     } while (shouldContinue);\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n    final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n    long countAggregate \u003d 0;\n    boolean shouldContinue \u003d true;\n\n    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n            client.getFileSystem(),\n            path,\n            startFrom);\n\n    final String relativePath \u003d getRelativePath(path);\n    String continuation \u003d null;\n\n    // generate continuation token if a valid startFrom is provided.\n    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n      continuation \u003d getIsNamespaceEnabled()\n              ? generateContinuationTokenForXns(startFrom)\n              : generateContinuationTokenForNonXns(relativePath, startFrom);\n    }\n\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n    do {\n      try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n        AbfsRestOperation op \u003d client.listPath(relativePath, false,\n            abfsConfiguration.getListMaxResults(), continuation);\n        perfInfo.registerResult(op.getResult());\n        continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n        ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n        if (retrievedSchema \u003d\u003d null) {\n          throw new AbfsRestOperationException(\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                  \"listStatusAsync path not found\",\n                  null, op.getResult());\n        }\n\n        long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n        for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n          final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n          final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n          final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                  ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                  : AbfsPermission.valueOf(entry.permissions());\n          final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n          long lastModifiedMillis \u003d 0;\n          long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n          boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n          if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n            lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n          }\n\n          Path entryPath \u003d new Path(File.separator + entry.name());\n          entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n          fileStatuses.add(\n                  new VersionedFileStatus(\n                          owner,\n                          group,\n                          fsPermission,\n                          hasAcl,\n                          contentLength,\n                          isDirectory,\n                          1,\n                          blockSize,\n                          lastModifiedMillis,\n                          entryPath,\n                          entry.eTag()));\n        }\n\n        perfInfo.registerSuccess(true);\n        countAggregate++;\n        shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n\n        if (!shouldContinue) {\n          perfInfo.registerAggregates(startAggregate, countAggregate);\n        }\n      }\n    } while (shouldContinue);\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "6ce5f8734f1864a2d628b23479cf3f6621b2fcb4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16920 ABFS: Make list page size configurable.\n\n\r\nContributed by Bilahari T H.\r\n\r\nThe page limit is set in \"fs.azure.list.max.results\"; default value is 500. \r\n\r\nThere\u0027s currently a limit of 5000 in the store -there are no range checks\r\nin the client code so that limit can be changed on the server without\r\nany need to update the abfs connector.",
      "commitDate": "18/03/20 7:14 AM",
      "commitName": "6ce5f8734f1864a2d628b23479cf3f6621b2fcb4",
      "commitAuthor": "bilaharith",
      "commitDateOld": "27/02/20 10:27 AM",
      "commitNameOld": "791270a2e5e31546ff5c1ef4fa8bad6852b906dc",
      "commitAuthorOld": "Sneha Vijayarajan",
      "daysBetweenCommits": 19.82,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,83 @@\n   public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n     final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n     long countAggregate \u003d 0;\n     boolean shouldContinue \u003d true;\n \n     LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n             client.getFileSystem(),\n             path,\n             startFrom);\n \n     final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n \n     // generate continuation token if a valid startFrom is provided.\n     if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n       continuation \u003d getIsNamespaceEnabled()\n               ? generateContinuationTokenForXns(startFrom)\n               : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n     }\n \n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n     do {\n       try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n-        AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n+        AbfsRestOperation op \u003d client.listPath(relativePath, false,\n+            abfsConfiguration.getListMaxResults(), continuation);\n         perfInfo.registerResult(op.getResult());\n         continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n         ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n         if (retrievedSchema \u003d\u003d null) {\n           throw new AbfsRestOperationException(\n                   AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                   AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                   \"listStatusAsync path not found\",\n                   null, op.getResult());\n         }\n \n         long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n         for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n           final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n           final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n           final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                   ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                   : AbfsPermission.valueOf(entry.permissions());\n           final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n           long lastModifiedMillis \u003d 0;\n           long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n           boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n           if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n             lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n           }\n \n           Path entryPath \u003d new Path(File.separator + entry.name());\n           entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n           fileStatuses.add(\n                   new VersionedFileStatus(\n                           owner,\n                           group,\n                           fsPermission,\n                           hasAcl,\n                           contentLength,\n                           isDirectory,\n                           1,\n                           blockSize,\n                           lastModifiedMillis,\n                           entryPath,\n                           entry.eTag()));\n         }\n \n         perfInfo.registerSuccess(true);\n         countAggregate++;\n         shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n \n         if (!shouldContinue) {\n           perfInfo.registerAggregates(startAggregate, countAggregate);\n         }\n       }\n     } while (shouldContinue);\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n    final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n    long countAggregate \u003d 0;\n    boolean shouldContinue \u003d true;\n\n    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n            client.getFileSystem(),\n            path,\n            startFrom);\n\n    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n\n    // generate continuation token if a valid startFrom is provided.\n    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n      continuation \u003d getIsNamespaceEnabled()\n              ? generateContinuationTokenForXns(startFrom)\n              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n    }\n\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n    do {\n      try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n        AbfsRestOperation op \u003d client.listPath(relativePath, false,\n            abfsConfiguration.getListMaxResults(), continuation);\n        perfInfo.registerResult(op.getResult());\n        continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n        ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n        if (retrievedSchema \u003d\u003d null) {\n          throw new AbfsRestOperationException(\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                  \"listStatusAsync path not found\",\n                  null, op.getResult());\n        }\n\n        long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n        for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n          final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n          final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n          final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                  ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                  : AbfsPermission.valueOf(entry.permissions());\n          final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n          long lastModifiedMillis \u003d 0;\n          long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n          boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n          if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n            lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n          }\n\n          Path entryPath \u003d new Path(File.separator + entry.name());\n          entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n          fileStatuses.add(\n                  new VersionedFileStatus(\n                          owner,\n                          group,\n                          fsPermission,\n                          hasAcl,\n                          contentLength,\n                          isDirectory,\n                          1,\n                          blockSize,\n                          lastModifiedMillis,\n                          entryPath,\n                          entry.eTag()));\n        }\n\n        perfInfo.registerSuccess(true);\n        countAggregate++;\n        shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n\n        if (!shouldContinue) {\n          perfInfo.registerAggregates(startAggregate, countAggregate);\n        }\n      }\n    } while (shouldContinue);\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "b033c681e4fc3ee1a38caa807e130aee481d99d5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16612. Track Azure Blob File System client-perceived latency\n\nContributed by Jeetesh Mangwani.\n\nThis add the ability to track the end-to-end performance of ADLS Gen 2 REST APIs by measuring latency in the Hadoop ABFS driver.\nThe latency information is sent back to the ADLS Gen 2 REST API endpoints in the subsequent requests.\n",
      "commitDate": "19/11/19 9:00 AM",
      "commitName": "b033c681e4fc3ee1a38caa807e130aee481d99d5",
      "commitAuthor": "Jeetesh Mangwani",
      "commitDateOld": "28/09/19 8:39 PM",
      "commitNameOld": "c0edc848a8e71b5e2a1586a589bbf2ac8685040d",
      "commitAuthorOld": "Sneha Vijayarajan",
      "daysBetweenCommits": 51.56,
      "commitsBetweenForRepo": 252,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,82 @@\n   public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n+    final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n+    long countAggregate \u003d 0;\n+    boolean shouldContinue \u003d true;\n+\n     LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n             client.getFileSystem(),\n             path,\n             startFrom);\n \n     final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n \n     // generate continuation token if a valid startFrom is provided.\n     if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n       continuation \u003d getIsNamespaceEnabled()\n               ? generateContinuationTokenForXns(startFrom)\n               : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n     }\n \n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n     do {\n-      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n-      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n-      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n-      if (retrievedSchema \u003d\u003d null) {\n-        throw new AbfsRestOperationException(\n-                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-                \"listStatusAsync path not found\",\n-                null, op.getResult());\n-      }\n-\n-      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n-\n-      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n-        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n-        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n-                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n-                : AbfsPermission.valueOf(entry.permissions());\n-        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n-\n-        long lastModifiedMillis \u003d 0;\n-        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n-        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n-        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n-          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n+      try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n+        AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n+        perfInfo.registerResult(op.getResult());\n+        continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n+        ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n+        if (retrievedSchema \u003d\u003d null) {\n+          throw new AbfsRestOperationException(\n+                  AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                  AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                  \"listStatusAsync path not found\",\n+                  null, op.getResult());\n         }\n \n-        Path entryPath \u003d new Path(File.separator + entry.name());\n-        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+        long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n-        fileStatuses.add(\n-                new VersionedFileStatus(\n-                        owner,\n-                        group,\n-                        fsPermission,\n-                        hasAcl,\n-                        contentLength,\n-                        isDirectory,\n-                        1,\n-                        blockSize,\n-                        lastModifiedMillis,\n-                        entryPath,\n-                        entry.eTag()));\n+        for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n+          final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n+          final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n+          final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n+                  ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n+                  : AbfsPermission.valueOf(entry.permissions());\n+          final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n+\n+          long lastModifiedMillis \u003d 0;\n+          long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n+          boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n+          if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n+            lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n+          }\n+\n+          Path entryPath \u003d new Path(File.separator + entry.name());\n+          entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n+          fileStatuses.add(\n+                  new VersionedFileStatus(\n+                          owner,\n+                          group,\n+                          fsPermission,\n+                          hasAcl,\n+                          contentLength,\n+                          isDirectory,\n+                          1,\n+                          blockSize,\n+                          lastModifiedMillis,\n+                          entryPath,\n+                          entry.eTag()));\n+        }\n+\n+        perfInfo.registerSuccess(true);\n+        countAggregate++;\n+        shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n+\n+        if (!shouldContinue) {\n+          perfInfo.registerAggregates(startAggregate, countAggregate);\n+        }\n       }\n-\n-    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n+    } while (shouldContinue);\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n    final Instant startAggregate \u003d abfsPerfTracker.getLatencyInstant();\n    long countAggregate \u003d 0;\n    boolean shouldContinue \u003d true;\n\n    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n            client.getFileSystem(),\n            path,\n            startFrom);\n\n    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n\n    // generate continuation token if a valid startFrom is provided.\n    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n      continuation \u003d getIsNamespaceEnabled()\n              ? generateContinuationTokenForXns(startFrom)\n              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n    }\n\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n    do {\n      try (AbfsPerfInfo perfInfo \u003d startTracking(\"listStatus\", \"listPath\")) {\n        AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n        perfInfo.registerResult(op.getResult());\n        continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n        ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n        if (retrievedSchema \u003d\u003d null) {\n          throw new AbfsRestOperationException(\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                  AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                  \"listStatusAsync path not found\",\n                  null, op.getResult());\n        }\n\n        long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n        for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n          final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n          final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n          final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                  ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                  : AbfsPermission.valueOf(entry.permissions());\n          final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n          long lastModifiedMillis \u003d 0;\n          long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n          boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n          if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n            lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n          }\n\n          Path entryPath \u003d new Path(File.separator + entry.name());\n          entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n          fileStatuses.add(\n                  new VersionedFileStatus(\n                          owner,\n                          group,\n                          fsPermission,\n                          hasAcl,\n                          contentLength,\n                          isDirectory,\n                          1,\n                          blockSize,\n                          lastModifiedMillis,\n                          entryPath,\n                          entry.eTag()));\n        }\n\n        perfInfo.registerSuccess(true);\n        countAggregate++;\n        shouldContinue \u003d continuation !\u003d null \u0026\u0026 !continuation.isEmpty();\n\n        if (!shouldContinue) {\n          perfInfo.registerAggregates(startAggregate, countAggregate);\n        }\n      }\n    } while (shouldContinue);\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "3418bbbb597d354bf24cfd610c1ad3adb06d8eae": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16269. ABFS: add listFileStatus with StartFrom.\n\nAuthor:    Da Zhou\n",
      "commitDate": "08/05/19 9:20 AM",
      "commitName": "3418bbbb597d354bf24cfd610c1ad3adb06d8eae",
      "commitAuthor": "Da Zhou",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16269. ABFS: add listFileStatus with StartFrom.\n\nAuthor:    Da Zhou\n",
          "commitDate": "08/05/19 9:20 AM",
          "commitName": "3418bbbb597d354bf24cfd610c1ad3adb06d8eae",
          "commitAuthor": "Da Zhou",
          "commitDateOld": "08/03/19 5:53 AM",
          "commitNameOld": "e0260417ade5568ae37dcc3753aea0d1e0fd701b",
          "commitAuthorOld": "Da Zhou",
          "daysBetweenCommits": 61.1,
          "commitsBetweenForRepo": 396,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-  public FileStatus[] listStatus(final Path path) throws IOException {\n-    LOG.debug(\"listStatus filesystem: {} path: {}\",\n+  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n+    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n             client.getFileSystem(),\n-           path);\n+            path,\n+            startFrom);\n \n-    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n+    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n-    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n+    // generate continuation token if a valid startFrom is provided.\n+    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n+      continuation \u003d getIsNamespaceEnabled()\n+              ? generateContinuationTokenForXns(startFrom)\n+              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n+    }\n+\n+    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n         final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n            client.getFileSystem(),\n            path,\n            startFrom);\n\n    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n\n    // generate continuation token if a valid startFrom is provided.\n    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n      continuation \u003d getIsNamespaceEnabled()\n              ? generateContinuationTokenForXns(startFrom)\n              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n    }\n\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path(modifiers-final)]",
            "newValue": "[path-Path(modifiers-final), startFrom-String(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16269. ABFS: add listFileStatus with StartFrom.\n\nAuthor:    Da Zhou\n",
          "commitDate": "08/05/19 9:20 AM",
          "commitName": "3418bbbb597d354bf24cfd610c1ad3adb06d8eae",
          "commitAuthor": "Da Zhou",
          "commitDateOld": "08/03/19 5:53 AM",
          "commitNameOld": "e0260417ade5568ae37dcc3753aea0d1e0fd701b",
          "commitAuthorOld": "Da Zhou",
          "daysBetweenCommits": 61.1,
          "commitsBetweenForRepo": 396,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-  public FileStatus[] listStatus(final Path path) throws IOException {\n-    LOG.debug(\"listStatus filesystem: {} path: {}\",\n+  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n+    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n             client.getFileSystem(),\n-           path);\n+            path,\n+            startFrom);\n \n-    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n+    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n-    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n+    // generate continuation token if a valid startFrom is provided.\n+    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n+      continuation \u003d getIsNamespaceEnabled()\n+              ? generateContinuationTokenForXns(startFrom)\n+              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n+    }\n+\n+    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n         final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path, final String startFrom) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}, startFrom: {}\",\n            client.getFileSystem(),\n            path,\n            startFrom);\n\n    final String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n\n    // generate continuation token if a valid startFrom is provided.\n    if (startFrom !\u003d null \u0026\u0026 !startFrom.isEmpty()) {\n      continuation \u003d getIsNamespaceEnabled()\n              ? generateContinuationTokenForXns(startFrom)\n              : generateContinuationTokenForNonXns(path.isRoot() ? ROOT_PATH : relativePath, startFrom);\n    }\n\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "3988e75ca385aec31ca1fc49d6cffce1ea935825": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16136. ABFS: Should only transform username to short name\n\nContributed by Da Zhou.\n",
      "commitDate": "26/02/19 7:37 AM",
      "commitName": "3988e75ca385aec31ca1fc49d6cffce1ea935825",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "07/02/19 1:58 PM",
      "commitNameOld": "1f1655028eede24197705a594b6ef19e6737db35",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 18.74,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n-        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n+        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n+        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "1f1655028eede24197705a594b6ef19e6737db35": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15954. ABFS: Enable owner and group conversion for MSI and login user using OAuth.\n\nContributed by Da Zhou and Junhua Gu.\n",
      "commitDate": "07/02/19 1:58 PM",
      "commitName": "1f1655028eede24197705a594b6ef19e6737db35",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "07/02/19 1:57 PM",
      "commitNameOld": "668817a6cefa6025ddfe082ed71d7d317d811381",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n-        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n+        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n+        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n-    return fileStatuses.toArray(new FileStatus[0]);\n+    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "668817a6cefa6025ddfe082ed71d7d317d811381": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-15954. ABFS: Enable owner and group conversion for MSI and login user using OAuth.\"\n\n(accidentally mixed in two patches)\n\nThis reverts commit fa8cd1bf28f5b81849ba351a2d7225fbc580350d.\n",
      "commitDate": "07/02/19 1:57 PM",
      "commitName": "668817a6cefa6025ddfe082ed71d7d317d811381",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/02/19 11:23 AM",
      "commitNameOld": "fa8cd1bf28f5b81849ba351a2d7225fbc580350d",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n-        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n+        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n+        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n-    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n+    return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "fa8cd1bf28f5b81849ba351a2d7225fbc580350d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15954. ABFS: Enable owner and group conversion for MSI and login user using OAuth.\n\nContributed by Da Zhou and Junhua Gu.\n",
      "commitDate": "05/02/19 11:23 AM",
      "commitName": "fa8cd1bf28f5b81849ba351a2d7225fbc580350d",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "22/01/19 8:40 AM",
      "commitNameOld": "00ad9e23e88d1e1b1f887b6c9473a7a924a95a97",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n-        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n+        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n+        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n-    return fileStatuses.toArray(new FileStatus[0]);\n+    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "a8302e398c2ca4b0deff062c0e921053351b688e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15872. ABFS: Update to target 2018-11-09 REST version for ADLS Gen 2.\n\nContributed by Junhua Gu and Da Zhou.\n",
      "commitDate": "23/11/18 6:17 AM",
      "commitName": "a8302e398c2ca4b0deff062c0e921053351b688e",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "13/11/18 1:46 PM",
      "commitNameOld": "a13be203b7877ba56ef63aac4a2e65d4e1a4adbc",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 9.69,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d entry.owner() \u003d\u003d null ? userName : entry.owner();\n-        final String group \u003d entry.group() \u003d\u003d null ? primaryUserGroup : entry.group();\n+        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n+        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "a383ac47cabe22e563725fae9de73e5e69e51f3e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15801. ABFS: Fixing skipUserGroupMetadata in AzureBlobFileSystemStore.\nContributed by Da Zhou\n",
      "commitDate": "02/10/18 3:42 AM",
      "commitName": "a383ac47cabe22e563725fae9de73e5e69e51f3e",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/09/18 4:20 AM",
      "commitNameOld": "df2166a6435b4b62011a363ea24dfcc9bc44181c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d entry.owner() \u003d\u003d null ? userGroupInformation.getUserName() : entry.owner();\n-        final String group \u003d entry.group() \u003d\u003d null ? userGroupInformation.getPrimaryGroupName() : entry.group();\n+        final String owner \u003d entry.owner() \u003d\u003d null ? userName : entry.owner();\n+        final String group \u003d entry.group() \u003d\u003d null ? primaryUserGroup : entry.group();\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d entry.owner() \u003d\u003d null ? userName : entry.owner();\n        final String group \u003d entry.group() \u003d\u003d null ? primaryUserGroup : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "9c1e4e81399913f180131f4faa95604087c6d962": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15661. ABFS: Add support for ACL.\nContributed by Junhua Gu and Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "9c1e4e81399913f180131f4faa95604087c6d962",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "9149b9703e3ab09abdc087db129e82ad3f4cefa1",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n+        final String owner \u003d entry.owner() \u003d\u003d null ? userGroupInformation.getUserName() : entry.owner();\n+        final String group \u003d entry.group() \u003d\u003d null ? userGroupInformation.getPrimaryGroupName() : entry.group();\n+        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n+                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n+                : AbfsPermission.valueOf(entry.permissions());\n+        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n+\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n-                        userGroupInformation.getUserName(),\n-                        userGroupInformation.getPrimaryGroupName(),\n+                        owner,\n+                        group,\n+                        fsPermission,\n+                        hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d entry.owner() \u003d\u003d null ? userGroupInformation.getUserName() : entry.owner();\n        final String group \u003d entry.group() \u003d\u003d null ? userGroupInformation.getPrimaryGroupName() : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15659. Code changes for bug fix and new tests.\nContributed by Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "b54b0c1b676c616aef9574e4e88ea30c314c79dc",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,51 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n-          final DateTime dateTime \u003d DateTime.parse(\n-                  entry.lastModified(),\n-                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n-          lastModifiedMillis \u003d dateTime.getMillis();\n+          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         userGroupInformation.getUserName(),\n                         userGroupInformation.getPrimaryGroupName(),\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15446. ABFS: tune imports \u0026 javadocs; stabilise tests.\nContributed by Steve Loughran and Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n-    this.LOG.debug(\n-            \"listStatus filesystem: {} path: {}\",\n+    LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n-            path.toString());\n+           path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n                   entry.lastModified(),\n                   DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         userGroupInformation.getUserName(),\n                         userGroupInformation.getPrimaryGroupName(),\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462": {
      "type": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldPath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpServiceImpl.java",
            "newPath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldValue": "[AzureBlobFileSystemException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldValue": "[azureBlobFileSystem-AzureBlobFileSystem(modifiers-final), path-Path(modifiers-final)]",
            "newValue": "[path-Path(modifiers-final)]"
          }
        }
      ]
    },
    "f044deedbbfee0812316d587139cb828f27172e9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15407. HADOOP-15540. Support Windows Azure Storage - Blob file system \"ABFS\" in Hadoop: Core Commit.\n\nContributed by Shane Mainali, Thomas Marquardt, Zichen Sun, Georgi Chalakov, Esfandiar Manii, Amit Singh, Dana Kaban, Da Zhou, Junhua Gu, Saher Ahwal, Saurabh Pant, James Baker, Shaoyu Zhang, Lawrence Chen, Kevin Chen and Steve Loughran\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,54 @@\n+  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n+    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n+\n+    this.LOG.debug(\n+        \"listStatus filesystem: {} path: {}\",\n+        client.getFileSystem(),\n+        path.toString());\n+\n+    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n+    String continuation \u003d null;\n+    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n+\n+    do {\n+      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n+      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n+      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n+      if (retrievedSchema \u003d\u003d null) {\n+        throw new AbfsRestOperationException(\n+            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+            \"listStatusAsync path not found\",\n+            null, op.getResult());\n+      }\n+\n+      long blockSize \u003d configurationService.getAzureBlockSize();\n+\n+      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n+        long lastModifiedMillis \u003d 0;\n+        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n+        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n+        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n+          final DateTime dateTime \u003d DateTime.parse(\n+              entry.lastModified(),\n+              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+          lastModifiedMillis \u003d dateTime.getMillis();\n+        }\n+\n+        fileStatuses.add(\n+            new VersionedFileStatus(\n+                azureBlobFileSystem.getOwnerUser(),\n+                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n+                contentLength,\n+                isDirectory,\n+                1,\n+                blockSize,\n+                lastModifiedMillis,\n+                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n+                entry.eTag()));\n+      }\n+\n+    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n+\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n\n    this.LOG.debug(\n        \"listStatus filesystem: {} path: {}\",\n        client.getFileSystem(),\n        path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n            \"listStatusAsync path not found\",\n            null, op.getResult());\n      }\n\n      long blockSize \u003d configurationService.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n              entry.lastModified(),\n              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        fileStatuses.add(\n            new VersionedFileStatus(\n                azureBlobFileSystem.getOwnerUser(),\n                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n                contentLength,\n                isDirectory,\n                1,\n                blockSize,\n                lastModifiedMillis,\n                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n                entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpServiceImpl.java"
    }
  }
}