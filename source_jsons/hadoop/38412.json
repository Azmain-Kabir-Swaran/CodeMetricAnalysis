{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMNodeLabelsManager.java",
  "functionName": "updateResourceMappings",
  "functionId": "updateResourceMappings___before-Map__String,Host____after-Map__String,Host__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
  "functionStartLine": 426,
  "functionEndLine": 513,
  "numCommitsSeen": 22,
  "timeTaken": 2077,
  "changeHistory": [
    "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
    "b7442bf92eb6e1ae64a0f9644ffc2eee4597aad5",
    "746ad6e989683fe1dfc61a611702c9be7b5cd264",
    "5f57b904f550515693d93a2959e663b0d0260696",
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
    "db7f1653198b950e89567c06898d64f6b930a0ee"
  ],
  "changeHistoryShort": {
    "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0": "Ybodychange",
    "b7442bf92eb6e1ae64a0f9644ffc2eee4597aad5": "Ybodychange",
    "746ad6e989683fe1dfc61a611702c9be7b5cd264": "Ybodychange",
    "5f57b904f550515693d93a2959e663b0d0260696": "Ybodychange",
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb": "Ybodychange",
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1": "Ybodychange",
    "db7f1653198b950e89567c06898d64f6b930a0ee": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3345. Add non-exclusive node label API. Contributed by Wangda Tan\n",
      "commitDate": "20/03/15 7:04 PM",
      "commitName": "e1feb4ea1a532d680d6ca69b55ffcae1552d64f0",
      "commitAuthor": "Jian He",
      "commitDateOld": "18/02/15 11:51 AM",
      "commitNameOld": "f5da5566d9c392a5df71a2dce4c2d0d50eea51ee",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 30.26,
      "commitsBetweenForRepo": 262,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private void updateResourceMappings(Map\u003cString, Host\u003e before,\n       Map\u003cString, Host\u003e after) {\n     // Get NMs in before only\n     Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n     for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     \n     // Map used to notify RM\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n \n     // traverse all nms\n     for (NodeId nodeId : allNMs) {\n       Node oldNM;\n       if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n         Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n         // no label in the past\n         if (oldLabels.isEmpty()) {\n           // update labels\n-          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n+          RMNodeLabel label \u003d labelCollections.get(NO_LABEL);\n           label.removeNode(oldNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.subtractFrom(q.resource, oldNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : oldLabels) {\n-            NodeLabel label \u003d labelCollections.get(labelName);\n+            RMNodeLabel label \u003d labelCollections.get(labelName);\n             if (null \u003d\u003d label) {\n               continue;\n             }\n             label.removeNode(oldNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(oldLabels, q)) {\n               Resources.subtractFrom(q.resource, oldNM.resource);\n             }\n           }\n         }\n       }\n \n       Node newNM;\n       if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n         Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n         \n         newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n         \n         // no label in the past\n         if (newLabels.isEmpty()) {\n           // update labels\n-          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n+          RMNodeLabel label \u003d labelCollections.get(NO_LABEL);\n           label.addNode(newNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.addTo(q.resource, newNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : newLabels) {\n-            NodeLabel label \u003d labelCollections.get(labelName);\n+            RMNodeLabel label \u003d labelCollections.get(labelName);\n             label.addNode(newNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(newLabels, q)) {\n               Resources.addTo(q.resource, newNM.resource);\n             }\n           }\n         }\n       }\n     }\n     \n     // Notify RM\n     if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    \n    // Map used to notify RM\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          RMNodeLabel label \u003d labelCollections.get(NO_LABEL);\n          label.removeNode(oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            RMNodeLabel label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            label.removeNode(oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        \n        newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n        \n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          RMNodeLabel label \u003d labelCollections.get(NO_LABEL);\n          label.addNode(newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            RMNodeLabel label \u003d labelCollections.get(labelName);\n            label.addNode(newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n    \n    // Notify RM\n    if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "b7442bf92eb6e1ae64a0f9644ffc2eee4597aad5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2493. Added node-labels page on RM web UI. Contributed by Wangda Tan\n",
      "commitDate": "30/12/14 4:49 PM",
      "commitName": "b7442bf92eb6e1ae64a0f9644ffc2eee4597aad5",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/12/14 4:48 PM",
      "commitNameOld": "746ad6e989683fe1dfc61a611702c9be7b5cd264",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private void updateResourceMappings(Map\u003cString, Host\u003e before,\n       Map\u003cString, Host\u003e after) {\n     // Get NMs in before only\n     Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n     for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     \n     // Map used to notify RM\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n \n     // traverse all nms\n     for (NodeId nodeId : allNMs) {\n       Node oldNM;\n       if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n         Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n         // no label in the past\n         if (oldLabels.isEmpty()) {\n           // update labels\n-          Label label \u003d labelCollections.get(NO_LABEL);\n-          Resources.subtractFrom(label.getResource(), oldNM.resource);\n+          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n+          label.removeNode(oldNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.subtractFrom(q.resource, oldNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : oldLabels) {\n-            Label label \u003d labelCollections.get(labelName);\n+            NodeLabel label \u003d labelCollections.get(labelName);\n             if (null \u003d\u003d label) {\n               continue;\n             }\n-            Resources.subtractFrom(label.getResource(), oldNM.resource);\n+            label.removeNode(oldNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(oldLabels, q)) {\n               Resources.subtractFrom(q.resource, oldNM.resource);\n             }\n           }\n         }\n       }\n \n       Node newNM;\n       if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n         Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n         \n         newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n         \n         // no label in the past\n         if (newLabels.isEmpty()) {\n           // update labels\n-          Label label \u003d labelCollections.get(NO_LABEL);\n-          Resources.addTo(label.getResource(), newNM.resource);\n+          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n+          label.addNode(newNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.addTo(q.resource, newNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : newLabels) {\n-            Label label \u003d labelCollections.get(labelName);\n-            Resources.addTo(label.getResource(), newNM.resource);\n+            NodeLabel label \u003d labelCollections.get(labelName);\n+            label.addNode(newNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(newLabels, q)) {\n               Resources.addTo(q.resource, newNM.resource);\n             }\n           }\n         }\n       }\n     }\n     \n     // Notify RM\n     if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    \n    // Map used to notify RM\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n          label.removeNode(oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            NodeLabel label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            label.removeNode(oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        \n        newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n        \n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n          label.addNode(newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            NodeLabel label \u003d labelCollections.get(labelName);\n            label.addNode(newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n    \n    // Notify RM\n    if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "746ad6e989683fe1dfc61a611702c9be7b5cd264": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-2492(wrong jira number). Added node-labels page on RM web UI. Contributed by Wangda Tan\"\n\nThis reverts commit 5f57b904f550515693d93a2959e663b0d0260696.\n",
      "commitDate": "30/12/14 4:48 PM",
      "commitName": "746ad6e989683fe1dfc61a611702c9be7b5cd264",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/12/14 3:38 PM",
      "commitNameOld": "5f57b904f550515693d93a2959e663b0d0260696",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private void updateResourceMappings(Map\u003cString, Host\u003e before,\n       Map\u003cString, Host\u003e after) {\n     // Get NMs in before only\n     Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n     for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     \n     // Map used to notify RM\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n \n     // traverse all nms\n     for (NodeId nodeId : allNMs) {\n       Node oldNM;\n       if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n         Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n         // no label in the past\n         if (oldLabels.isEmpty()) {\n           // update labels\n-          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n-          label.removeNode(oldNM.resource);\n+          Label label \u003d labelCollections.get(NO_LABEL);\n+          Resources.subtractFrom(label.getResource(), oldNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.subtractFrom(q.resource, oldNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : oldLabels) {\n-            NodeLabel label \u003d labelCollections.get(labelName);\n+            Label label \u003d labelCollections.get(labelName);\n             if (null \u003d\u003d label) {\n               continue;\n             }\n-            label.removeNode(oldNM.resource);\n+            Resources.subtractFrom(label.getResource(), oldNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(oldLabels, q)) {\n               Resources.subtractFrom(q.resource, oldNM.resource);\n             }\n           }\n         }\n       }\n \n       Node newNM;\n       if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n         Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n         \n         newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n         \n         // no label in the past\n         if (newLabels.isEmpty()) {\n           // update labels\n-          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n-          label.addNode(newNM.resource);\n+          Label label \u003d labelCollections.get(NO_LABEL);\n+          Resources.addTo(label.getResource(), newNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.addTo(q.resource, newNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : newLabels) {\n-            NodeLabel label \u003d labelCollections.get(labelName);\n-            label.addNode(newNM.resource);\n+            Label label \u003d labelCollections.get(labelName);\n+            Resources.addTo(label.getResource(), newNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(newLabels, q)) {\n               Resources.addTo(q.resource, newNM.resource);\n             }\n           }\n         }\n       }\n     }\n     \n     // Notify RM\n     if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    \n    // Map used to notify RM\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.subtractFrom(label.getResource(), oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            Resources.subtractFrom(label.getResource(), oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        \n        newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n        \n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.addTo(label.getResource(), newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            Resources.addTo(label.getResource(), newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n    \n    // Notify RM\n    if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "5f57b904f550515693d93a2959e663b0d0260696": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2492. Added node-labels page on RM web UI. Contributed by Wangda Tan\n",
      "commitDate": "30/12/14 3:38 PM",
      "commitName": "5f57b904f550515693d93a2959e663b0d0260696",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/12/14 4:51 PM",
      "commitNameOld": "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   private void updateResourceMappings(Map\u003cString, Host\u003e before,\n       Map\u003cString, Host\u003e after) {\n     // Get NMs in before only\n     Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n     for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     \n     // Map used to notify RM\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n \n     // traverse all nms\n     for (NodeId nodeId : allNMs) {\n       Node oldNM;\n       if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n         Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n         // no label in the past\n         if (oldLabels.isEmpty()) {\n           // update labels\n-          Label label \u003d labelCollections.get(NO_LABEL);\n-          Resources.subtractFrom(label.getResource(), oldNM.resource);\n+          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n+          label.removeNode(oldNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.subtractFrom(q.resource, oldNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : oldLabels) {\n-            Label label \u003d labelCollections.get(labelName);\n+            NodeLabel label \u003d labelCollections.get(labelName);\n             if (null \u003d\u003d label) {\n               continue;\n             }\n-            Resources.subtractFrom(label.getResource(), oldNM.resource);\n+            label.removeNode(oldNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(oldLabels, q)) {\n               Resources.subtractFrom(q.resource, oldNM.resource);\n             }\n           }\n         }\n       }\n \n       Node newNM;\n       if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n         Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n         \n         newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n         \n         // no label in the past\n         if (newLabels.isEmpty()) {\n           // update labels\n-          Label label \u003d labelCollections.get(NO_LABEL);\n-          Resources.addTo(label.getResource(), newNM.resource);\n+          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n+          label.addNode(newNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.addTo(q.resource, newNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : newLabels) {\n-            Label label \u003d labelCollections.get(labelName);\n-            Resources.addTo(label.getResource(), newNM.resource);\n+            NodeLabel label \u003d labelCollections.get(labelName);\n+            label.addNode(newNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(newLabels, q)) {\n               Resources.addTo(q.resource, newNM.resource);\n             }\n           }\n         }\n       }\n     }\n     \n     // Notify RM\n     if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    \n    // Map used to notify RM\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n          label.removeNode(oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            NodeLabel label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            label.removeNode(oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        \n        newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n        \n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          NodeLabel label \u003d labelCollections.get(NO_LABEL);\n          label.addNode(newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            NodeLabel label \u003d labelCollections.get(labelName);\n            label.addNode(newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n    \n    // Notify RM\n    if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2920. Changed CapacityScheduler to kill containers on nodes where node labels are changed. Contributed by  Wangda Tan\n",
      "commitDate": "22/12/14 4:51 PM",
      "commitName": "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/12/14 3:06 AM",
      "commitNameOld": "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.57,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,88 @@\n   private void updateResourceMappings(Map\u003cString, Host\u003e before,\n       Map\u003cString, Host\u003e after) {\n     // Get NMs in before only\n     Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n     for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n+    \n+    // Map used to notify RM\n+    Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n+        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n \n     // traverse all nms\n     for (NodeId nodeId : allNMs) {\n       Node oldNM;\n       if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n         Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n         // no label in the past\n         if (oldLabels.isEmpty()) {\n           // update labels\n           Label label \u003d labelCollections.get(NO_LABEL);\n           Resources.subtractFrom(label.getResource(), oldNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.subtractFrom(q.resource, oldNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : oldLabels) {\n             Label label \u003d labelCollections.get(labelName);\n             if (null \u003d\u003d label) {\n               continue;\n             }\n             Resources.subtractFrom(label.getResource(), oldNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(oldLabels, q)) {\n               Resources.subtractFrom(q.resource, oldNM.resource);\n             }\n           }\n         }\n       }\n \n       Node newNM;\n       if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n         Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n+        \n+        newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n+        \n         // no label in the past\n         if (newLabels.isEmpty()) {\n           // update labels\n           Label label \u003d labelCollections.get(NO_LABEL);\n           Resources.addTo(label.getResource(), newNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.addTo(q.resource, newNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : newLabels) {\n             Label label \u003d labelCollections.get(labelName);\n             Resources.addTo(label.getResource(), newNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(newLabels, q)) {\n               Resources.addTo(q.resource, newNM.resource);\n             }\n           }\n         }\n       }\n     }\n+    \n+    // Notify RM\n+    if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    \n    // Map used to notify RM\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNodeToLabelsMap \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.subtractFrom(label.getResource(), oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            Resources.subtractFrom(label.getResource(), oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        \n        newNodeToLabelsMap.put(nodeId, ImmutableSet.copyOf(newLabels));\n        \n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.addTo(label.getResource(), newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            Resources.addTo(label.getResource(), newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n    \n    // Notify RM\n    if (rmContext !\u003d null \u0026\u0026 rmContext.getDispatcher() !\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new NodeLabelsUpdateSchedulerEvent(newNodeToLabelsMap));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2939. Fix new findbugs warnings in hadoop-yarn-common. (Li Lu via junping_du)\n",
      "commitDate": "22/12/14 3:06 AM",
      "commitName": "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
      "commitAuthor": "Junping Du",
      "commitDateOld": "17/10/14 8:58 AM",
      "commitNameOld": "abae63caf9c53b404f2f2db7d482555484eaeaf8",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 65.8,
      "commitsBetweenForRepo": 544,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private void updateResourceMappings(Map\u003cString, Host\u003e before,\n       Map\u003cString, Host\u003e after) {\n     // Get NMs in before only\n     Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n     for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n     for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n       allNMs.addAll(entry.getValue().nms.keySet());\n     }\n \n     // traverse all nms\n     for (NodeId nodeId : allNMs) {\n       Node oldNM;\n       if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n         Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n         // no label in the past\n         if (oldLabels.isEmpty()) {\n           // update labels\n           Label label \u003d labelCollections.get(NO_LABEL);\n-          Resources.subtractFrom(label.resource, oldNM.resource);\n+          Resources.subtractFrom(label.getResource(), oldNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.subtractFrom(q.resource, oldNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : oldLabels) {\n             Label label \u003d labelCollections.get(labelName);\n             if (null \u003d\u003d label) {\n               continue;\n             }\n-            Resources.subtractFrom(label.resource, oldNM.resource);\n+            Resources.subtractFrom(label.getResource(), oldNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(oldLabels, q)) {\n               Resources.subtractFrom(q.resource, oldNM.resource);\n             }\n           }\n         }\n       }\n \n       Node newNM;\n       if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n         Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n         // no label in the past\n         if (newLabels.isEmpty()) {\n           // update labels\n           Label label \u003d labelCollections.get(NO_LABEL);\n-          Resources.addTo(label.resource, newNM.resource);\n+          Resources.addTo(label.getResource(), newNM.resource);\n \n           // update queues, all queue can access this node\n           for (Queue q : queueCollections.values()) {\n             Resources.addTo(q.resource, newNM.resource);\n           }\n         } else {\n           // update labels\n           for (String labelName : newLabels) {\n             Label label \u003d labelCollections.get(labelName);\n-            Resources.addTo(label.resource, newNM.resource);\n+            Resources.addTo(label.getResource(), newNM.resource);\n           }\n \n           // update queues, only queue can access this node will be subtract\n           for (Queue q : queueCollections.values()) {\n             if (isNodeUsableByQueue(newLabels, q)) {\n               Resources.addTo(q.resource, newNM.resource);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.subtractFrom(label.getResource(), oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            Resources.subtractFrom(label.getResource(), oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.addTo(label.getResource(), newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            Resources.addTo(label.getResource(), newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "db7f1653198b950e89567c06898d64f6b930a0ee": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2494. Added NodeLabels Manager internal API and implementation. Contributed by Wangda Tan.\n",
      "commitDate": "10/10/14 11:44 AM",
      "commitName": "db7f1653198b950e89567c06898d64f6b930a0ee",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,75 @@\n+  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n+      Map\u003cString, Host\u003e after) {\n+    // Get NMs in before only\n+    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n+    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n+      allNMs.addAll(entry.getValue().nms.keySet());\n+    }\n+    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n+      allNMs.addAll(entry.getValue().nms.keySet());\n+    }\n+\n+    // traverse all nms\n+    for (NodeId nodeId : allNMs) {\n+      Node oldNM;\n+      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n+        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n+        // no label in the past\n+        if (oldLabels.isEmpty()) {\n+          // update labels\n+          Label label \u003d labelCollections.get(NO_LABEL);\n+          Resources.subtractFrom(label.resource, oldNM.resource);\n+\n+          // update queues, all queue can access this node\n+          for (Queue q : queueCollections.values()) {\n+            Resources.subtractFrom(q.resource, oldNM.resource);\n+          }\n+        } else {\n+          // update labels\n+          for (String labelName : oldLabels) {\n+            Label label \u003d labelCollections.get(labelName);\n+            if (null \u003d\u003d label) {\n+              continue;\n+            }\n+            Resources.subtractFrom(label.resource, oldNM.resource);\n+          }\n+\n+          // update queues, only queue can access this node will be subtract\n+          for (Queue q : queueCollections.values()) {\n+            if (isNodeUsableByQueue(oldLabels, q)) {\n+              Resources.subtractFrom(q.resource, oldNM.resource);\n+            }\n+          }\n+        }\n+      }\n+\n+      Node newNM;\n+      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n+        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n+        // no label in the past\n+        if (newLabels.isEmpty()) {\n+          // update labels\n+          Label label \u003d labelCollections.get(NO_LABEL);\n+          Resources.addTo(label.resource, newNM.resource);\n+\n+          // update queues, all queue can access this node\n+          for (Queue q : queueCollections.values()) {\n+            Resources.addTo(q.resource, newNM.resource);\n+          }\n+        } else {\n+          // update labels\n+          for (String labelName : newLabels) {\n+            Label label \u003d labelCollections.get(labelName);\n+            Resources.addTo(label.resource, newNM.resource);\n+          }\n+\n+          // update queues, only queue can access this node will be subtract\n+          for (Queue q : queueCollections.values()) {\n+            if (isNodeUsableByQueue(newLabels, q)) {\n+              Resources.addTo(q.resource, newNM.resource);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateResourceMappings(Map\u003cString, Host\u003e before,\n      Map\u003cString, Host\u003e after) {\n    // Get NMs in before only\n    Set\u003cNodeId\u003e allNMs \u003d new HashSet\u003cNodeId\u003e();\n    for (Entry\u003cString, Host\u003e entry : before.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n    for (Entry\u003cString, Host\u003e entry : after.entrySet()) {\n      allNMs.addAll(entry.getValue().nms.keySet());\n    }\n\n    // traverse all nms\n    for (NodeId nodeId : allNMs) {\n      Node oldNM;\n      if ((oldNM \u003d getNMInNodeSet(nodeId, before, true)) !\u003d null) {\n        Set\u003cString\u003e oldLabels \u003d getLabelsByNode(nodeId, before);\n        // no label in the past\n        if (oldLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.subtractFrom(label.resource, oldNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.subtractFrom(q.resource, oldNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : oldLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            if (null \u003d\u003d label) {\n              continue;\n            }\n            Resources.subtractFrom(label.resource, oldNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(oldLabels, q)) {\n              Resources.subtractFrom(q.resource, oldNM.resource);\n            }\n          }\n        }\n      }\n\n      Node newNM;\n      if ((newNM \u003d getNMInNodeSet(nodeId, after, true)) !\u003d null) {\n        Set\u003cString\u003e newLabels \u003d getLabelsByNode(nodeId, after);\n        // no label in the past\n        if (newLabels.isEmpty()) {\n          // update labels\n          Label label \u003d labelCollections.get(NO_LABEL);\n          Resources.addTo(label.resource, newNM.resource);\n\n          // update queues, all queue can access this node\n          for (Queue q : queueCollections.values()) {\n            Resources.addTo(q.resource, newNM.resource);\n          }\n        } else {\n          // update labels\n          for (String labelName : newLabels) {\n            Label label \u003d labelCollections.get(labelName);\n            Resources.addTo(label.resource, newNM.resource);\n          }\n\n          // update queues, only queue can access this node will be subtract\n          for (Queue q : queueCollections.values()) {\n            if (isNodeUsableByQueue(newLabels, q)) {\n              Resources.addTo(q.resource, newNM.resource);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/nodelabels/RMNodeLabelsManager.java"
    }
  }
}