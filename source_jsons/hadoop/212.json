{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OpenFileCtx.java",
  "functionName": "executeWriteBack",
  "functionId": "executeWriteBack",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
  "functionStartLine": 1020,
  "functionEndLine": 1056,
  "numCommitsSeen": 36,
  "timeTaken": 2057,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f",
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
    "5792d59da390842caec86ccaa8472d5be7933837",
    "5c02d2f6225144772dcb975d3144b057b71d6476",
    "28e3d09230971b32f74284311931525cb7ad1b7c",
    "37f587563a943a827fbff865f5302bac6d202415"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": "Ybodychange",
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464": "Ybodychange",
    "5792d59da390842caec86ccaa8472d5be7933837": "Ybodychange",
    "5c02d2f6225144772dcb975d3144b057b71d6476": "Ybodychange",
    "28e3d09230971b32f74284311931525cb7ad1b7c": "Ymultichange(Ymodifierchange,Ybodychange)",
    "37f587563a943a827fbff865f5302bac6d202415": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/10/17 10:38 AM",
      "commitNameOld": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 126.95,
      "commitsBetweenForRepo": 833,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n   void executeWriteBack() {\n     Preconditions.checkState(asyncStatus,\n         \"openFileCtx has false asyncStatus, fileId: \" + latestAttr.getFileId());\n     final long startOffset \u003d asyncWriteBackStartOffset;  \n     try {\n       while (activeState) {\n         // asyncStatus could be changed to false in offerNextToWrite()\n         WriteCtx toWrite \u003d offerNextToWrite();\n         if (toWrite !\u003d null) {\n           // Do the write\n           doSingleWrite(toWrite);\n           updateLastAccessTime();\n         } else {\n           break;\n         }\n       }\n       \n-      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n-        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n-            + latestAttr.getFileId());\n+      if (!activeState) {\n+        LOG.debug(\"The openFileCtx is not active anymore, fileId: {}\",\n+            latestAttr.getFileId());\n       }\n     } finally {\n       // Make sure to reset asyncStatus to false unless a race happens\n       synchronized (this) {\n         if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n           asyncStatus \u003d false;\n         } else {\n-          LOG.info(\"Another async task is already started before this one\"\n-              + \" is finalized. fileId: \" + latestAttr.getFileId()\n-              + \" asyncStatus: \" + asyncStatus + \" original startOffset: \"\n-              + startOffset + \" new startOffset: \" + asyncWriteBackStartOffset\n-              + \". Won\u0027t change asyncStatus here.\");\n+          LOG.info(\"Another async task is already started before this one \" +\n+                  \"is finalized. fileId: {} asyncStatus: {} \" +\n+                  \"original startOffset: {} \" +\n+                  \"new startOffset: {}. Won\u0027t change asyncStatus here.\",\n+              latestAttr.getFileId(), asyncStatus,\n+              startOffset, asyncWriteBackStartOffset);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"openFileCtx has false asyncStatus, fileId: \" + latestAttr.getFileId());\n    final long startOffset \u003d asyncWriteBackStartOffset;  \n    try {\n      while (activeState) {\n        // asyncStatus could be changed to false in offerNextToWrite()\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: {}\",\n            latestAttr.getFileId());\n      }\n    } finally {\n      // Make sure to reset asyncStatus to false unless a race happens\n      synchronized (this) {\n        if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n          asyncStatus \u003d false;\n        } else {\n          LOG.info(\"Another async task is already started before this one \" +\n                  \"is finalized. fileId: {} asyncStatus: {} \" +\n                  \"original startOffset: {} \" +\n                  \"new startOffset: {}. Won\u0027t change asyncStatus here.\",\n              latestAttr.getFileId(), asyncStatus,\n              startOffset, asyncWriteBackStartOffset);\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7423. various typos and message formatting fixes in nfs daemon and doc. (Charles Lamb via yliu)\n",
      "commitDate": "28/01/15 12:56 PM",
      "commitName": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthor": "yliu",
      "commitDateOld": "11/12/14 3:40 PM",
      "commitNameOld": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 47.89,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   void executeWriteBack() {\n     Preconditions.checkState(asyncStatus,\n-        \"openFileCtx has false asyncStatus, fileId:\" + latestAttr.getFileId());\n+        \"openFileCtx has false asyncStatus, fileId: \" + latestAttr.getFileId());\n     final long startOffset \u003d asyncWriteBackStartOffset;  \n     try {\n       while (activeState) {\n         // asyncStatus could be changed to false in offerNextToWrite()\n         WriteCtx toWrite \u003d offerNextToWrite();\n         if (toWrite !\u003d null) {\n           // Do the write\n           doSingleWrite(toWrite);\n           updateLastAccessTime();\n         } else {\n           break;\n         }\n       }\n       \n       if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n         LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n             + latestAttr.getFileId());\n       }\n     } finally {\n       // Make sure to reset asyncStatus to false unless a race happens\n       synchronized (this) {\n         if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n           asyncStatus \u003d false;\n         } else {\n-          LOG.info(\"Another asyn task is already started before this one\"\n-              + \" is finalized. fileId:\" + latestAttr.getFileId()\n-              + \" asyncStatus:\" + asyncStatus + \" original startOffset:\"\n-              + startOffset + \" new startOffset:\" + asyncWriteBackStartOffset\n+          LOG.info(\"Another async task is already started before this one\"\n+              + \" is finalized. fileId: \" + latestAttr.getFileId()\n+              + \" asyncStatus: \" + asyncStatus + \" original startOffset: \"\n+              + startOffset + \" new startOffset: \" + asyncWriteBackStartOffset\n               + \". Won\u0027t change asyncStatus here.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"openFileCtx has false asyncStatus, fileId: \" + latestAttr.getFileId());\n    final long startOffset \u003d asyncWriteBackStartOffset;  \n    try {\n      while (activeState) {\n        // asyncStatus could be changed to false in offerNextToWrite()\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n            + latestAttr.getFileId());\n      }\n    } finally {\n      // Make sure to reset asyncStatus to false unless a race happens\n      synchronized (this) {\n        if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n          asyncStatus \u003d false;\n        } else {\n          LOG.info(\"Another async task is already started before this one\"\n              + \" is finalized. fileId: \" + latestAttr.getFileId()\n              + \" asyncStatus: \" + asyncStatus + \" original startOffset: \"\n              + startOffset + \" new startOffset: \" + asyncWriteBackStartOffset\n              + \". Won\u0027t change asyncStatus here.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6050. NFS does not handle exceptions correctly in a few places. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 1:49 PM",
      "commitName": "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "17/12/13 12:40 PM",
      "commitNameOld": "5792d59da390842caec86ccaa8472d5be7933837",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 97.01,
      "commitsBetweenForRepo": 719,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   void executeWriteBack() {\n     Preconditions.checkState(asyncStatus,\n-        \"openFileCtx has false asyncStatus, fileId:\" + latestAttr.getFileid());\n+        \"openFileCtx has false asyncStatus, fileId:\" + latestAttr.getFileId());\n     final long startOffset \u003d asyncWriteBackStartOffset;  \n     try {\n       while (activeState) {\n         // asyncStatus could be changed to false in offerNextToWrite()\n         WriteCtx toWrite \u003d offerNextToWrite();\n         if (toWrite !\u003d null) {\n           // Do the write\n           doSingleWrite(toWrite);\n           updateLastAccessTime();\n         } else {\n           break;\n         }\n       }\n       \n       if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n         LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n             + latestAttr.getFileId());\n       }\n     } finally {\n       // Make sure to reset asyncStatus to false unless a race happens\n       synchronized (this) {\n         if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n           asyncStatus \u003d false;\n         } else {\n           LOG.info(\"Another asyn task is already started before this one\"\n-              + \" is finalized. fileId:\" + latestAttr.getFileid()\n+              + \" is finalized. fileId:\" + latestAttr.getFileId()\n               + \" asyncStatus:\" + asyncStatus + \" original startOffset:\"\n               + startOffset + \" new startOffset:\" + asyncWriteBackStartOffset\n               + \". Won\u0027t change asyncStatus here.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"openFileCtx has false asyncStatus, fileId:\" + latestAttr.getFileId());\n    final long startOffset \u003d asyncWriteBackStartOffset;  \n    try {\n      while (activeState) {\n        // asyncStatus could be changed to false in offerNextToWrite()\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n            + latestAttr.getFileId());\n      }\n    } finally {\n      // Make sure to reset asyncStatus to false unless a race happens\n      synchronized (this) {\n        if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n          asyncStatus \u003d false;\n        } else {\n          LOG.info(\"Another asyn task is already started before this one\"\n              + \" is finalized. fileId:\" + latestAttr.getFileId()\n              + \" asyncStatus:\" + asyncStatus + \" original startOffset:\"\n              + startOffset + \" new startOffset:\" + asyncWriteBackStartOffset\n              + \". Won\u0027t change asyncStatus here.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "5792d59da390842caec86ccaa8472d5be7933837": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5657. race condition causes writeback state error in NFS gateway. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551691 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/13 12:40 PM",
      "commitName": "5792d59da390842caec86ccaa8472d5be7933837",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "27/11/13 3:41 PM",
      "commitNameOld": "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 19.87,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,36 @@\n   void executeWriteBack() {\n     Preconditions.checkState(asyncStatus,\n-        \"The openFileCtx has false async status\");\n+        \"openFileCtx has false asyncStatus, fileId:\" + latestAttr.getFileid());\n+    final long startOffset \u003d asyncWriteBackStartOffset;  \n     try {\n       while (activeState) {\n+        // asyncStatus could be changed to false in offerNextToWrite()\n         WriteCtx toWrite \u003d offerNextToWrite();\n         if (toWrite !\u003d null) {\n           // Do the write\n           doSingleWrite(toWrite);\n           updateLastAccessTime();\n         } else {\n           break;\n         }\n       }\n       \n       if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n         LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n             + latestAttr.getFileId());\n       }\n     } finally {\n-      // make sure we reset asyncStatus to false\n-      asyncStatus \u003d false;\n+      // Make sure to reset asyncStatus to false unless a race happens\n+      synchronized (this) {\n+        if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n+          asyncStatus \u003d false;\n+        } else {\n+          LOG.info(\"Another asyn task is already started before this one\"\n+              + \" is finalized. fileId:\" + latestAttr.getFileid()\n+              + \" asyncStatus:\" + asyncStatus + \" original startOffset:\"\n+              + startOffset + \" new startOffset:\" + asyncWriteBackStartOffset\n+              + \". Won\u0027t change asyncStatus here.\");\n+        }\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"openFileCtx has false asyncStatus, fileId:\" + latestAttr.getFileid());\n    final long startOffset \u003d asyncWriteBackStartOffset;  \n    try {\n      while (activeState) {\n        // asyncStatus could be changed to false in offerNextToWrite()\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n            + latestAttr.getFileId());\n      }\n    } finally {\n      // Make sure to reset asyncStatus to false unless a race happens\n      synchronized (this) {\n        if (startOffset \u003d\u003d asyncWriteBackStartOffset) {\n          asyncStatus \u003d false;\n        } else {\n          LOG.info(\"Another asyn task is already started before this one\"\n              + \" is finalized. fileId:\" + latestAttr.getFileid()\n              + \" asyncStatus:\" + asyncStatus + \" original startOffset:\"\n              + startOffset + \" new startOffset:\" + asyncWriteBackStartOffset\n              + \". Won\u0027t change asyncStatus here.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "5c02d2f6225144772dcb975d3144b057b71d6476": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/13 4:40 PM",
      "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "06/10/13 7:57 PM",
      "commitNameOld": "caa4abd30cfc4361c7bc9f212a9092840d7c3b53",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 1.86,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   void executeWriteBack() {\n     Preconditions.checkState(asyncStatus,\n         \"The openFileCtx has false async status\");\n     try {\n       while (activeState) {\n         WriteCtx toWrite \u003d offerNextToWrite();\n         if (toWrite !\u003d null) {\n           // Do the write\n           doSingleWrite(toWrite);\n           updateLastAccessTime();\n         } else {\n           break;\n         }\n       }\n       \n       if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n         LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n-            + +latestAttr.getFileId());\n+            + latestAttr.getFileId());\n       }\n     } finally {\n       // make sure we reset asyncStatus to false\n       asyncStatus \u003d false;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"The openFileCtx has false async status\");\n    try {\n      while (activeState) {\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n            + latestAttr.getFileId());\n      }\n    } finally {\n      // make sure we reset asyncStatus to false\n      asyncStatus \u003d false;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "28e3d09230971b32f74284311931525cb7ad1b7c": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/13 1:02 PM",
      "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/09/13 1:02 PM",
          "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "17/09/13 11:08 PM",
          "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 5.58,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,24 @@\n-  public void executeWriteBack() {\n-    long nextOffset;\n-    OffsetRange key;\n-    WriteCtx writeCtx;\n-\n+  void executeWriteBack() {\n+    Preconditions.checkState(asyncStatus,\n+        \"The openFileCtx has false async status\");\n     try {\n-      // Don\u0027t lock OpenFileCtx for all writes to reduce the timeout of other\n-      // client request to the same file\n-      while (true) {\n-        lockCtx();\n-        if (!asyncStatus) {\n-          // This should never happen. There should be only one thread working\n-          // on one OpenFileCtx anytime.\n-          LOG.fatal(\"The openFileCtx has false async status\");\n-          throw new RuntimeException(\"The openFileCtx has false async status\");\n-        }\n-        // Any single write failure can change activeState to false, so do the\n-        // check each loop.\n-        if (pendingWrites.isEmpty()) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"The asyn write task has no pendding writes, fileId: \"\n-                + latestAttr.getFileId());\n-          }\n-          break;\n-        }\n-        if (!activeState) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n-                + latestAttr.getFileId());\n-          }\n-          break;\n-        }\n-\n-        // Get the next sequential write\n-        nextOffset \u003d getNextOffsetUnprotected();\n-        key \u003d pendingWrites.firstKey();\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(\"key.getMin()\u003d\" + key.getMin() + \" nextOffset\u003d\"\n-              + nextOffset);\n-        }\n-\n-        if (key.getMin() \u003e nextOffset) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.info(\"The next sequencial write has not arrived yet\");\n-          }\n-          break;\n-\n-        } else if (key.getMin() \u003c nextOffset \u0026\u0026 key.getMax() \u003e nextOffset) {\n-          // Can\u0027t handle overlapping write. Didn\u0027t see it in tests yet.\n-          LOG.fatal(\"Got a overlapping write (\" + key.getMin() + \",\"\n-              + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n-          throw new RuntimeException(\"Got a overlapping write (\" + key.getMin()\n-              + \",\" + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n-\n-        } else {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Remove write(\" + key.getMin() + \"-\" + key.getMax()\n-                + \") from the list\");\n-          }\n-          writeCtx \u003d pendingWrites.remove(key);\n+      while (activeState) {\n+        WriteCtx toWrite \u003d offerNextToWrite();\n+        if (toWrite !\u003d null) {\n           // Do the write\n-          doSingleWrite(writeCtx);\n+          doSingleWrite(toWrite);\n           updateLastAccessTime();\n+        } else {\n+          break;\n         }\n-        \n-        unlockCtx();\n       }\n-\n+      \n+      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n+        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n+            + +latestAttr.getFileId());\n+      }\n     } finally {\n-      // Always reset the async status so another async task can be created\n-      // for this file\n+      // make sure we reset asyncStatus to false\n       asyncStatus \u003d false;\n-      if (ctxLock.isHeldByCurrentThread()) {\n-        unlockCtx();\n-      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"The openFileCtx has false async status\");\n    try {\n      while (activeState) {\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n            + +latestAttr.getFileId());\n      }\n    } finally {\n      // make sure we reset asyncStatus to false\n      asyncStatus \u003d false;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/09/13 1:02 PM",
          "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "17/09/13 11:08 PM",
          "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 5.58,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,24 @@\n-  public void executeWriteBack() {\n-    long nextOffset;\n-    OffsetRange key;\n-    WriteCtx writeCtx;\n-\n+  void executeWriteBack() {\n+    Preconditions.checkState(asyncStatus,\n+        \"The openFileCtx has false async status\");\n     try {\n-      // Don\u0027t lock OpenFileCtx for all writes to reduce the timeout of other\n-      // client request to the same file\n-      while (true) {\n-        lockCtx();\n-        if (!asyncStatus) {\n-          // This should never happen. There should be only one thread working\n-          // on one OpenFileCtx anytime.\n-          LOG.fatal(\"The openFileCtx has false async status\");\n-          throw new RuntimeException(\"The openFileCtx has false async status\");\n-        }\n-        // Any single write failure can change activeState to false, so do the\n-        // check each loop.\n-        if (pendingWrites.isEmpty()) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"The asyn write task has no pendding writes, fileId: \"\n-                + latestAttr.getFileId());\n-          }\n-          break;\n-        }\n-        if (!activeState) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n-                + latestAttr.getFileId());\n-          }\n-          break;\n-        }\n-\n-        // Get the next sequential write\n-        nextOffset \u003d getNextOffsetUnprotected();\n-        key \u003d pendingWrites.firstKey();\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(\"key.getMin()\u003d\" + key.getMin() + \" nextOffset\u003d\"\n-              + nextOffset);\n-        }\n-\n-        if (key.getMin() \u003e nextOffset) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.info(\"The next sequencial write has not arrived yet\");\n-          }\n-          break;\n-\n-        } else if (key.getMin() \u003c nextOffset \u0026\u0026 key.getMax() \u003e nextOffset) {\n-          // Can\u0027t handle overlapping write. Didn\u0027t see it in tests yet.\n-          LOG.fatal(\"Got a overlapping write (\" + key.getMin() + \",\"\n-              + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n-          throw new RuntimeException(\"Got a overlapping write (\" + key.getMin()\n-              + \",\" + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n-\n-        } else {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Remove write(\" + key.getMin() + \"-\" + key.getMax()\n-                + \") from the list\");\n-          }\n-          writeCtx \u003d pendingWrites.remove(key);\n+      while (activeState) {\n+        WriteCtx toWrite \u003d offerNextToWrite();\n+        if (toWrite !\u003d null) {\n           // Do the write\n-          doSingleWrite(writeCtx);\n+          doSingleWrite(toWrite);\n           updateLastAccessTime();\n+        } else {\n+          break;\n         }\n-        \n-        unlockCtx();\n       }\n-\n+      \n+      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n+        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n+            + +latestAttr.getFileId());\n+      }\n     } finally {\n-      // Always reset the async status so another async task can be created\n-      // for this file\n+      // make sure we reset asyncStatus to false\n       asyncStatus \u003d false;\n-      if (ctxLock.isHeldByCurrentThread()) {\n-        unlockCtx();\n-      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void executeWriteBack() {\n    Preconditions.checkState(asyncStatus,\n        \"The openFileCtx has false async status\");\n    try {\n      while (activeState) {\n        WriteCtx toWrite \u003d offerNextToWrite();\n        if (toWrite !\u003d null) {\n          // Do the write\n          doSingleWrite(toWrite);\n          updateLastAccessTime();\n        } else {\n          break;\n        }\n      }\n      \n      if (!activeState \u0026\u0026 LOG.isDebugEnabled()) {\n        LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n            + +latestAttr.getFileId());\n      }\n    } finally {\n      // make sure we reset asyncStatus to false\n      asyncStatus \u003d false;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
          "extendedDetails": {}
        }
      ]
    },
    "37f587563a943a827fbff865f5302bac6d202415": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4762 Provide HDFS based NFSv3 and Mountd implementation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1499029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/13 10:31 AM",
      "commitName": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,77 @@\n+  public void executeWriteBack() {\n+    long nextOffset;\n+    OffsetRange key;\n+    WriteCtx writeCtx;\n+\n+    try {\n+      // Don\u0027t lock OpenFileCtx for all writes to reduce the timeout of other\n+      // client request to the same file\n+      while (true) {\n+        lockCtx();\n+        if (!asyncStatus) {\n+          // This should never happen. There should be only one thread working\n+          // on one OpenFileCtx anytime.\n+          LOG.fatal(\"The openFileCtx has false async status\");\n+          throw new RuntimeException(\"The openFileCtx has false async status\");\n+        }\n+        // Any single write failure can change activeState to false, so do the\n+        // check each loop.\n+        if (pendingWrites.isEmpty()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"The asyn write task has no pendding writes, fileId: \"\n+                + latestAttr.getFileId());\n+          }\n+          break;\n+        }\n+        if (!activeState) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n+                + latestAttr.getFileId());\n+          }\n+          break;\n+        }\n+\n+        // Get the next sequential write\n+        nextOffset \u003d getNextOffsetUnprotected();\n+        key \u003d pendingWrites.firstKey();\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(\"key.getMin()\u003d\" + key.getMin() + \" nextOffset\u003d\"\n+              + nextOffset);\n+        }\n+\n+        if (key.getMin() \u003e nextOffset) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.info(\"The next sequencial write has not arrived yet\");\n+          }\n+          break;\n+\n+        } else if (key.getMin() \u003c nextOffset \u0026\u0026 key.getMax() \u003e nextOffset) {\n+          // Can\u0027t handle overlapping write. Didn\u0027t see it in tests yet.\n+          LOG.fatal(\"Got a overlapping write (\" + key.getMin() + \",\"\n+              + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n+          throw new RuntimeException(\"Got a overlapping write (\" + key.getMin()\n+              + \",\" + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n+\n+        } else {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Remove write(\" + key.getMin() + \"-\" + key.getMax()\n+                + \") from the list\");\n+          }\n+          writeCtx \u003d pendingWrites.remove(key);\n+          // Do the write\n+          doSingleWrite(writeCtx);\n+          updateLastAccessTime();\n+        }\n+        \n+        unlockCtx();\n+      }\n+\n+    } finally {\n+      // Always reset the async status so another async task can be created\n+      // for this file\n+      asyncStatus \u003d false;\n+      if (ctxLock.isHeldByCurrentThread()) {\n+        unlockCtx();\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void executeWriteBack() {\n    long nextOffset;\n    OffsetRange key;\n    WriteCtx writeCtx;\n\n    try {\n      // Don\u0027t lock OpenFileCtx for all writes to reduce the timeout of other\n      // client request to the same file\n      while (true) {\n        lockCtx();\n        if (!asyncStatus) {\n          // This should never happen. There should be only one thread working\n          // on one OpenFileCtx anytime.\n          LOG.fatal(\"The openFileCtx has false async status\");\n          throw new RuntimeException(\"The openFileCtx has false async status\");\n        }\n        // Any single write failure can change activeState to false, so do the\n        // check each loop.\n        if (pendingWrites.isEmpty()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"The asyn write task has no pendding writes, fileId: \"\n                + latestAttr.getFileId());\n          }\n          break;\n        }\n        if (!activeState) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"The openFileCtx is not active anymore, fileId: \"\n                + latestAttr.getFileId());\n          }\n          break;\n        }\n\n        // Get the next sequential write\n        nextOffset \u003d getNextOffsetUnprotected();\n        key \u003d pendingWrites.firstKey();\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"key.getMin()\u003d\" + key.getMin() + \" nextOffset\u003d\"\n              + nextOffset);\n        }\n\n        if (key.getMin() \u003e nextOffset) {\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"The next sequencial write has not arrived yet\");\n          }\n          break;\n\n        } else if (key.getMin() \u003c nextOffset \u0026\u0026 key.getMax() \u003e nextOffset) {\n          // Can\u0027t handle overlapping write. Didn\u0027t see it in tests yet.\n          LOG.fatal(\"Got a overlapping write (\" + key.getMin() + \",\"\n              + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n          throw new RuntimeException(\"Got a overlapping write (\" + key.getMin()\n              + \",\" + key.getMax() + \"), nextOffset\u003d\" + nextOffset);\n\n        } else {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Remove write(\" + key.getMin() + \"-\" + key.getMax()\n                + \") from the list\");\n          }\n          writeCtx \u003d pendingWrites.remove(key);\n          // Do the write\n          doSingleWrite(writeCtx);\n          updateLastAccessTime();\n        }\n        \n        unlockCtx();\n      }\n\n    } finally {\n      // Always reset the async status so another async task can be created\n      // for this file\n      asyncStatus \u003d false;\n      if (ctxLock.isHeldByCurrentThread()) {\n        unlockCtx();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java"
    }
  }
}