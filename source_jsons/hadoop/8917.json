{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirStatAndListingOp.java",
  "functionName": "getBlockLocations",
  "functionId": "getBlockLocations___fsd-FSDirectory__pc-FSPermissionChecker__src-String__offset-long__length-long__needBlockToken-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
  "functionStartLine": 144,
  "functionEndLine": 191,
  "numCommitsSeen": 61,
  "timeTaken": 4801,
  "changeHistory": [
    "72003b19bf4c652b53625984d109542abd0cf20e",
    "3085a604300ed76d06a0011bd5555e419897b6cd",
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
    "744208431f7365bf054e6b773b86af2583001e1d",
    "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
    "71a81b6257c0000475ad62eb69292a20d45d269c",
    "f62237bc2f02afe11ce185e13aa51a60b5960037"
  ],
  "changeHistoryShort": {
    "72003b19bf4c652b53625984d109542abd0cf20e": "Ybodychange",
    "3085a604300ed76d06a0011bd5555e419897b6cd": "Ybodychange",
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ybodychange",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": "Ybodychange",
    "744208431f7365bf054e6b773b86af2583001e1d": "Ybodychange",
    "a0730aa5ced7666a8c92f9fb830b615f5f9f477a": "Ybodychange",
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ybodychange",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": "Ybodychange",
    "71a81b6257c0000475ad62eb69292a20d45d269c": "Ybodychange",
    "f62237bc2f02afe11ce185e13aa51a60b5960037": "Ybodychange"
  },
  "changeHistoryDetails": {
    "72003b19bf4c652b53625984d109542abd0cf20e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13901. INode access time is ignored because of race between open and rename. Contributed by Jinglun.\n",
      "commitDate": "21/10/19 5:31 PM",
      "commitName": "72003b19bf4c652b53625984d109542abd0cf20e",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "29/11/18 1:55 PM",
      "commitNameOld": "0081b02e35306cb757c63d0f11a536941d73a139",
      "commitAuthorOld": "Tsz Wo Nicholas Sze",
      "daysBetweenCommits": 326.11,
      "commitsBetweenForRepo": 2429,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     BlockManager bm \u003d fsd.getBlockManager();\n     fsd.readLock();\n     try {\n       final INodesInPath iip \u003d fsd.resolvePath(pc, src, DirOp.READ);\n       src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, iip);\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d\n           FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n-      return new GetBlockLocationsResult(updateAccessTime, blocks);\n+      return new GetBlockLocationsResult(updateAccessTime, blocks, iip);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    BlockManager bm \u003d fsd.getBlockManager();\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src, DirOp.READ);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, iip);\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d\n          FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks, iip);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "3085a604300ed76d06a0011bd5555e419897b6cd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8112. Relax permission checking for EC related operations.\n",
      "commitDate": "03/03/17 1:00 PM",
      "commitName": "3085a604300ed76d06a0011bd5555e419897b6cd",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 129.95,
      "commitsBetweenForRepo": 799,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     BlockManager bm \u003d fsd.getBlockManager();\n     fsd.readLock();\n     try {\n       final INodesInPath iip \u003d fsd.resolvePath(pc, src, DirOp.READ);\n       src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, iip);\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d\n           FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n-          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n+          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    BlockManager bm \u003d fsd.getBlockManager();\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src, DirOp.READ);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, iip);\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d\n          FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "06/10/16 1:11 PM",
      "commitNameOld": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 18.09,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     BlockManager bm \u003d fsd.getBlockManager();\n     fsd.readLock();\n     try {\n-      final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n+      final INodesInPath iip \u003d fsd.resolvePath(pc, src, DirOp.READ);\n       src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, iip);\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d\n           FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    BlockManager bm \u003d fsd.getBlockManager();\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src, DirOp.READ);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, iip);\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d\n          FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
      "commitDate": "06/10/16 1:11 PM",
      "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "03/10/16 9:27 AM",
      "commitNameOld": "744208431f7365bf054e6b773b86af2583001e1d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 3.16,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,48 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     BlockManager bm \u003d fsd.getBlockManager();\n     fsd.readLock();\n     try {\n       final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n       src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n-        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n+        fsd.checkUnreadableBySuperuser(pc, iip);\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n-      final FileEncryptionInfo feInfo \u003d iip.isRaw() ? null\n-          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n-          iip.getPathSnapshotId(), iip);\n+      final FileEncryptionInfo feInfo \u003d\n+          FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    BlockManager bm \u003d fsd.getBlockManager();\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, iip);\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d\n          FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "744208431f7365bf054e6b773b86af2583001e1d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10940. Reduce performance penalty of block caching when not used. Contributed by Daryn Sharp.\n",
      "commitDate": "03/10/16 9:27 AM",
      "commitName": "744208431f7365bf054e6b773b86af2583001e1d",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "30/09/16 11:03 AM",
      "commitNameOld": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.93,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,49 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n-    CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n     BlockManager bm \u003d fsd.getBlockManager();\n     fsd.readLock();\n     try {\n       final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n       src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d iip.isRaw() ? null\n           : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n           iip.getPathSnapshotId(), iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n-      // Set caching information for the located blocks.\n-      for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n-        cm.setCachedLocations(lb);\n-      }\n-\n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    BlockManager bm \u003d fsd.getBlockManager();\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d iip.isRaw() ? null\n          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n          iip.getPathSnapshotId(), iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "a0730aa5ced7666a8c92f9fb830b615f5f9f477a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10851. FSDirStatAndListingOp: stop passing path as string. Contributed by Daryn Sharp.\n",
      "commitDate": "30/09/16 11:03 AM",
      "commitName": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "24/08/16 1:21 PM",
      "commitNameOld": "a1f3293762dddb0ca953d1145f5b53d9086b25b8",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 36.9,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,55 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n     BlockManager bm \u003d fsd.getBlockManager();\n-    boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n     fsd.readLock();\n     try {\n       final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n       src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n-      final FileEncryptionInfo feInfo \u003d isReservedName ? null\n+      final FileEncryptionInfo feInfo \u003d iip.isRaw() ? null\n           : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n           iip.getPathSnapshotId(), iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       // Set caching information for the located blocks.\n       for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n         cm.setCachedLocations(lb);\n       }\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n    BlockManager bm \u003d fsd.getBlockManager();\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d iip.isRaw() ? null\n          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n          iip.getPathSnapshotId(), iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      // Set caching information for the located blocks.\n      for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n        cm.setCachedLocations(lb);\n      }\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/08/16 2:45 PM",
      "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n     BlockManager bm \u003d fsd.getBlockManager();\n     boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n     fsd.readLock();\n     try {\n-      src \u003d fsd.resolvePath(pc, src);\n-      final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n+      final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n+      src \u003d iip.getPath();\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d isReservedName ? null\n           : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n           iip.getPathSnapshotId(), iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       // Set caching information for the located blocks.\n       for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n         cm.setCachedLocations(lb);\n       }\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n    BlockManager bm \u003d fsd.getBlockManager();\n    boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n    fsd.readLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePath(pc, src);\n      src \u003d iip.getPath();\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d isReservedName ? null\n          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n          iip.getPathSnapshotId(), iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      // Set caching information for the located blocks.\n      for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n        cm.setCachedLocations(lb);\n      }\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
      "commitDate": "15/08/16 2:45 PM",
      "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/08/16 7:07 AM",
      "commitNameOld": "6ae39199dac6ac7be6802b31452552c76da16e24",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 11.32,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,56 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n     BlockManager bm \u003d fsd.getBlockManager();\n-    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n     fsd.readLock();\n     try {\n-      src \u003d fsd.resolvePath(pc, src, pathComponents);\n+      src \u003d fsd.resolvePath(pc, src);\n       final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d isReservedName ? null\n           : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n           iip.getPathSnapshotId(), iip);\n       final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n           getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       // Set caching information for the located blocks.\n       for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n         cm.setCachedLocations(lb);\n       }\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n    BlockManager bm \u003d fsd.getBlockManager();\n    boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n    fsd.readLock();\n    try {\n      src \u003d fsd.resolvePath(pc, src);\n      final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d isReservedName ? null\n          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n          iip.getPathSnapshotId(), iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      // Set caching information for the located blocks.\n      for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n        cm.setCachedLocations(lb);\n      }\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "71a81b6257c0000475ad62eb69292a20d45d269c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7529. Consolidate encryption zone related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "24/09/15 8:34 AM",
      "commitName": "71a81b6257c0000475ad62eb69292a20d45d269c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "18/09/15 9:26 AM",
      "commitNameOld": "3f4275310203de4ccfb15337f3c503e25408a265",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.96,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,55 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n     BlockManager bm \u003d fsd.getBlockManager();\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n     fsd.readLock();\n     try {\n       src \u003d fsd.resolvePath(pc, src, pathComponents);\n       final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d isReservedName ? null\n-          : fsd.getFileEncryptionInfo(inode, iip.getPathSnapshotId(), iip);\n+          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n+              iip.getPathSnapshotId(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n           length, needBlockToken, iip.isSnapshot(), feInfo);\n \n       // Set caching information for the located blocks.\n       for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n         cm.setCachedLocations(lb);\n       }\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n    BlockManager bm \u003d fsd.getBlockManager();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n    fsd.readLock();\n    try {\n      src \u003d fsd.resolvePath(pc, src, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d isReservedName ? null\n          : FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, inode,\n              iip.getPathSnapshotId(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo);\n\n      // Set caching information for the located blocks.\n      for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n        cm.setCachedLocations(lb);\n      }\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "f62237bc2f02afe11ce185e13aa51a60b5960037": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
      "commitDate": "09/09/15 11:07 PM",
      "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 16.42,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   static GetBlockLocationsResult getBlockLocations(\n       FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n       long length, boolean needBlockToken) throws IOException {\n     Preconditions.checkArgument(offset \u003e\u003d 0,\n         \"Negative offset is not supported. File: \" + src);\n     Preconditions.checkArgument(length \u003e\u003d 0,\n         \"Negative length is not supported. File: \" + src);\n     CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n     BlockManager bm \u003d fsd.getBlockManager();\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n     fsd.readLock();\n     try {\n       src \u003d fsd.resolvePath(pc, src, pathComponents);\n       final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n       final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.READ);\n         fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n       }\n \n       final long fileSize \u003d iip.isSnapshot()\n           ? inode.computeFileSize(iip.getPathSnapshotId())\n           : inode.computeFileSizeNotIncludingLastUcBlock();\n \n       boolean isUc \u003d inode.isUnderConstruction();\n       if (iip.isSnapshot()) {\n         // if src indicates a snapshot file, we need to make sure the returned\n         // blocks do not exceed the size of the snapshot file.\n         length \u003d Math.min(length, fileSize - offset);\n         isUc \u003d false;\n       }\n \n       final FileEncryptionInfo feInfo \u003d isReservedName ? null\n           : fsd.getFileEncryptionInfo(inode, iip.getPathSnapshotId(), iip);\n-      final ErasureCodingZone ecZone \u003d FSDirErasureCodingOp.getErasureCodingZone(\n-          fsd.getFSNamesystem(), iip);\n+      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n+          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n       final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n           inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n-          length, needBlockToken, iip.isSnapshot(), feInfo, ecZone);\n+          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n \n       // Set caching information for the located blocks.\n       for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n         cm.setCachedLocations(lb);\n       }\n \n       final long now \u003d now();\n       boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n           \u0026\u0026 !iip.isSnapshot()\n           \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n       return new GetBlockLocationsResult(updateAccessTime, blocks);\n     } finally {\n       fsd.readUnlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static GetBlockLocationsResult getBlockLocations(\n      FSDirectory fsd, FSPermissionChecker pc, String src, long offset,\n      long length, boolean needBlockToken) throws IOException {\n    Preconditions.checkArgument(offset \u003e\u003d 0,\n        \"Negative offset is not supported. File: \" + src);\n    Preconditions.checkArgument(length \u003e\u003d 0,\n        \"Negative length is not supported. File: \" + src);\n    CacheManager cm \u003d fsd.getFSNamesystem().getCacheManager();\n    BlockManager bm \u003d fsd.getBlockManager();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    boolean isReservedName \u003d FSDirectory.isReservedRawName(src);\n    fsd.readLock();\n    try {\n      src \u003d fsd.resolvePath(pc, src, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath(src, true);\n      final INodeFile inode \u003d INodeFile.valueOf(iip.getLastINode(), src);\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.READ);\n        fsd.checkUnreadableBySuperuser(pc, inode, iip.getPathSnapshotId());\n      }\n\n      final long fileSize \u003d iip.isSnapshot()\n          ? inode.computeFileSize(iip.getPathSnapshotId())\n          : inode.computeFileSizeNotIncludingLastUcBlock();\n\n      boolean isUc \u003d inode.isUnderConstruction();\n      if (iip.isSnapshot()) {\n        // if src indicates a snapshot file, we need to make sure the returned\n        // blocks do not exceed the size of the snapshot file.\n        length \u003d Math.min(length, fileSize - offset);\n        isUc \u003d false;\n      }\n\n      final FileEncryptionInfo feInfo \u003d isReservedName ? null\n          : fsd.getFileEncryptionInfo(inode, iip.getPathSnapshotId(), iip);\n      final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.\n          getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n      final LocatedBlocks blocks \u003d bm.createLocatedBlocks(\n          inode.getBlocks(iip.getPathSnapshotId()), fileSize, isUc, offset,\n          length, needBlockToken, iip.isSnapshot(), feInfo, ecPolicy);\n\n      // Set caching information for the located blocks.\n      for (LocatedBlock lb : blocks.getLocatedBlocks()) {\n        cm.setCachedLocations(lb);\n      }\n\n      final long now \u003d now();\n      boolean updateAccessTime \u003d fsd.isAccessTimeSupported()\n          \u0026\u0026 !iip.isSnapshot()\n          \u0026\u0026 now \u003e inode.getAccessTime() + fsd.getAccessTimePrecision();\n      return new GetBlockLocationsResult(updateAccessTime, blocks);\n    } finally {\n      fsd.readUnlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    }
  }
}