{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DelegationTokenAuthenticationHandler.java",
  "functionName": "managementOperation",
  "functionId": "managementOperation___token-AuthenticationToken__request-HttpServletRequest__response-HttpServletResponse",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
  "functionStartLine": 223,
  "functionEndLine": 357,
  "numCommitsSeen": 29,
  "timeTaken": 4940,
  "changeHistory": [
    "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2",
    "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81",
    "2b08a1fc644904a37545107666efc25b3552542d",
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
    "822ae88f7da638e15a25747f6965caee8198aca6",
    "4bca385241c0fc8ff168c7b0f2984a7aed2c7492",
    "7d2070493e07198896bc49135bc84ef00499a375",
    "424a00daa069bf2049014fd46ad152ec5fc77ac8",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "11375578162d77b78cc3f7a82f2495b1e31a3656",
    "cdce88376a60918dfe2f3bcd82a7666d74992a19",
    "be9c67930b57c516723d566625f9036a88a84055",
    "4e7c4a6e1fd00767d966cd2482a364b2eacbd35b",
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941",
    "4d4560189adccb941a3dc5eee7add134adbf6519"
  ],
  "changeHistoryShort": {
    "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2": "Ybodychange",
    "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81": "Ybodychange",
    "2b08a1fc644904a37545107666efc25b3552542d": "Ybodychange",
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e": "Ybodychange",
    "822ae88f7da638e15a25747f6965caee8198aca6": "Ybodychange",
    "4bca385241c0fc8ff168c7b0f2984a7aed2c7492": "Ybodychange",
    "7d2070493e07198896bc49135bc84ef00499a375": "Ybodychange",
    "424a00daa069bf2049014fd46ad152ec5fc77ac8": "Ybodychange",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "11375578162d77b78cc3f7a82f2495b1e31a3656": "Ybodychange",
    "cdce88376a60918dfe2f3bcd82a7666d74992a19": "Ybodychange",
    "be9c67930b57c516723d566625f9036a88a84055": "Ybodychange",
    "4e7c4a6e1fd00767d966cd2482a364b2eacbd35b": "Yfilerename",
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941": "Ybodychange",
    "4d4560189adccb941a3dc5eee7add134adbf6519": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14445. Delegation tokens are not shared between KMS instances. Contributed by Xiao Chen and Rushabh S Shah.\"\n\nThis reverts commit 583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81.\n\n Conflicts:\n\thadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSTokenRenewer.java\n\thadoop-common-project/hadoop-kms/src/test/java/org/apache/hadoop/crypto/key/kms/server/TestKMS.java\n",
      "commitDate": "07/05/18 1:32 PM",
      "commitName": "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "10/04/18 3:38 PM",
      "commitNameOld": "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 26.91,
      "commitsBetweenForRepo": 686,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,135 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n-    LOG.trace(\"Processing operation for req\u003d({}), token: {}\",\n-        request.getRequestURL(), token);\n+    LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (isManagementOperation(request)) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           // Don\u0027t authenticate via DT for DT ops.\n           token \u003d authHandler.authenticate(request, response);\n           LOG.trace(\"Got token: {}.\", token);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               String service \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.SERVICE_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer,\n                     service);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (isManagementOperation(request)) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          LOG.trace(\"Got token: {}.\", token);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              String service \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.SERVICE_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer,\n                    service);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14445. Delegation tokens are not shared between KMS instances. Contributed by Xiao Chen and Rushabh S Shah.\n",
      "commitDate": "10/04/18 3:38 PM",
      "commitName": "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "06/10/17 10:12 AM",
      "commitNameOld": "2b08a1fc644904a37545107666efc25b3552542d",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 186.23,
      "commitsBetweenForRepo": 1374,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n-    LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n+    LOG.trace(\"Processing operation for req\u003d({}), token: {}\",\n+        request.getRequestURL(), token);\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (isManagementOperation(request)) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           // Don\u0027t authenticate via DT for DT ops.\n           token \u003d authHandler.authenticate(request, response);\n           LOG.trace(\"Got token: {}.\", token);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               String service \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.SERVICE_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer,\n                     service);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    LOG.trace(\"Processing operation for req\u003d({}), token: {}\",\n        request.getRequestURL(), token);\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (isManagementOperation(request)) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          LOG.trace(\"Got token: {}.\", token);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              String service \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.SERVICE_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer,\n                    service);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "2b08a1fc644904a37545107666efc25b3552542d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14920. KMSClientProvider won\u0027t work with KMS delegation token retrieved from non-Java client. Contributed by Xiaoyu Yao.\n",
      "commitDate": "06/10/17 10:12 AM",
      "commitName": "2b08a1fc644904a37545107666efc25b3552542d",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "08/06/17 9:34 PM",
      "commitNameOld": "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 119.53,
      "commitsBetweenForRepo": 869,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,135 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (isManagementOperation(request)) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           // Don\u0027t authenticate via DT for DT ops.\n           token \u003d authHandler.authenticate(request, response);\n           LOG.trace(\"Got token: {}.\", token);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n+              String service \u003d ServletUtils.getParameter(request,\n+                  KerberosDelegationTokenAuthenticator.SERVICE_PARAM);\n               try {\n-                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n+                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer,\n+                    service);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (isManagementOperation(request)) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          LOG.trace(\"Got token: {}.\", token);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              String service \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.SERVICE_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer,\n                    service);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13174. Add more debug logs for delegation tokens and authentication.\n",
      "commitDate": "08/06/17 9:34 PM",
      "commitName": "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "28/11/16 9:07 PM",
      "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 191.98,
      "commitsBetweenForRepo": 1032,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,132 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n+    LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (isManagementOperation(request)) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           // Don\u0027t authenticate via DT for DT ops.\n           token \u003d authHandler.authenticate(request, response);\n+          LOG.trace(\"Got token: {}.\", token);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    LOG.trace(\"Processing operation for req\u003d({}), token: {}\", request, token);\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (isManagementOperation(request)) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          LOG.trace(\"Got token: {}.\", token);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "822ae88f7da638e15a25747f6965caee8198aca6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13346. DelegationTokenAuthenticationHandler writes via closed writer. Contributed by Gregory Chanan and Hrishikesh Gadre.\n",
      "commitDate": "09/11/16 9:33 AM",
      "commitName": "822ae88f7da638e15a25747f6965caee8198aca6",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "18/10/16 6:32 PM",
      "commitNameOld": "4bca385241c0fc8ff168c7b0f2984a7aed2c7492",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 21.67,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (isManagementOperation(request)) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           // Don\u0027t authenticate via DT for DT ops.\n           token \u003d authHandler.authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n-              ObjectMapper jsonMapper \u003d new ObjectMapper();\n+              ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (isManagementOperation(request)) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper(jsonFactory);\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "4bca385241c0fc8ff168c7b0f2984a7aed2c7492": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12082 Support multiple authentication schemes via AuthenticationFilter\n",
      "commitDate": "18/10/16 6:32 PM",
      "commitName": "4bca385241c0fc8ff168c7b0f2984a7aed2c7492",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "27/06/16 6:46 PM",
      "commitNameOld": "7d2070493e07198896bc49135bc84ef00499a375",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 112.99,
      "commitsBetweenForRepo": 852,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n-    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n-        !request.getMethod().equals(\"OPTIONS\")) {\n+    if (isManagementOperation(request)) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           // Don\u0027t authenticate via DT for DT ops.\n           token \u003d authHandler.authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (isManagementOperation(request)) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "7d2070493e07198896bc49135bc84ef00499a375": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13316. Enforce Kerberos authentication for required ops in DelegationTokenAuthenticator. Contributed by Xiao Chen.\n",
      "commitDate": "27/06/16 6:46 PM",
      "commitName": "7d2070493e07198896bc49135bc84ef00499a375",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "23/06/16 11:08 AM",
      "commitNameOld": "e98c0c7a1c2fe9380c90f7530a46752153cc37f2",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.32,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,131 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n-          token \u003d authenticate(request, response);\n+          // Don\u0027t authenticate via DT for DT ops.\n+          token \u003d authHandler.authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          // Don\u0027t authenticate via DT for DT ops.\n          token \u003d authHandler.authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "424a00daa069bf2049014fd46ad152ec5fc77ac8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11704. DelegationTokenAuthenticationFilter must pass ipaddress instead of hostname to ProxyUsers#authorize (Anubhav Dhoot via asuresh)\n",
      "commitDate": "21/04/15 11:31 AM",
      "commitName": "424a00daa069bf2049014fd46ad152ec5fc77ac8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "02/03/15 9:17 PM",
      "commitNameOld": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 49.55,
      "commitsBetweenForRepo": 416,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           token \u003d authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n-              ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n+              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteAddr());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n-    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n+    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           token \u003d authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? StringUtils.toUpperCase(op) : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n-    op \u003d (op !\u003d null) ? op.toUpperCase(Locale.ENGLISH) : null;\n+    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           token \u003d authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "17/10/14 3:56 PM",
      "commitNameOld": "11375578162d77b78cc3f7a82f2495b1e31a3656",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 124.22,
      "commitsBetweenForRepo": 985,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n-    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n+    op \u003d (op !\u003d null) ? op.toUpperCase(Locale.ENGLISH) : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           token \u003d authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           // Create the proxy user if doAsUser exists\n           String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n           if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n             requestUgi \u003d UserGroupInformation.createProxyUser(\n                 doAsUser, requestUgi);\n             try {\n               ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n             } catch (AuthorizationException ex) {\n               HttpExceptionUtils.createServletExceptionResponse(response,\n                   HttpServletResponse.SC_FORBIDDEN, ex);\n               return false;\n             }\n           }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase(Locale.ENGLISH) : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "11375578162d77b78cc3f7a82f2495b1e31a3656": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11207. Enhanced common DelegationTokenAuthenticationHandler to support proxy-users on Delegation-token management operations. Contributed by Zhijie Shen.\n",
      "commitDate": "17/10/14 3:56 PM",
      "commitName": "11375578162d77b78cc3f7a82f2495b1e31a3656",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/10/14 9:50 PM",
      "commitNameOld": "1220bb72d452521c6f09cebe1dd77341054ee9dd",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 2.75,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,130 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           token \u003d authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n+          // Create the proxy user if doAsUser exists\n+          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n+          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n+            requestUgi \u003d UserGroupInformation.createProxyUser(\n+                doAsUser, requestUgi);\n+            try {\n+              ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n+            } catch (AuthorizationException ex) {\n+              HttpExceptionUtils.createServletExceptionResponse(response,\n+                  HttpServletResponse.SC_FORBIDDEN, ex);\n+              return false;\n+            }\n+          }\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n                 Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          // Create the proxy user if doAsUser exists\n          String doAsUser \u003d DelegationTokenAuthenticationFilter.getDoAs(request);\n          if (requestUgi !\u003d null \u0026\u0026 doAsUser !\u003d null) {\n            requestUgi \u003d UserGroupInformation.createProxyUser(\n                doAsUser, requestUgi);\n            try {\n              ProxyUsers.authorize(requestUgi, request.getRemoteHost());\n            } catch (AuthorizationException ex) {\n              HttpExceptionUtils.createServletExceptionResponse(response,\n                  HttpServletResponse.SC_FORBIDDEN, ex);\n              return false;\n            }\n          }\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "cdce88376a60918dfe2f3bcd82a7666d74992a19": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11181. Generalized o.a.h.s.t.d.DelegationTokenManager to handle all sub-classes of AbstractDelegationTokenIdentifier. Contributed by Zhijie Shen.\n",
      "commitDate": "14/10/14 11:35 AM",
      "commitName": "cdce88376a60918dfe2f3bcd82a7666d74992a19",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "20/09/14 8:21 AM",
      "commitNameOld": "db890eef3208cc557476fa510f7a253ba22bc68a",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 24.13,
      "commitsBetweenForRepo": 240,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,117 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n       throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d ServletUtils.getParameter(request,\n         KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n           KerberosDelegationTokenAuthenticator.\n               DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           token \u003d authenticate(request, response);\n           if (token \u003d\u003d null) {\n             requestContinues \u003d false;\n             doManagement \u003d false;\n           } else {\n             doManagement \u003d true;\n           }\n         } else {\n           doManagement \u003d true;\n         }\n         if (doManagement) {\n           UserGroupInformation requestUgi \u003d (token !\u003d null)\n               ? UserGroupInformation.createRemoteUser(token.getUserName())\n               : null;\n           Map map \u003d null;\n           switch (dtOp) {\n             case GETDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String renewer \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n               try {\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                 map \u003d delegationTokenToJSON(dToken);\n               } catch (IOException ex) {\n                 throw new AuthenticationException(ex.toString(), ex);\n               }\n               break;\n             case RENEWDELEGATIONTOKEN:\n               if (requestUgi \u003d\u003d null) {\n                 throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n               String tokenToRenew \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToRenew \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n-                Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n-                    new Token\u003cDelegationTokenIdentifier\u003e();\n+                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToRenew);\n                   long expirationTime \u003d tokenManager.renewToken(dt,\n                       requestUgi.getShortUserName());\n                   map \u003d new HashMap();\n                   map.put(\"long\", expirationTime);\n                 } catch (IOException ex) {\n                   throw new AuthenticationException(ex.toString(), ex);\n                 }\n               }\n               break;\n             case CANCELDELEGATIONTOKEN:\n               String tokenToCancel \u003d ServletUtils.getParameter(request,\n                   KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n               if (tokenToCancel \u003d\u003d null) {\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                         \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                         KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                 );\n                 requestContinues \u003d false;\n               } else {\n-                Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n-                    new Token\u003cDelegationTokenIdentifier\u003e();\n+                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                 try {\n                   dt.decodeFromUrlString(tokenToCancel);\n                   tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                       ? requestUgi.getShortUserName() : null);\n                 } catch (IOException ex) {\n                   response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                       \"Invalid delegation token, cannot cancel\");\n                   requestContinues \u003d false;\n                 }\n               }\n               break;\n           }\n           if (requestContinues) {\n             response.setStatus(HttpServletResponse.SC_OK);\n             if (map !\u003d null) {\n               response.setContentType(MediaType.APPLICATION_JSON);\n               Writer writer \u003d response.getWriter();\n               ObjectMapper jsonMapper \u003d new ObjectMapper();\n               jsonMapper.writeValue(writer, map);\n               writer.write(ENTER);\n               writer.flush();\n             }\n             requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n             MessageFormat.format(\n                 \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                     \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cAbstractDelegationTokenIdentifier\u003e dt \u003d new Token();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "be9c67930b57c516723d566625f9036a88a84055": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10771. Refactor HTTP delegation support out of httpfs to common, PART 2. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616672 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/14 9:58 PM",
      "commitName": "be9c67930b57c516723d566625f9036a88a84055",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "07/08/14 9:55 PM",
      "commitNameOld": "4e7c4a6e1fd00767d966cd2482a364b2eacbd35b",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,119 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n-    throws IOException, AuthenticationException {\n+      throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n-    String op \u003d request.getParameter(HttpFSFileSystem.OP_PARAM);\n+    String op \u003d ServletUtils.getParameter(request,\n+        KerberosDelegationTokenAuthenticator.OP_PARAM);\n     op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n-      DelegationTokenOperation dtOp \u003d\n-        DelegationTokenOperation.valueOf(op);\n+      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n+          KerberosDelegationTokenAuthenticator.\n+              DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n+        boolean doManagement;\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n-          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n-            MessageFormat.format(\n-              \"Operation [{0}] requires SPNEGO authentication established\",\n-              dtOp));\n-          requestContinues \u003d false;\n+          token \u003d authenticate(request, response);\n+          if (token \u003d\u003d null) {\n+            requestContinues \u003d false;\n+            doManagement \u003d false;\n+          } else {\n+            doManagement \u003d true;\n+          }\n         } else {\n-          DelegationTokenManager tokenManager \u003d\n-            HttpFSServerWebApp.get().get(DelegationTokenManager.class);\n-          try {\n-            Map map \u003d null;\n-            switch (dtOp) {\n-              case GETDELEGATIONTOKEN:\n-                String renewerParam \u003d\n-                  request.getParameter(HttpFSKerberosAuthenticator.RENEWER_PARAM);\n-                if (renewerParam \u003d\u003d null) {\n-                  renewerParam \u003d token.getUserName();\n-                }\n-                Token\u003c?\u003e dToken \u003d tokenManager.createToken(\n-                  UserGroupInformation.getCurrentUser(), renewerParam);\n-                map \u003d delegationTokenToJSON(dToken);\n-                break;\n-              case RENEWDELEGATIONTOKEN:\n-              case CANCELDELEGATIONTOKEN:\n-                String tokenParam \u003d\n-                  request.getParameter(HttpFSKerberosAuthenticator.TOKEN_PARAM);\n-                if (tokenParam \u003d\u003d null) {\n-                  response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n-                    MessageFormat.format(\n-                      \"Operation [{0}] requires the parameter [{1}]\",\n-                      dtOp, HttpFSKerberosAuthenticator.TOKEN_PARAM));\n-                  requestContinues \u003d false;\n-                } else {\n-                  if (dtOp \u003d\u003d DelegationTokenOperation.CANCELDELEGATIONTOKEN) {\n-                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n-                      new Token\u003cDelegationTokenIdentifier\u003e();\n-                    dt.decodeFromUrlString(tokenParam);\n-                    tokenManager.cancelToken(dt,\n-                      UserGroupInformation.getCurrentUser().getUserName());\n-                  } else {\n-                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n-                      new Token\u003cDelegationTokenIdentifier\u003e();\n-                    dt.decodeFromUrlString(tokenParam);\n-                    long expirationTime \u003d\n-                      tokenManager.renewToken(dt, token.getUserName());\n-                    map \u003d new HashMap();\n-                    map.put(\"long\", expirationTime);\n-                  }\n-                }\n-                break;\n-            }\n-            if (requestContinues) {\n-              response.setStatus(HttpServletResponse.SC_OK);\n-              if (map !\u003d null) {\n-                response.setContentType(MediaType.APPLICATION_JSON);\n-                Writer writer \u003d response.getWriter();\n-                JSONObject.writeJSONString(map, writer);\n-                writer.write(ENTER);\n-                writer.flush();\n-\n+          doManagement \u003d true;\n+        }\n+        if (doManagement) {\n+          UserGroupInformation requestUgi \u003d (token !\u003d null)\n+              ? UserGroupInformation.createRemoteUser(token.getUserName())\n+              : null;\n+          Map map \u003d null;\n+          switch (dtOp) {\n+            case GETDELEGATIONTOKEN:\n+              if (requestUgi \u003d\u003d null) {\n+                throw new IllegalStateException(\"request UGI cannot be NULL\");\n               }\n-              requestContinues \u003d false;\n+              String renewer \u003d ServletUtils.getParameter(request,\n+                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n+              try {\n+                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n+                map \u003d delegationTokenToJSON(dToken);\n+              } catch (IOException ex) {\n+                throw new AuthenticationException(ex.toString(), ex);\n+              }\n+              break;\n+            case RENEWDELEGATIONTOKEN:\n+              if (requestUgi \u003d\u003d null) {\n+                throw new IllegalStateException(\"request UGI cannot be NULL\");\n+              }\n+              String tokenToRenew \u003d ServletUtils.getParameter(request,\n+                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n+              if (tokenToRenew \u003d\u003d null) {\n+                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n+                    MessageFormat.format(\n+                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n+                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n+                );\n+                requestContinues \u003d false;\n+              } else {\n+                Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n+                    new Token\u003cDelegationTokenIdentifier\u003e();\n+                try {\n+                  dt.decodeFromUrlString(tokenToRenew);\n+                  long expirationTime \u003d tokenManager.renewToken(dt,\n+                      requestUgi.getShortUserName());\n+                  map \u003d new HashMap();\n+                  map.put(\"long\", expirationTime);\n+                } catch (IOException ex) {\n+                  throw new AuthenticationException(ex.toString(), ex);\n+                }\n+              }\n+              break;\n+            case CANCELDELEGATIONTOKEN:\n+              String tokenToCancel \u003d ServletUtils.getParameter(request,\n+                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n+              if (tokenToCancel \u003d\u003d null) {\n+                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n+                    MessageFormat.format(\n+                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n+                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n+                );\n+                requestContinues \u003d false;\n+              } else {\n+                Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n+                    new Token\u003cDelegationTokenIdentifier\u003e();\n+                try {\n+                  dt.decodeFromUrlString(tokenToCancel);\n+                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n+                      ? requestUgi.getShortUserName() : null);\n+                } catch (IOException ex) {\n+                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n+                      \"Invalid delegation token, cannot cancel\");\n+                  requestContinues \u003d false;\n+                }\n+              }\n+              break;\n+          }\n+          if (requestContinues) {\n+            response.setStatus(HttpServletResponse.SC_OK);\n+            if (map !\u003d null) {\n+              response.setContentType(MediaType.APPLICATION_JSON);\n+              Writer writer \u003d response.getWriter();\n+              ObjectMapper jsonMapper \u003d new ObjectMapper();\n+              jsonMapper.writeValue(writer, map);\n+              writer.write(ENTER);\n+              writer.flush();\n             }\n-          } catch (DelegationTokenManagerException ex) {\n-            throw new AuthenticationException(ex.toString(), ex);\n+            requestContinues \u003d false;\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n-          MessageFormat.format(\n-            \"Wrong HTTP method [{0}] for operation [{1}], it should be [{2}]\",\n-            request.getMethod(), dtOp, dtOp.getHttpMethod()));\n+            MessageFormat.format(\n+                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n+                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n      throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d ServletUtils.getParameter(request,\n        KerberosDelegationTokenAuthenticator.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      KerberosDelegationTokenAuthenticator.DelegationTokenOperation dtOp \u003d\n          KerberosDelegationTokenAuthenticator.\n              DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        boolean doManagement;\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          token \u003d authenticate(request, response);\n          if (token \u003d\u003d null) {\n            requestContinues \u003d false;\n            doManagement \u003d false;\n          } else {\n            doManagement \u003d true;\n          }\n        } else {\n          doManagement \u003d true;\n        }\n        if (doManagement) {\n          UserGroupInformation requestUgi \u003d (token !\u003d null)\n              ? UserGroupInformation.createRemoteUser(token.getUserName())\n              : null;\n          Map map \u003d null;\n          switch (dtOp) {\n            case GETDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String renewer \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.RENEWER_PARAM);\n              try {\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(requestUgi, renewer);\n                map \u003d delegationTokenToJSON(dToken);\n              } catch (IOException ex) {\n                throw new AuthenticationException(ex.toString(), ex);\n              }\n              break;\n            case RENEWDELEGATIONTOKEN:\n              if (requestUgi \u003d\u003d null) {\n                throw new IllegalStateException(\"request UGI cannot be NULL\");\n              }\n              String tokenToRenew \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToRenew \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                    new Token\u003cDelegationTokenIdentifier\u003e();\n                try {\n                  dt.decodeFromUrlString(tokenToRenew);\n                  long expirationTime \u003d tokenManager.renewToken(dt,\n                      requestUgi.getShortUserName());\n                  map \u003d new HashMap();\n                  map.put(\"long\", expirationTime);\n                } catch (IOException ex) {\n                  throw new AuthenticationException(ex.toString(), ex);\n                }\n              }\n              break;\n            case CANCELDELEGATIONTOKEN:\n              String tokenToCancel \u003d ServletUtils.getParameter(request,\n                  KerberosDelegationTokenAuthenticator.TOKEN_PARAM);\n              if (tokenToCancel \u003d\u003d null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                        \"Operation [{0}] requires the parameter [{1}]\", dtOp,\n                        KerberosDelegationTokenAuthenticator.TOKEN_PARAM)\n                );\n                requestContinues \u003d false;\n              } else {\n                Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                    new Token\u003cDelegationTokenIdentifier\u003e();\n                try {\n                  dt.decodeFromUrlString(tokenToCancel);\n                  tokenManager.cancelToken(dt, (requestUgi !\u003d null)\n                      ? requestUgi.getShortUserName() : null);\n                } catch (IOException ex) {\n                  response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                      \"Invalid delegation token, cannot cancel\");\n                  requestContinues \u003d false;\n                }\n              }\n              break;\n          }\n          if (requestContinues) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            if (map !\u003d null) {\n              response.setContentType(MediaType.APPLICATION_JSON);\n              Writer writer \u003d response.getWriter();\n              ObjectMapper jsonMapper \u003d new ObjectMapper();\n              jsonMapper.writeValue(writer, map);\n              writer.write(ENTER);\n              writer.flush();\n            }\n            requestContinues \u003d false;\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n            MessageFormat.format(\n                \"Wrong HTTP method [{0}] for operation [{1}], it should be \" +\n                    \"[{2}]\", request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "4e7c4a6e1fd00767d966cd2482a364b2eacbd35b": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-10771. Refactor HTTP delegation support out of httpfs to common, PART 1. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616671 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/14 9:55 PM",
      "commitName": "4e7c4a6e1fd00767d966cd2482a364b2eacbd35b",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "07/08/14 9:27 PM",
      "commitNameOld": "2ac640ec751f665365d548104b3713e414f53351",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n    throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d request.getParameter(HttpFSFileSystem.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      DelegationTokenOperation dtOp \u003d\n        DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n            MessageFormat.format(\n              \"Operation [{0}] requires SPNEGO authentication established\",\n              dtOp));\n          requestContinues \u003d false;\n        } else {\n          DelegationTokenManager tokenManager \u003d\n            HttpFSServerWebApp.get().get(DelegationTokenManager.class);\n          try {\n            Map map \u003d null;\n            switch (dtOp) {\n              case GETDELEGATIONTOKEN:\n                String renewerParam \u003d\n                  request.getParameter(HttpFSKerberosAuthenticator.RENEWER_PARAM);\n                if (renewerParam \u003d\u003d null) {\n                  renewerParam \u003d token.getUserName();\n                }\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(\n                  UserGroupInformation.getCurrentUser(), renewerParam);\n                map \u003d delegationTokenToJSON(dToken);\n                break;\n              case RENEWDELEGATIONTOKEN:\n              case CANCELDELEGATIONTOKEN:\n                String tokenParam \u003d\n                  request.getParameter(HttpFSKerberosAuthenticator.TOKEN_PARAM);\n                if (tokenParam \u003d\u003d null) {\n                  response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                      \"Operation [{0}] requires the parameter [{1}]\",\n                      dtOp, HttpFSKerberosAuthenticator.TOKEN_PARAM));\n                  requestContinues \u003d false;\n                } else {\n                  if (dtOp \u003d\u003d DelegationTokenOperation.CANCELDELEGATIONTOKEN) {\n                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                      new Token\u003cDelegationTokenIdentifier\u003e();\n                    dt.decodeFromUrlString(tokenParam);\n                    tokenManager.cancelToken(dt,\n                      UserGroupInformation.getCurrentUser().getUserName());\n                  } else {\n                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                      new Token\u003cDelegationTokenIdentifier\u003e();\n                    dt.decodeFromUrlString(tokenParam);\n                    long expirationTime \u003d\n                      tokenManager.renewToken(dt, token.getUserName());\n                    map \u003d new HashMap();\n                    map.put(\"long\", expirationTime);\n                  }\n                }\n                break;\n            }\n            if (requestContinues) {\n              response.setStatus(HttpServletResponse.SC_OK);\n              if (map !\u003d null) {\n                response.setContentType(MediaType.APPLICATION_JSON);\n                Writer writer \u003d response.getWriter();\n                JSONObject.writeJSONString(map, writer);\n                writer.write(ENTER);\n                writer.flush();\n\n              }\n              requestContinues \u003d false;\n            }\n          } catch (DelegationTokenManagerException ex) {\n            throw new AuthenticationException(ex.toString(), ex);\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n          MessageFormat.format(\n            \"Wrong HTTP method [{0}] for operation [{1}], it should be [{2}]\",\n            request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSKerberosAuthenticationHandler.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationHandler.java"
      }
    },
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7967. Need generalized multi-token filesystem support (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1374271 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/12 7:05 AM",
      "commitName": "8fa10b184e607a33f59e67bd4b1fbe5a2e683941",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "01/08/12 4:14 PM",
      "commitNameOld": "08e89662170010dd619c0df859c670cb37b630dd",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 15.62,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,88 @@\n   public boolean managementOperation(AuthenticationToken token,\n       HttpServletRequest request, HttpServletResponse response)\n     throws IOException, AuthenticationException {\n     boolean requestContinues \u003d true;\n     String op \u003d request.getParameter(HttpFSFileSystem.OP_PARAM);\n     op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n     if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n         !request.getMethod().equals(\"OPTIONS\")) {\n       DelegationTokenOperation dtOp \u003d\n         DelegationTokenOperation.valueOf(op);\n       if (dtOp.getHttpMethod().equals(request.getMethod())) {\n         if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n           response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n             MessageFormat.format(\n               \"Operation [{0}] requires SPNEGO authentication established\",\n               dtOp));\n           requestContinues \u003d false;\n         } else {\n           DelegationTokenManager tokenManager \u003d\n             HttpFSServerWebApp.get().get(DelegationTokenManager.class);\n           try {\n             Map map \u003d null;\n             switch (dtOp) {\n               case GETDELEGATIONTOKEN:\n-              case GETDELEGATIONTOKENS:\n                 String renewerParam \u003d\n                   request.getParameter(HttpFSKerberosAuthenticator.RENEWER_PARAM);\n                 if (renewerParam \u003d\u003d null) {\n                   renewerParam \u003d token.getUserName();\n                 }\n                 Token\u003c?\u003e dToken \u003d tokenManager.createToken(\n                   UserGroupInformation.getCurrentUser(), renewerParam);\n-                if (dtOp \u003d\u003d DelegationTokenOperation.GETDELEGATIONTOKEN) {\n-                  map \u003d delegationTokenToJSON(dToken);\n-                } else {\n-                  map \u003d delegationTokensToJSON(Arrays.asList((Token)dToken));\n-                }\n+                map \u003d delegationTokenToJSON(dToken);\n                 break;\n               case RENEWDELEGATIONTOKEN:\n               case CANCELDELEGATIONTOKEN:\n                 String tokenParam \u003d\n                   request.getParameter(HttpFSKerberosAuthenticator.TOKEN_PARAM);\n                 if (tokenParam \u003d\u003d null) {\n                   response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                     MessageFormat.format(\n                       \"Operation [{0}] requires the parameter [{1}]\",\n                       dtOp, HttpFSKerberosAuthenticator.TOKEN_PARAM));\n                   requestContinues \u003d false;\n                 } else {\n                   if (dtOp \u003d\u003d DelegationTokenOperation.CANCELDELEGATIONTOKEN) {\n                     Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                       new Token\u003cDelegationTokenIdentifier\u003e();\n                     dt.decodeFromUrlString(tokenParam);\n                     tokenManager.cancelToken(dt,\n                       UserGroupInformation.getCurrentUser().getUserName());\n                   } else {\n                     Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                       new Token\u003cDelegationTokenIdentifier\u003e();\n                     dt.decodeFromUrlString(tokenParam);\n                     long expirationTime \u003d\n                       tokenManager.renewToken(dt, token.getUserName());\n                     map \u003d new HashMap();\n                     map.put(\"long\", expirationTime);\n                   }\n                 }\n                 break;\n             }\n             if (requestContinues) {\n               response.setStatus(HttpServletResponse.SC_OK);\n               if (map !\u003d null) {\n                 response.setContentType(MediaType.APPLICATION_JSON);\n                 Writer writer \u003d response.getWriter();\n                 JSONObject.writeJSONString(map, writer);\n                 writer.write(ENTER);\n                 writer.flush();\n \n               }\n               requestContinues \u003d false;\n             }\n           } catch (DelegationTokenManagerException ex) {\n             throw new AuthenticationException(ex.toString(), ex);\n           }\n         }\n       } else {\n         response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n           MessageFormat.format(\n             \"Wrong HTTP method [{0}] for operation [{1}], it should be [{2}]\",\n             request.getMethod(), dtOp, dtOp.getHttpMethod()));\n         requestContinues \u003d false;\n       }\n     }\n     return requestContinues;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n    throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d request.getParameter(HttpFSFileSystem.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      DelegationTokenOperation dtOp \u003d\n        DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n            MessageFormat.format(\n              \"Operation [{0}] requires SPNEGO authentication established\",\n              dtOp));\n          requestContinues \u003d false;\n        } else {\n          DelegationTokenManager tokenManager \u003d\n            HttpFSServerWebApp.get().get(DelegationTokenManager.class);\n          try {\n            Map map \u003d null;\n            switch (dtOp) {\n              case GETDELEGATIONTOKEN:\n                String renewerParam \u003d\n                  request.getParameter(HttpFSKerberosAuthenticator.RENEWER_PARAM);\n                if (renewerParam \u003d\u003d null) {\n                  renewerParam \u003d token.getUserName();\n                }\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(\n                  UserGroupInformation.getCurrentUser(), renewerParam);\n                map \u003d delegationTokenToJSON(dToken);\n                break;\n              case RENEWDELEGATIONTOKEN:\n              case CANCELDELEGATIONTOKEN:\n                String tokenParam \u003d\n                  request.getParameter(HttpFSKerberosAuthenticator.TOKEN_PARAM);\n                if (tokenParam \u003d\u003d null) {\n                  response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                      \"Operation [{0}] requires the parameter [{1}]\",\n                      dtOp, HttpFSKerberosAuthenticator.TOKEN_PARAM));\n                  requestContinues \u003d false;\n                } else {\n                  if (dtOp \u003d\u003d DelegationTokenOperation.CANCELDELEGATIONTOKEN) {\n                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                      new Token\u003cDelegationTokenIdentifier\u003e();\n                    dt.decodeFromUrlString(tokenParam);\n                    tokenManager.cancelToken(dt,\n                      UserGroupInformation.getCurrentUser().getUserName());\n                  } else {\n                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                      new Token\u003cDelegationTokenIdentifier\u003e();\n                    dt.decodeFromUrlString(tokenParam);\n                    long expirationTime \u003d\n                      tokenManager.renewToken(dt, token.getUserName());\n                    map \u003d new HashMap();\n                    map.put(\"long\", expirationTime);\n                  }\n                }\n                break;\n            }\n            if (requestContinues) {\n              response.setStatus(HttpServletResponse.SC_OK);\n              if (map !\u003d null) {\n                response.setContentType(MediaType.APPLICATION_JSON);\n                Writer writer \u003d response.getWriter();\n                JSONObject.writeJSONString(map, writer);\n                writer.write(ENTER);\n                writer.flush();\n\n              }\n              requestContinues \u003d false;\n            }\n          } catch (DelegationTokenManagerException ex) {\n            throw new AuthenticationException(ex.toString(), ex);\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n          MessageFormat.format(\n            \"Wrong HTTP method [{0}] for operation [{1}], it should be [{2}]\",\n            request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSKerberosAuthenticationHandler.java",
      "extendedDetails": {}
    },
    "4d4560189adccb941a3dc5eee7add134adbf6519": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3113. httpfs does not support delegation tokens. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1365988 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/12 6:39 AM",
      "commitName": "4d4560189adccb941a3dc5eee7add134adbf6519",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,93 @@\n+  public boolean managementOperation(AuthenticationToken token,\n+      HttpServletRequest request, HttpServletResponse response)\n+    throws IOException, AuthenticationException {\n+    boolean requestContinues \u003d true;\n+    String op \u003d request.getParameter(HttpFSFileSystem.OP_PARAM);\n+    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n+    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n+        !request.getMethod().equals(\"OPTIONS\")) {\n+      DelegationTokenOperation dtOp \u003d\n+        DelegationTokenOperation.valueOf(op);\n+      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n+        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n+          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n+            MessageFormat.format(\n+              \"Operation [{0}] requires SPNEGO authentication established\",\n+              dtOp));\n+          requestContinues \u003d false;\n+        } else {\n+          DelegationTokenManager tokenManager \u003d\n+            HttpFSServerWebApp.get().get(DelegationTokenManager.class);\n+          try {\n+            Map map \u003d null;\n+            switch (dtOp) {\n+              case GETDELEGATIONTOKEN:\n+              case GETDELEGATIONTOKENS:\n+                String renewerParam \u003d\n+                  request.getParameter(HttpFSKerberosAuthenticator.RENEWER_PARAM);\n+                if (renewerParam \u003d\u003d null) {\n+                  renewerParam \u003d token.getUserName();\n+                }\n+                Token\u003c?\u003e dToken \u003d tokenManager.createToken(\n+                  UserGroupInformation.getCurrentUser(), renewerParam);\n+                if (dtOp \u003d\u003d DelegationTokenOperation.GETDELEGATIONTOKEN) {\n+                  map \u003d delegationTokenToJSON(dToken);\n+                } else {\n+                  map \u003d delegationTokensToJSON(Arrays.asList((Token)dToken));\n+                }\n+                break;\n+              case RENEWDELEGATIONTOKEN:\n+              case CANCELDELEGATIONTOKEN:\n+                String tokenParam \u003d\n+                  request.getParameter(HttpFSKerberosAuthenticator.TOKEN_PARAM);\n+                if (tokenParam \u003d\u003d null) {\n+                  response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n+                    MessageFormat.format(\n+                      \"Operation [{0}] requires the parameter [{1}]\",\n+                      dtOp, HttpFSKerberosAuthenticator.TOKEN_PARAM));\n+                  requestContinues \u003d false;\n+                } else {\n+                  if (dtOp \u003d\u003d DelegationTokenOperation.CANCELDELEGATIONTOKEN) {\n+                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n+                      new Token\u003cDelegationTokenIdentifier\u003e();\n+                    dt.decodeFromUrlString(tokenParam);\n+                    tokenManager.cancelToken(dt,\n+                      UserGroupInformation.getCurrentUser().getUserName());\n+                  } else {\n+                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n+                      new Token\u003cDelegationTokenIdentifier\u003e();\n+                    dt.decodeFromUrlString(tokenParam);\n+                    long expirationTime \u003d\n+                      tokenManager.renewToken(dt, token.getUserName());\n+                    map \u003d new HashMap();\n+                    map.put(\"long\", expirationTime);\n+                  }\n+                }\n+                break;\n+            }\n+            if (requestContinues) {\n+              response.setStatus(HttpServletResponse.SC_OK);\n+              if (map !\u003d null) {\n+                response.setContentType(MediaType.APPLICATION_JSON);\n+                Writer writer \u003d response.getWriter();\n+                JSONObject.writeJSONString(map, writer);\n+                writer.write(ENTER);\n+                writer.flush();\n+\n+              }\n+              requestContinues \u003d false;\n+            }\n+          } catch (DelegationTokenManagerException ex) {\n+            throw new AuthenticationException(ex.toString(), ex);\n+          }\n+        }\n+      } else {\n+        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n+          MessageFormat.format(\n+            \"Wrong HTTP method [{0}] for operation [{1}], it should be [{2}]\",\n+            request.getMethod(), dtOp, dtOp.getHttpMethod()));\n+        requestContinues \u003d false;\n+      }\n+    }\n+    return requestContinues;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean managementOperation(AuthenticationToken token,\n      HttpServletRequest request, HttpServletResponse response)\n    throws IOException, AuthenticationException {\n    boolean requestContinues \u003d true;\n    String op \u003d request.getParameter(HttpFSFileSystem.OP_PARAM);\n    op \u003d (op !\u003d null) ? op.toUpperCase() : null;\n    if (DELEGATION_TOKEN_OPS.contains(op) \u0026\u0026\n        !request.getMethod().equals(\"OPTIONS\")) {\n      DelegationTokenOperation dtOp \u003d\n        DelegationTokenOperation.valueOf(op);\n      if (dtOp.getHttpMethod().equals(request.getMethod())) {\n        if (dtOp.requiresKerberosCredentials() \u0026\u0026 token \u003d\u003d null) {\n          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n            MessageFormat.format(\n              \"Operation [{0}] requires SPNEGO authentication established\",\n              dtOp));\n          requestContinues \u003d false;\n        } else {\n          DelegationTokenManager tokenManager \u003d\n            HttpFSServerWebApp.get().get(DelegationTokenManager.class);\n          try {\n            Map map \u003d null;\n            switch (dtOp) {\n              case GETDELEGATIONTOKEN:\n              case GETDELEGATIONTOKENS:\n                String renewerParam \u003d\n                  request.getParameter(HttpFSKerberosAuthenticator.RENEWER_PARAM);\n                if (renewerParam \u003d\u003d null) {\n                  renewerParam \u003d token.getUserName();\n                }\n                Token\u003c?\u003e dToken \u003d tokenManager.createToken(\n                  UserGroupInformation.getCurrentUser(), renewerParam);\n                if (dtOp \u003d\u003d DelegationTokenOperation.GETDELEGATIONTOKEN) {\n                  map \u003d delegationTokenToJSON(dToken);\n                } else {\n                  map \u003d delegationTokensToJSON(Arrays.asList((Token)dToken));\n                }\n                break;\n              case RENEWDELEGATIONTOKEN:\n              case CANCELDELEGATIONTOKEN:\n                String tokenParam \u003d\n                  request.getParameter(HttpFSKerberosAuthenticator.TOKEN_PARAM);\n                if (tokenParam \u003d\u003d null) {\n                  response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                    MessageFormat.format(\n                      \"Operation [{0}] requires the parameter [{1}]\",\n                      dtOp, HttpFSKerberosAuthenticator.TOKEN_PARAM));\n                  requestContinues \u003d false;\n                } else {\n                  if (dtOp \u003d\u003d DelegationTokenOperation.CANCELDELEGATIONTOKEN) {\n                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                      new Token\u003cDelegationTokenIdentifier\u003e();\n                    dt.decodeFromUrlString(tokenParam);\n                    tokenManager.cancelToken(dt,\n                      UserGroupInformation.getCurrentUser().getUserName());\n                  } else {\n                    Token\u003cDelegationTokenIdentifier\u003e dt \u003d\n                      new Token\u003cDelegationTokenIdentifier\u003e();\n                    dt.decodeFromUrlString(tokenParam);\n                    long expirationTime \u003d\n                      tokenManager.renewToken(dt, token.getUserName());\n                    map \u003d new HashMap();\n                    map.put(\"long\", expirationTime);\n                  }\n                }\n                break;\n            }\n            if (requestContinues) {\n              response.setStatus(HttpServletResponse.SC_OK);\n              if (map !\u003d null) {\n                response.setContentType(MediaType.APPLICATION_JSON);\n                Writer writer \u003d response.getWriter();\n                JSONObject.writeJSONString(map, writer);\n                writer.write(ENTER);\n                writer.flush();\n\n              }\n              requestContinues \u003d false;\n            }\n          } catch (DelegationTokenManagerException ex) {\n            throw new AuthenticationException(ex.toString(), ex);\n          }\n        }\n      } else {\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n          MessageFormat.format(\n            \"Wrong HTTP method [{0}] for operation [{1}], it should be [{2}]\",\n            request.getMethod(), dtOp, dtOp.getHttpMethod()));\n        requestContinues \u003d false;\n      }\n    }\n    return requestContinues;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSKerberosAuthenticationHandler.java"
    }
  }
}