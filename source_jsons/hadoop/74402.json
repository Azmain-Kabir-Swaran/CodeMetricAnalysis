{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SSLHostnameVerifier.java",
  "functionName": "check",
  "functionId": "check___hosts-String[](modifiers-final)__cns-String[](modifiers-final)__subjectAlts-String[](modifiers-final)__ie6-boolean(modifiers-final)__strictWithSubDomains-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
  "functionStartLine": 362,
  "functionEndLine": 456,
  "numCommitsSeen": 10,
  "timeTaken": 2378,
  "changeHistory": [
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
    "32bb36b750ab656f2f32f6c74eaa1a3e68ae956e",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "640a72efbee17f6c7056650dae04f8b3f59ddaab",
    "9d16c9354b0c05edb30d23003dcdec4cc44ed925"
  ],
  "changeHistoryShort": {
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": "Ybodychange",
    "32bb36b750ab656f2f32f6c74eaa1a3e68ae956e": "Ybodychange",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "640a72efbee17f6c7056650dae04f8b3f59ddaab": "Ybodychange",
    "9d16c9354b0c05edb30d23003dcdec4cc44ed925": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16029. Consecutive StringBuilder.append can be reused. Contributed by Ayush Saxena.\n",
      "commitDate": "11/01/19 10:54 AM",
      "commitName": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 92.59,
      "commitsBetweenForRepo": 680,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,95 @@\n         public void check(final String[] hosts, final String[] cns,\n                           final String[] subjectAlts, final boolean ie6,\n                           final boolean strictWithSubDomains)\n             throws SSLException {\n             if (LOG.isTraceEnabled()) {\n                 LOG.trace(\"Hosts:{}, CNs:{} subjectAlts:{}, ie6:{}, \" +\n                     \"strictWithSubDomains{}\", Arrays.toString(hosts),\n                     Arrays.toString(cns), Arrays.toString(subjectAlts), ie6,\n                     strictWithSubDomains);\n             }\n             // Build up lists of allowed hosts For logging/debugging purposes.\n             StringBuffer buf \u003d new StringBuffer(32);\n             buf.append(\u0027\u003c\u0027);\n             for (int i \u003d 0; i \u003c hosts.length; i++) {\n                 String h \u003d hosts[i];\n                 h \u003d h !\u003d null ? StringUtils.toLowerCase(h.trim()) : \"\";\n                 hosts[i] \u003d h;\n                 if (i \u003e 0) {\n                     buf.append(\u0027/\u0027);\n                 }\n                 buf.append(h);\n             }\n             buf.append(\u0027\u003e\u0027);\n             String hostnames \u003d buf.toString();\n             // Build the list of names we\u0027re going to check.  Our DEFAULT and\n             // STRICT implementations of the HostnameVerifier only use the\n             // first CN provided.  All other CNs are ignored.\n             // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n             final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n             if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                 names.add(cns[0]);\n                 if (ie6) {\n                     for (int i \u003d 1; i \u003c cns.length; i++) {\n                         names.add(cns[i]);\n                     }\n                 }\n             }\n             if (subjectAlts !\u003d null) {\n                 for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                     if (subjectAlts[i] !\u003d null) {\n                         names.add(subjectAlts[i]);\n                     }\n                 }\n             }\n             if (names.isEmpty()) {\n                 String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                 throw new SSLException(msg);\n             }\n \n             // StringBuffer for building the error message.\n             buf \u003d new StringBuffer();\n \n             boolean match \u003d false;\n             out:\n             for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                 // Don\u0027t trim the CN, though!\n                 final String cn \u003d StringUtils.toLowerCase(it.next());\n                 // Store CN in StringBuffer in case we need to report an error.\n-                buf.append(\" \u003c\");\n-                buf.append(cn);\n-                buf.append(\u0027\u003e\u0027);\n+            buf.append(\" \u003c\")\n+            .append(cn)\n+            .append(\u0027\u003e\u0027);\n                 if (it.hasNext()) {\n                     buf.append(\" OR\");\n                 }\n \n                 // The CN better have at least two dots if it wants wildcard\n                 // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                 // [*.org.uk], etc...\n                 boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                      cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                      !isIP4Address(cn) \u0026\u0026\n                                      acceptableCountryWildcard(cn);\n \n                 for (int i \u003d 0; i \u003c hosts.length; i++) {\n                     final String hostName \u003d\n                         StringUtils.toLowerCase(hosts[i].trim());\n                     if (doWildcard) {\n                         match \u003d hostName.endsWith(cn.substring(1));\n                         if (match \u0026\u0026 strictWithSubDomains) {\n                             // If we\u0027re in strict mode, then [*.foo.com] is not\n                             // allowed to match [a.b.foo.com]\n                             match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                         }\n                     } else {\n                         match \u003d hostName.equals(cn);\n                     }\n                     if (match) {\n                         break out;\n                     }\n                 }\n             }\n             if (!match) {\n                 throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n             }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Hosts:{}, CNs:{} subjectAlts:{}, ie6:{}, \" +\n                    \"strictWithSubDomains{}\", Arrays.toString(hosts),\n                    Arrays.toString(cns), Arrays.toString(subjectAlts), ie6,\n                    strictWithSubDomains);\n            }\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? StringUtils.toLowerCase(h.trim()) : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                final String cn \u003d StringUtils.toLowerCase(it.next());\n                // Store CN in StringBuffer in case we need to report an error.\n            buf.append(\" \u003c\")\n            .append(cn)\n            .append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d\n                        StringUtils.toLowerCase(hosts[i].trim());\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
      "extendedDetails": {}
    },
    "32bb36b750ab656f2f32f6c74eaa1a3e68ae956e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11302. Improve Logging for SSLHostnameVerifier. Contributed by Chen Liang.\n",
      "commitDate": "05/04/17 5:28 PM",
      "commitName": "32bb36b750ab656f2f32f6c74eaa1a3e68ae956e",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "02/03/15 9:17 PM",
      "commitNameOld": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 764.8,
      "commitsBetweenForRepo": 5525,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,95 @@\n         public void check(final String[] hosts, final String[] cns,\n                           final String[] subjectAlts, final boolean ie6,\n                           final boolean strictWithSubDomains)\n             throws SSLException {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Hosts:{}, CNs:{} subjectAlts:{}, ie6:{}, \" +\n+                    \"strictWithSubDomains{}\", Arrays.toString(hosts),\n+                    Arrays.toString(cns), Arrays.toString(subjectAlts), ie6,\n+                    strictWithSubDomains);\n+            }\n             // Build up lists of allowed hosts For logging/debugging purposes.\n             StringBuffer buf \u003d new StringBuffer(32);\n             buf.append(\u0027\u003c\u0027);\n             for (int i \u003d 0; i \u003c hosts.length; i++) {\n                 String h \u003d hosts[i];\n                 h \u003d h !\u003d null ? StringUtils.toLowerCase(h.trim()) : \"\";\n                 hosts[i] \u003d h;\n                 if (i \u003e 0) {\n                     buf.append(\u0027/\u0027);\n                 }\n                 buf.append(h);\n             }\n             buf.append(\u0027\u003e\u0027);\n             String hostnames \u003d buf.toString();\n             // Build the list of names we\u0027re going to check.  Our DEFAULT and\n             // STRICT implementations of the HostnameVerifier only use the\n             // first CN provided.  All other CNs are ignored.\n             // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n             final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n             if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                 names.add(cns[0]);\n                 if (ie6) {\n                     for (int i \u003d 1; i \u003c cns.length; i++) {\n                         names.add(cns[i]);\n                     }\n                 }\n             }\n             if (subjectAlts !\u003d null) {\n                 for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                     if (subjectAlts[i] !\u003d null) {\n                         names.add(subjectAlts[i]);\n                     }\n                 }\n             }\n             if (names.isEmpty()) {\n                 String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                 throw new SSLException(msg);\n             }\n \n             // StringBuffer for building the error message.\n             buf \u003d new StringBuffer();\n \n             boolean match \u003d false;\n             out:\n             for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                 // Don\u0027t trim the CN, though!\n                 final String cn \u003d StringUtils.toLowerCase(it.next());\n                 // Store CN in StringBuffer in case we need to report an error.\n                 buf.append(\" \u003c\");\n                 buf.append(cn);\n                 buf.append(\u0027\u003e\u0027);\n                 if (it.hasNext()) {\n                     buf.append(\" OR\");\n                 }\n \n                 // The CN better have at least two dots if it wants wildcard\n                 // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                 // [*.org.uk], etc...\n                 boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                      cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                      !isIP4Address(cn) \u0026\u0026\n                                      acceptableCountryWildcard(cn);\n \n                 for (int i \u003d 0; i \u003c hosts.length; i++) {\n                     final String hostName \u003d\n                         StringUtils.toLowerCase(hosts[i].trim());\n                     if (doWildcard) {\n                         match \u003d hostName.endsWith(cn.substring(1));\n                         if (match \u0026\u0026 strictWithSubDomains) {\n                             // If we\u0027re in strict mode, then [*.foo.com] is not\n                             // allowed to match [a.b.foo.com]\n                             match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                         }\n                     } else {\n                         match \u003d hostName.equals(cn);\n                     }\n                     if (match) {\n                         break out;\n                     }\n                 }\n             }\n             if (!match) {\n                 throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n             }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Hosts:{}, CNs:{} subjectAlts:{}, ie6:{}, \" +\n                    \"strictWithSubDomains{}\", Arrays.toString(hosts),\n                    Arrays.toString(cns), Arrays.toString(subjectAlts), ie6,\n                    strictWithSubDomains);\n            }\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? StringUtils.toLowerCase(h.trim()) : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                final String cn \u003d StringUtils.toLowerCase(it.next());\n                // Store CN in StringBuffer in case we need to report an error.\n                buf.append(\" \u003c\");\n                buf.append(cn);\n                buf.append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d\n                        StringUtils.toLowerCase(hosts[i].trim());\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
      "extendedDetails": {}
    },
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n         public void check(final String[] hosts, final String[] cns,\n                           final String[] subjectAlts, final boolean ie6,\n                           final boolean strictWithSubDomains)\n             throws SSLException {\n             // Build up lists of allowed hosts For logging/debugging purposes.\n             StringBuffer buf \u003d new StringBuffer(32);\n             buf.append(\u0027\u003c\u0027);\n             for (int i \u003d 0; i \u003c hosts.length; i++) {\n                 String h \u003d hosts[i];\n-                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n+                h \u003d h !\u003d null ? StringUtils.toLowerCase(h.trim()) : \"\";\n                 hosts[i] \u003d h;\n                 if (i \u003e 0) {\n                     buf.append(\u0027/\u0027);\n                 }\n                 buf.append(h);\n             }\n             buf.append(\u0027\u003e\u0027);\n             String hostnames \u003d buf.toString();\n             // Build the list of names we\u0027re going to check.  Our DEFAULT and\n             // STRICT implementations of the HostnameVerifier only use the\n             // first CN provided.  All other CNs are ignored.\n             // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n             final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n             if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                 names.add(cns[0]);\n                 if (ie6) {\n                     for (int i \u003d 1; i \u003c cns.length; i++) {\n                         names.add(cns[i]);\n                     }\n                 }\n             }\n             if (subjectAlts !\u003d null) {\n                 for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                     if (subjectAlts[i] !\u003d null) {\n                         names.add(subjectAlts[i]);\n                     }\n                 }\n             }\n             if (names.isEmpty()) {\n                 String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                 throw new SSLException(msg);\n             }\n \n             // StringBuffer for building the error message.\n             buf \u003d new StringBuffer();\n \n             boolean match \u003d false;\n             out:\n             for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                 // Don\u0027t trim the CN, though!\n-                final String cn \u003d it.next().toLowerCase();\n+                final String cn \u003d StringUtils.toLowerCase(it.next());\n                 // Store CN in StringBuffer in case we need to report an error.\n                 buf.append(\" \u003c\");\n                 buf.append(cn);\n                 buf.append(\u0027\u003e\u0027);\n                 if (it.hasNext()) {\n                     buf.append(\" OR\");\n                 }\n \n                 // The CN better have at least two dots if it wants wildcard\n                 // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                 // [*.org.uk], etc...\n                 boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                      cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                      !isIP4Address(cn) \u0026\u0026\n                                      acceptableCountryWildcard(cn);\n \n                 for (int i \u003d 0; i \u003c hosts.length; i++) {\n-                    final String hostName \u003d hosts[i].trim().toLowerCase();\n+                    final String hostName \u003d\n+                        StringUtils.toLowerCase(hosts[i].trim());\n                     if (doWildcard) {\n                         match \u003d hostName.endsWith(cn.substring(1));\n                         if (match \u0026\u0026 strictWithSubDomains) {\n                             // If we\u0027re in strict mode, then [*.foo.com] is not\n                             // allowed to match [a.b.foo.com]\n                             match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                         }\n                     } else {\n                         match \u003d hostName.equals(cn);\n                     }\n                     if (match) {\n                         break out;\n                     }\n                 }\n             }\n             if (!match) {\n                 throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n             }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? StringUtils.toLowerCase(h.trim()) : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                final String cn \u003d StringUtils.toLowerCase(it.next());\n                // Store CN in StringBuffer in case we need to report an error.\n                buf.append(\" \u003c\");\n                buf.append(cn);\n                buf.append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d\n                        StringUtils.toLowerCase(hosts[i].trim());\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,88 @@\n         public void check(final String[] hosts, final String[] cns,\n                           final String[] subjectAlts, final boolean ie6,\n                           final boolean strictWithSubDomains)\n             throws SSLException {\n             // Build up lists of allowed hosts For logging/debugging purposes.\n             StringBuffer buf \u003d new StringBuffer(32);\n             buf.append(\u0027\u003c\u0027);\n             for (int i \u003d 0; i \u003c hosts.length; i++) {\n                 String h \u003d hosts[i];\n-                h \u003d h !\u003d null ? h.trim().toLowerCase(Locale.ENGLISH) : \"\";\n+                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n                 hosts[i] \u003d h;\n                 if (i \u003e 0) {\n                     buf.append(\u0027/\u0027);\n                 }\n                 buf.append(h);\n             }\n             buf.append(\u0027\u003e\u0027);\n             String hostnames \u003d buf.toString();\n             // Build the list of names we\u0027re going to check.  Our DEFAULT and\n             // STRICT implementations of the HostnameVerifier only use the\n             // first CN provided.  All other CNs are ignored.\n             // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n             final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n             if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                 names.add(cns[0]);\n                 if (ie6) {\n                     for (int i \u003d 1; i \u003c cns.length; i++) {\n                         names.add(cns[i]);\n                     }\n                 }\n             }\n             if (subjectAlts !\u003d null) {\n                 for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                     if (subjectAlts[i] !\u003d null) {\n                         names.add(subjectAlts[i]);\n                     }\n                 }\n             }\n             if (names.isEmpty()) {\n                 String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                 throw new SSLException(msg);\n             }\n \n             // StringBuffer for building the error message.\n             buf \u003d new StringBuffer();\n \n             boolean match \u003d false;\n             out:\n             for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                 // Don\u0027t trim the CN, though!\n-                final String cn \u003d it.next().toLowerCase(Locale.ENGLISH);\n+                final String cn \u003d it.next().toLowerCase();\n                 // Store CN in StringBuffer in case we need to report an error.\n                 buf.append(\" \u003c\");\n                 buf.append(cn);\n                 buf.append(\u0027\u003e\u0027);\n                 if (it.hasNext()) {\n                     buf.append(\" OR\");\n                 }\n \n                 // The CN better have at least two dots if it wants wildcard\n                 // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                 // [*.org.uk], etc...\n                 boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                      cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                      !isIP4Address(cn) \u0026\u0026\n                                      acceptableCountryWildcard(cn);\n \n                 for (int i \u003d 0; i \u003c hosts.length; i++) {\n-                    final String hostName \u003d\n-                        hosts[i].trim().toLowerCase(Locale.ENGLISH);\n+                    final String hostName \u003d hosts[i].trim().toLowerCase();\n                     if (doWildcard) {\n                         match \u003d hostName.endsWith(cn.substring(1));\n                         if (match \u0026\u0026 strictWithSubDomains) {\n                             // If we\u0027re in strict mode, then [*.foo.com] is not\n                             // allowed to match [a.b.foo.com]\n                             match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                         }\n                     } else {\n                         match \u003d hostName.equals(cn);\n                     }\n                     if (match) {\n                         break out;\n                     }\n                 }\n             }\n             if (!match) {\n                 throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n             }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                final String cn \u003d it.next().toLowerCase();\n                // Store CN in StringBuffer in case we need to report an error.\n                buf.append(\" \u003c\");\n                buf.append(cn);\n                buf.append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d hosts[i].trim().toLowerCase();\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "28/03/14 11:15 AM",
      "commitNameOld": "640a72efbee17f6c7056650dae04f8b3f59ddaab",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 327.41,
      "commitsBetweenForRepo": 2601,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n         public void check(final String[] hosts, final String[] cns,\n                           final String[] subjectAlts, final boolean ie6,\n                           final boolean strictWithSubDomains)\n             throws SSLException {\n             // Build up lists of allowed hosts For logging/debugging purposes.\n             StringBuffer buf \u003d new StringBuffer(32);\n             buf.append(\u0027\u003c\u0027);\n             for (int i \u003d 0; i \u003c hosts.length; i++) {\n                 String h \u003d hosts[i];\n-                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n+                h \u003d h !\u003d null ? h.trim().toLowerCase(Locale.ENGLISH) : \"\";\n                 hosts[i] \u003d h;\n                 if (i \u003e 0) {\n                     buf.append(\u0027/\u0027);\n                 }\n                 buf.append(h);\n             }\n             buf.append(\u0027\u003e\u0027);\n             String hostnames \u003d buf.toString();\n             // Build the list of names we\u0027re going to check.  Our DEFAULT and\n             // STRICT implementations of the HostnameVerifier only use the\n             // first CN provided.  All other CNs are ignored.\n             // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n             final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n             if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                 names.add(cns[0]);\n                 if (ie6) {\n                     for (int i \u003d 1; i \u003c cns.length; i++) {\n                         names.add(cns[i]);\n                     }\n                 }\n             }\n             if (subjectAlts !\u003d null) {\n                 for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                     if (subjectAlts[i] !\u003d null) {\n                         names.add(subjectAlts[i]);\n                     }\n                 }\n             }\n             if (names.isEmpty()) {\n                 String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                 throw new SSLException(msg);\n             }\n \n             // StringBuffer for building the error message.\n             buf \u003d new StringBuffer();\n \n             boolean match \u003d false;\n             out:\n             for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                 // Don\u0027t trim the CN, though!\n-                final String cn \u003d it.next().toLowerCase();\n+                final String cn \u003d it.next().toLowerCase(Locale.ENGLISH);\n                 // Store CN in StringBuffer in case we need to report an error.\n                 buf.append(\" \u003c\");\n                 buf.append(cn);\n                 buf.append(\u0027\u003e\u0027);\n                 if (it.hasNext()) {\n                     buf.append(\" OR\");\n                 }\n \n                 // The CN better have at least two dots if it wants wildcard\n                 // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                 // [*.org.uk], etc...\n                 boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                      cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                      !isIP4Address(cn) \u0026\u0026\n                                      acceptableCountryWildcard(cn);\n \n                 for (int i \u003d 0; i \u003c hosts.length; i++) {\n-                    final String hostName \u003d hosts[i].trim().toLowerCase();\n+                    final String hostName \u003d\n+                        hosts[i].trim().toLowerCase(Locale.ENGLISH);\n                     if (doWildcard) {\n                         match \u003d hostName.endsWith(cn.substring(1));\n                         if (match \u0026\u0026 strictWithSubDomains) {\n                             // If we\u0027re in strict mode, then [*.foo.com] is not\n                             // allowed to match [a.b.foo.com]\n                             match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                         }\n                     } else {\n                         match \u003d hostName.equals(cn);\n                     }\n                     if (match) {\n                         break out;\n                     }\n                 }\n             }\n             if (!match) {\n                 throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n             }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? h.trim().toLowerCase(Locale.ENGLISH) : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                final String cn \u003d it.next().toLowerCase(Locale.ENGLISH);\n                // Store CN in StringBuffer in case we need to report an error.\n                buf.append(\" \u003c\");\n                buf.append(cn);\n                buf.append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d\n                        hosts[i].trim().toLowerCase(Locale.ENGLISH);\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
      "extendedDetails": {}
    },
    "640a72efbee17f6c7056650dae04f8b3f59ddaab": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10449. Fix the javac warnings in the security package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1582851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/03/14 11:15 AM",
      "commitName": "640a72efbee17f6c7056650dae04f8b3f59ddaab",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 580.72,
      "commitsBetweenForRepo": 3631,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,88 @@\n         public void check(final String[] hosts, final String[] cns,\n                           final String[] subjectAlts, final boolean ie6,\n                           final boolean strictWithSubDomains)\n             throws SSLException {\n             // Build up lists of allowed hosts For logging/debugging purposes.\n             StringBuffer buf \u003d new StringBuffer(32);\n             buf.append(\u0027\u003c\u0027);\n             for (int i \u003d 0; i \u003c hosts.length; i++) {\n                 String h \u003d hosts[i];\n                 h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n                 hosts[i] \u003d h;\n                 if (i \u003e 0) {\n                     buf.append(\u0027/\u0027);\n                 }\n                 buf.append(h);\n             }\n             buf.append(\u0027\u003e\u0027);\n             String hostnames \u003d buf.toString();\n             // Build the list of names we\u0027re going to check.  Our DEFAULT and\n             // STRICT implementations of the HostnameVerifier only use the\n             // first CN provided.  All other CNs are ignored.\n             // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n-            TreeSet names \u003d new TreeSet();\n+            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n             if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                 names.add(cns[0]);\n                 if (ie6) {\n                     for (int i \u003d 1; i \u003c cns.length; i++) {\n                         names.add(cns[i]);\n                     }\n                 }\n             }\n             if (subjectAlts !\u003d null) {\n                 for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                     if (subjectAlts[i] !\u003d null) {\n                         names.add(subjectAlts[i]);\n                     }\n                 }\n             }\n             if (names.isEmpty()) {\n                 String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                 throw new SSLException(msg);\n             }\n \n             // StringBuffer for building the error message.\n             buf \u003d new StringBuffer();\n \n             boolean match \u003d false;\n             out:\n-            for (Iterator it \u003d names.iterator(); it.hasNext();) {\n+            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                 // Don\u0027t trim the CN, though!\n-                String cn \u003d (String) it.next();\n-                cn \u003d cn.toLowerCase();\n+                final String cn \u003d it.next().toLowerCase();\n                 // Store CN in StringBuffer in case we need to report an error.\n                 buf.append(\" \u003c\");\n                 buf.append(cn);\n                 buf.append(\u0027\u003e\u0027);\n                 if (it.hasNext()) {\n                     buf.append(\" OR\");\n                 }\n \n                 // The CN better have at least two dots if it wants wildcard\n                 // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                 // [*.org.uk], etc...\n                 boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                      cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                      !isIP4Address(cn) \u0026\u0026\n                                      acceptableCountryWildcard(cn);\n \n                 for (int i \u003d 0; i \u003c hosts.length; i++) {\n                     final String hostName \u003d hosts[i].trim().toLowerCase();\n                     if (doWildcard) {\n                         match \u003d hostName.endsWith(cn.substring(1));\n                         if (match \u0026\u0026 strictWithSubDomains) {\n                             // If we\u0027re in strict mode, then [*.foo.com] is not\n                             // allowed to match [a.b.foo.com]\n                             match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                         }\n                     } else {\n                         match \u003d hostName.equals(cn);\n                     }\n                     if (match) {\n                         break out;\n                     }\n                 }\n             }\n             if (!match) {\n                 throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n             }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            final Set\u003cString\u003e names \u003d new TreeSet\u003cString\u003e();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator\u003cString\u003e it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                final String cn \u003d it.next().toLowerCase();\n                // Store CN in StringBuffer in case we need to report an error.\n                buf.append(\" \u003c\");\n                buf.append(cn);\n                buf.append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d hosts[i].trim().toLowerCase();\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java",
      "extendedDetails": {}
    },
    "9d16c9354b0c05edb30d23003dcdec4cc44ed925": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-4417. add support for encrypted shuffle (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1365979 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/12 6:23 AM",
      "commitName": "9d16c9354b0c05edb30d23003dcdec4cc44ed925",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,89 @@\n+        public void check(final String[] hosts, final String[] cns,\n+                          final String[] subjectAlts, final boolean ie6,\n+                          final boolean strictWithSubDomains)\n+            throws SSLException {\n+            // Build up lists of allowed hosts For logging/debugging purposes.\n+            StringBuffer buf \u003d new StringBuffer(32);\n+            buf.append(\u0027\u003c\u0027);\n+            for (int i \u003d 0; i \u003c hosts.length; i++) {\n+                String h \u003d hosts[i];\n+                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n+                hosts[i] \u003d h;\n+                if (i \u003e 0) {\n+                    buf.append(\u0027/\u0027);\n+                }\n+                buf.append(h);\n+            }\n+            buf.append(\u0027\u003e\u0027);\n+            String hostnames \u003d buf.toString();\n+            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n+            // STRICT implementations of the HostnameVerifier only use the\n+            // first CN provided.  All other CNs are ignored.\n+            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n+            TreeSet names \u003d new TreeSet();\n+            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n+                names.add(cns[0]);\n+                if (ie6) {\n+                    for (int i \u003d 1; i \u003c cns.length; i++) {\n+                        names.add(cns[i]);\n+                    }\n+                }\n+            }\n+            if (subjectAlts !\u003d null) {\n+                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n+                    if (subjectAlts[i] !\u003d null) {\n+                        names.add(subjectAlts[i]);\n+                    }\n+                }\n+            }\n+            if (names.isEmpty()) {\n+                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n+                throw new SSLException(msg);\n+            }\n+\n+            // StringBuffer for building the error message.\n+            buf \u003d new StringBuffer();\n+\n+            boolean match \u003d false;\n+            out:\n+            for (Iterator it \u003d names.iterator(); it.hasNext();) {\n+                // Don\u0027t trim the CN, though!\n+                String cn \u003d (String) it.next();\n+                cn \u003d cn.toLowerCase();\n+                // Store CN in StringBuffer in case we need to report an error.\n+                buf.append(\" \u003c\");\n+                buf.append(cn);\n+                buf.append(\u0027\u003e\u0027);\n+                if (it.hasNext()) {\n+                    buf.append(\" OR\");\n+                }\n+\n+                // The CN better have at least two dots if it wants wildcard\n+                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n+                // [*.org.uk], etc...\n+                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n+                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n+                                     !isIP4Address(cn) \u0026\u0026\n+                                     acceptableCountryWildcard(cn);\n+\n+                for (int i \u003d 0; i \u003c hosts.length; i++) {\n+                    final String hostName \u003d hosts[i].trim().toLowerCase();\n+                    if (doWildcard) {\n+                        match \u003d hostName.endsWith(cn.substring(1));\n+                        if (match \u0026\u0026 strictWithSubDomains) {\n+                            // If we\u0027re in strict mode, then [*.foo.com] is not\n+                            // allowed to match [a.b.foo.com]\n+                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n+                        }\n+                    } else {\n+                        match \u003d hostName.equals(cn);\n+                    }\n+                    if (match) {\n+                        break out;\n+                    }\n+                }\n+            }\n+            if (!match) {\n+                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n+            }\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        public void check(final String[] hosts, final String[] cns,\n                          final String[] subjectAlts, final boolean ie6,\n                          final boolean strictWithSubDomains)\n            throws SSLException {\n            // Build up lists of allowed hosts For logging/debugging purposes.\n            StringBuffer buf \u003d new StringBuffer(32);\n            buf.append(\u0027\u003c\u0027);\n            for (int i \u003d 0; i \u003c hosts.length; i++) {\n                String h \u003d hosts[i];\n                h \u003d h !\u003d null ? h.trim().toLowerCase() : \"\";\n                hosts[i] \u003d h;\n                if (i \u003e 0) {\n                    buf.append(\u0027/\u0027);\n                }\n                buf.append(h);\n            }\n            buf.append(\u0027\u003e\u0027);\n            String hostnames \u003d buf.toString();\n            // Build the list of names we\u0027re going to check.  Our DEFAULT and\n            // STRICT implementations of the HostnameVerifier only use the\n            // first CN provided.  All other CNs are ignored.\n            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n            TreeSet names \u003d new TreeSet();\n            if (cns !\u003d null \u0026\u0026 cns.length \u003e 0 \u0026\u0026 cns[0] !\u003d null) {\n                names.add(cns[0]);\n                if (ie6) {\n                    for (int i \u003d 1; i \u003c cns.length; i++) {\n                        names.add(cns[i]);\n                    }\n                }\n            }\n            if (subjectAlts !\u003d null) {\n                for (int i \u003d 0; i \u003c subjectAlts.length; i++) {\n                    if (subjectAlts[i] !\u003d null) {\n                        names.add(subjectAlts[i]);\n                    }\n                }\n            }\n            if (names.isEmpty()) {\n                String msg \u003d \"Certificate for \" + hosts[0] + \" doesn\u0027t contain CN or DNS subjectAlt\";\n                throw new SSLException(msg);\n            }\n\n            // StringBuffer for building the error message.\n            buf \u003d new StringBuffer();\n\n            boolean match \u003d false;\n            out:\n            for (Iterator it \u003d names.iterator(); it.hasNext();) {\n                // Don\u0027t trim the CN, though!\n                String cn \u003d (String) it.next();\n                cn \u003d cn.toLowerCase();\n                // Store CN in StringBuffer in case we need to report an error.\n                buf.append(\" \u003c\");\n                buf.append(cn);\n                buf.append(\u0027\u003e\u0027);\n                if (it.hasNext()) {\n                    buf.append(\" OR\");\n                }\n\n                // The CN better have at least two dots if it wants wildcard\n                // action.  It also can\u0027t be [*.co.uk] or [*.co.jp] or\n                // [*.org.uk], etc...\n                boolean doWildcard \u003d cn.startsWith(\"*.\") \u0026\u0026\n                                     cn.lastIndexOf(\u0027.\u0027) \u003e\u003d 0 \u0026\u0026\n                                     !isIP4Address(cn) \u0026\u0026\n                                     acceptableCountryWildcard(cn);\n\n                for (int i \u003d 0; i \u003c hosts.length; i++) {\n                    final String hostName \u003d hosts[i].trim().toLowerCase();\n                    if (doWildcard) {\n                        match \u003d hostName.endsWith(cn.substring(1));\n                        if (match \u0026\u0026 strictWithSubDomains) {\n                            // If we\u0027re in strict mode, then [*.foo.com] is not\n                            // allowed to match [a.b.foo.com]\n                            match \u003d countDots(hostName) \u003d\u003d countDots(cn);\n                        }\n                    } else {\n                        match \u003d hostName.equals(cn);\n                    }\n                    if (match) {\n                        break out;\n                    }\n                }\n            }\n            if (!match) {\n                throw new SSLException(\"hostname in certificate didn\u0027t match: \" + hostnames + \" !\u003d\" + buf);\n            }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/SSLHostnameVerifier.java"
    }
  }
}