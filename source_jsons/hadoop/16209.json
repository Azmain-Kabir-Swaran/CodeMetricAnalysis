{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterRpcClient.java",
  "functionName": "invokeConcurrent",
  "functionId": "invokeConcurrent___locations-Collection__T__(modifiers-final)__method-RemoteMethod(modifiers-final)__requireResponse-boolean__standby-boolean__timeOutMs-long__clazz-Class__R__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
  "functionStartLine": 1152,
  "functionEndLine": 1191,
  "numCommitsSeen": 34,
  "timeTaken": 7820,
  "changeHistory": [
    "3df0adaaea485bcbd4ae1a04fe160f3148c14437",
    "203664e6b258b642239651fa6a17fd2561b903d2",
    "6c42d4050461ab71c88f123569649793dc53aebd",
    "50aee18a84fcbca38be4272cfa0d33aadafe076d",
    "912b90f91e11a183e47d9271dec089e25f159dee",
    "235406d9047af2039090ad48fc708368046df008",
    "01ff8178148790f7b0112058cf08d23d031b6868",
    "37269261d1232bc71708f30c76193188258ef4bd",
    "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1",
    "e87be8a2a49573897e40bfdf43541e3635e35c98",
    "a92200f4a6cec57b7080d1cd6e2a20d79d772dd6",
    "2be64eb201134502a92f7239bef8aa780771ca0b",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
    "81601dac8ec7650bec14700b174910390a92fe1f"
  ],
  "changeHistoryShort": {
    "3df0adaaea485bcbd4ae1a04fe160f3148c14437": "Ybodychange",
    "203664e6b258b642239651fa6a17fd2561b903d2": "Ybodychange",
    "6c42d4050461ab71c88f123569649793dc53aebd": "Ybodychange",
    "50aee18a84fcbca38be4272cfa0d33aadafe076d": "Ybodychange",
    "912b90f91e11a183e47d9271dec089e25f159dee": "Ybodychange",
    "235406d9047af2039090ad48fc708368046df008": "Ybodychange",
    "01ff8178148790f7b0112058cf08d23d031b6868": "Ybodychange",
    "37269261d1232bc71708f30c76193188258ef4bd": "Ybodychange",
    "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1": "Ybodychange",
    "e87be8a2a49573897e40bfdf43541e3635e35c98": "Ybodychange",
    "a92200f4a6cec57b7080d1cd6e2a20d79d772dd6": "Ybodychange",
    "2be64eb201134502a92f7239bef8aa780771ca0b": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "81601dac8ec7650bec14700b174910390a92fe1f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3df0adaaea485bcbd4ae1a04fe160f3148c14437": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15127. RBF: Do not allow writes when a subcluster is unavailable for HASH_ALL mount points. Contributed by Inigo Goiri\n",
      "commitDate": "12/02/20 6:11 AM",
      "commitName": "3df0adaaea485bcbd4ae1a04fe160f3148c14437",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "16/01/20 10:39 AM",
      "commitNameOld": "263413e83840c7795a988e3939cd292d020c8d5f",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 26.81,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,40 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n     final List\u003cRemoteResult\u003cT, R\u003e\u003e results \u003d invokeConcurrent(\n         locations, method, standby, timeOutMs, clazz);\n \n+    // Go over the results and exceptions\n     final Map\u003cT, R\u003e ret \u003d new TreeMap\u003c\u003e();\n+    final List\u003cIOException\u003e thrownExceptions \u003d new ArrayList\u003c\u003e();\n+    IOException firstUnavailableException \u003d null;\n     for (final RemoteResult\u003cT, R\u003e result : results) {\n-      // Response from all servers required, use this error.\n-      if (requireResponse \u0026\u0026 result.hasException()) {\n-        throw result.getException();\n+      if (result.hasException()) {\n+        IOException ioe \u003d result.getException();\n+        thrownExceptions.add(ioe);\n+        // Track unavailable exceptions to throw them first\n+        if (isUnavailableException(ioe)) {\n+          firstUnavailableException \u003d ioe;\n+        }\n       }\n       if (result.hasResult()) {\n         ret.put(result.getLocation(), result.getResult());\n       }\n     }\n \n-    // Throw the exception for the first location if there are no results\n-    if (ret.isEmpty()) {\n-      final RemoteResult\u003cT, R\u003e result \u003d results.get(0);\n-      if (result.hasException()) {\n-        throw result.getException();\n+    // Throw exceptions if needed\n+    if (!thrownExceptions.isEmpty()) {\n+      // Throw if response from all servers required or no results\n+      if (requireResponse || ret.isEmpty()) {\n+        // Throw unavailable exceptions first\n+        if (firstUnavailableException !\u003d null) {\n+          throw firstUnavailableException;\n+        } else {\n+          throw thrownExceptions.get(0);\n+        }\n       }\n     }\n \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n    final List\u003cRemoteResult\u003cT, R\u003e\u003e results \u003d invokeConcurrent(\n        locations, method, standby, timeOutMs, clazz);\n\n    // Go over the results and exceptions\n    final Map\u003cT, R\u003e ret \u003d new TreeMap\u003c\u003e();\n    final List\u003cIOException\u003e thrownExceptions \u003d new ArrayList\u003c\u003e();\n    IOException firstUnavailableException \u003d null;\n    for (final RemoteResult\u003cT, R\u003e result : results) {\n      if (result.hasException()) {\n        IOException ioe \u003d result.getException();\n        thrownExceptions.add(ioe);\n        // Track unavailable exceptions to throw them first\n        if (isUnavailableException(ioe)) {\n          firstUnavailableException \u003d ioe;\n        }\n      }\n      if (result.hasResult()) {\n        ret.put(result.getLocation(), result.getResult());\n      }\n    }\n\n    // Throw exceptions if needed\n    if (!thrownExceptions.isEmpty()) {\n      // Throw if response from all servers required or no results\n      if (requireResponse || ret.isEmpty()) {\n        // Throw unavailable exceptions first\n        if (firstUnavailableException !\u003d null) {\n          throw firstUnavailableException;\n        } else {\n          throw thrownExceptions.get(0);\n        }\n      }\n    }\n\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "203664e6b258b642239651fa6a17fd2561b903d2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14454. RBF: getContentSummary() should allow non-existing folders. Contributed by Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "203664e6b258b642239651fa6a17fd2561b903d2",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "6c42d4050461ab71c88f123569649793dc53aebd",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,28 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n+    final List\u003cRemoteResult\u003cT, R\u003e\u003e results \u003d invokeConcurrent(\n+        locations, method, standby, timeOutMs, clazz);\n \n-    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n-    final Method m \u003d method.getMethod();\n-\n-    if (locations.isEmpty()) {\n-      throw new IOException(\"No remote locations available\");\n-    } else if (locations.size() \u003d\u003d 1 \u0026\u0026 timeOutMs \u003c\u003d 0) {\n-      // Shortcut, just one call\n-      T location \u003d locations.iterator().next();\n-      String ns \u003d location.getNameserviceId();\n-      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n-          getNamenodesForNameservice(ns);\n-      try {\n-        Class\u003c?\u003e proto \u003d method.getProtocol();\n-        Object[] paramList \u003d method.getParams(location);\n-        Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n-        return Collections.singletonMap(location, (R) result);\n-      } catch (IOException ioe) {\n-        // Localize the exception\n-        throw processException(ioe, location);\n+    final Map\u003cT, R\u003e ret \u003d new TreeMap\u003c\u003e();\n+    for (final RemoteResult\u003cT, R\u003e result : results) {\n+      // Response from all servers required, use this error.\n+      if (requireResponse \u0026\u0026 result.hasException()) {\n+        throw result.getException();\n+      }\n+      if (result.hasResult()) {\n+        ret.put(result.getLocation(), result.getResult());\n       }\n     }\n \n-    List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n-    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n-    for (final T location : locations) {\n-      String nsId \u003d location.getNameserviceId();\n-      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n-          getNamenodesForNameservice(nsId);\n-      final Class\u003c?\u003e proto \u003d method.getProtocol();\n-      final Object[] paramList \u003d method.getParams(location);\n-      if (standby) {\n-        // Call the objectGetter to all NNs (including standby)\n-        for (final FederationNamenodeContext nn : namenodes) {\n-          String nnId \u003d nn.getNamenodeId();\n-          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n-              Collections.singletonList(nn);\n-          T nnLocation \u003d location;\n-          if (location instanceof RemoteLocation) {\n-            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n-          }\n-          orderedLocations.add(nnLocation);\n-          callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n-        }\n-      } else {\n-        // Call the objectGetter in order of nameservices in the NS list\n-        orderedLocations.add(location);\n-        callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n+    // Throw the exception for the first location if there are no results\n+    if (ret.isEmpty()) {\n+      final RemoteResult\u003cT, R\u003e result \u003d results.get(0);\n+      if (result.hasException()) {\n+        throw result.getException();\n       }\n     }\n \n-    if (rpcMonitor !\u003d null) {\n-      rpcMonitor.proxyOp();\n-    }\n-\n-    try {\n-      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n-      if (timeOutMs \u003e 0) {\n-        futures \u003d executorService.invokeAll(\n-            callables, timeOutMs, TimeUnit.MILLISECONDS);\n-      } else {\n-        futures \u003d executorService.invokeAll(callables);\n-      }\n-      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n-      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n-      for (int i\u003d0; i\u003cfutures.size(); i++) {\n-        T location \u003d orderedLocations.get(i);\n-        try {\n-          Future\u003cObject\u003e future \u003d futures.get(i);\n-          Object result \u003d future.get();\n-          results.put(location, (R) result);\n-        } catch (CancellationException ce) {\n-          T loc \u003d orderedLocations.get(i);\n-          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n-              + method.getMethodName() + \"\\\" timed out\";\n-          LOG.error(msg);\n-          IOException ioe \u003d new SubClusterTimeoutException(msg);\n-          exceptions.put(location, ioe);\n-        } catch (ExecutionException ex) {\n-          Throwable cause \u003d ex.getCause();\n-          LOG.debug(\"Canot execute {} in {}: {}\",\n-              m.getName(), location, cause.getMessage());\n-\n-          // Convert into IOException if needed\n-          IOException ioe \u003d null;\n-          if (cause instanceof IOException) {\n-            ioe \u003d (IOException) cause;\n-          } else {\n-            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n-                m.getName() + \": \" + cause.getMessage(), cause);\n-          }\n-\n-          // Response from all servers required, use this error.\n-          if (requireResponse) {\n-            throw ioe;\n-          }\n-\n-          // Store the exceptions\n-          exceptions.put(location, ioe);\n-        }\n-      }\n-\n-      // Throw the exception for the first location if there are no results\n-      if (results.isEmpty()) {\n-        T location \u003d orderedLocations.get(0);\n-        IOException ioe \u003d exceptions.get(location);\n-        if (ioe !\u003d null) {\n-          throw ioe;\n-        }\n-      }\n-\n-      return results;\n-    } catch (RejectedExecutionException e) {\n-      if (rpcMonitor !\u003d null) {\n-        rpcMonitor.proxyOpFailureClientOverloaded();\n-      }\n-      int active \u003d executorService.getActiveCount();\n-      int total \u003d executorService.getMaximumPoolSize();\n-      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n-      LOG.error(msg);\n-      throw new StandbyException(\n-          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n-    } catch (InterruptedException ex) {\n-      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n-      throw new IOException(\n-          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n-    }\n+    return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n    final List\u003cRemoteResult\u003cT, R\u003e\u003e results \u003d invokeConcurrent(\n        locations, method, standby, timeOutMs, clazz);\n\n    final Map\u003cT, R\u003e ret \u003d new TreeMap\u003c\u003e();\n    for (final RemoteResult\u003cT, R\u003e result : results) {\n      // Response from all servers required, use this error.\n      if (requireResponse \u0026\u0026 result.hasException()) {\n        throw result.getException();\n      }\n      if (result.hasResult()) {\n        ret.put(result.getLocation(), result.getResult());\n      }\n    }\n\n    // Throw the exception for the first location if there are no results\n    if (ret.isEmpty()) {\n      final RemoteResult\u003cT, R\u003e result \u003d results.get(0);\n      if (result.hasException()) {\n        throw result.getException();\n      }\n    }\n\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "6c42d4050461ab71c88f123569649793dc53aebd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14316. RBF: Support unavailable subclusters for mount points with multiple destinations. Contributed by Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "6c42d4050461ab71c88f123569649793dc53aebd",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "50aee18a84fcbca38be4272cfa0d33aadafe076d",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,132 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n-    } else if (locations.size() \u003d\u003d 1) {\n+    } else if (locations.size() \u003d\u003d 1 \u0026\u0026 timeOutMs \u003c\u003d 0) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       try {\n         Class\u003c?\u003e proto \u003d method.getProtocol();\n         Object[] paramList \u003d method.getParams(location);\n         Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n         return Collections.singletonMap(location, (R) result);\n       } catch (IOException ioe) {\n         // Localize the exception\n         throw processException(ioe, location);\n       }\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n     List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, (R) result);\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n               + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (RejectedExecutionException e) {\n       if (rpcMonitor !\u003d null) {\n         rpcMonitor.proxyOpFailureClientOverloaded();\n       }\n       int active \u003d executorService.getActiveCount();\n       int total \u003d executorService.getMaximumPoolSize();\n       String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n       LOG.error(msg);\n       throw new StandbyException(\n           \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1 \u0026\u0026 timeOutMs \u003c\u003d 0) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      try {\n        Class\u003c?\u003e proto \u003d method.getProtocol();\n        Object[] paramList \u003d method.getParams(location);\n        Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n        return Collections.singletonMap(location, (R) result);\n      } catch (IOException ioe) {\n        // Localize the exception\n        throw processException(ioe, location);\n      }\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, (R) result);\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "50aee18a84fcbca38be4272cfa0d33aadafe076d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14268. RBF: Fix the location of the DNs in getDatanodeReport(). Contributed by Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "50aee18a84fcbca38be4272cfa0d33aadafe076d",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "7e63e37dc5cbe330082a6a42598ffb76e0770fc1",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,132 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       try {\n         Class\u003c?\u003e proto \u003d method.getProtocol();\n         Object[] paramList \u003d method.getParams(location);\n         Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n         return Collections.singletonMap(location, (R) result);\n       } catch (IOException ioe) {\n         // Localize the exception\n         throw processException(ioe, location);\n       }\n     }\n \n-    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n-    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n+    List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n+    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n-          callables.add(new Callable\u003cObject\u003e() {\n-            public Object call() throws Exception {\n-              return invokeMethod(ugi, nnList, proto, m, paramList);\n-            }\n-          });\n+          callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n-        callables.add(new Callable\u003cObject\u003e() {\n-          public Object call() throws Exception {\n-            return invokeMethod(ugi, namenodes, proto, m, paramList);\n-          }\n-        });\n+        callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, (R) result);\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n               + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (RejectedExecutionException e) {\n       if (rpcMonitor !\u003d null) {\n         rpcMonitor.proxyOpFailureClientOverloaded();\n       }\n       int active \u003d executorService.getActiveCount();\n       int total \u003d executorService.getMaximumPoolSize();\n       String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n       LOG.error(msg);\n       throw new StandbyException(\n           \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      try {\n        Class\u003c?\u003e proto \u003d method.getProtocol();\n        Object[] paramList \u003d method.getParams(location);\n        Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n        return Collections.singletonMap(location, (R) result);\n      } catch (IOException ioe) {\n        // Localize the exception\n        throw processException(ioe, location);\n      }\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, (R) result);\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "912b90f91e11a183e47d9271dec089e25f159dee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14252. RBF : Exceptions are exposing the actual sub cluster path. Contributed by Ayush Saxena.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "912b90f91e11a183e47d9271dec089e25f159dee",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "235406d9047af2039090ad48fc708368046df008",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,140 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n-      Class\u003c?\u003e proto \u003d method.getProtocol();\n-      Object[] paramList \u003d method.getParams(location);\n-      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n-      return Collections.singletonMap(location, (R) result);\n+      try {\n+        Class\u003c?\u003e proto \u003d method.getProtocol();\n+        Object[] paramList \u003d method.getParams(location);\n+        Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n+        return Collections.singletonMap(location, (R) result);\n+      } catch (IOException ioe) {\n+        // Localize the exception\n+        throw processException(ioe, location);\n+      }\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, (R) result);\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n               + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (RejectedExecutionException e) {\n       if (rpcMonitor !\u003d null) {\n         rpcMonitor.proxyOpFailureClientOverloaded();\n       }\n       int active \u003d executorService.getActiveCount();\n       int total \u003d executorService.getMaximumPoolSize();\n       String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n       LOG.error(msg);\n       throw new StandbyException(\n           \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      try {\n        Class\u003c?\u003e proto \u003d method.getProtocol();\n        Object[] paramList \u003d method.getParams(location);\n        Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n        return Collections.singletonMap(location, (R) result);\n      } catch (IOException ioe) {\n        // Localize the exception\n        throw processException(ioe, location);\n      }\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, (R) result);\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "235406d9047af2039090ad48fc708368046df008": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14156. RBF: rollEdit() command fails with Router. Contributed by Shubham Dewan.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "235406d9047af2039090ad48fc708368046df008",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "f3cbf0eb9ace860cb2da77b09042e2056ef9255f",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n-      return Collections.singletonMap(location, clazz.cast(result));\n+      return Collections.singletonMap(location, (R) result);\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n-          results.put(location, clazz.cast(result));\n+          results.put(location, (R) result);\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n               + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (RejectedExecutionException e) {\n       if (rpcMonitor !\u003d null) {\n         rpcMonitor.proxyOpFailureClientOverloaded();\n       }\n       int active \u003d executorService.getActiveCount();\n       int total \u003d executorService.getMaximumPoolSize();\n       String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n       LOG.error(msg);\n       throw new StandbyException(\n           \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, (R) result);\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, (R) result);\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "01ff8178148790f7b0112058cf08d23d031b6868": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13750. RBF: Router ID in RouterRpcClient is always null. Contributed by Takanobu Asanuma.\n",
      "commitDate": "20/08/18 8:01 AM",
      "commitName": "01ff8178148790f7b0112058cf08d23d031b6868",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "01/05/18 11:49 PM",
      "commitNameOld": "37269261d1232bc71708f30c76193188258ef4bd",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 110.34,
      "commitsBetweenForRepo": 835,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n       return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n               + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (RejectedExecutionException e) {\n       if (rpcMonitor !\u003d null) {\n         rpcMonitor.proxyOpFailureClientOverloaded();\n       }\n       int active \u003d executorService.getActiveCount();\n       int total \u003d executorService.getMaximumPoolSize();\n       String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n       LOG.error(msg);\n       throw new StandbyException(\n-          \"Router \" + routerId + \" is overloaded: \" + msg);\n+          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "37269261d1232bc71708f30c76193188258ef4bd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13488. RBF: Reject requests when a Router is overloaded. Contributed by Inigo Goiri.\n",
      "commitDate": "01/05/18 11:49 PM",
      "commitName": "37269261d1232bc71708f30c76193188258ef4bd",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "16/04/18 8:23 PM",
      "commitNameOld": "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 15.14,
      "commitsBetweenForRepo": 608,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,135 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n       return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n               + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n+    } catch (RejectedExecutionException e) {\n+      if (rpcMonitor !\u003d null) {\n+        rpcMonitor.proxyOpFailureClientOverloaded();\n+      }\n+      int active \u003d executorService.getActiveCount();\n+      int total \u003d executorService.getMaximumPoolSize();\n+      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n+      LOG.error(msg);\n+      throw new StandbyException(\n+          \"Router \" + routerId + \" is overloaded: \" + msg);\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + routerId + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13435. RBF: Improve the error loggings for printing the stack trace.\n",
      "commitDate": "16/04/18 8:23 PM",
      "commitName": "c4d3636c21acaeb2b7d56d19cd4996aa25151bd1",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "11/04/18 8:37 AM",
      "commitNameOld": "0c93d43f3d624a4fd17b3b050443d9e7e20d4f0a",
      "commitAuthorOld": "Wei Yan",
      "daysBetweenCommits": 5.49,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n       return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n-          String msg \u003d\n-              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n+          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n+              + method.getMethodName() + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "e87be8a2a49573897e40bfdf43541e3635e35c98": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13384. RBF: Improve timeout RPC call mechanism. Contributed by Inigo Goiri.\n",
      "commitDate": "10/04/18 12:34 AM",
      "commitName": "e87be8a2a49573897e40bfdf43541e3635e35c98",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "09/04/18 11:29 PM",
      "commitNameOld": "a92200f4a6cec57b7080d1cd6e2a20d79d772dd6",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.isEmpty()) {\n       throw new IOException(\"No remote locations available\");\n     } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n       return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d\n               \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n           LOG.error(msg);\n-          IOException ioe \u003d new IOException(msg);\n+          IOException ioe \u003d new SubClusterTimeoutException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "a92200f4a6cec57b7080d1cd6e2a20d79d772dd6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13410. RBF: Support federation with no subclusters. Contributed by Inigo Goiri.\n",
      "commitDate": "09/04/18 11:29 PM",
      "commitName": "a92200f4a6cec57b7080d1cd6e2a20d79d772dd6",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "03/04/18 12:08 AM",
      "commitNameOld": "2be64eb201134502a92f7239bef8aa780771ca0b",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 6.97,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,125 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n-    if (locations.size() \u003d\u003d 1) {\n+    if (locations.isEmpty()) {\n+      throw new IOException(\"No remote locations available\");\n+    } else if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n       return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d\n               \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new IOException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "2be64eb201134502a92f7239bef8aa780771ca0b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13364. RBF: Support NamenodeProtocol in the Router. Contributed by Inigo Goiri.\n",
      "commitDate": "03/04/18 12:08 AM",
      "commitName": "2be64eb201134502a92f7239bef8aa780771ca0b",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "20/03/18 8:32 PM",
      "commitNameOld": "2caba999bbb9d6e3ec56024a0a9d3d56a229edcf",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 13.15,
      "commitsBetweenForRepo": 209,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,123 @@\n   public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n       boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n+      Class\u003c?\u003e proto \u003d method.getProtocol();\n       Object[] paramList \u003d method.getParams(location);\n-      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n+      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n       return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n+      final Class\u003c?\u003e proto \u003d method.getProtocol();\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n-              return invokeMethod(ugi, nnList, m, paramList);\n+              return invokeMethod(ugi, nnList, proto, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n-            return invokeMethod(ugi, namenodes, m, paramList);\n+            return invokeMethod(ugi, namenodes, proto, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n       Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d\n               \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new IOException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Class\u003c?\u003e proto \u003d method.getProtocol();\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, proto, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, proto, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, proto, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java"
      }
    },
    "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
      "commitDate": "12/01/18 4:25 PM",
      "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
          "commitDate": "12/01/18 4:25 PM",
          "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "29/11/17 9:43 AM",
          "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
          "commitAuthorOld": "Wei Yan",
          "daysBetweenCommits": 44.28,
          "commitsBetweenForRepo": 258,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,121 @@\n-  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n-      boolean requireResponse, boolean standby, long timeOutMs)\n+      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n-      return Collections.singletonMap(location, result);\n+      return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n-      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n+      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n-          results.put(location, result);\n+          results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d\n               \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new IOException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
          "extendedDetails": {
            "oldValue": "[locations-Collection\u003cT\u003e(modifiers-final), method-RemoteMethod(modifiers-final), requireResponse-boolean, standby-boolean, timeOutMs-long]",
            "newValue": "[locations-Collection\u003cT\u003e(modifiers-final), method-RemoteMethod(modifiers-final), requireResponse-boolean, standby-boolean, timeOutMs-long, clazz-Class\u003cR\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
          "commitDate": "12/01/18 4:25 PM",
          "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "29/11/17 9:43 AM",
          "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
          "commitAuthorOld": "Wei Yan",
          "daysBetweenCommits": 44.28,
          "commitsBetweenForRepo": 258,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,121 @@\n-  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n-      boolean requireResponse, boolean standby, long timeOutMs)\n+      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n-      return Collections.singletonMap(location, result);\n+      return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n-      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n+      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n-          results.put(location, result);\n+          results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d\n               \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new IOException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
          "extendedDetails": {
            "oldValue": "Map\u003cT,Object\u003e",
            "newValue": "Map\u003cT,R\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.\n",
          "commitDate": "12/01/18 4:25 PM",
          "commitName": "d5d6a0353bb85b882cc4ef60e3a12d63243d34ba",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "29/11/17 9:43 AM",
          "commitNameOld": "301641811d93ac22dc6fe1a05f18c1f266cc5e54",
          "commitAuthorOld": "Wei Yan",
          "daysBetweenCommits": 44.28,
          "commitsBetweenForRepo": 258,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,121 @@\n-  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n       final Collection\u003cT\u003e locations, final RemoteMethod method,\n-      boolean requireResponse, boolean standby, long timeOutMs)\n+      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n           throws IOException {\n \n     final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n     final Method m \u003d method.getMethod();\n \n     if (locations.size() \u003d\u003d 1) {\n       // Shortcut, just one call\n       T location \u003d locations.iterator().next();\n       String ns \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(ns);\n       Object[] paramList \u003d method.getParams(location);\n       Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n-      return Collections.singletonMap(location, result);\n+      return Collections.singletonMap(location, clazz.cast(result));\n     }\n \n     List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n     Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n     for (final T location : locations) {\n       String nsId \u003d location.getNameserviceId();\n       final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n           getNamenodesForNameservice(nsId);\n       final Object[] paramList \u003d method.getParams(location);\n       if (standby) {\n         // Call the objectGetter to all NNs (including standby)\n         for (final FederationNamenodeContext nn : namenodes) {\n           String nnId \u003d nn.getNamenodeId();\n           final List\u003cFederationNamenodeContext\u003e nnList \u003d\n               Collections.singletonList(nn);\n           T nnLocation \u003d location;\n           if (location instanceof RemoteLocation) {\n             nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n           }\n           orderedLocations.add(nnLocation);\n           callables.add(new Callable\u003cObject\u003e() {\n             public Object call() throws Exception {\n               return invokeMethod(ugi, nnList, m, paramList);\n             }\n           });\n         }\n       } else {\n         // Call the objectGetter in order of nameservices in the NS list\n         orderedLocations.add(location);\n         callables.add(new Callable\u003cObject\u003e() {\n           public Object call() throws Exception {\n             return invokeMethod(ugi, namenodes, m, paramList);\n           }\n         });\n       }\n     }\n \n     if (rpcMonitor !\u003d null) {\n       rpcMonitor.proxyOp();\n     }\n \n     try {\n       List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n       if (timeOutMs \u003e 0) {\n         futures \u003d executorService.invokeAll(\n             callables, timeOutMs, TimeUnit.MILLISECONDS);\n       } else {\n         futures \u003d executorService.invokeAll(callables);\n       }\n-      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n+      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n       Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n       for (int i\u003d0; i\u003cfutures.size(); i++) {\n         T location \u003d orderedLocations.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n-          results.put(location, result);\n+          results.put(location, clazz.cast(result));\n         } catch (CancellationException ce) {\n           T loc \u003d orderedLocations.get(i);\n           String msg \u003d\n               \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n           LOG.error(msg);\n           IOException ioe \u003d new IOException(msg);\n           exceptions.put(location, ioe);\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Canot execute {} in {}: {}\",\n               m.getName(), location, cause.getMessage());\n \n           // Convert into IOException if needed\n           IOException ioe \u003d null;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else {\n             ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                 m.getName() + \": \" + cause.getMessage(), cause);\n           }\n \n           // Response from all servers required, use this error.\n           if (requireResponse) {\n             throw ioe;\n           }\n \n           // Store the exceptions\n           exceptions.put(location, ioe);\n         }\n       }\n \n       // Throw the exception for the first location if there are no results\n       if (results.isEmpty()) {\n         T location \u003d orderedLocations.get(0);\n         IOException ioe \u003d exceptions.get(location);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n \n       return results;\n     } catch (InterruptedException ex) {\n       LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n       throw new IOException(\n           \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public \u003cT extends RemoteLocationContext, R\u003e Map\u003cT, R\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs, Class\u003cR\u003e clazz)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, clazz.cast(result));\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, R\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, clazz.cast(result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "81601dac8ec7650bec14700b174910390a92fe1f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12273. Federation UI. Contributed by Inigo Goiri.\n\n(cherry picked from commit adbb2e00c7b85524fd43bd68895d49814c16680a)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "81601dac8ec7650bec14700b174910390a92fe1f",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,121 @@\n+  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n+      final Collection\u003cT\u003e locations, final RemoteMethod method,\n+      boolean requireResponse, boolean standby, long timeOutMs)\n+          throws IOException {\n+\n+    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n+    final Method m \u003d method.getMethod();\n+\n+    if (locations.size() \u003d\u003d 1) {\n+      // Shortcut, just one call\n+      T location \u003d locations.iterator().next();\n+      String ns \u003d location.getNameserviceId();\n+      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n+          getNamenodesForNameservice(ns);\n+      Object[] paramList \u003d method.getParams(location);\n+      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n+      return Collections.singletonMap(location, result);\n+    }\n+\n+    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n+    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n+    for (final T location : locations) {\n+      String nsId \u003d location.getNameserviceId();\n+      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n+          getNamenodesForNameservice(nsId);\n+      final Object[] paramList \u003d method.getParams(location);\n+      if (standby) {\n+        // Call the objectGetter to all NNs (including standby)\n+        for (final FederationNamenodeContext nn : namenodes) {\n+          String nnId \u003d nn.getNamenodeId();\n+          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n+              Collections.singletonList(nn);\n+          T nnLocation \u003d location;\n+          if (location instanceof RemoteLocation) {\n+            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n+          }\n+          orderedLocations.add(nnLocation);\n+          callables.add(new Callable\u003cObject\u003e() {\n+            public Object call() throws Exception {\n+              return invokeMethod(ugi, nnList, m, paramList);\n+            }\n+          });\n+        }\n+      } else {\n+        // Call the objectGetter in order of nameservices in the NS list\n+        orderedLocations.add(location);\n+        callables.add(new Callable\u003cObject\u003e() {\n+          public Object call() throws Exception {\n+            return invokeMethod(ugi, namenodes, m, paramList);\n+          }\n+        });\n+      }\n+    }\n+\n+    if (rpcMonitor !\u003d null) {\n+      rpcMonitor.proxyOp();\n+    }\n+\n+    try {\n+      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n+      if (timeOutMs \u003e 0) {\n+        futures \u003d executorService.invokeAll(\n+            callables, timeOutMs, TimeUnit.MILLISECONDS);\n+      } else {\n+        futures \u003d executorService.invokeAll(callables);\n+      }\n+      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n+      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n+      for (int i\u003d0; i\u003cfutures.size(); i++) {\n+        T location \u003d orderedLocations.get(i);\n+        try {\n+          Future\u003cObject\u003e future \u003d futures.get(i);\n+          Object result \u003d future.get();\n+          results.put(location, result);\n+        } catch (CancellationException ce) {\n+          T loc \u003d orderedLocations.get(i);\n+          String msg \u003d\n+              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n+          LOG.error(msg);\n+          IOException ioe \u003d new IOException(msg);\n+          exceptions.put(location, ioe);\n+        } catch (ExecutionException ex) {\n+          Throwable cause \u003d ex.getCause();\n+          LOG.debug(\"Canot execute {} in {}: {}\",\n+              m.getName(), location, cause.getMessage());\n+\n+          // Convert into IOException if needed\n+          IOException ioe \u003d null;\n+          if (cause instanceof IOException) {\n+            ioe \u003d (IOException) cause;\n+          } else {\n+            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n+                m.getName() + \": \" + cause.getMessage(), cause);\n+          }\n+\n+          // Response from all servers required, use this error.\n+          if (requireResponse) {\n+            throw ioe;\n+          }\n+\n+          // Store the exceptions\n+          exceptions.put(location, ioe);\n+        }\n+      }\n+\n+      // Throw the exception for the first location if there are no results\n+      if (results.isEmpty()) {\n+        T location \u003d orderedLocations.get(0);\n+        IOException ioe \u003d exceptions.get(location);\n+        if (ioe !\u003d null) {\n+          throw ioe;\n+        }\n+      }\n+\n+      return results;\n+    } catch (InterruptedException ex) {\n+      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n+      throw new IOException(\n+          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public \u003cT extends RemoteLocationContext\u003e Map\u003cT, Object\u003e invokeConcurrent(\n      final Collection\u003cT\u003e locations, final RemoteMethod method,\n      boolean requireResponse, boolean standby, long timeOutMs)\n          throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.size() \u003d\u003d 1) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      Object[] paramList \u003d method.getParams(location);\n      Object result \u003d invokeMethod(ugi, namenodes, m, paramList);\n      return Collections.singletonMap(location, result);\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new LinkedList\u003c\u003e();\n    Set\u003cCallable\u003cObject\u003e\u003e callables \u003d new HashSet\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(new Callable\u003cObject\u003e() {\n            public Object call() throws Exception {\n              return invokeMethod(ugi, nnList, m, paramList);\n            }\n          });\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(new Callable\u003cObject\u003e() {\n          public Object call() throws Exception {\n            return invokeMethod(ugi, namenodes, m, paramList);\n          }\n        });\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      Map\u003cT, Object\u003e results \u003d new TreeMap\u003c\u003e();\n      Map\u003cT, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(location, result);\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d\n              \"Invocation to \\\"\" + loc + \"\\\" for \\\"\" + method + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new IOException(msg);\n          exceptions.put(location, ioe);\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Response from all servers required, use this error.\n          if (requireResponse) {\n            throw ioe;\n          }\n\n          // Store the exceptions\n          exceptions.put(location, ioe);\n        }\n      }\n\n      // Throw the exception for the first location if there are no results\n      if (results.isEmpty()) {\n        T location \u003d orderedLocations.get(0);\n        IOException ioe \u003d exceptions.get(location);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n\n      return results;\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java"
    }
  }
}