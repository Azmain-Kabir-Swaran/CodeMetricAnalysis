{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OpenFileCtx.java",
  "functionName": "dump",
  "functionId": "dump",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
  "functionStartLine": 306,
  "functionEndLine": 373,
  "numCommitsSeen": 36,
  "timeTaken": 1816,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f",
    "e3088e4aef8cdfc0841858e7851f7276fab9b24b",
    "28e3d09230971b32f74284311931525cb7ad1b7c"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": "Ybodychange",
    "e3088e4aef8cdfc0841858e7851f7276fab9b24b": "Ybodychange",
    "28e3d09230971b32f74284311931525cb7ad1b7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/10/17 10:38 AM",
      "commitNameOld": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 126.95,
      "commitsBetweenForRepo": 833,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,68 @@\n     private void dump() {\n       // Create dump outputstream for the first time\n       if (dumpOut \u003d\u003d null) {\n-        LOG.info(\"Create dump file: \" + dumpFilePath);\n+        LOG.info(\"Create dump file: {}\", dumpFilePath);\n         File dumpFile \u003d new File(dumpFilePath);\n         try {\n           synchronized (this) {\n             // check if alive again\n             Preconditions.checkState(dumpFile.createNewFile(),\n                 \"The dump file should not exist: %s\", dumpFilePath);\n             dumpOut \u003d new FileOutputStream(dumpFile);\n           }\n         } catch (IOException e) {\n-          LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n+          LOG.error(\"Got failure when creating dump stream {}\",\n+              dumpFilePath, e);\n           enabledDump \u003d false;\n           if (dumpOut !\u003d null) {\n             try {\n               dumpOut.close();\n             } catch (IOException e1) {\n-              LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n+              LOG.error(\"Can\u0027t close dump stream {}\", dumpFilePath, e);\n             }\n           }\n           return;\n         }\n       }\n \n       // Get raf for the first dump\n       if (raf \u003d\u003d null) {\n         try {\n           raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n         } catch (FileNotFoundException e) {\n-          LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n+          LOG.error(\"Can\u0027t get random access to file {}\", dumpFilePath);\n           // Disable dump\n           enabledDump \u003d false;\n           return;\n         }\n       }\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n-            + nonSequentialWriteInMemory.get());\n-      }\n+      LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d {}\",\n+            nonSequentialWriteInMemory.get());\n \n       Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n       while (activeState \u0026\u0026 it.hasNext()\n           \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n         OffsetRange key \u003d it.next();\n         WriteCtx writeCtx \u003d pendingWrites.get(key);\n         if (writeCtx \u003d\u003d null) {\n           // This write was just deleted\n           continue;\n         }\n         try {\n           long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n           if (dumpedDataSize \u003e 0) {\n             updateNonSequentialWriteInMemory(-dumpedDataSize);\n           }\n         } catch (IOException e) {\n-          LOG.error(\"Dump data failed: \" + writeCtx + \" with error: \" + e\n-              + \" OpenFileCtx state: \" + activeState);\n+          LOG.error(\"Dump data failed: {} OpenFileCtx state: {}\",\n+              writeCtx, activeState, e);\n           // Disable dump\n           enabledDump \u003d false;\n           return;\n         }\n       }\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n-            + nonSequentialWriteInMemory.get());\n-      }\n+      LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d {}\",\n+          nonSequentialWriteInMemory.get());\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dump() {\n      // Create dump outputstream for the first time\n      if (dumpOut \u003d\u003d null) {\n        LOG.info(\"Create dump file: {}\", dumpFilePath);\n        File dumpFile \u003d new File(dumpFilePath);\n        try {\n          synchronized (this) {\n            // check if alive again\n            Preconditions.checkState(dumpFile.createNewFile(),\n                \"The dump file should not exist: %s\", dumpFilePath);\n            dumpOut \u003d new FileOutputStream(dumpFile);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Got failure when creating dump stream {}\",\n              dumpFilePath, e);\n          enabledDump \u003d false;\n          if (dumpOut !\u003d null) {\n            try {\n              dumpOut.close();\n            } catch (IOException e1) {\n              LOG.error(\"Can\u0027t close dump stream {}\", dumpFilePath, e);\n            }\n          }\n          return;\n        }\n      }\n\n      // Get raf for the first dump\n      if (raf \u003d\u003d null) {\n        try {\n          raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n        } catch (FileNotFoundException e) {\n          LOG.error(\"Can\u0027t get random access to file {}\", dumpFilePath);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d {}\",\n            nonSequentialWriteInMemory.get());\n\n      Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n      while (activeState \u0026\u0026 it.hasNext()\n          \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n        OffsetRange key \u003d it.next();\n        WriteCtx writeCtx \u003d pendingWrites.get(key);\n        if (writeCtx \u003d\u003d null) {\n          // This write was just deleted\n          continue;\n        }\n        try {\n          long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n          if (dumpedDataSize \u003e 0) {\n            updateNonSequentialWriteInMemory(-dumpedDataSize);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Dump data failed: {} OpenFileCtx state: {}\",\n              writeCtx, activeState, e);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d {}\",\n          nonSequentialWriteInMemory.get());\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7423. various typos and message formatting fixes in nfs daemon and doc. (Charles Lamb via yliu)\n",
      "commitDate": "28/01/15 12:56 PM",
      "commitName": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthor": "yliu",
      "commitDateOld": "11/12/14 3:40 PM",
      "commitNameOld": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 47.89,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n     private void dump() {\n       // Create dump outputstream for the first time\n       if (dumpOut \u003d\u003d null) {\n-        LOG.info(\"Create dump file:\" + dumpFilePath);\n+        LOG.info(\"Create dump file: \" + dumpFilePath);\n         File dumpFile \u003d new File(dumpFilePath);\n         try {\n           synchronized (this) {\n             // check if alive again\n             Preconditions.checkState(dumpFile.createNewFile(),\n                 \"The dump file should not exist: %s\", dumpFilePath);\n             dumpOut \u003d new FileOutputStream(dumpFile);\n           }\n         } catch (IOException e) {\n           LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n           enabledDump \u003d false;\n           if (dumpOut !\u003d null) {\n             try {\n               dumpOut.close();\n             } catch (IOException e1) {\n               LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n             }\n           }\n           return;\n         }\n       }\n \n       // Get raf for the first dump\n       if (raf \u003d\u003d null) {\n         try {\n           raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n         } catch (FileNotFoundException e) {\n           LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n           // Disable dump\n           enabledDump \u003d false;\n           return;\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n             + nonSequentialWriteInMemory.get());\n       }\n \n       Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n       while (activeState \u0026\u0026 it.hasNext()\n           \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n         OffsetRange key \u003d it.next();\n         WriteCtx writeCtx \u003d pendingWrites.get(key);\n         if (writeCtx \u003d\u003d null) {\n           // This write was just deleted\n           continue;\n         }\n         try {\n           long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n           if (dumpedDataSize \u003e 0) {\n             updateNonSequentialWriteInMemory(-dumpedDataSize);\n           }\n         } catch (IOException e) {\n-          LOG.error(\"Dump data failed:\" + writeCtx + \" with error:\" + e\n-              + \" OpenFileCtx state:\" + activeState);\n+          LOG.error(\"Dump data failed: \" + writeCtx + \" with error: \" + e\n+              + \" OpenFileCtx state: \" + activeState);\n           // Disable dump\n           enabledDump \u003d false;\n           return;\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n             + nonSequentialWriteInMemory.get());\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dump() {\n      // Create dump outputstream for the first time\n      if (dumpOut \u003d\u003d null) {\n        LOG.info(\"Create dump file: \" + dumpFilePath);\n        File dumpFile \u003d new File(dumpFilePath);\n        try {\n          synchronized (this) {\n            // check if alive again\n            Preconditions.checkState(dumpFile.createNewFile(),\n                \"The dump file should not exist: %s\", dumpFilePath);\n            dumpOut \u003d new FileOutputStream(dumpFile);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n          enabledDump \u003d false;\n          if (dumpOut !\u003d null) {\n            try {\n              dumpOut.close();\n            } catch (IOException e1) {\n              LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n            }\n          }\n          return;\n        }\n      }\n\n      // Get raf for the first dump\n      if (raf \u003d\u003d null) {\n        try {\n          raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n        } catch (FileNotFoundException e) {\n          LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n            + nonSequentialWriteInMemory.get());\n      }\n\n      Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n      while (activeState \u0026\u0026 it.hasNext()\n          \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n        OffsetRange key \u003d it.next();\n        WriteCtx writeCtx \u003d pendingWrites.get(key);\n        if (writeCtx \u003d\u003d null) {\n          // This write was just deleted\n          continue;\n        }\n        try {\n          long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n          if (dumpedDataSize \u003e 0) {\n            updateNonSequentialWriteInMemory(-dumpedDataSize);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Dump data failed: \" + writeCtx + \" with error: \" + e\n              + \" OpenFileCtx state: \" + activeState);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n            + nonSequentialWriteInMemory.get());\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "e3088e4aef8cdfc0841858e7851f7276fab9b24b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5249. Fix dumper thread which may die silently. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/13 9:11 PM",
      "commitName": "e3088e4aef8cdfc0841858e7851f7276fab9b24b",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "23/09/13 1:02 PM",
      "commitNameOld": "28e3d09230971b32f74284311931525cb7ad1b7c",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,71 @@\n     private void dump() {\n       // Create dump outputstream for the first time\n       if (dumpOut \u003d\u003d null) {\n         LOG.info(\"Create dump file:\" + dumpFilePath);\n         File dumpFile \u003d new File(dumpFilePath);\n         try {\n           synchronized (this) {\n             // check if alive again\n-          Preconditions.checkState(dumpFile.createNewFile(),\n-              \"The dump file should not exist: %s\", dumpFilePath);\n-          dumpOut \u003d new FileOutputStream(dumpFile);\n+            Preconditions.checkState(dumpFile.createNewFile(),\n+                \"The dump file should not exist: %s\", dumpFilePath);\n+            dumpOut \u003d new FileOutputStream(dumpFile);\n           }\n         } catch (IOException e) {\n           LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n           enabledDump \u003d false;\n           if (dumpOut !\u003d null) {\n             try {\n               dumpOut.close();\n             } catch (IOException e1) {\n               LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n             }\n           }\n           return;\n         }\n       }\n \n       // Get raf for the first dump\n       if (raf \u003d\u003d null) {\n         try {\n           raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n         } catch (FileNotFoundException e) {\n           LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n           // Disable dump\n           enabledDump \u003d false;\n           return;\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n             + nonSequentialWriteInMemory.get());\n       }\n \n       Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n       while (activeState \u0026\u0026 it.hasNext()\n           \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n         OffsetRange key \u003d it.next();\n         WriteCtx writeCtx \u003d pendingWrites.get(key);\n+        if (writeCtx \u003d\u003d null) {\n+          // This write was just deleted\n+          continue;\n+        }\n         try {\n           long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n           if (dumpedDataSize \u003e 0) {\n             updateNonSequentialWriteInMemory(-dumpedDataSize);\n           }\n         } catch (IOException e) {\n           LOG.error(\"Dump data failed:\" + writeCtx + \" with error:\" + e\n               + \" OpenFileCtx state:\" + activeState);\n           // Disable dump\n           enabledDump \u003d false;\n           return;\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n             + nonSequentialWriteInMemory.get());\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dump() {\n      // Create dump outputstream for the first time\n      if (dumpOut \u003d\u003d null) {\n        LOG.info(\"Create dump file:\" + dumpFilePath);\n        File dumpFile \u003d new File(dumpFilePath);\n        try {\n          synchronized (this) {\n            // check if alive again\n            Preconditions.checkState(dumpFile.createNewFile(),\n                \"The dump file should not exist: %s\", dumpFilePath);\n            dumpOut \u003d new FileOutputStream(dumpFile);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n          enabledDump \u003d false;\n          if (dumpOut !\u003d null) {\n            try {\n              dumpOut.close();\n            } catch (IOException e1) {\n              LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n            }\n          }\n          return;\n        }\n      }\n\n      // Get raf for the first dump\n      if (raf \u003d\u003d null) {\n        try {\n          raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n        } catch (FileNotFoundException e) {\n          LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n            + nonSequentialWriteInMemory.get());\n      }\n\n      Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n      while (activeState \u0026\u0026 it.hasNext()\n          \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n        OffsetRange key \u003d it.next();\n        WriteCtx writeCtx \u003d pendingWrites.get(key);\n        if (writeCtx \u003d\u003d null) {\n          // This write was just deleted\n          continue;\n        }\n        try {\n          long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n          if (dumpedDataSize \u003e 0) {\n            updateNonSequentialWriteInMemory(-dumpedDataSize);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Dump data failed:\" + writeCtx + \" with error:\" + e\n              + \" OpenFileCtx state:\" + activeState);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n            + nonSequentialWriteInMemory.get());\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "28e3d09230971b32f74284311931525cb7ad1b7c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/13 1:02 PM",
      "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,67 @@\n+    private void dump() {\n+      // Create dump outputstream for the first time\n+      if (dumpOut \u003d\u003d null) {\n+        LOG.info(\"Create dump file:\" + dumpFilePath);\n+        File dumpFile \u003d new File(dumpFilePath);\n+        try {\n+          synchronized (this) {\n+            // check if alive again\n+          Preconditions.checkState(dumpFile.createNewFile(),\n+              \"The dump file should not exist: %s\", dumpFilePath);\n+          dumpOut \u003d new FileOutputStream(dumpFile);\n+          }\n+        } catch (IOException e) {\n+          LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n+          enabledDump \u003d false;\n+          if (dumpOut !\u003d null) {\n+            try {\n+              dumpOut.close();\n+            } catch (IOException e1) {\n+              LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n+            }\n+          }\n+          return;\n+        }\n+      }\n+\n+      // Get raf for the first dump\n+      if (raf \u003d\u003d null) {\n+        try {\n+          raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n+        } catch (FileNotFoundException e) {\n+          LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n+          // Disable dump\n+          enabledDump \u003d false;\n+          return;\n+        }\n+      }\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n+            + nonSequentialWriteInMemory.get());\n+      }\n+\n+      Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n+      while (activeState \u0026\u0026 it.hasNext()\n+          \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n+        OffsetRange key \u003d it.next();\n+        WriteCtx writeCtx \u003d pendingWrites.get(key);\n+        try {\n+          long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n+          if (dumpedDataSize \u003e 0) {\n+            updateNonSequentialWriteInMemory(-dumpedDataSize);\n+          }\n+        } catch (IOException e) {\n+          LOG.error(\"Dump data failed:\" + writeCtx + \" with error:\" + e\n+              + \" OpenFileCtx state:\" + activeState);\n+          // Disable dump\n+          enabledDump \u003d false;\n+          return;\n+        }\n+      }\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n+            + nonSequentialWriteInMemory.get());\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void dump() {\n      // Create dump outputstream for the first time\n      if (dumpOut \u003d\u003d null) {\n        LOG.info(\"Create dump file:\" + dumpFilePath);\n        File dumpFile \u003d new File(dumpFilePath);\n        try {\n          synchronized (this) {\n            // check if alive again\n          Preconditions.checkState(dumpFile.createNewFile(),\n              \"The dump file should not exist: %s\", dumpFilePath);\n          dumpOut \u003d new FileOutputStream(dumpFile);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Got failure when creating dump stream \" + dumpFilePath, e);\n          enabledDump \u003d false;\n          if (dumpOut !\u003d null) {\n            try {\n              dumpOut.close();\n            } catch (IOException e1) {\n              LOG.error(\"Can\u0027t close dump stream \" + dumpFilePath, e);\n            }\n          }\n          return;\n        }\n      }\n\n      // Get raf for the first dump\n      if (raf \u003d\u003d null) {\n        try {\n          raf \u003d new RandomAccessFile(dumpFilePath, \"r\");\n        } catch (FileNotFoundException e) {\n          LOG.error(\"Can\u0027t get random access to file \" + dumpFilePath);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Start dump. Before dump, nonSequentialWriteInMemory \u003d\u003d \"\n            + nonSequentialWriteInMemory.get());\n      }\n\n      Iterator\u003cOffsetRange\u003e it \u003d pendingWrites.keySet().iterator();\n      while (activeState \u0026\u0026 it.hasNext()\n          \u0026\u0026 nonSequentialWriteInMemory.get() \u003e 0) {\n        OffsetRange key \u003d it.next();\n        WriteCtx writeCtx \u003d pendingWrites.get(key);\n        try {\n          long dumpedDataSize \u003d writeCtx.dumpData(dumpOut, raf);\n          if (dumpedDataSize \u003e 0) {\n            updateNonSequentialWriteInMemory(-dumpedDataSize);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Dump data failed:\" + writeCtx + \" with error:\" + e\n              + \" OpenFileCtx state:\" + activeState);\n          // Disable dump\n          enabledDump \u003d false;\n          return;\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"After dump, nonSequentialWriteInMemory \u003d\u003d \"\n            + nonSequentialWriteInMemory.get());\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java"
    }
  }
}