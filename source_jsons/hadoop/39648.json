{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeafQueue.java",
  "functionName": "activateApplications",
  "functionId": "activateApplications",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
  "functionStartLine": 776,
  "functionEndLine": 889,
  "numCommitsSeen": 214,
  "timeTaken": 12509,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "c2731d4b6399f88f76341ed697e80652ed1b61ea",
    "03489124ea1b8d5648ade5e3563e39b5bc323384",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
    "e9c2aa1bc383cb08784846534415bf17667d6e41",
    "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "f4a57d4a531e793373fe3118d644871a3b9ae0b1",
    "b08ecf5c7589b055e93b2907413213f36097724d",
    "109e528ef5d8df07443373751266b4417acc981a",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
    "56e4f6237ae8b1852e82b186e08db3934f79a9db",
    "cf9d3c925608e8bc650d43975382ed3014081057",
    "b039e69bb03accef485361af301fa59f03d08d6a",
    "bdd90110e6904b59746812d9a093924a65e72280",
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
    "86358221fc85a7743052a0b4c1647353508bf308",
    "c53420f58364b11fbda1dace7679d45534533382",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "70bc14f2344f31ec75f512256e8c8c3d36af5e78",
    "6b608aad7d52b524fa94955a538e8b3524d42d93"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "c2731d4b6399f88f76341ed697e80652ed1b61ea": "Ybodychange",
    "03489124ea1b8d5648ade5e3563e39b5bc323384": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ymodifierchange",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": "Ybodychange",
    "e9c2aa1bc383cb08784846534415bf17667d6e41": "Ybodychange",
    "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "f4a57d4a531e793373fe3118d644871a3b9ae0b1": "Ybodychange",
    "b08ecf5c7589b055e93b2907413213f36097724d": "Ybodychange",
    "109e528ef5d8df07443373751266b4417acc981a": "Ybodychange",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": "Ybodychange",
    "56e4f6237ae8b1852e82b186e08db3934f79a9db": "Ybodychange",
    "cf9d3c925608e8bc650d43975382ed3014081057": "Ybodychange",
    "b039e69bb03accef485361af301fa59f03d08d6a": "Ybodychange",
    "bdd90110e6904b59746812d9a093924a65e72280": "Ybodychange",
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5": "Ybodychange",
    "86358221fc85a7743052a0b4c1647353508bf308": "Ybodychange",
    "c53420f58364b11fbda1dace7679d45534533382": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "70bc14f2344f31ec75f512256e8c8c3d36af5e78": "Ybodychange",
    "6b608aad7d52b524fa94955a538e8b3524d42d93": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/01/20 7:54 PM",
      "commitNameOld": "e578e52aae01248507e089b406fe038ab8e84207",
      "commitAuthorOld": "Eric Badger",
      "daysBetweenCommits": 56.31,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,114 @@\n   protected void activateApplications() {\n     writeLock.lock();\n     try {\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy()\n                .getAssignmentIterator(IteratorSelector.EMPTY_ITERATOR_SELECTOR);\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!resourceCalculator.fitsIn(amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                 + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n               application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!resourceCalculator.fitsIn(userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             LOG.debug(\"Not activating application {} for user: {} as\"\n                 + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                 applicationId, user, userAmIfStarted, userAMLimit);\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n-            .getUser() + \" activated in queue: \" + getQueueName());\n+            .getUser() + \" activated in queue: \" + getQueuePath());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void activateApplications() {\n    writeLock.lock();\n    try {\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy()\n               .getAssignmentIterator(IteratorSelector.EMPTY_ITERATOR_SELECTOR);\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!resourceCalculator.fitsIn(amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!resourceCalculator.fitsIn(userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} for user: {} as\"\n                + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                applicationId, user, userAmIfStarted, userAMLimit);\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueuePath());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "c2731d4b6399f88f76341ed697e80652ed1b61ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9730. Support forcing configured partitions to be exclusive based on app node label\n",
      "commitDate": "24/09/19 1:51 PM",
      "commitName": "c2731d4b6399f88f76341ed697e80652ed1b61ea",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "02/09/19 11:23 PM",
      "commitNameOld": "03489124ea1b8d5648ade5e3563e39b5bc323384",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 21.6,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,114 @@\n   protected void activateApplications() {\n     writeLock.lock();\n     try {\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n-           getPendingAppsOrderingPolicy().getAssignmentIterator();\n+           getPendingAppsOrderingPolicy()\n+               .getAssignmentIterator(IteratorSelector.EMPTY_ITERATOR_SELECTOR);\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!resourceCalculator.fitsIn(amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                 + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n               application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!resourceCalculator.fitsIn(userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             LOG.debug(\"Not activating application {} for user: {} as\"\n                 + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                 applicationId, user, userAmIfStarted, userAMLimit);\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void activateApplications() {\n    writeLock.lock();\n    try {\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy()\n               .getAssignmentIterator(IteratorSelector.EMPTY_ITERATOR_SELECTOR);\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!resourceCalculator.fitsIn(amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!resourceCalculator.fitsIn(userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} for user: {} as\"\n                + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                applicationId, user, userAmIfStarted, userAMLimit);\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "03489124ea1b8d5648ade5e3563e39b5bc323384": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9797. LeafQueue#activateApplications should use resourceCalculator#fitsIn. Contributed by  Bilwa S T.\n",
      "commitDate": "02/09/19 11:23 PM",
      "commitName": "03489124ea1b8d5648ade5e3563e39b5bc323384",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "31/08/19 9:24 PM",
      "commitNameOld": "d2d963f3d4819704351c04dbeb90fc8154488f91",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 2.08,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,113 @@\n   protected void activateApplications() {\n     writeLock.lock();\n     try {\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n-        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-            amIfStarted, amLimit)) {\n+        if (!resourceCalculator.fitsIn(amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                 + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n               application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n-        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-            userAmIfStarted, userAMLimit)) {\n+        if (!resourceCalculator.fitsIn(userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             LOG.debug(\"Not activating application {} for user: {} as\"\n                 + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                 applicationId, user, userAmIfStarted, userAMLimit);\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void activateApplications() {\n    writeLock.lock();\n    try {\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!resourceCalculator.fitsIn(amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!resourceCalculator.fitsIn(userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} for user: {} as\"\n                + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                applicationId, user, userAmIfStarted, userAMLimit);\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,115 @@\n   protected void activateApplications() {\n     writeLock.lock();\n     try {\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Not activating application \" + applicationId\n-                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n-                  + amLimit);\n-            }\n+            LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n+                + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n               application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Not activating application \" + applicationId\n-                  + \" for user: \" + user + \" as userAmIfStarted: \"\n-                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n-            }\n+            LOG.debug(\"Not activating application {} for user: {} as\"\n+                + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n+                applicationId, user, userAmIfStarted, userAMLimit);\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void activateApplications() {\n    writeLock.lock();\n    try {\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} as  amIfStarted: {}\"\n                + \" exceeds amLimit: {}\", applicationId, amIfStarted, amLimit);\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.debug(\"Not activating application {} for user: {} as\"\n                + \" userAmIfStarted: {} exceeds userAmLimit: {}\",\n                applicationId, user, userAmIfStarted, userAMLimit);\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   protected void activateApplications() {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                   + amLimit);\n             }\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n               application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" for user: \" + user + \" as userAmIfStarted: \"\n                   + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n             }\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void activateApplications() {\n    writeLock.lock();\n    try {\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                  + amLimit);\n            }\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" for user: \" + user + \" as userAmIfStarted: \"\n                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n            }\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "d52627a7cbddfd981db973e223aefffde1ebf82d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n-  private void activateApplications() {\n+  protected void activateApplications() {\n     try {\n       writeLock.lock();\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                   + amLimit);\n             }\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n               application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" for user: \" + user + \" as userAmIfStarted: \"\n                   + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n             }\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void activateApplications() {\n    try {\n      writeLock.lock();\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                  + amLimit);\n            }\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" for user: \" + user + \" as userAmIfStarted: \"\n                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n            }\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5892. Support user-specific minimum user limit percentage in Capacity Scheduler. Contributed by Eric Payne.\n",
      "commitDate": "22/06/17 11:50 PM",
      "commitName": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/06/17 9:01 AM",
      "commitNameOld": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 3.62,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,120 @@\n   private void activateApplications() {\n     try {\n       writeLock.lock();\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                   + amLimit);\n             }\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n-          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n+          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n+              application.getUser());\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" for user: \" + user + \" as userAmIfStarted: \"\n                   + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n             }\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(partitionName,\n             application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void activateApplications() {\n    try {\n      writeLock.lock();\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                  + amLimit);\n            }\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName,\n              application.getUser());\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" for user: \" + user + \" as userAmIfStarted: \"\n                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n            }\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "e9c2aa1bc383cb08784846534415bf17667d6e41": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6467. CSQueueMetrics needs to update the current metrics for default partition only. Contributed by Manikandan R.\n",
      "commitDate": "19/06/17 9:01 AM",
      "commitName": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,119 @@\n   private void activateApplications() {\n     try {\n       writeLock.lock();\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                   + amLimit);\n             }\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Not activating application \" + applicationId\n                   + \" for user: \" + user + \" as userAmIfStarted: \"\n                   + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n             }\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n-        metrics.incAMUsed(application.getUser(),\n+        metrics.incAMUsed(partitionName, application.getUser(),\n             application.getAMResource(partitionName));\n-        metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n+        metrics.setAMResouceLimitForUser(partitionName,\n+            application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void activateApplications() {\n    try {\n      writeLock.lock();\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                  + amLimit);\n            }\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" for user: \" + user + \" as userAmIfStarted: \"\n                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n            }\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(partitionName, application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(partitionName,\n            application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5773. RM recovery too slow due to LeafQueue#activateApplications (Bibin A Chundatt via Varun Saxena)\n",
      "commitDate": "29/10/16 1:17 AM",
      "commitName": "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "04/10/16 5:23 PM",
      "commitNameOld": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 24.33,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,118 @@\n   private void activateApplications() {\n     try {\n       writeLock.lock();\n       // limit of allowed resource usage for application masters\n       Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n           new HashMap\u003cString, Resource\u003e();\n \n       // AM Resource Limit for accessible labels can be pre-calculated.\n       // This will help in updating AMResourceLimit for all labels when queue\n       // is initialized for the first time (when no applications are present).\n       for (String nodePartition : getNodeLabelsForQueue()) {\n         calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n       for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n            getPendingAppsOrderingPolicy().getAssignmentIterator();\n            fsApp.hasNext(); ) {\n         FiCaSchedulerApp application \u003d fsApp.next();\n         ApplicationId applicationId \u003d application.getApplicationId();\n \n         // Get the am-node-partition associated with each application\n         // and calculate max-am resource limit for this partition.\n         String partitionName \u003d application.getAppAMNodePartitionName();\n \n         Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         // Verify whether we already calculated am-limit for this label.\n         if (amLimit \u003d\u003d null) {\n           amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n         // Check am resource limit.\n         Resource amIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             queueUsage.getAMUsed(partitionName));\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"application \" + application.getId() + \" AMResource \"\n               + application.getAMResource(partitionName)\n               + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n               + \" amLimit \" + amLimit + \" lastClusterResource \"\n               + lastClusterResource + \" amIfStarted \" + amIfStarted\n               + \" AM node-partition name \" + partitionName);\n         }\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             amIfStarted, amLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue, it is likely set too low.\"\n                 + \" skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n-            LOG.info(\"Not activating application \" + applicationId\n-                + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n-                + amLimit);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Not activating application \" + applicationId\n+                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n+                  + amLimit);\n+            }\n             continue;\n           }\n         }\n \n         // Check user am resource limit\n         User user \u003d getUser(application.getUser());\n         Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n         // Verify whether we already calculated user-am-limit for this label.\n         if (userAMLimit \u003d\u003d null) {\n           userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n           userAmPartitionLimit.put(partitionName, userAMLimit);\n         }\n \n         Resource userAmIfStarted \u003d Resources.add(\n             application.getAMResource(partitionName),\n             user.getConsumedAMResources(partitionName));\n \n         if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n             userAmIfStarted, userAMLimit)) {\n           if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n               resourceCalculator, lastClusterResource,\n               queueUsage.getAMUsed(partitionName), Resources.none()))) {\n             LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                 + \" single application in queue for user, it is likely set too\"\n                 + \" low. skipping enforcement to allow at least one application\"\n                 + \" to start\");\n           } else{\n             application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                 CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n-            LOG.info(\n-                \"Not activating application \" + applicationId + \" for user: \"\n-                    + user + \" as userAmIfStarted: \" + userAmIfStarted\n-                    + \" exceeds userAmLimit: \" + userAMLimit);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Not activating application \" + applicationId\n+                  + \" for user: \" + user + \" as userAmIfStarted: \"\n+                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n+            }\n             continue;\n           }\n         }\n         user.activateApplication();\n         orderingPolicy.addSchedulableEntity(application);\n         application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n         queueUsage.incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().incAMUsed(partitionName,\n             application.getAMResource(partitionName));\n         user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n         metrics.incAMUsed(application.getUser(),\n             application.getAMResource(partitionName));\n         metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n         fsApp.remove();\n         LOG.info(\"Application \" + applicationId + \" from user: \" + application\n             .getUser() + \" activated in queue: \" + getQueueName());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void activateApplications() {\n    try {\n      writeLock.lock();\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                  + amLimit);\n            }\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Not activating application \" + applicationId\n                  + \" for user: \" + user + \" as userAmIfStarted: \"\n                  + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n            }\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,115 @@\n-  private synchronized void activateApplications() {\n-    // limit of allowed resource usage for application masters\n-    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n-        new HashMap\u003cString, Resource\u003e();\n+  private void activateApplications() {\n+    try {\n+      writeLock.lock();\n+      // limit of allowed resource usage for application masters\n+      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n+          new HashMap\u003cString, Resource\u003e();\n \n-    // AM Resource Limit for accessible labels can be pre-calculated.\n-    // This will help in updating AMResourceLimit for all labels when queue\n-    // is initialized for the first time (when no applications are present).\n-    for (String nodePartition : getNodeLabelsForQueue()) {\n-      calculateAndGetAMResourceLimitPerPartition(nodePartition);\n-    }\n-\n-    for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n-        getPendingAppsOrderingPolicy().getAssignmentIterator();\n-        fsApp.hasNext();) {\n-      FiCaSchedulerApp application \u003d fsApp.next();\n-      ApplicationId applicationId \u003d application.getApplicationId();\n-\n-      // Get the am-node-partition associated with each application\n-      // and calculate max-am resource limit for this partition.\n-      String partitionName \u003d application.getAppAMNodePartitionName();\n-\n-      Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n-      // Verify whether we already calculated am-limit for this label.\n-      if (amLimit \u003d\u003d null) {\n-        amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n-      }\n-      // Check am resource limit.\n-      Resource amIfStarted \u003d Resources.add(\n-          application.getAMResource(partitionName),\n-          queueUsage.getAMUsed(partitionName));\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n-            + application.getAMResource(partitionName)\n-            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n-            + \" amLimit \" + amLimit + \" lastClusterResource \"\n-            + lastClusterResource + \" amIfStarted \" + amIfStarted\n-            + \" AM node-partition name \" + partitionName);\n+      // AM Resource Limit for accessible labels can be pre-calculated.\n+      // This will help in updating AMResourceLimit for all labels when queue\n+      // is initialized for the first time (when no applications are present).\n+      for (String nodePartition : getNodeLabelsForQueue()) {\n+        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n-      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-          amIfStarted, amLimit)) {\n-        if (getNumActiveApplications() \u003c 1\n-            || (Resources.lessThanOrEqual(resourceCalculator,\n-                lastClusterResource, queueUsage.getAMUsed(partitionName),\n-                Resources.none()))) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n-              + \" single application in queue, it is likely set too low.\"\n-              + \" skipping enforcement to allow at least one application\"\n-              + \" to start\");\n-        } else {\n-          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n-              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n-          LOG.info(\"Not activating application \" + applicationId\n-              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n-              + amLimit);\n-          continue;\n+      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n+           getPendingAppsOrderingPolicy().getAssignmentIterator();\n+           fsApp.hasNext(); ) {\n+        FiCaSchedulerApp application \u003d fsApp.next();\n+        ApplicationId applicationId \u003d application.getApplicationId();\n+\n+        // Get the am-node-partition associated with each application\n+        // and calculate max-am resource limit for this partition.\n+        String partitionName \u003d application.getAppAMNodePartitionName();\n+\n+        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n+        // Verify whether we already calculated am-limit for this label.\n+        if (amLimit \u003d\u003d null) {\n+          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n-      }\n+        // Check am resource limit.\n+        Resource amIfStarted \u003d Resources.add(\n+            application.getAMResource(partitionName),\n+            queueUsage.getAMUsed(partitionName));\n \n-      // Check user am resource limit\n-      User user \u003d getUser(application.getUser());\n-      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n-\n-      // Verify whether we already calculated user-am-limit for this label.\n-      if (userAMLimit \u003d\u003d null) {\n-        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n-        userAmPartitionLimit.put(partitionName, userAMLimit);\n-      }\n-\n-      Resource userAmIfStarted \u003d Resources.add(\n-          application.getAMResource(partitionName),\n-          user.getConsumedAMResources(partitionName));\n-\n-      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-          userAmIfStarted, userAMLimit)) {\n-        if (getNumActiveApplications() \u003c 1\n-            || (Resources.lessThanOrEqual(resourceCalculator,\n-                lastClusterResource, queueUsage.getAMUsed(partitionName),\n-                Resources.none()))) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n-              + \" single application in queue for user, it is likely set too\"\n-              + \" low. skipping enforcement to allow at least one application\"\n-              + \" to start\");\n-        } else {\n-          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n-              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n-          LOG.info(\"Not activating application \" + applicationId\n-              + \" for user: \" + user + \" as userAmIfStarted: \"\n-              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n-          continue;\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n+              + application.getAMResource(partitionName)\n+              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n+              + \" amLimit \" + amLimit + \" lastClusterResource \"\n+              + lastClusterResource + \" amIfStarted \" + amIfStarted\n+              + \" AM node-partition name \" + partitionName);\n         }\n-      }\n-      user.activateApplication();\n-      orderingPolicy.addSchedulableEntity(application);\n-      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n-      queueUsage.incAMUsed(partitionName,\n-          application.getAMResource(partitionName));\n-      user.getResourceUsage().incAMUsed(partitionName,\n-          application.getAMResource(partitionName));\n-      user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n-      metrics.incAMUsed(application.getUser(),\n-          application.getAMResource(partitionName));\n-      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n-      fsApp.remove();\n-      LOG.info(\"Application \" + applicationId + \" from user: \"\n-          + application.getUser() + \" activated in queue: \" + getQueueName());\n+        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+            amIfStarted, amLimit)) {\n+          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n+              resourceCalculator, lastClusterResource,\n+              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n+            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+                + \" single application in queue, it is likely set too low.\"\n+                + \" skipping enforcement to allow at least one application\"\n+                + \" to start\");\n+          } else{\n+            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n+            LOG.info(\"Not activating application \" + applicationId\n+                + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n+                + amLimit);\n+            continue;\n+          }\n+        }\n+\n+        // Check user am resource limit\n+        User user \u003d getUser(application.getUser());\n+        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n+\n+        // Verify whether we already calculated user-am-limit for this label.\n+        if (userAMLimit \u003d\u003d null) {\n+          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n+          userAmPartitionLimit.put(partitionName, userAMLimit);\n+        }\n+\n+        Resource userAmIfStarted \u003d Resources.add(\n+            application.getAMResource(partitionName),\n+            user.getConsumedAMResources(partitionName));\n+\n+        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+            userAmIfStarted, userAMLimit)) {\n+          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n+              resourceCalculator, lastClusterResource,\n+              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n+            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+                + \" single application in queue for user, it is likely set too\"\n+                + \" low. skipping enforcement to allow at least one application\"\n+                + \" to start\");\n+          } else{\n+            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n+            LOG.info(\n+                \"Not activating application \" + applicationId + \" for user: \"\n+                    + user + \" as userAmIfStarted: \" + userAmIfStarted\n+                    + \" exceeds userAmLimit: \" + userAMLimit);\n+            continue;\n+          }\n+        }\n+        user.activateApplication();\n+        orderingPolicy.addSchedulableEntity(application);\n+        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n+\n+        queueUsage.incAMUsed(partitionName,\n+            application.getAMResource(partitionName));\n+        user.getResourceUsage().incAMUsed(partitionName,\n+            application.getAMResource(partitionName));\n+        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n+        metrics.incAMUsed(application.getUser(),\n+            application.getAMResource(partitionName));\n+        metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n+        fsApp.remove();\n+        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n+            .getUser() + \" activated in queue: \" + getQueueName());\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void activateApplications() {\n    try {\n      writeLock.lock();\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.info(\"Not activating application \" + applicationId\n                + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                + amLimit);\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.info(\n                \"Not activating application \" + applicationId + \" for user: \"\n                    + user + \" as userAmIfStarted: \" + userAmIfStarted\n                    + \" exceeds userAmLimit: \" + userAMLimit);\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,115 @@\n-  private synchronized void activateApplications() {\n-    // limit of allowed resource usage for application masters\n-    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n-        new HashMap\u003cString, Resource\u003e();\n+  private void activateApplications() {\n+    try {\n+      writeLock.lock();\n+      // limit of allowed resource usage for application masters\n+      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n+          new HashMap\u003cString, Resource\u003e();\n \n-    // AM Resource Limit for accessible labels can be pre-calculated.\n-    // This will help in updating AMResourceLimit for all labels when queue\n-    // is initialized for the first time (when no applications are present).\n-    for (String nodePartition : getNodeLabelsForQueue()) {\n-      calculateAndGetAMResourceLimitPerPartition(nodePartition);\n-    }\n-\n-    for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n-        getPendingAppsOrderingPolicy().getAssignmentIterator();\n-        fsApp.hasNext();) {\n-      FiCaSchedulerApp application \u003d fsApp.next();\n-      ApplicationId applicationId \u003d application.getApplicationId();\n-\n-      // Get the am-node-partition associated with each application\n-      // and calculate max-am resource limit for this partition.\n-      String partitionName \u003d application.getAppAMNodePartitionName();\n-\n-      Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n-      // Verify whether we already calculated am-limit for this label.\n-      if (amLimit \u003d\u003d null) {\n-        amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n-      }\n-      // Check am resource limit.\n-      Resource amIfStarted \u003d Resources.add(\n-          application.getAMResource(partitionName),\n-          queueUsage.getAMUsed(partitionName));\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n-            + application.getAMResource(partitionName)\n-            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n-            + \" amLimit \" + amLimit + \" lastClusterResource \"\n-            + lastClusterResource + \" amIfStarted \" + amIfStarted\n-            + \" AM node-partition name \" + partitionName);\n+      // AM Resource Limit for accessible labels can be pre-calculated.\n+      // This will help in updating AMResourceLimit for all labels when queue\n+      // is initialized for the first time (when no applications are present).\n+      for (String nodePartition : getNodeLabelsForQueue()) {\n+        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n       }\n \n-      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-          amIfStarted, amLimit)) {\n-        if (getNumActiveApplications() \u003c 1\n-            || (Resources.lessThanOrEqual(resourceCalculator,\n-                lastClusterResource, queueUsage.getAMUsed(partitionName),\n-                Resources.none()))) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n-              + \" single application in queue, it is likely set too low.\"\n-              + \" skipping enforcement to allow at least one application\"\n-              + \" to start\");\n-        } else {\n-          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n-              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n-          LOG.info(\"Not activating application \" + applicationId\n-              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n-              + amLimit);\n-          continue;\n+      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n+           getPendingAppsOrderingPolicy().getAssignmentIterator();\n+           fsApp.hasNext(); ) {\n+        FiCaSchedulerApp application \u003d fsApp.next();\n+        ApplicationId applicationId \u003d application.getApplicationId();\n+\n+        // Get the am-node-partition associated with each application\n+        // and calculate max-am resource limit for this partition.\n+        String partitionName \u003d application.getAppAMNodePartitionName();\n+\n+        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n+        // Verify whether we already calculated am-limit for this label.\n+        if (amLimit \u003d\u003d null) {\n+          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n         }\n-      }\n+        // Check am resource limit.\n+        Resource amIfStarted \u003d Resources.add(\n+            application.getAMResource(partitionName),\n+            queueUsage.getAMUsed(partitionName));\n \n-      // Check user am resource limit\n-      User user \u003d getUser(application.getUser());\n-      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n-\n-      // Verify whether we already calculated user-am-limit for this label.\n-      if (userAMLimit \u003d\u003d null) {\n-        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n-        userAmPartitionLimit.put(partitionName, userAMLimit);\n-      }\n-\n-      Resource userAmIfStarted \u003d Resources.add(\n-          application.getAMResource(partitionName),\n-          user.getConsumedAMResources(partitionName));\n-\n-      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-          userAmIfStarted, userAMLimit)) {\n-        if (getNumActiveApplications() \u003c 1\n-            || (Resources.lessThanOrEqual(resourceCalculator,\n-                lastClusterResource, queueUsage.getAMUsed(partitionName),\n-                Resources.none()))) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n-              + \" single application in queue for user, it is likely set too\"\n-              + \" low. skipping enforcement to allow at least one application\"\n-              + \" to start\");\n-        } else {\n-          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n-              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n-          LOG.info(\"Not activating application \" + applicationId\n-              + \" for user: \" + user + \" as userAmIfStarted: \"\n-              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n-          continue;\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n+              + application.getAMResource(partitionName)\n+              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n+              + \" amLimit \" + amLimit + \" lastClusterResource \"\n+              + lastClusterResource + \" amIfStarted \" + amIfStarted\n+              + \" AM node-partition name \" + partitionName);\n         }\n-      }\n-      user.activateApplication();\n-      orderingPolicy.addSchedulableEntity(application);\n-      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n \n-      queueUsage.incAMUsed(partitionName,\n-          application.getAMResource(partitionName));\n-      user.getResourceUsage().incAMUsed(partitionName,\n-          application.getAMResource(partitionName));\n-      user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n-      metrics.incAMUsed(application.getUser(),\n-          application.getAMResource(partitionName));\n-      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n-      fsApp.remove();\n-      LOG.info(\"Application \" + applicationId + \" from user: \"\n-          + application.getUser() + \" activated in queue: \" + getQueueName());\n+        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+            amIfStarted, amLimit)) {\n+          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n+              resourceCalculator, lastClusterResource,\n+              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n+            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+                + \" single application in queue, it is likely set too low.\"\n+                + \" skipping enforcement to allow at least one application\"\n+                + \" to start\");\n+          } else{\n+            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n+            LOG.info(\"Not activating application \" + applicationId\n+                + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n+                + amLimit);\n+            continue;\n+          }\n+        }\n+\n+        // Check user am resource limit\n+        User user \u003d getUser(application.getUser());\n+        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n+\n+        // Verify whether we already calculated user-am-limit for this label.\n+        if (userAMLimit \u003d\u003d null) {\n+          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n+          userAmPartitionLimit.put(partitionName, userAMLimit);\n+        }\n+\n+        Resource userAmIfStarted \u003d Resources.add(\n+            application.getAMResource(partitionName),\n+            user.getConsumedAMResources(partitionName));\n+\n+        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+            userAmIfStarted, userAMLimit)) {\n+          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n+              resourceCalculator, lastClusterResource,\n+              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n+            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+                + \" single application in queue for user, it is likely set too\"\n+                + \" low. skipping enforcement to allow at least one application\"\n+                + \" to start\");\n+          } else{\n+            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n+            LOG.info(\n+                \"Not activating application \" + applicationId + \" for user: \"\n+                    + user + \" as userAmIfStarted: \" + userAmIfStarted\n+                    + \" exceeds userAmLimit: \" + userAMLimit);\n+            continue;\n+          }\n+        }\n+        user.activateApplication();\n+        orderingPolicy.addSchedulableEntity(application);\n+        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n+\n+        queueUsage.incAMUsed(partitionName,\n+            application.getAMResource(partitionName));\n+        user.getResourceUsage().incAMUsed(partitionName,\n+            application.getAMResource(partitionName));\n+        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n+        metrics.incAMUsed(application.getUser(),\n+            application.getAMResource(partitionName));\n+        metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n+        fsApp.remove();\n+        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n+            .getUser() + \" activated in queue: \" + getQueueName());\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void activateApplications() {\n    try {\n      writeLock.lock();\n      // limit of allowed resource usage for application masters\n      Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n          new HashMap\u003cString, Resource\u003e();\n\n      // AM Resource Limit for accessible labels can be pre-calculated.\n      // This will help in updating AMResourceLimit for all labels when queue\n      // is initialized for the first time (when no applications are present).\n      for (String nodePartition : getNodeLabelsForQueue()) {\n        calculateAndGetAMResourceLimitPerPartition(nodePartition);\n      }\n\n      for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n           getPendingAppsOrderingPolicy().getAssignmentIterator();\n           fsApp.hasNext(); ) {\n        FiCaSchedulerApp application \u003d fsApp.next();\n        ApplicationId applicationId \u003d application.getApplicationId();\n\n        // Get the am-node-partition associated with each application\n        // and calculate max-am resource limit for this partition.\n        String partitionName \u003d application.getAppAMNodePartitionName();\n\n        Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        // Verify whether we already calculated am-limit for this label.\n        if (amLimit \u003d\u003d null) {\n          amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n        }\n        // Check am resource limit.\n        Resource amIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            queueUsage.getAMUsed(partitionName));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"application \" + application.getId() + \" AMResource \"\n              + application.getAMResource(partitionName)\n              + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n              + \" amLimit \" + amLimit + \" lastClusterResource \"\n              + lastClusterResource + \" amIfStarted \" + amIfStarted\n              + \" AM node-partition name \" + partitionName);\n        }\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            amIfStarted, amLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue, it is likely set too low.\"\n                + \" skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.info(\"Not activating application \" + applicationId\n                + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n                + amLimit);\n            continue;\n          }\n        }\n\n        // Check user am resource limit\n        User user \u003d getUser(application.getUser());\n        Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n        // Verify whether we already calculated user-am-limit for this label.\n        if (userAMLimit \u003d\u003d null) {\n          userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n          userAmPartitionLimit.put(partitionName, userAMLimit);\n        }\n\n        Resource userAmIfStarted \u003d Resources.add(\n            application.getAMResource(partitionName),\n            user.getConsumedAMResources(partitionName));\n\n        if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n            userAmIfStarted, userAMLimit)) {\n          if (getNumActiveApplications() \u003c 1 || (Resources.lessThanOrEqual(\n              resourceCalculator, lastClusterResource,\n              queueUsage.getAMUsed(partitionName), Resources.none()))) {\n            LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n                + \" single application in queue for user, it is likely set too\"\n                + \" low. skipping enforcement to allow at least one application\"\n                + \" to start\");\n          } else{\n            application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n                CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n            LOG.info(\n                \"Not activating application \" + applicationId + \" for user: \"\n                    + user + \" as userAmIfStarted: \" + userAmIfStarted\n                    + \" exceeds userAmLimit: \" + userAMLimit);\n            continue;\n          }\n        }\n        user.activateApplication();\n        orderingPolicy.addSchedulableEntity(application);\n        application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n        queueUsage.incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().incAMUsed(partitionName,\n            application.getAMResource(partitionName));\n        user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n        metrics.incAMUsed(application.getUser(),\n            application.getAMResource(partitionName));\n        metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n        fsApp.remove();\n        LOG.info(\"Application \" + applicationId + \" from user: \" + application\n            .getUser() + \" activated in queue: \" + getQueueName());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "f4a57d4a531e793373fe3118d644871a3b9ae0b1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4617. LeafQueue#pendingOrderingPolicy should always use fixed ordering policy instead of using same as active applications ordering policy. Contributed by Rohith Sharma K S\n",
      "commitDate": "29/01/16 12:22 PM",
      "commitName": "f4a57d4a531e793373fe3118d644871a3b9ae0b1",
      "commitAuthor": "Jian He",
      "commitDateOld": "28/01/16 2:51 PM",
      "commitNameOld": "7f46636495e23693d588b0915f464fa7afd9102e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,111 @@\n   private synchronized void activateApplications() {\n     // limit of allowed resource usage for application masters\n     Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n         new HashMap\u003cString, Resource\u003e();\n \n     // AM Resource Limit for accessible labels can be pre-calculated.\n     // This will help in updating AMResourceLimit for all labels when queue\n     // is initialized for the first time (when no applications are present).\n     for (String nodePartition : getNodeLabelsForQueue()) {\n       calculateAndGetAMResourceLimitPerPartition(nodePartition);\n     }\n \n-    activateApplications(getPendingAppsOrderingPolicyRecovery()\n-        .getAssignmentIterator(), userAmPartitionLimit);\n+    for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n+        getPendingAppsOrderingPolicy().getAssignmentIterator();\n+        fsApp.hasNext();) {\n+      FiCaSchedulerApp application \u003d fsApp.next();\n+      ApplicationId applicationId \u003d application.getApplicationId();\n \n-    activateApplications(\n-        getPendingAppsOrderingPolicy().getAssignmentIterator(),\n-        userAmPartitionLimit);\n+      // Get the am-node-partition associated with each application\n+      // and calculate max-am resource limit for this partition.\n+      String partitionName \u003d application.getAppAMNodePartitionName();\n+\n+      Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n+      // Verify whether we already calculated am-limit for this label.\n+      if (amLimit \u003d\u003d null) {\n+        amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n+      }\n+      // Check am resource limit.\n+      Resource amIfStarted \u003d Resources.add(\n+          application.getAMResource(partitionName),\n+          queueUsage.getAMUsed(partitionName));\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n+            + application.getAMResource(partitionName)\n+            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n+            + \" amLimit \" + amLimit + \" lastClusterResource \"\n+            + lastClusterResource + \" amIfStarted \" + amIfStarted\n+            + \" AM node-partition name \" + partitionName);\n+      }\n+\n+      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+          amIfStarted, amLimit)) {\n+        if (getNumActiveApplications() \u003c 1\n+            || (Resources.lessThanOrEqual(resourceCalculator,\n+                lastClusterResource, queueUsage.getAMUsed(partitionName),\n+                Resources.none()))) {\n+          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+              + \" single application in queue, it is likely set too low.\"\n+              + \" skipping enforcement to allow at least one application\"\n+              + \" to start\");\n+        } else {\n+          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n+          LOG.info(\"Not activating application \" + applicationId\n+              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n+              + amLimit);\n+          continue;\n+        }\n+      }\n+\n+      // Check user am resource limit\n+      User user \u003d getUser(application.getUser());\n+      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n+\n+      // Verify whether we already calculated user-am-limit for this label.\n+      if (userAMLimit \u003d\u003d null) {\n+        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n+        userAmPartitionLimit.put(partitionName, userAMLimit);\n+      }\n+\n+      Resource userAmIfStarted \u003d Resources.add(\n+          application.getAMResource(partitionName),\n+          user.getConsumedAMResources(partitionName));\n+\n+      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+          userAmIfStarted, userAMLimit)) {\n+        if (getNumActiveApplications() \u003c 1\n+            || (Resources.lessThanOrEqual(resourceCalculator,\n+                lastClusterResource, queueUsage.getAMUsed(partitionName),\n+                Resources.none()))) {\n+          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+              + \" single application in queue for user, it is likely set too\"\n+              + \" low. skipping enforcement to allow at least one application\"\n+              + \" to start\");\n+        } else {\n+          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n+          LOG.info(\"Not activating application \" + applicationId\n+              + \" for user: \" + user + \" as userAmIfStarted: \"\n+              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n+          continue;\n+        }\n+      }\n+      user.activateApplication();\n+      orderingPolicy.addSchedulableEntity(application);\n+      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n+\n+      queueUsage.incAMUsed(partitionName,\n+          application.getAMResource(partitionName));\n+      user.getResourceUsage().incAMUsed(partitionName,\n+          application.getAMResource(partitionName));\n+      user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n+      metrics.incAMUsed(application.getUser(),\n+          application.getAMResource(partitionName));\n+      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n+      fsApp.remove();\n+      LOG.info(\"Application \" + applicationId + \" from user: \"\n+          + application.getUser() + \" activated in queue: \" + getQueueName());\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    // limit of allowed resource usage for application masters\n    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    // AM Resource Limit for accessible labels can be pre-calculated.\n    // This will help in updating AMResourceLimit for all labels when queue\n    // is initialized for the first time (when no applications are present).\n    for (String nodePartition : getNodeLabelsForQueue()) {\n      calculateAndGetAMResourceLimitPerPartition(nodePartition);\n    }\n\n    for (Iterator\u003cFiCaSchedulerApp\u003e fsApp \u003d\n        getPendingAppsOrderingPolicy().getAssignmentIterator();\n        fsApp.hasNext();) {\n      FiCaSchedulerApp application \u003d fsApp.next();\n      ApplicationId applicationId \u003d application.getApplicationId();\n\n      // Get the am-node-partition associated with each application\n      // and calculate max-am resource limit for this partition.\n      String partitionName \u003d application.getAppAMNodePartitionName();\n\n      Resource amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n      // Verify whether we already calculated am-limit for this label.\n      if (amLimit \u003d\u003d null) {\n        amLimit \u003d calculateAndGetAMResourceLimitPerPartition(partitionName);\n      }\n      // Check am resource limit.\n      Resource amIfStarted \u003d Resources.add(\n          application.getAMResource(partitionName),\n          queueUsage.getAMUsed(partitionName));\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n            + application.getAMResource(partitionName)\n            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n            + \" amLimit \" + amLimit + \" lastClusterResource \"\n            + lastClusterResource + \" amIfStarted \" + amIfStarted\n            + \" AM node-partition name \" + partitionName);\n      }\n\n      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n          amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1\n            || (Resources.lessThanOrEqual(resourceCalculator,\n                lastClusterResource, queueUsage.getAMUsed(partitionName),\n                Resources.none()))) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n              + \" single application in queue, it is likely set too low.\"\n              + \" skipping enforcement to allow at least one application\"\n              + \" to start\");\n        } else {\n          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n          LOG.info(\"Not activating application \" + applicationId\n              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n              + amLimit);\n          continue;\n        }\n      }\n\n      // Check user am resource limit\n      User user \u003d getUser(application.getUser());\n      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n      // Verify whether we already calculated user-am-limit for this label.\n      if (userAMLimit \u003d\u003d null) {\n        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n        userAmPartitionLimit.put(partitionName, userAMLimit);\n      }\n\n      Resource userAmIfStarted \u003d Resources.add(\n          application.getAMResource(partitionName),\n          user.getConsumedAMResources(partitionName));\n\n      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n          userAmIfStarted, userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1\n            || (Resources.lessThanOrEqual(resourceCalculator,\n                lastClusterResource, queueUsage.getAMUsed(partitionName),\n                Resources.none()))) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n              + \" single application in queue for user, it is likely set too\"\n              + \" low. skipping enforcement to allow at least one application\"\n              + \" to start\");\n        } else {\n          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n          LOG.info(\"Not activating application \" + applicationId\n              + \" for user: \" + user + \" as userAmIfStarted: \"\n              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n      queueUsage.incAMUsed(partitionName,\n          application.getAMResource(partitionName));\n      user.getResourceUsage().incAMUsed(partitionName,\n          application.getAMResource(partitionName));\n      user.getResourceUsage().setAMLimit(partitionName, userAMLimit);\n      metrics.incAMUsed(application.getUser(),\n          application.getAMResource(partitionName));\n      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n      fsApp.remove();\n      LOG.info(\"Application \" + applicationId + \" from user: \"\n          + application.getUser() + \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "b08ecf5c7589b055e93b2907413213f36097724d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4304. AM max resource configuration per partition to be displayed/updated correctly in UI and in various partition related metrics. (Sunil G via wangda)\n",
      "commitDate": "17/01/16 7:11 PM",
      "commitName": "b08ecf5c7589b055e93b2907413213f36097724d",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/01/16 3:51 PM",
      "commitNameOld": "109e528ef5d8df07443373751266b4417acc981a",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 9.14,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,19 @@\n   private synchronized void activateApplications() {\n     // limit of allowed resource usage for application masters\n-    Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n         new HashMap\u003cString, Resource\u003e();\n \n+    // AM Resource Limit for accessible labels can be pre-calculated.\n+    // This will help in updating AMResourceLimit for all labels when queue\n+    // is initialized for the first time (when no applications are present).\n+    for (String nodePartition : getNodeLabelsForQueue()) {\n+      calculateAndGetAMResourceLimitPerPartition(nodePartition);\n+    }\n+\n     activateApplications(getPendingAppsOrderingPolicyRecovery()\n-        .getAssignmentIterator(), amPartitionLimit, userAmPartitionLimit);\n+        .getAssignmentIterator(), userAmPartitionLimit);\n \n     activateApplications(\n         getPendingAppsOrderingPolicy().getAssignmentIterator(),\n-        amPartitionLimit, userAmPartitionLimit);\n+        userAmPartitionLimit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    // limit of allowed resource usage for application masters\n    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    // AM Resource Limit for accessible labels can be pre-calculated.\n    // This will help in updating AMResourceLimit for all labels when queue\n    // is initialized for the first time (when no applications are present).\n    for (String nodePartition : getNodeLabelsForQueue()) {\n      calculateAndGetAMResourceLimitPerPartition(nodePartition);\n    }\n\n    activateApplications(getPendingAppsOrderingPolicyRecovery()\n        .getAssignmentIterator(), userAmPartitionLimit);\n\n    activateApplications(\n        getPendingAppsOrderingPolicy().getAssignmentIterator(),\n        userAmPartitionLimit);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "109e528ef5d8df07443373751266b4417acc981a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4479. Change CS LeafQueue pendingOrderingPolicy to hornor recovered apps. Contributed by Rohith Sharma K S\n",
      "commitDate": "08/01/16 3:51 PM",
      "commitName": "109e528ef5d8df07443373751266b4417acc981a",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/12/15 3:30 PM",
      "commitNameOld": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.01,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,13 @@\n   private synchronized void activateApplications() {\n     // limit of allowed resource usage for application masters\n     Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n         new HashMap\u003cString, Resource\u003e();\n \n-    for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n-        .getAssignmentIterator(); i.hasNext();) {\n-      FiCaSchedulerApp application \u003d i.next();\n-      ApplicationId applicationId \u003d application.getApplicationId();\n+    activateApplications(getPendingAppsOrderingPolicyRecovery()\n+        .getAssignmentIterator(), amPartitionLimit, userAmPartitionLimit);\n \n-      // Get the am-node-partition associated with each application\n-      // and calculate max-am resource limit for this partition.\n-      String partitionName \u003d application.getAppAMNodePartitionName();\n-\n-      Resource amLimit \u003d amPartitionLimit.get(partitionName);\n-      // Verify whether we already calculated am-limit for this label.\n-      if (amLimit \u003d\u003d null) {\n-        amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n-        amPartitionLimit.put(partitionName, amLimit);\n-      }\n-      // Check am resource limit.\n-      Resource amIfStarted \u003d Resources.add(\n-          application.getAMResource(partitionName),\n-          queueUsage.getAMUsed(partitionName));\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n-            + application.getAMResource(partitionName)\n-            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n-            + \" amLimit \" + amLimit + \" lastClusterResource \"\n-            + lastClusterResource + \" amIfStarted \" + amIfStarted\n-            + \" AM node-partition name \" + partitionName);\n-      }\n-\n-      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-          amIfStarted, amLimit)) {\n-        if (getNumActiveApplications() \u003c 1\n-            || (Resources.lessThanOrEqual(resourceCalculator,\n-                lastClusterResource, queueUsage.getAMUsed(partitionName),\n-                Resources.none()))) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n-              + \" single application in queue, it is likely set too low.\"\n-              + \" skipping enforcement to allow at least one application\"\n-              + \" to start\");\n-        } else {\n-          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n-              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n-          LOG.info(\"Not activating application \" + applicationId\n-              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n-              + amLimit);\n-          continue;\n-        }\n-      }\n-\n-      // Check user am resource limit\n-      User user \u003d getUser(application.getUser());\n-      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n-\n-      // Verify whether we already calculated user-am-limit for this label.\n-      if (userAMLimit \u003d\u003d null) {\n-        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n-        userAmPartitionLimit.put(partitionName, userAMLimit);\n-      }\n-\n-      Resource userAmIfStarted \u003d Resources.add(\n-          application.getAMResource(partitionName),\n-          user.getConsumedAMResources(partitionName));\n-\n-      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n-          userAmIfStarted, userAMLimit)) {\n-        if (getNumActiveApplications() \u003c 1\n-            || (Resources.lessThanOrEqual(resourceCalculator,\n-                lastClusterResource, queueUsage.getAMUsed(partitionName),\n-                Resources.none()))) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n-              + \" single application in queue for user, it is likely set too\"\n-              + \" low. skipping enforcement to allow at least one application\"\n-              + \" to start\");\n-        } else {\n-          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n-              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n-          LOG.info(\"Not activating application \" + applicationId\n-              + \" for user: \" + user + \" as userAmIfStarted: \"\n-              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n-          continue;\n-        }\n-      }\n-      user.activateApplication();\n-      orderingPolicy.addSchedulableEntity(application);\n-      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n-\n-      queueUsage.incAMUsed(partitionName,\n-          application.getAMResource(partitionName));\n-      user.getResourceUsage().incAMUsed(partitionName,\n-          application.getAMResource(partitionName));\n-      metrics.incAMUsed(application.getUser(),\n-          application.getAMResource(partitionName));\n-      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n-      i.remove();\n-      LOG.info(\"Application \" + applicationId + \" from user: \"\n-          + application.getUser() + \" activated in queue: \" + getQueueName());\n-    }\n+    activateApplications(\n+        getPendingAppsOrderingPolicy().getAssignmentIterator(),\n+        amPartitionLimit, userAmPartitionLimit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    // limit of allowed resource usage for application masters\n    Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    activateApplications(getPendingAppsOrderingPolicyRecovery()\n        .getAssignmentIterator(), amPartitionLimit, userAmPartitionLimit);\n\n    activateApplications(\n        getPendingAppsOrderingPolicy().getAssignmentIterator(),\n        amPartitionLimit, userAmPartitionLimit);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app\u0027s diagnostic message. (Naganarasimha G R via wangda)\n",
      "commitDate": "14/12/15 10:52 AM",
      "commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "20/11/15 3:55 PM",
      "commitNameOld": "2346fa3141bf28f25a90b6a426a1d3a3982e464f",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 23.79,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,104 @@\n   private synchronized void activateApplications() {\n     // limit of allowed resource usage for application masters\n     Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n         new HashMap\u003cString, Resource\u003e();\n \n     for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n         .getAssignmentIterator(); i.hasNext();) {\n       FiCaSchedulerApp application \u003d i.next();\n       ApplicationId applicationId \u003d application.getApplicationId();\n \n       // Get the am-node-partition associated with each application\n       // and calculate max-am resource limit for this partition.\n       String partitionName \u003d application.getAppAMNodePartitionName();\n \n       Resource amLimit \u003d amPartitionLimit.get(partitionName);\n       // Verify whether we already calculated am-limit for this label.\n       if (amLimit \u003d\u003d null) {\n         amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n         amPartitionLimit.put(partitionName, amLimit);\n       }\n       // Check am resource limit.\n       Resource amIfStarted \u003d Resources.add(\n           application.getAMResource(partitionName),\n           queueUsage.getAMUsed(partitionName));\n \n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"application AMResource \"\n+        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n             + application.getAMResource(partitionName)\n             + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n             + \" amLimit \" + amLimit + \" lastClusterResource \"\n             + lastClusterResource + \" amIfStarted \" + amIfStarted\n             + \" AM node-partition name \" + partitionName);\n       }\n \n       if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n           amIfStarted, amLimit)) {\n         if (getNumActiveApplications() \u003c 1\n             || (Resources.lessThanOrEqual(resourceCalculator,\n                 lastClusterResource, queueUsage.getAMUsed(partitionName),\n                 Resources.none()))) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n               + \" single application in queue, it is likely set too low.\"\n               + \" skipping enforcement to allow at least one application\"\n               + \" to start\");\n         } else {\n+          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n           LOG.info(\"Not activating application \" + applicationId\n               + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n               + amLimit);\n           continue;\n         }\n       }\n \n       // Check user am resource limit\n       User user \u003d getUser(application.getUser());\n       Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n \n       // Verify whether we already calculated user-am-limit for this label.\n       if (userAMLimit \u003d\u003d null) {\n         userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n         userAmPartitionLimit.put(partitionName, userAMLimit);\n       }\n \n       Resource userAmIfStarted \u003d Resources.add(\n           application.getAMResource(partitionName),\n           user.getConsumedAMResources(partitionName));\n \n       if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n           userAmIfStarted, userAMLimit)) {\n         if (getNumActiveApplications() \u003c 1\n             || (Resources.lessThanOrEqual(resourceCalculator,\n                 lastClusterResource, queueUsage.getAMUsed(partitionName),\n                 Resources.none()))) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n               + \" single application in queue for user, it is likely set too\"\n               + \" low. skipping enforcement to allow at least one application\"\n               + \" to start\");\n         } else {\n+          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n+              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n           LOG.info(\"Not activating application \" + applicationId\n               + \" for user: \" + user + \" as userAmIfStarted: \"\n               + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n           continue;\n         }\n       }\n       user.activateApplication();\n       orderingPolicy.addSchedulableEntity(application);\n+      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n+\n       queueUsage.incAMUsed(partitionName,\n           application.getAMResource(partitionName));\n       user.getResourceUsage().incAMUsed(partitionName,\n           application.getAMResource(partitionName));\n       metrics.incAMUsed(application.getUser(),\n           application.getAMResource(partitionName));\n       metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n       i.remove();\n       LOG.info(\"Application \" + applicationId + \" from user: \"\n           + application.getUser() + \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    // limit of allowed resource usage for application masters\n    Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n        .getAssignmentIterator(); i.hasNext();) {\n      FiCaSchedulerApp application \u003d i.next();\n      ApplicationId applicationId \u003d application.getApplicationId();\n\n      // Get the am-node-partition associated with each application\n      // and calculate max-am resource limit for this partition.\n      String partitionName \u003d application.getAppAMNodePartitionName();\n\n      Resource amLimit \u003d amPartitionLimit.get(partitionName);\n      // Verify whether we already calculated am-limit for this label.\n      if (amLimit \u003d\u003d null) {\n        amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        amPartitionLimit.put(partitionName, amLimit);\n      }\n      // Check am resource limit.\n      Resource amIfStarted \u003d Resources.add(\n          application.getAMResource(partitionName),\n          queueUsage.getAMUsed(partitionName));\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application \"+application.getId() +\" AMResource \"\n            + application.getAMResource(partitionName)\n            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n            + \" amLimit \" + amLimit + \" lastClusterResource \"\n            + lastClusterResource + \" amIfStarted \" + amIfStarted\n            + \" AM node-partition name \" + partitionName);\n      }\n\n      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n          amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1\n            || (Resources.lessThanOrEqual(resourceCalculator,\n                lastClusterResource, queueUsage.getAMUsed(partitionName),\n                Resources.none()))) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n              + \" single application in queue, it is likely set too low.\"\n              + \" skipping enforcement to allow at least one application\"\n              + \" to start\");\n        } else {\n          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n              CSAMContainerLaunchDiagnosticsConstants.QUEUE_AM_RESOURCE_LIMIT_EXCEED);\n          LOG.info(\"Not activating application \" + applicationId\n              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n              + amLimit);\n          continue;\n        }\n      }\n\n      // Check user am resource limit\n      User user \u003d getUser(application.getUser());\n      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n      // Verify whether we already calculated user-am-limit for this label.\n      if (userAMLimit \u003d\u003d null) {\n        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n        userAmPartitionLimit.put(partitionName, userAMLimit);\n      }\n\n      Resource userAmIfStarted \u003d Resources.add(\n          application.getAMResource(partitionName),\n          user.getConsumedAMResources(partitionName));\n\n      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n          userAmIfStarted, userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1\n            || (Resources.lessThanOrEqual(resourceCalculator,\n                lastClusterResource, queueUsage.getAMUsed(partitionName),\n                Resources.none()))) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n              + \" single application in queue for user, it is likely set too\"\n              + \" low. skipping enforcement to allow at least one application\"\n              + \" to start\");\n        } else {\n          application.updateAMContainerDiagnostics(AMState.INACTIVATED,\n              CSAMContainerLaunchDiagnosticsConstants.USER_AM_RESOURCE_LIMIT_EXCEED);\n          LOG.info(\"Not activating application \" + applicationId\n              + \" for user: \" + user + \" as userAmIfStarted: \"\n              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      application.updateAMContainerDiagnostics(AMState.ACTIVATED, null);\n\n      queueUsage.incAMUsed(partitionName,\n          application.getAMResource(partitionName));\n      user.getResourceUsage().incAMUsed(partitionName,\n          application.getAMResource(partitionName));\n      metrics.incAMUsed(application.getUser(),\n          application.getAMResource(partitionName));\n      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n      i.remove();\n      LOG.info(\"Application \" + applicationId + \" from user: \"\n          + application.getUser() + \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "56e4f6237ae8b1852e82b186e08db3934f79a9db": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3216. Max-AM-Resource-Percentage should respect node labels. (Sunil G via wangda)\n",
      "commitDate": "26/10/15 4:44 PM",
      "commitName": "56e4f6237ae8b1852e82b186e08db3934f79a9db",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/10/15 1:07 PM",
      "commitNameOld": "3cc73773eb26f7469c99b25a76814d6fad0be28e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,98 @@\n   private synchronized void activateApplications() {\n-    //limit of allowed resource usage for application masters\n-    Resource amLimit \u003d getAMResourceLimit();\n-    Resource userAMLimit \u003d getUserAMResourceLimit();\n-        \n+    // limit of allowed resource usage for application masters\n+    Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n+    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n+        new HashMap\u003cString, Resource\u003e();\n+\n     for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n         .getAssignmentIterator(); i.hasNext();) {\n       FiCaSchedulerApp application \u003d i.next();\n       ApplicationId applicationId \u003d application.getApplicationId();\n-      // Check am resource limit\n-      Resource amIfStarted \u003d \n-        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n-      \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"application AMResource \" + application.getAMResource() +\n-          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n-          \" amLimit \" + amLimit +\n-          \" lastClusterResource \" + lastClusterResource +\n-          \" amIfStarted \" + amIfStarted);\n+\n+      // Get the am-node-partition associated with each application\n+      // and calculate max-am resource limit for this partition.\n+      String partitionName \u003d application.getAppAMNodePartitionName();\n+\n+      Resource amLimit \u003d amPartitionLimit.get(partitionName);\n+      // Verify whether we already calculated am-limit for this label.\n+      if (amLimit \u003d\u003d null) {\n+        amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n+        amPartitionLimit.put(partitionName, amLimit);\n       }\n-      \n-      if (!Resources.lessThanOrEqual(\n-        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n-        if (getNumActiveApplications() \u003c 1) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n-            \" single application in queue, it is likely set too low.\" +\n-            \" skipping enforcement to allow at least one application to start\"); \n+      // Check am resource limit.\n+      Resource amIfStarted \u003d Resources.add(\n+          application.getAMResource(partitionName),\n+          queueUsage.getAMUsed(partitionName));\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"application AMResource \"\n+            + application.getAMResource(partitionName)\n+            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n+            + \" amLimit \" + amLimit + \" lastClusterResource \"\n+            + lastClusterResource + \" amIfStarted \" + amIfStarted\n+            + \" AM node-partition name \" + partitionName);\n+      }\n+\n+      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+          amIfStarted, amLimit)) {\n+        if (getNumActiveApplications() \u003c 1\n+            || (Resources.lessThanOrEqual(resourceCalculator,\n+                lastClusterResource, queueUsage.getAMUsed(partitionName),\n+                Resources.none()))) {\n+          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+              + \" single application in queue, it is likely set too low.\"\n+              + \" skipping enforcement to allow at least one application\"\n+              + \" to start\");\n         } else {\n           LOG.info(\"Not activating application \" + applicationId\n               + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n               + amLimit);\n           continue;\n         }\n       }\n-      \n+\n       // Check user am resource limit\n-      \n       User user \u003d getUser(application.getUser());\n-      \n-      Resource userAmIfStarted \u003d \n-        Resources.add(application.getAMResource(),\n-          user.getConsumedAMResources());\n-        \n-      if (!Resources.lessThanOrEqual(\n-          resourceCalculator, lastClusterResource, userAmIfStarted, \n-          userAMLimit)) {\n-        if (getNumActiveApplications() \u003c 1) {\n-          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n-            \" single application in queue for user, it is likely set too low.\" +\n-            \" skipping enforcement to allow at least one application to start\"); \n+      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n+\n+      // Verify whether we already calculated user-am-limit for this label.\n+      if (userAMLimit \u003d\u003d null) {\n+        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n+        userAmPartitionLimit.put(partitionName, userAMLimit);\n+      }\n+\n+      Resource userAmIfStarted \u003d Resources.add(\n+          application.getAMResource(partitionName),\n+          user.getConsumedAMResources(partitionName));\n+\n+      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n+          userAmIfStarted, userAMLimit)) {\n+        if (getNumActiveApplications() \u003c 1\n+            || (Resources.lessThanOrEqual(resourceCalculator,\n+                lastClusterResource, queueUsage.getAMUsed(partitionName),\n+                Resources.none()))) {\n+          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n+              + \" single application in queue for user, it is likely set too\"\n+              + \" low. skipping enforcement to allow at least one application\"\n+              + \" to start\");\n         } else {\n           LOG.info(\"Not activating application \" + applicationId\n               + \" for user: \" + user + \" as userAmIfStarted: \"\n               + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n           continue;\n         }\n       }\n       user.activateApplication();\n       orderingPolicy.addSchedulableEntity(application);\n-      queueUsage.incAMUsed(application.getAMResource());\n-      user.getResourceUsage().incAMUsed(application.getAMResource());\n-      metrics.incAMUsed(application.getUser(), application.getAMResource());\n+      queueUsage.incAMUsed(partitionName,\n+          application.getAMResource(partitionName));\n+      user.getResourceUsage().incAMUsed(partitionName,\n+          application.getAMResource(partitionName));\n+      metrics.incAMUsed(application.getUser(),\n+          application.getAMResource(partitionName));\n       metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n       i.remove();\n       LOG.info(\"Application \" + applicationId + \" from user: \"\n           + application.getUser() + \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    // limit of allowed resource usage for application masters\n    Map\u003cString, Resource\u003e amPartitionLimit \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e userAmPartitionLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n        .getAssignmentIterator(); i.hasNext();) {\n      FiCaSchedulerApp application \u003d i.next();\n      ApplicationId applicationId \u003d application.getApplicationId();\n\n      // Get the am-node-partition associated with each application\n      // and calculate max-am resource limit for this partition.\n      String partitionName \u003d application.getAppAMNodePartitionName();\n\n      Resource amLimit \u003d amPartitionLimit.get(partitionName);\n      // Verify whether we already calculated am-limit for this label.\n      if (amLimit \u003d\u003d null) {\n        amLimit \u003d getAMResourceLimitPerPartition(partitionName);\n        amPartitionLimit.put(partitionName, amLimit);\n      }\n      // Check am resource limit.\n      Resource amIfStarted \u003d Resources.add(\n          application.getAMResource(partitionName),\n          queueUsage.getAMUsed(partitionName));\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \"\n            + application.getAMResource(partitionName)\n            + \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent\n            + \" amLimit \" + amLimit + \" lastClusterResource \"\n            + lastClusterResource + \" amIfStarted \" + amIfStarted\n            + \" AM node-partition name \" + partitionName);\n      }\n\n      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n          amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1\n            || (Resources.lessThanOrEqual(resourceCalculator,\n                lastClusterResource, queueUsage.getAMUsed(partitionName),\n                Resources.none()))) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n              + \" single application in queue, it is likely set too low.\"\n              + \" skipping enforcement to allow at least one application\"\n              + \" to start\");\n        } else {\n          LOG.info(\"Not activating application \" + applicationId\n              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n              + amLimit);\n          continue;\n        }\n      }\n\n      // Check user am resource limit\n      User user \u003d getUser(application.getUser());\n      Resource userAMLimit \u003d userAmPartitionLimit.get(partitionName);\n\n      // Verify whether we already calculated user-am-limit for this label.\n      if (userAMLimit \u003d\u003d null) {\n        userAMLimit \u003d getUserAMResourceLimitPerPartition(partitionName);\n        userAmPartitionLimit.put(partitionName, userAMLimit);\n      }\n\n      Resource userAmIfStarted \u003d Resources.add(\n          application.getAMResource(partitionName),\n          user.getConsumedAMResources(partitionName));\n\n      if (!Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,\n          userAmIfStarted, userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1\n            || (Resources.lessThanOrEqual(resourceCalculator,\n                lastClusterResource, queueUsage.getAMUsed(partitionName),\n                Resources.none()))) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\"\n              + \" single application in queue for user, it is likely set too\"\n              + \" low. skipping enforcement to allow at least one application\"\n              + \" to start\");\n        } else {\n          LOG.info(\"Not activating application \" + applicationId\n              + \" for user: \" + user + \" as userAmIfStarted: \"\n              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      queueUsage.incAMUsed(partitionName,\n          application.getAMResource(partitionName));\n      user.getResourceUsage().incAMUsed(partitionName,\n          application.getAMResource(partitionName));\n      metrics.incAMUsed(application.getUser(),\n          application.getAMResource(partitionName));\n      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n      i.remove();\n      LOG.info(\"Application \" + applicationId + \" from user: \"\n          + application.getUser() + \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "cf9d3c925608e8bc650d43975382ed3014081057": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3873. PendingApplications in LeafQueue should also use OrderingPolicy. (Sunil G via wangda)\n",
      "commitDate": "10/08/15 2:54 PM",
      "commitName": "cf9d3c925608e8bc650d43975382ed3014081057",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/08/15 9:46 AM",
      "commitNameOld": "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private synchronized void activateApplications() {\n     //limit of allowed resource usage for application masters\n     Resource amLimit \u003d getAMResourceLimit();\n     Resource userAMLimit \u003d getUserAMResourceLimit();\n         \n-    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n-         i.hasNext(); ) {\n+    for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n+        .getAssignmentIterator(); i.hasNext();) {\n       FiCaSchedulerApp application \u003d i.next();\n       ApplicationId applicationId \u003d application.getApplicationId();\n       // Check am resource limit\n       Resource amIfStarted \u003d \n         Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n       \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"application AMResource \" + application.getAMResource() +\n           \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n           \" amLimit \" + amLimit +\n           \" lastClusterResource \" + lastClusterResource +\n           \" amIfStarted \" + amIfStarted);\n       }\n       \n       if (!Resources.lessThanOrEqual(\n         resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"Not activating application \" + applicationId\n               + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n               + amLimit);\n           continue;\n         }\n       }\n       \n       // Check user am resource limit\n       \n       User user \u003d getUser(application.getUser());\n       \n       Resource userAmIfStarted \u003d \n         Resources.add(application.getAMResource(),\n           user.getConsumedAMResources());\n         \n       if (!Resources.lessThanOrEqual(\n           resourceCalculator, lastClusterResource, userAmIfStarted, \n           userAMLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue for user, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"Not activating application \" + applicationId\n               + \" for user: \" + user + \" as userAmIfStarted: \"\n               + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n           continue;\n         }\n       }\n       user.activateApplication();\n       orderingPolicy.addSchedulableEntity(application);\n       queueUsage.incAMUsed(application.getAMResource());\n       user.getResourceUsage().incAMUsed(application.getAMResource());\n       metrics.incAMUsed(application.getUser(), application.getAMResource());\n       metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n       i.remove();\n       LOG.info(\"Application \" + applicationId + \" from user: \"\n           + application.getUser() + \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    //limit of allowed resource usage for application masters\n    Resource amLimit \u003d getAMResourceLimit();\n    Resource userAMLimit \u003d getUserAMResourceLimit();\n        \n    for (Iterator\u003cFiCaSchedulerApp\u003e i \u003d getPendingAppsOrderingPolicy()\n        .getAssignmentIterator(); i.hasNext();) {\n      FiCaSchedulerApp application \u003d i.next();\n      ApplicationId applicationId \u003d application.getApplicationId();\n      // Check am resource limit\n      Resource amIfStarted \u003d \n        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \" + application.getAMResource() +\n          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n          \" amLimit \" + amLimit +\n          \" lastClusterResource \" + lastClusterResource +\n          \" amIfStarted \" + amIfStarted);\n      }\n      \n      if (!Resources.lessThanOrEqual(\n        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"Not activating application \" + applicationId\n              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n              + amLimit);\n          continue;\n        }\n      }\n      \n      // Check user am resource limit\n      \n      User user \u003d getUser(application.getUser());\n      \n      Resource userAmIfStarted \u003d \n        Resources.add(application.getAMResource(),\n          user.getConsumedAMResources());\n        \n      if (!Resources.lessThanOrEqual(\n          resourceCalculator, lastClusterResource, userAmIfStarted, \n          userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue for user, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"Not activating application \" + applicationId\n              + \" for user: \" + user + \" as userAmIfStarted: \"\n              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      queueUsage.incAMUsed(application.getAMResource());\n      user.getResourceUsage().incAMUsed(application.getAMResource());\n      metrics.incAMUsed(application.getUser(), application.getAMResource());\n      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n      i.remove();\n      LOG.info(\"Application \" + applicationId + \" from user: \"\n          + application.getUser() + \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "b039e69bb03accef485361af301fa59f03d08d6a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3789. Improve logs for LeafQueue#activateApplications(). Contributed\nby Bibin A Chundatt.\n",
      "commitDate": "16/06/15 1:33 AM",
      "commitName": "b039e69bb03accef485361af301fa59f03d08d6a",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "07/05/15 5:35 PM",
      "commitNameOld": "f489a4ec969f3727d03c8e85d51af1018fc0b2a1",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 39.33,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   private synchronized void activateApplications() {\n     //limit of allowed resource usage for application masters\n     Resource amLimit \u003d getAMResourceLimit();\n     Resource userAMLimit \u003d getUserAMResourceLimit();\n         \n     for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n       FiCaSchedulerApp application \u003d i.next();\n-      \n+      ApplicationId applicationId \u003d application.getApplicationId();\n       // Check am resource limit\n       Resource amIfStarted \u003d \n         Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n       \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"application AMResource \" + application.getAMResource() +\n           \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n           \" amLimit \" + amLimit +\n           \" lastClusterResource \" + lastClusterResource +\n           \" amIfStarted \" + amIfStarted);\n       }\n       \n       if (!Resources.lessThanOrEqual(\n         resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n-          LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n+          LOG.info(\"Not activating application \" + applicationId\n+              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n+              + amLimit);\n           continue;\n         }\n       }\n       \n       // Check user am resource limit\n       \n       User user \u003d getUser(application.getUser());\n       \n       Resource userAmIfStarted \u003d \n         Resources.add(application.getAMResource(),\n           user.getConsumedAMResources());\n         \n       if (!Resources.lessThanOrEqual(\n           resourceCalculator, lastClusterResource, userAmIfStarted, \n           userAMLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue for user, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n-          LOG.info(\"not starting application as amIfStarted exceeds \" +\n-            \"userAmLimit\");\n+          LOG.info(\"Not activating application \" + applicationId\n+              + \" for user: \" + user + \" as userAmIfStarted: \"\n+              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n           continue;\n         }\n       }\n       user.activateApplication();\n       orderingPolicy.addSchedulableEntity(application);\n       queueUsage.incAMUsed(application.getAMResource());\n       user.getResourceUsage().incAMUsed(application.getAMResource());\n       metrics.incAMUsed(application.getUser(), application.getAMResource());\n       metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n       i.remove();\n-      LOG.info(\"Application \" + application.getApplicationId() +\n-          \" from user: \" + application.getUser() + \n-          \" activated in queue: \" + getQueueName());\n+      LOG.info(\"Application \" + applicationId + \" from user: \"\n+          + application.getUser() + \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    //limit of allowed resource usage for application masters\n    Resource amLimit \u003d getAMResourceLimit();\n    Resource userAMLimit \u003d getUserAMResourceLimit();\n        \n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      ApplicationId applicationId \u003d application.getApplicationId();\n      // Check am resource limit\n      Resource amIfStarted \u003d \n        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \" + application.getAMResource() +\n          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n          \" amLimit \" + amLimit +\n          \" lastClusterResource \" + lastClusterResource +\n          \" amIfStarted \" + amIfStarted);\n      }\n      \n      if (!Resources.lessThanOrEqual(\n        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"Not activating application \" + applicationId\n              + \" as  amIfStarted: \" + amIfStarted + \" exceeds amLimit: \"\n              + amLimit);\n          continue;\n        }\n      }\n      \n      // Check user am resource limit\n      \n      User user \u003d getUser(application.getUser());\n      \n      Resource userAmIfStarted \u003d \n        Resources.add(application.getAMResource(),\n          user.getConsumedAMResources());\n        \n      if (!Resources.lessThanOrEqual(\n          resourceCalculator, lastClusterResource, userAmIfStarted, \n          userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue for user, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"Not activating application \" + applicationId\n              + \" for user: \" + user + \" as userAmIfStarted: \"\n              + userAmIfStarted + \" exceeds userAmLimit: \" + userAMLimit);\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      queueUsage.incAMUsed(application.getAMResource());\n      user.getResourceUsage().incAMUsed(application.getAMResource());\n      metrics.incAMUsed(application.getUser(), application.getAMResource());\n      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n      i.remove();\n      LOG.info(\"Application \" + applicationId + \" from user: \"\n          + application.getUser() + \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "bdd90110e6904b59746812d9a093924a65e72280": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3494. Expose AM resource limit and usage in CS QueueMetrics. Contributed by Rohith Sharmaks\n",
      "commitDate": "21/04/15 8:06 PM",
      "commitName": "bdd90110e6904b59746812d9a093924a65e72280",
      "commitAuthor": "Jian He",
      "commitDateOld": "20/04/15 5:12 PM",
      "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   private synchronized void activateApplications() {\n     //limit of allowed resource usage for application masters\n     Resource amLimit \u003d getAMResourceLimit();\n     Resource userAMLimit \u003d getUserAMResourceLimit();\n         \n     for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n       FiCaSchedulerApp application \u003d i.next();\n       \n       // Check am resource limit\n       Resource amIfStarted \u003d \n         Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n       \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"application AMResource \" + application.getAMResource() +\n           \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n           \" amLimit \" + amLimit +\n           \" lastClusterResource \" + lastClusterResource +\n           \" amIfStarted \" + amIfStarted);\n       }\n       \n       if (!Resources.lessThanOrEqual(\n         resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n           continue;\n         }\n       }\n       \n       // Check user am resource limit\n       \n       User user \u003d getUser(application.getUser());\n       \n       Resource userAmIfStarted \u003d \n         Resources.add(application.getAMResource(),\n           user.getConsumedAMResources());\n         \n       if (!Resources.lessThanOrEqual(\n           resourceCalculator, lastClusterResource, userAmIfStarted, \n           userAMLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue for user, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"not starting application as amIfStarted exceeds \" +\n             \"userAmLimit\");\n           continue;\n         }\n       }\n       user.activateApplication();\n       orderingPolicy.addSchedulableEntity(application);\n       queueUsage.incAMUsed(application.getAMResource());\n       user.getResourceUsage().incAMUsed(application.getAMResource());\n+      metrics.incAMUsed(application.getUser(), application.getAMResource());\n+      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n       i.remove();\n       LOG.info(\"Application \" + application.getApplicationId() +\n           \" from user: \" + application.getUser() + \n           \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    //limit of allowed resource usage for application masters\n    Resource amLimit \u003d getAMResourceLimit();\n    Resource userAMLimit \u003d getUserAMResourceLimit();\n        \n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      \n      // Check am resource limit\n      Resource amIfStarted \u003d \n        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \" + application.getAMResource() +\n          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n          \" amLimit \" + amLimit +\n          \" lastClusterResource \" + lastClusterResource +\n          \" amIfStarted \" + amIfStarted);\n      }\n      \n      if (!Resources.lessThanOrEqual(\n        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n          continue;\n        }\n      }\n      \n      // Check user am resource limit\n      \n      User user \u003d getUser(application.getUser());\n      \n      Resource userAmIfStarted \u003d \n        Resources.add(application.getAMResource(),\n          user.getConsumedAMResources());\n        \n      if (!Resources.lessThanOrEqual(\n          resourceCalculator, lastClusterResource, userAmIfStarted, \n          userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue for user, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds \" +\n            \"userAmLimit\");\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      queueUsage.incAMUsed(application.getAMResource());\n      user.getResourceUsage().incAMUsed(application.getAMResource());\n      metrics.incAMUsed(application.getUser(), application.getAMResource());\n      metrics.setAMResouceLimitForUser(application.getUser(), userAMLimit);\n      i.remove();\n      LOG.info(\"Application \" + application.getApplicationId() +\n          \" from user: \" + application.getUser() + \n          \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3463. Integrate OrderingPolicy Framework with CapacityScheduler. (Craig Welch via wangda)\n",
      "commitDate": "20/04/15 5:12 PM",
      "commitName": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/04/15 1:36 PM",
      "commitNameOld": "d573f09fb93dbb711d504620af5d73840ea063a6",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.15,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private synchronized void activateApplications() {\n     //limit of allowed resource usage for application masters\n     Resource amLimit \u003d getAMResourceLimit();\n     Resource userAMLimit \u003d getUserAMResourceLimit();\n         \n     for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n       FiCaSchedulerApp application \u003d i.next();\n       \n       // Check am resource limit\n       Resource amIfStarted \u003d \n         Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n       \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"application AMResource \" + application.getAMResource() +\n           \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n           \" amLimit \" + amLimit +\n           \" lastClusterResource \" + lastClusterResource +\n           \" amIfStarted \" + amIfStarted);\n       }\n       \n       if (!Resources.lessThanOrEqual(\n         resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n           continue;\n         }\n       }\n       \n       // Check user am resource limit\n       \n       User user \u003d getUser(application.getUser());\n       \n       Resource userAmIfStarted \u003d \n         Resources.add(application.getAMResource(),\n           user.getConsumedAMResources());\n         \n       if (!Resources.lessThanOrEqual(\n           resourceCalculator, lastClusterResource, userAmIfStarted, \n           userAMLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue for user, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"not starting application as amIfStarted exceeds \" +\n             \"userAmLimit\");\n           continue;\n         }\n       }\n       user.activateApplication();\n-      activeApplications.add(application);\n+      orderingPolicy.addSchedulableEntity(application);\n       queueUsage.incAMUsed(application.getAMResource());\n       user.getResourceUsage().incAMUsed(application.getAMResource());\n       i.remove();\n       LOG.info(\"Application \" + application.getApplicationId() +\n           \" from user: \" + application.getUser() + \n           \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    //limit of allowed resource usage for application masters\n    Resource amLimit \u003d getAMResourceLimit();\n    Resource userAMLimit \u003d getUserAMResourceLimit();\n        \n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      \n      // Check am resource limit\n      Resource amIfStarted \u003d \n        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \" + application.getAMResource() +\n          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n          \" amLimit \" + amLimit +\n          \" lastClusterResource \" + lastClusterResource +\n          \" amIfStarted \" + amIfStarted);\n      }\n      \n      if (!Resources.lessThanOrEqual(\n        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n          continue;\n        }\n      }\n      \n      // Check user am resource limit\n      \n      User user \u003d getUser(application.getUser());\n      \n      Resource userAmIfStarted \u003d \n        Resources.add(application.getAMResource(),\n          user.getConsumedAMResources());\n        \n      if (!Resources.lessThanOrEqual(\n          resourceCalculator, lastClusterResource, userAmIfStarted, \n          userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue for user, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds \" +\n            \"userAmLimit\");\n          continue;\n        }\n      }\n      user.activateApplication();\n      orderingPolicy.addSchedulableEntity(application);\n      queueUsage.incAMUsed(application.getAMResource());\n      user.getResourceUsage().incAMUsed(application.getAMResource());\n      i.remove();\n      LOG.info(\"Application \" + application.getApplicationId() +\n          \" from user: \" + application.getUser() + \n          \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "86358221fc85a7743052a0b4c1647353508bf308": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3099. Capacity Scheduler LeafQueue/ParentQueue should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "30/01/15 3:15 PM",
      "commitName": "86358221fc85a7743052a0b4c1647353508bf308",
      "commitAuthor": "Jian He",
      "commitDateOld": "27/01/15 3:36 PM",
      "commitNameOld": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,64 @@\n   private synchronized void activateApplications() {\n     //limit of allowed resource usage for application masters\n     Resource amLimit \u003d getAMResourceLimit();\n     Resource userAMLimit \u003d getUserAMResourceLimit();\n         \n     for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n       FiCaSchedulerApp application \u003d i.next();\n       \n       // Check am resource limit\n       Resource amIfStarted \u003d \n-        Resources.add(application.getAMResource(), usedAMResources);\n+        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n       \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"application AMResource \" + application.getAMResource() +\n           \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n           \" amLimit \" + amLimit +\n           \" lastClusterResource \" + lastClusterResource +\n           \" amIfStarted \" + amIfStarted);\n       }\n       \n       if (!Resources.lessThanOrEqual(\n         resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n           continue;\n         }\n       }\n       \n       // Check user am resource limit\n       \n       User user \u003d getUser(application.getUser());\n       \n       Resource userAmIfStarted \u003d \n         Resources.add(application.getAMResource(),\n           user.getConsumedAMResources());\n         \n       if (!Resources.lessThanOrEqual(\n           resourceCalculator, lastClusterResource, userAmIfStarted, \n           userAMLimit)) {\n         if (getNumActiveApplications() \u003c 1) {\n           LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n             \" single application in queue for user, it is likely set too low.\" +\n             \" skipping enforcement to allow at least one application to start\"); \n         } else {\n           LOG.info(\"not starting application as amIfStarted exceeds \" +\n             \"userAmLimit\");\n           continue;\n         }\n       }\n       user.activateApplication();\n       activeApplications.add(application);\n-      Resources.addTo(usedAMResources, application.getAMResource());\n-      Resources.addTo(user.getConsumedAMResources(), \n-        application.getAMResource());\n+      queueUsage.incAMUsed(application.getAMResource());\n+      user.getResourceUsage().incAMUsed(application.getAMResource());\n       i.remove();\n       LOG.info(\"Application \" + application.getApplicationId() +\n           \" from user: \" + application.getUser() + \n           \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    //limit of allowed resource usage for application masters\n    Resource amLimit \u003d getAMResourceLimit();\n    Resource userAMLimit \u003d getUserAMResourceLimit();\n        \n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      \n      // Check am resource limit\n      Resource amIfStarted \u003d \n        Resources.add(application.getAMResource(), queueUsage.getAMUsed());\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \" + application.getAMResource() +\n          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n          \" amLimit \" + amLimit +\n          \" lastClusterResource \" + lastClusterResource +\n          \" amIfStarted \" + amIfStarted);\n      }\n      \n      if (!Resources.lessThanOrEqual(\n        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n          continue;\n        }\n      }\n      \n      // Check user am resource limit\n      \n      User user \u003d getUser(application.getUser());\n      \n      Resource userAmIfStarted \u003d \n        Resources.add(application.getAMResource(),\n          user.getConsumedAMResources());\n        \n      if (!Resources.lessThanOrEqual(\n          resourceCalculator, lastClusterResource, userAmIfStarted, \n          userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue for user, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds \" +\n            \"userAmLimit\");\n          continue;\n        }\n      }\n      user.activateApplication();\n      activeApplications.add(application);\n      queueUsage.incAMUsed(application.getAMResource());\n      user.getResourceUsage().incAMUsed(application.getAMResource());\n      i.remove();\n      LOG.info(\"Application \" + application.getApplicationId() +\n          \" from user: \" + application.getUser() + \n          \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "c53420f58364b11fbda1dace7679d45534533382": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2637. Fixed max-am-resource-percent calculation in CapacityScheduler when activating applications. Contributed by Craig Welch\n",
      "commitDate": "13/01/15 5:32 PM",
      "commitName": "c53420f58364b11fbda1dace7679d45534533382",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/01/15 2:15 PM",
      "commitNameOld": "dd57c2047bfd21910acc38c98153eedf1db75169",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.14,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,65 @@\n   private synchronized void activateApplications() {\n+    //limit of allowed resource usage for application masters\n+    Resource amLimit \u003d getAMResourceLimit();\n+    Resource userAMLimit \u003d getUserAMResourceLimit();\n+        \n     for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n       FiCaSchedulerApp application \u003d i.next();\n       \n-      // Check queue limit\n-      if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n-        break;\n+      // Check am resource limit\n+      Resource amIfStarted \u003d \n+        Resources.add(application.getAMResource(), usedAMResources);\n+      \n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"application AMResource \" + application.getAMResource() +\n+          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n+          \" amLimit \" + amLimit +\n+          \" lastClusterResource \" + lastClusterResource +\n+          \" amIfStarted \" + amIfStarted);\n       }\n       \n-      // Check user limit\n-      User user \u003d getUser(application.getUser());\n-      if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n-        user.activateApplication();\n-        activeApplications.add(application);\n-        i.remove();\n-        LOG.info(\"Application \" + application.getApplicationId() +\n-            \" from user: \" + application.getUser() + \n-            \" activated in queue: \" + getQueueName());\n+      if (!Resources.lessThanOrEqual(\n+        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n+        if (getNumActiveApplications() \u003c 1) {\n+          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n+            \" single application in queue, it is likely set too low.\" +\n+            \" skipping enforcement to allow at least one application to start\"); \n+        } else {\n+          LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n+          continue;\n+        }\n       }\n+      \n+      // Check user am resource limit\n+      \n+      User user \u003d getUser(application.getUser());\n+      \n+      Resource userAmIfStarted \u003d \n+        Resources.add(application.getAMResource(),\n+          user.getConsumedAMResources());\n+        \n+      if (!Resources.lessThanOrEqual(\n+          resourceCalculator, lastClusterResource, userAmIfStarted, \n+          userAMLimit)) {\n+        if (getNumActiveApplications() \u003c 1) {\n+          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n+            \" single application in queue for user, it is likely set too low.\" +\n+            \" skipping enforcement to allow at least one application to start\"); \n+        } else {\n+          LOG.info(\"not starting application as amIfStarted exceeds \" +\n+            \"userAmLimit\");\n+          continue;\n+        }\n+      }\n+      user.activateApplication();\n+      activeApplications.add(application);\n+      Resources.addTo(usedAMResources, application.getAMResource());\n+      Resources.addTo(user.getConsumedAMResources(), \n+        application.getAMResource());\n+      i.remove();\n+      LOG.info(\"Application \" + application.getApplicationId() +\n+          \" from user: \" + application.getUser() + \n+          \" activated in queue: \" + getQueueName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    //limit of allowed resource usage for application masters\n    Resource amLimit \u003d getAMResourceLimit();\n    Resource userAMLimit \u003d getUserAMResourceLimit();\n        \n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      \n      // Check am resource limit\n      Resource amIfStarted \u003d \n        Resources.add(application.getAMResource(), usedAMResources);\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"application AMResource \" + application.getAMResource() +\n          \" maxAMResourcePerQueuePercent \" + maxAMResourcePerQueuePercent +\n          \" amLimit \" + amLimit +\n          \" lastClusterResource \" + lastClusterResource +\n          \" amIfStarted \" + amIfStarted);\n      }\n      \n      if (!Resources.lessThanOrEqual(\n        resourceCalculator, lastClusterResource, amIfStarted, amLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds amLimit\");\n          continue;\n        }\n      }\n      \n      // Check user am resource limit\n      \n      User user \u003d getUser(application.getUser());\n      \n      Resource userAmIfStarted \u003d \n        Resources.add(application.getAMResource(),\n          user.getConsumedAMResources());\n        \n      if (!Resources.lessThanOrEqual(\n          resourceCalculator, lastClusterResource, userAmIfStarted, \n          userAMLimit)) {\n        if (getNumActiveApplications() \u003c 1) {\n          LOG.warn(\"maximum-am-resource-percent is insufficient to start a\" +\n            \" single application in queue for user, it is likely set too low.\" +\n            \" skipping enforcement to allow at least one application to start\"); \n        } else {\n          LOG.info(\"not starting application as amIfStarted exceeds \" +\n            \"userAmLimit\");\n          continue;\n        }\n      }\n      user.activateApplication();\n      activeApplications.add(application);\n      Resources.addTo(usedAMResources, application.getAMResource());\n      Resources.addTo(user.getConsumedAMResources(), \n        application.getAMResource());\n      i.remove();\n      LOG.info(\"Application \" + application.getApplicationId() +\n          \" from user: \" + application.getUser() + \n          \" activated in queue: \" + getQueueName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void activateApplications() {\n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      \n      // Check queue limit\n      if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n        break;\n      }\n      \n      // Check user limit\n      User user \u003d getUser(application.getUser());\n      if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n        user.activateApplication();\n        activeApplications.add(application);\n        i.remove();\n        LOG.info(\"Application \" + application.getApplicationId() +\n            \" from user: \" + application.getUser() + \n            \" activated in queue: \" + getQueueName());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "10/07/12 2:26 PM",
      "commitNameOld": "3bfb26ad3b5ac46f992a632541c97ca2bc897638",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,22 @@\n   private synchronized void activateApplications() {\n-    for (Iterator\u003cSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n+    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n-      SchedulerApp application \u003d i.next();\n+      FiCaSchedulerApp application \u003d i.next();\n       \n       // Check queue limit\n       if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n         break;\n       }\n       \n       // Check user limit\n       User user \u003d getUser(application.getUser());\n       if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n         user.activateApplication();\n         activeApplications.add(application);\n         i.remove();\n         LOG.info(\"Application \" + application.getApplicationId() +\n             \" from user: \" + application.getUser() + \n             \" activated in queue: \" + getQueueName());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    for (Iterator\u003cFiCaSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      FiCaSchedulerApp application \u003d i.next();\n      \n      // Check queue limit\n      if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n        break;\n      }\n      \n      // Check user limit\n      User user \u003d getUser(application.getUser());\n      if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n        user.activateApplication();\n        activeApplications.add(application);\n        i.remove();\n        LOG.info(\"Application \" + application.getApplicationId() +\n            \" from user: \" + application.getUser() + \n            \" activated in queue: \" + getQueueName());\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "70bc14f2344f31ec75f512256e8c8c3d36af5e78": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3780. Fixed a bug where applications killed before getting activated were not getting cleaned up properly. Contributed by Hitesh Shah. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239443 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/02/12 6:31 PM",
      "commitName": "70bc14f2344f31ec75f512256e8c8c3d36af5e78",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "01/02/12 4:41 PM",
      "commitNameOld": "ef1a619a4df3a612eb293a6e8e1e952eaef18eba",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,22 @@\n   private synchronized void activateApplications() {\n     for (Iterator\u003cSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n          i.hasNext(); ) {\n       SchedulerApp application \u003d i.next();\n       \n       // Check queue limit\n       if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n         break;\n       }\n       \n       // Check user limit\n       User user \u003d getUser(application.getUser());\n       if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n         user.activateApplication();\n         activeApplications.add(application);\n         i.remove();\n-        LOG.info(\"Application \" + application.getApplicationId().getId() + \n+        LOG.info(\"Application \" + application.getApplicationId() +\n             \" from user: \" + application.getUser() + \n             \" activated in queue: \" + getQueueName());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    for (Iterator\u003cSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      SchedulerApp application \u003d i.next();\n      \n      // Check queue limit\n      if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n        break;\n      }\n      \n      // Check user limit\n      User user \u003d getUser(application.getUser());\n      if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n        user.activateApplication();\n        activeApplications.add(application);\n        i.remove();\n        LOG.info(\"Application \" + application.getApplicationId() +\n            \" from user: \" + application.getUser() + \n            \" activated in queue: \" + getQueueName());\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "6b608aad7d52b524fa94955a538e8b3524d42d93": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2697. Enhance CapacityScheduler to cap concurrently running applications per-queue \u0026 per-user.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/11 12:49 PM",
      "commitName": "6b608aad7d52b524fa94955a538e8b3524d42d93",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,22 @@\n+  private synchronized void activateApplications() {\n+    for (Iterator\u003cSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n+         i.hasNext(); ) {\n+      SchedulerApp application \u003d i.next();\n+      \n+      // Check queue limit\n+      if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n+        break;\n+      }\n+      \n+      // Check user limit\n+      User user \u003d getUser(application.getUser());\n+      if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n+        user.activateApplication();\n+        activeApplications.add(application);\n+        i.remove();\n+        LOG.info(\"Application \" + application.getApplicationId().getId() + \n+            \" from user: \" + application.getUser() + \n+            \" activated in queue: \" + getQueueName());\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void activateApplications() {\n    for (Iterator\u003cSchedulerApp\u003e i\u003dpendingApplications.iterator(); \n         i.hasNext(); ) {\n      SchedulerApp application \u003d i.next();\n      \n      // Check queue limit\n      if (getNumActiveApplications() \u003e\u003d getMaximumActiveApplications()) {\n        break;\n      }\n      \n      // Check user limit\n      User user \u003d getUser(application.getUser());\n      if (user.getActiveApplications() \u003c getMaximumActiveApplicationsPerUser()) {\n        user.activateApplication();\n        activeApplications.add(application);\n        i.remove();\n        LOG.info(\"Application \" + application.getApplicationId().getId() + \n            \" from user: \" + application.getUser() + \n            \" activated in queue: \" + getQueueName());\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}