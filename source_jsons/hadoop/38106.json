{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "IntraQueueCandidatesSelector.java",
  "functionName": "preemptFromLeastStarvedApp",
  "functionId": "preemptFromLeastStarvedApp___leafQueue-LeafQueue__app-FiCaSchedulerApp__selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______curCandidates-Map__ApplicationAttemptId,Set__RMContainer______clusterResource-Resource__totalPreemptedResourceAllowed-Resource__resToObtainByPartition-Map__String,Resource____rollingResourceUsagePerUser-Map__String,Resource__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
  "functionStartLine": 209,
  "functionEndLine": 276,
  "numCommitsSeen": 25,
  "timeTaken": 4793,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ymultichange(Yparameterchange,Ybodychange)",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ybodychange",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": "Ymultichange(Yparameterchange,Ybodychange)",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,68 @@\n   private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n       FiCaSchedulerApp app,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed,\n       Map\u003cString, Resource\u003e resToObtainByPartition,\n       Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n \n     // ToDo: Reuse reservation selector here.\n \n     List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n     sortContainers(liveContainers);\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\n-          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n-              + totalPreemptedResourceAllowed);\n-    }\n+    LOG.debug(\"totalPreemptedResourceAllowed for preemption at this\"\n+        + \" round is :{}\", totalPreemptedResourceAllowed);\n \n     Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n         .get(app.getUser());\n     for (RMContainer c : liveContainers) {\n \n       // if there are no demand, return.\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // skip preselected containers.\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedCandidates)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         continue;\n       }\n \n       // If selected container brings down resource usage under its user\u0027s\n       // UserLimit (or equals to), we must skip such containers.\n       if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n           clusterResource, rollingUsedResourcePerUser, c)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\n-              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n-                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n-                  + app.getUser() + \" with resource usage: \"\n-                  + rollingUsedResourcePerUser + \" is going under UL\");\n-        }\n+        LOG.debug(\"Skipping container: {} with resource:{} as UserLimit for\"\n+            + \" user:{} with resource usage: {} is going under UL\",\n+            c.getContainerId(), c.getAllocatedResource(), app.getUser(),\n+            rollingUsedResourcePerUser);\n+\n         break;\n       }\n \n       // Try to preempt this container\n       boolean ret \u003d CapacitySchedulerPreemptionUtils\n           .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n               resToObtainByPartition, c, clusterResource, selectedCandidates,\n               curCandidates, totalPreemptedResourceAllowed, true);\n \n       // Subtract from respective user\u0027s resource usage once a container is\n       // selected for preemption.\n       if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n           .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n         Resources.subtractFrom(rollingUsedResourcePerUser,\n             c.getAllocatedResource());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n      FiCaSchedulerApp app,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition,\n      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n    sortContainers(liveContainers);\n    LOG.debug(\"totalPreemptedResourceAllowed for preemption at this\"\n        + \" round is :{}\", totalPreemptedResourceAllowed);\n\n    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n        .get(app.getUser());\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // If selected container brings down resource usage under its user\u0027s\n      // UserLimit (or equals to), we must skip such containers.\n      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n          clusterResource, rollingUsedResourcePerUser, c)) {\n        LOG.debug(\"Skipping container: {} with resource:{} as UserLimit for\"\n            + \" user:{} with resource usage: {} is going under UL\",\n            c.getContainerId(), c.getAllocatedResource(), app.getUser(),\n            rollingUsedResourcePerUser);\n\n        break;\n      }\n\n      // Try to preempt this container\n      boolean ret \u003d CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedCandidates,\n              curCandidates, totalPreemptedResourceAllowed, true);\n\n      // Subtract from respective user\u0027s resource usage once a container is\n      // selected for preemption.\n      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n        Resources.subtractFrom(rollingUsedResourcePerUser,\n            c.getAllocatedResource());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "28/05/18 4:02 AM",
          "commitNameOld": "7c343669baf660df3b70d58987d6e68aec54d6fa",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 31.26,
          "commitsBetweenForRepo": 215,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,74 @@\n   private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n       FiCaSchedulerApp app,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed,\n       Map\u003cString, Resource\u003e resToObtainByPartition,\n       Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n \n     // ToDo: Reuse reservation selector here.\n \n     List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n     sortContainers(liveContainers);\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"totalPreemptedResourceAllowed for preemption at this round is :\"\n               + totalPreemptedResourceAllowed);\n     }\n \n     Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n         .get(app.getUser());\n     for (RMContainer c : liveContainers) {\n \n       // if there are no demand, return.\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // skip preselected containers.\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedCandidates)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         continue;\n       }\n \n       // If selected container brings down resource usage under its user\u0027s\n       // UserLimit (or equals to), we must skip such containers.\n       if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n           clusterResource, rollingUsedResourcePerUser, c)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                   + c.getAllocatedResource() + \" as UserLimit for user:\"\n                   + app.getUser() + \" with resource usage: \"\n                   + rollingUsedResourcePerUser + \" is going under UL\");\n         }\n         break;\n       }\n \n       // Try to preempt this container\n       boolean ret \u003d CapacitySchedulerPreemptionUtils\n           .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n               resToObtainByPartition, c, clusterResource, selectedCandidates,\n-              totalPreemptedResourceAllowed, true);\n+              curCandidates, totalPreemptedResourceAllowed, true);\n \n       // Subtract from respective user\u0027s resource usage once a container is\n       // selected for preemption.\n       if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n           .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n         Resources.subtractFrom(rollingUsedResourcePerUser,\n             c.getAllocatedResource());\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n      FiCaSchedulerApp app,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition,\n      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n    sortContainers(liveContainers);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n              + totalPreemptedResourceAllowed);\n    }\n\n    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n        .get(app.getUser());\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // If selected container brings down resource usage under its user\u0027s\n      // UserLimit (or equals to), we must skip such containers.\n      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n          clusterResource, rollingUsedResourcePerUser, c)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n                  + app.getUser() + \" with resource usage: \"\n                  + rollingUsedResourcePerUser + \" is going under UL\");\n        }\n        break;\n      }\n\n      // Try to preempt this container\n      boolean ret \u003d CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedCandidates,\n              curCandidates, totalPreemptedResourceAllowed, true);\n\n      // Subtract from respective user\u0027s resource usage once a container is\n      // selected for preemption.\n      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n        Resources.subtractFrom(rollingUsedResourcePerUser,\n            c.getAllocatedResource());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
          "extendedDetails": {
            "oldValue": "[leafQueue-LeafQueue, app-FiCaSchedulerApp, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, clusterResource-Resource, totalPreemptedResourceAllowed-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, rollingResourceUsagePerUser-Map\u003cString,Resource\u003e]",
            "newValue": "[leafQueue-LeafQueue, app-FiCaSchedulerApp, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, curCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, clusterResource-Resource, totalPreemptedResourceAllowed-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, rollingResourceUsagePerUser-Map\u003cString,Resource\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "28/05/18 4:02 AM",
          "commitNameOld": "7c343669baf660df3b70d58987d6e68aec54d6fa",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 31.26,
          "commitsBetweenForRepo": 215,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,74 @@\n   private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n       FiCaSchedulerApp app,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed,\n       Map\u003cString, Resource\u003e resToObtainByPartition,\n       Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n \n     // ToDo: Reuse reservation selector here.\n \n     List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n     sortContainers(liveContainers);\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"totalPreemptedResourceAllowed for preemption at this round is :\"\n               + totalPreemptedResourceAllowed);\n     }\n \n     Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n         .get(app.getUser());\n     for (RMContainer c : liveContainers) {\n \n       // if there are no demand, return.\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // skip preselected containers.\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedCandidates)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         continue;\n       }\n \n       // If selected container brings down resource usage under its user\u0027s\n       // UserLimit (or equals to), we must skip such containers.\n       if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n           clusterResource, rollingUsedResourcePerUser, c)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                   + c.getAllocatedResource() + \" as UserLimit for user:\"\n                   + app.getUser() + \" with resource usage: \"\n                   + rollingUsedResourcePerUser + \" is going under UL\");\n         }\n         break;\n       }\n \n       // Try to preempt this container\n       boolean ret \u003d CapacitySchedulerPreemptionUtils\n           .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n               resToObtainByPartition, c, clusterResource, selectedCandidates,\n-              totalPreemptedResourceAllowed, true);\n+              curCandidates, totalPreemptedResourceAllowed, true);\n \n       // Subtract from respective user\u0027s resource usage once a container is\n       // selected for preemption.\n       if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n           .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n         Resources.subtractFrom(rollingUsedResourcePerUser,\n             c.getAllocatedResource());\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n      FiCaSchedulerApp app,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition,\n      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n    sortContainers(liveContainers);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n              + totalPreemptedResourceAllowed);\n    }\n\n    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n        .get(app.getUser());\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // If selected container brings down resource usage under its user\u0027s\n      // UserLimit (or equals to), we must skip such containers.\n      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n          clusterResource, rollingUsedResourcePerUser, c)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n                  + app.getUser() + \" with resource usage: \"\n                  + rollingUsedResourcePerUser + \" is going under UL\");\n        }\n        break;\n      }\n\n      // Try to preempt this container\n      boolean ret \u003d CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedCandidates,\n              curCandidates, totalPreemptedResourceAllowed, true);\n\n      // Subtract from respective user\u0027s resource usage once a container is\n      // selected for preemption.\n      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n        Resources.subtractFrom(rollingUsedResourcePerUser,\n            c.getAllocatedResource());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
          "extendedDetails": {}
        }
      ]
    },
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "19/02/18 12:06 PM",
      "commitNameOld": "949721508467968d5f46170353716ad04349cd6f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 94.83,
      "commitsBetweenForRepo": 1313,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n       FiCaSchedulerApp app,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed,\n       Map\u003cString, Resource\u003e resToObtainByPartition,\n       Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n \n     // ToDo: Reuse reservation selector here.\n \n     List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n     sortContainers(liveContainers);\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"totalPreemptedResourceAllowed for preemption at this round is :\"\n               + totalPreemptedResourceAllowed);\n     }\n \n     Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n         .get(app.getUser());\n     for (RMContainer c : liveContainers) {\n \n       // if there are no demand, return.\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // skip preselected containers.\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedCandidates)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         continue;\n       }\n \n       // If selected container brings down resource usage under its user\u0027s\n       // UserLimit (or equals to), we must skip such containers.\n       if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n           clusterResource, rollingUsedResourcePerUser, c)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                   + c.getAllocatedResource() + \" as UserLimit for user:\"\n                   + app.getUser() + \" with resource usage: \"\n                   + rollingUsedResourcePerUser + \" is going under UL\");\n         }\n         break;\n       }\n \n       // Try to preempt this container\n       boolean ret \u003d CapacitySchedulerPreemptionUtils\n           .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n               resToObtainByPartition, c, clusterResource, selectedCandidates,\n-              totalPreemptedResourceAllowed);\n+              totalPreemptedResourceAllowed, true);\n \n       // Subtract from respective user\u0027s resource usage once a container is\n       // selected for preemption.\n       if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n           .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n         Resources.subtractFrom(rollingUsedResourcePerUser,\n             c.getAllocatedResource());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n      FiCaSchedulerApp app,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition,\n      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n    sortContainers(liveContainers);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n              + totalPreemptedResourceAllowed);\n    }\n\n    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n        .get(app.getUser());\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // If selected container brings down resource usage under its user\u0027s\n      // UserLimit (or equals to), we must skip such containers.\n      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n          clusterResource, rollingUsedResourcePerUser, c)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n                  + app.getUser() + \" with resource usage: \"\n                  + rollingUsedResourcePerUser + \" is going under UL\");\n        }\n        break;\n      }\n\n      // Try to preempt this container\n      boolean ret \u003d CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedCandidates,\n              totalPreemptedResourceAllowed, true);\n\n      // Subtract from respective user\u0027s resource usage once a container is\n      // selected for preemption.\n      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n        Resources.subtractFrom(rollingUsedResourcePerUser,\n            c.getAllocatedResource());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
      "commitDate": "22/05/17 2:26 PM",
      "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
          "commitDate": "22/05/17 2:26 PM",
          "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "08/03/17 2:46 PM",
          "commitNameOld": "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 74.94,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,73 @@\n-  private void preemptFromLeastStarvedApp(\n+  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n+      FiCaSchedulerApp app,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed,\n-      Map\u003cString, Resource\u003e resToObtainByPartition, LeafQueue leafQueue,\n-      FiCaSchedulerApp app) {\n+      Map\u003cString, Resource\u003e resToObtainByPartition,\n+      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n \n     // ToDo: Reuse reservation selector here.\n \n-    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(\n-        app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n     sortContainers(liveContainers);\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"totalPreemptedResourceAllowed for preemption at this round is :\"\n               + totalPreemptedResourceAllowed);\n     }\n \n+    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n+        .get(app.getUser());\n     for (RMContainer c : liveContainers) {\n \n       // if there are no demand, return.\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // skip preselected containers.\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedCandidates)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         continue;\n       }\n \n-      // Try to preempt this container\n-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedCandidates, totalPreemptedResourceAllowed);\n-    }\n+      // If selected container brings down resource usage under its user\u0027s\n+      // UserLimit (or equals to), we must skip such containers.\n+      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n+          clusterResource, rollingUsedResourcePerUser, c)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\n+              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n+                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n+                  + app.getUser() + \" with resource usage: \"\n+                  + rollingUsedResourcePerUser + \" is going under UL\");\n+        }\n+        break;\n+      }\n \n+      // Try to preempt this container\n+      boolean ret \u003d CapacitySchedulerPreemptionUtils\n+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n+              resToObtainByPartition, c, clusterResource, selectedCandidates,\n+              totalPreemptedResourceAllowed);\n+\n+      // Subtract from respective user\u0027s resource usage once a container is\n+      // selected for preemption.\n+      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n+          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n+        Resources.subtractFrom(rollingUsedResourcePerUser,\n+            c.getAllocatedResource());\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n      FiCaSchedulerApp app,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition,\n      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n    sortContainers(liveContainers);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n              + totalPreemptedResourceAllowed);\n    }\n\n    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n        .get(app.getUser());\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // If selected container brings down resource usage under its user\u0027s\n      // UserLimit (or equals to), we must skip such containers.\n      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n          clusterResource, rollingUsedResourcePerUser, c)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n                  + app.getUser() + \" with resource usage: \"\n                  + rollingUsedResourcePerUser + \" is going under UL\");\n        }\n        break;\n      }\n\n      // Try to preempt this container\n      boolean ret \u003d CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedCandidates,\n              totalPreemptedResourceAllowed);\n\n      // Subtract from respective user\u0027s resource usage once a container is\n      // selected for preemption.\n      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n        Resources.subtractFrom(rollingUsedResourcePerUser,\n            c.getAllocatedResource());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
          "extendedDetails": {
            "oldValue": "[selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, clusterResource-Resource, totalPreemptedResourceAllowed-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, leafQueue-LeafQueue, app-FiCaSchedulerApp]",
            "newValue": "[leafQueue-LeafQueue, app-FiCaSchedulerApp, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, clusterResource-Resource, totalPreemptedResourceAllowed-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, rollingResourceUsagePerUser-Map\u003cString,Resource\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
          "commitDate": "22/05/17 2:26 PM",
          "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "08/03/17 2:46 PM",
          "commitNameOld": "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 74.94,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,73 @@\n-  private void preemptFromLeastStarvedApp(\n+  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n+      FiCaSchedulerApp app,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed,\n-      Map\u003cString, Resource\u003e resToObtainByPartition, LeafQueue leafQueue,\n-      FiCaSchedulerApp app) {\n+      Map\u003cString, Resource\u003e resToObtainByPartition,\n+      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n \n     // ToDo: Reuse reservation selector here.\n \n-    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(\n-        app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n     sortContainers(liveContainers);\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"totalPreemptedResourceAllowed for preemption at this round is :\"\n               + totalPreemptedResourceAllowed);\n     }\n \n+    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n+        .get(app.getUser());\n     for (RMContainer c : liveContainers) {\n \n       // if there are no demand, return.\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // skip preselected containers.\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedCandidates)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         continue;\n       }\n \n-      // Try to preempt this container\n-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedCandidates, totalPreemptedResourceAllowed);\n-    }\n+      // If selected container brings down resource usage under its user\u0027s\n+      // UserLimit (or equals to), we must skip such containers.\n+      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n+          clusterResource, rollingUsedResourcePerUser, c)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\n+              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n+                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n+                  + app.getUser() + \" with resource usage: \"\n+                  + rollingUsedResourcePerUser + \" is going under UL\");\n+        }\n+        break;\n+      }\n \n+      // Try to preempt this container\n+      boolean ret \u003d CapacitySchedulerPreemptionUtils\n+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n+              resToObtainByPartition, c, clusterResource, selectedCandidates,\n+              totalPreemptedResourceAllowed);\n+\n+      // Subtract from respective user\u0027s resource usage once a container is\n+      // selected for preemption.\n+      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n+          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n+        Resources.subtractFrom(rollingUsedResourcePerUser,\n+            c.getAllocatedResource());\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,\n      FiCaSchedulerApp app,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition,\n      Map\u003cString, Resource\u003e rollingResourceUsagePerUser) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n    sortContainers(liveContainers);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n              + totalPreemptedResourceAllowed);\n    }\n\n    Resource rollingUsedResourcePerUser \u003d rollingResourceUsagePerUser\n        .get(app.getUser());\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // If selected container brings down resource usage under its user\u0027s\n      // UserLimit (or equals to), we must skip such containers.\n      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,\n          clusterResource, rollingUsedResourcePerUser, c)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Skipping container: \" + c.getContainerId() + \" with resource:\"\n                  + c.getAllocatedResource() + \" as UserLimit for user:\"\n                  + app.getUser() + \" with resource usage: \"\n                  + rollingUsedResourcePerUser + \" is going under UL\");\n        }\n        break;\n      }\n\n      // Try to preempt this container\n      boolean ret \u003d CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedCandidates,\n              totalPreemptedResourceAllowed);\n\n      // Subtract from respective user\u0027s resource usage once a container is\n      // selected for preemption.\n      if (ret \u0026\u0026 preemptionContext.getIntraQueuePreemptionOrderPolicy()\n          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n        Resources.subtractFrom(rollingUsedResourcePerUser,\n            c.getAllocatedResource());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
          "extendedDetails": {}
        }
      ]
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,49 @@\n+  private void preemptFromLeastStarvedApp(\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n+      Map\u003cString, Resource\u003e resToObtainByPartition, LeafQueue leafQueue,\n+      FiCaSchedulerApp app) {\n+\n+    // ToDo: Reuse reservation selector here.\n+\n+    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(\n+        app.getLiveContainers());\n+    sortContainers(liveContainers);\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\n+          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n+              + totalPreemptedResourceAllowed);\n+    }\n+\n+    for (RMContainer c : liveContainers) {\n+\n+      // if there are no demand, return.\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n+      }\n+\n+      // skip preselected containers.\n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedCandidates)) {\n+        continue;\n+      }\n+\n+      // Skip already marked to killable containers\n+      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n+          .getKillableContainers().contains(c.getContainerId())) {\n+        continue;\n+      }\n+\n+      // Skip AM Container from preemption for now.\n+      if (c.isAMContainer()) {\n+        continue;\n+      }\n+\n+      // Try to preempt this container\n+      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n+          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n+          selectedCandidates, totalPreemptedResourceAllowed);\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFromLeastStarvedApp(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed,\n      Map\u003cString, Resource\u003e resToObtainByPartition, LeafQueue leafQueue,\n      FiCaSchedulerApp app) {\n\n    // ToDo: Reuse reservation selector here.\n\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(\n        app.getLiveContainers());\n    sortContainers(liveContainers);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"totalPreemptedResourceAllowed for preemption at this round is :\"\n              + totalPreemptedResourceAllowed);\n    }\n\n    for (RMContainer c : liveContainers) {\n\n      // if there are no demand, return.\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // skip preselected containers.\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedCandidates)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        continue;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n          selectedCandidates, totalPreemptedResourceAllowed);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java"
    }
  }
}