{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PriorityUtilizationQueueOrderingPolicy.java",
  "functionName": "compare",
  "functionId": "compare___q1-CSQueue__q2-CSQueue",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/policy/PriorityUtilizationQueueOrderingPolicy.java",
  "functionStartLine": 107,
  "functionEndLine": 142,
  "numCommitsSeen": 6,
  "timeTaken": 4224,
  "changeHistory": [
    "a8316df8c05a7b3d1a5577174b838711a49ef971",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "5ff5f67332b527acaca7a69ac421930a02ca55b3",
    "d573f09fb93dbb711d504620af5d73840ea063a6"
  ],
  "changeHistoryShort": {
    "a8316df8c05a7b3d1a5577174b838711a49ef971": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ymultichange(Ymovefromfile,Ybodychange)",
    "5ff5f67332b527acaca7a69ac421930a02ca55b3": "Ybodychange",
    "d573f09fb93dbb711d504620af5d73840ea063a6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a8316df8c05a7b3d1a5577174b838711a49ef971": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7520. Queue Ordering policy changes for ordering auto created leaf queues within Managed parent Queues. (Suma Shivaprasad via wangda)\n\nChange-Id: I482f086945bd448d512cb5b3879d7371e37ee134\n",
      "commitDate": "08/12/17 3:11 PM",
      "commitName": "a8316df8c05a7b3d1a5577174b838711a49ef971",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,36 @@\n     public int compare(CSQueue q1, CSQueue q2) {\n       String p \u003d partitionToLookAt.get();\n \n       int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n       if (0 !\u003d rc) {\n         return rc;\n       }\n \n-      float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n-      float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n-      int p1 \u003d 0;\n-      int p2 \u003d 0;\n-      if (respectPriority) {\n-        p1 \u003d q1.getPriority().getPriority();\n-        p2 \u003d q2.getPriority().getPriority();\n+      float q1AbsCapacity \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n+      float q2AbsCapacity \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n+\n+      //If q1\u0027s abs capacity \u003e 0 and q2 is 0, then prioritize q1\n+      if (Float.compare(q1AbsCapacity, 0f) \u003e 0 \u0026\u0026 Float.compare(q2AbsCapacity,\n+          0f) \u003d\u003d 0) {\n+        return -1;\n+        //If q2\u0027s abs capacity \u003e 0 and q1 is 0, then prioritize q2\n+      } else if (Float.compare(q2AbsCapacity, 0f) \u003e 0 \u0026\u0026 Float.compare(\n+          q1AbsCapacity, 0f) \u003d\u003d 0) {\n+        return 1;\n+      } else if (Float.compare(q1AbsCapacity, 0f) \u003d\u003d 0 \u0026\u0026 Float.compare(\n+          q2AbsCapacity, 0f) \u003d\u003d 0) {\n+        // both q1 has 0 and q2 has 0 capacity, then fall back to using\n+        // priority, abs used capacity to prioritize\n+        float used1 \u003d q1.getQueueCapacities().getAbsoluteUsedCapacity(p);\n+        float used2 \u003d q2.getQueueCapacities().getAbsoluteUsedCapacity(p);\n+\n+        return compare(q1, q2, used1, used2, p);\n+      } else{\n+        // both q1 has positive abs capacity and q2 has positive abs\n+        // capacity\n+        float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n+        float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n+\n+        return compare(q1, q2, used1, used2, p);\n       }\n-\n-      rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n-\n-      // For queue with same used ratio / priority, queue with higher configured\n-      // capacity goes first\n-      if (0 \u003d\u003d rc) {\n-        Resource minEffRes1 \u003d q1.getQueueResourceQuotas()\n-            .getConfiguredMinResource(p);\n-        Resource minEffRes2 \u003d q2.getQueueResourceQuotas()\n-            .getConfiguredMinResource(p);\n-        if (!minEffRes1.equals(Resources.none())\n-            \u0026\u0026 !minEffRes2.equals(Resources.none())) {\n-          return minEffRes2.compareTo(minEffRes1);\n-        }\n-\n-        float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n-        float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n-        return Float.compare(abs2, abs1);\n-      }\n-\n-      return rc;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(CSQueue q1, CSQueue q2) {\n      String p \u003d partitionToLookAt.get();\n\n      int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n      if (0 !\u003d rc) {\n        return rc;\n      }\n\n      float q1AbsCapacity \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n      float q2AbsCapacity \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n\n      //If q1\u0027s abs capacity \u003e 0 and q2 is 0, then prioritize q1\n      if (Float.compare(q1AbsCapacity, 0f) \u003e 0 \u0026\u0026 Float.compare(q2AbsCapacity,\n          0f) \u003d\u003d 0) {\n        return -1;\n        //If q2\u0027s abs capacity \u003e 0 and q1 is 0, then prioritize q2\n      } else if (Float.compare(q2AbsCapacity, 0f) \u003e 0 \u0026\u0026 Float.compare(\n          q1AbsCapacity, 0f) \u003d\u003d 0) {\n        return 1;\n      } else if (Float.compare(q1AbsCapacity, 0f) \u003d\u003d 0 \u0026\u0026 Float.compare(\n          q2AbsCapacity, 0f) \u003d\u003d 0) {\n        // both q1 has 0 and q2 has 0 capacity, then fall back to using\n        // priority, abs used capacity to prioritize\n        float used1 \u003d q1.getQueueCapacities().getAbsoluteUsedCapacity(p);\n        float used2 \u003d q2.getQueueCapacities().getAbsoluteUsedCapacity(p);\n\n        return compare(q1, q2, used1, used2, p);\n      } else{\n        // both q1 has positive abs capacity and q2 has positive abs\n        // capacity\n        float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n        float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n\n        return compare(q1, q2, used1, used2, p);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/policy/PriorityUtilizationQueueOrderingPolicy.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/01/17 5:07 AM",
      "commitNameOld": "165f07f51a03137d2e73e39ed1cb48385d963f39",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 314.58,
      "commitsBetweenForRepo": 2070,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,38 @@\n     public int compare(CSQueue q1, CSQueue q2) {\n       String p \u003d partitionToLookAt.get();\n \n       int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n       if (0 !\u003d rc) {\n         return rc;\n       }\n \n       float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n       float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n       int p1 \u003d 0;\n       int p2 \u003d 0;\n       if (respectPriority) {\n         p1 \u003d q1.getPriority().getPriority();\n         p2 \u003d q2.getPriority().getPriority();\n       }\n \n       rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n \n       // For queue with same used ratio / priority, queue with higher configured\n       // capacity goes first\n       if (0 \u003d\u003d rc) {\n+        Resource minEffRes1 \u003d q1.getQueueResourceQuotas()\n+            .getConfiguredMinResource(p);\n+        Resource minEffRes2 \u003d q2.getQueueResourceQuotas()\n+            .getConfiguredMinResource(p);\n+        if (!minEffRes1.equals(Resources.none())\n+            \u0026\u0026 !minEffRes2.equals(Resources.none())) {\n+          return minEffRes2.compareTo(minEffRes1);\n+        }\n+\n         float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n         float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n         return Float.compare(abs2, abs1);\n       }\n \n       return rc;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(CSQueue q1, CSQueue q2) {\n      String p \u003d partitionToLookAt.get();\n\n      int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n      if (0 !\u003d rc) {\n        return rc;\n      }\n\n      float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n      float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n      int p1 \u003d 0;\n      int p2 \u003d 0;\n      if (respectPriority) {\n        p1 \u003d q1.getPriority().getPriority();\n        p2 \u003d q2.getPriority().getPriority();\n      }\n\n      rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n\n      // For queue with same used ratio / priority, queue with higher configured\n      // capacity goes first\n      if (0 \u003d\u003d rc) {\n        Resource minEffRes1 \u003d q1.getQueueResourceQuotas()\n            .getConfiguredMinResource(p);\n        Resource minEffRes2 \u003d q2.getQueueResourceQuotas()\n            .getConfiguredMinResource(p);\n        if (!minEffRes1.equals(Resources.none())\n            \u0026\u0026 !minEffRes2.equals(Resources.none())) {\n          return minEffRes2.compareTo(minEffRes1);\n        }\n\n        float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n        float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n        return Float.compare(abs2, abs1);\n      }\n\n      return rc;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/policy/PriorityUtilizationQueueOrderingPolicy.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
          "commitDate": "23/01/17 10:52 AM",
          "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "23/01/17 9:12 AM",
          "commitNameOld": "69fa81679f59378fd19a2c65db8019393d7c05a2",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,29 @@\n-  public int compare(CSQueue q1, CSQueue q2) {\n-    /*\n-     * 1. Check accessible to given partition, if one queue accessible and\n-     * the other not, accessible queue goes first.\n-     */\n-    boolean q1Accessible \u003d\n-        q1.getAccessibleNodeLabels().contains(partitionToLookAt)\n-            || q1.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n-    boolean q2Accessible \u003d\n-        q2.getAccessibleNodeLabels().contains(partitionToLookAt)\n-            || q2.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n-    if (q1Accessible \u0026\u0026 !q2Accessible) {\n-      return -1;\n-    } else if (!q1Accessible \u0026\u0026 q2Accessible) {\n-      return 1;\n-    }\n+    public int compare(CSQueue q1, CSQueue q2) {\n+      String p \u003d partitionToLookAt.get();\n \n-    /*\n-     * \n-     * 2. When two queue has same accessibility, check who will go first:\n-     * Now we simply compare their used resource on the partition to lookAt\n-     */\n-    float used1 \u003d q1.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n-    float used2 \u003d q2.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n-    if (Math.abs(used1 - used2) \u003c 1e-6) {\n-      // When used capacity is same, compare their guaranteed-capacity\n-      float cap1 \u003d q1.getQueueCapacities().getCapacity(partitionToLookAt);\n-      float cap2 \u003d q2.getQueueCapacities().getCapacity(partitionToLookAt);\n-      \n-      // when cap1 \u003d\u003d cap2, we will compare queue\u0027s name\n-      if (Math.abs(cap1 - cap2) \u003c 1e-6) {\n-        return q1.getQueueName().compareTo(q2.getQueueName());\n+      int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n+      if (0 !\u003d rc) {\n+        return rc;\n       }\n-      return Float.compare(cap2, cap1);\n-    }\n-    \n-    return Float.compare(used1, used2);\n-  }\n\\ No newline at end of file\n+\n+      float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n+      float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n+      int p1 \u003d 0;\n+      int p2 \u003d 0;\n+      if (respectPriority) {\n+        p1 \u003d q1.getPriority().getPriority();\n+        p2 \u003d q2.getPriority().getPriority();\n+      }\n+\n+      rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n+\n+      // For queue with same used ratio / priority, queue with higher configured\n+      // capacity goes first\n+      if (0 \u003d\u003d rc) {\n+        float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n+        float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n+        return Float.compare(abs2, abs1);\n+      }\n+\n+      return rc;\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    public int compare(CSQueue q1, CSQueue q2) {\n      String p \u003d partitionToLookAt.get();\n\n      int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n      if (0 !\u003d rc) {\n        return rc;\n      }\n\n      float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n      float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n      int p1 \u003d 0;\n      int p2 \u003d 0;\n      if (respectPriority) {\n        p1 \u003d q1.getPriority().getPriority();\n        p2 \u003d q2.getPriority().getPriority();\n      }\n\n      rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n\n      // For queue with same used ratio / priority, queue with higher configured\n      // capacity goes first\n      if (0 \u003d\u003d rc) {\n        float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n        float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n        return Float.compare(abs2, abs1);\n      }\n\n      return rc;\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/policy/PriorityUtilizationQueueOrderingPolicy.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/PartitionedQueueComparator.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/policy/PriorityUtilizationQueueOrderingPolicy.java",
            "oldMethodName": "compare",
            "newMethodName": "compare"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
          "commitDate": "23/01/17 10:52 AM",
          "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "23/01/17 9:12 AM",
          "commitNameOld": "69fa81679f59378fd19a2c65db8019393d7c05a2",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,29 @@\n-  public int compare(CSQueue q1, CSQueue q2) {\n-    /*\n-     * 1. Check accessible to given partition, if one queue accessible and\n-     * the other not, accessible queue goes first.\n-     */\n-    boolean q1Accessible \u003d\n-        q1.getAccessibleNodeLabels().contains(partitionToLookAt)\n-            || q1.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n-    boolean q2Accessible \u003d\n-        q2.getAccessibleNodeLabels().contains(partitionToLookAt)\n-            || q2.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n-    if (q1Accessible \u0026\u0026 !q2Accessible) {\n-      return -1;\n-    } else if (!q1Accessible \u0026\u0026 q2Accessible) {\n-      return 1;\n-    }\n+    public int compare(CSQueue q1, CSQueue q2) {\n+      String p \u003d partitionToLookAt.get();\n \n-    /*\n-     * \n-     * 2. When two queue has same accessibility, check who will go first:\n-     * Now we simply compare their used resource on the partition to lookAt\n-     */\n-    float used1 \u003d q1.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n-    float used2 \u003d q2.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n-    if (Math.abs(used1 - used2) \u003c 1e-6) {\n-      // When used capacity is same, compare their guaranteed-capacity\n-      float cap1 \u003d q1.getQueueCapacities().getCapacity(partitionToLookAt);\n-      float cap2 \u003d q2.getQueueCapacities().getCapacity(partitionToLookAt);\n-      \n-      // when cap1 \u003d\u003d cap2, we will compare queue\u0027s name\n-      if (Math.abs(cap1 - cap2) \u003c 1e-6) {\n-        return q1.getQueueName().compareTo(q2.getQueueName());\n+      int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n+      if (0 !\u003d rc) {\n+        return rc;\n       }\n-      return Float.compare(cap2, cap1);\n-    }\n-    \n-    return Float.compare(used1, used2);\n-  }\n\\ No newline at end of file\n+\n+      float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n+      float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n+      int p1 \u003d 0;\n+      int p2 \u003d 0;\n+      if (respectPriority) {\n+        p1 \u003d q1.getPriority().getPriority();\n+        p2 \u003d q2.getPriority().getPriority();\n+      }\n+\n+      rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n+\n+      // For queue with same used ratio / priority, queue with higher configured\n+      // capacity goes first\n+      if (0 \u003d\u003d rc) {\n+        float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n+        float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n+        return Float.compare(abs2, abs1);\n+      }\n+\n+      return rc;\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    public int compare(CSQueue q1, CSQueue q2) {\n      String p \u003d partitionToLookAt.get();\n\n      int rc \u003d compareQueueAccessToPartition(q1, q2, p);\n      if (0 !\u003d rc) {\n        return rc;\n      }\n\n      float used1 \u003d q1.getQueueCapacities().getUsedCapacity(p);\n      float used2 \u003d q2.getQueueCapacities().getUsedCapacity(p);\n      int p1 \u003d 0;\n      int p2 \u003d 0;\n      if (respectPriority) {\n        p1 \u003d q1.getPriority().getPriority();\n        p2 \u003d q2.getPriority().getPriority();\n      }\n\n      rc \u003d PriorityUtilizationQueueOrderingPolicy.compare(used1, used2, p1, p2);\n\n      // For queue with same used ratio / priority, queue with higher configured\n      // capacity goes first\n      if (0 \u003d\u003d rc) {\n        float abs1 \u003d q1.getQueueCapacities().getAbsoluteCapacity(p);\n        float abs2 \u003d q2.getQueueCapacities().getAbsoluteCapacity(p);\n        return Float.compare(abs2, abs1);\n      }\n\n      return rc;\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/policy/PriorityUtilizationQueueOrderingPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "5ff5f67332b527acaca7a69ac421930a02ca55b3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4557. Fix improper Queues sorting in PartitionedQueueComparator when accessible-node-labels\u003d*. (Naganarasimha G R via wangda)\n",
      "commitDate": "20/01/16 7:21 PM",
      "commitName": "5ff5f67332b527acaca7a69ac421930a02ca55b3",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/04/15 1:36 PM",
      "commitNameOld": "d573f09fb93dbb711d504620af5d73840ea063a6",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 278.28,
      "commitsBetweenForRepo": 2171,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   public int compare(CSQueue q1, CSQueue q2) {\n     /*\n      * 1. Check accessible to given partition, if one queue accessible and\n      * the other not, accessible queue goes first.\n      */\n     boolean q1Accessible \u003d\n-        q1.getAccessibleNodeLabels().contains(partitionToLookAt);\n+        q1.getAccessibleNodeLabels().contains(partitionToLookAt)\n+            || q1.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n     boolean q2Accessible \u003d\n-        q2.getAccessibleNodeLabels().contains(partitionToLookAt);\n+        q2.getAccessibleNodeLabels().contains(partitionToLookAt)\n+            || q2.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n     if (q1Accessible \u0026\u0026 !q2Accessible) {\n       return -1;\n     } else if (!q1Accessible \u0026\u0026 q2Accessible) {\n       return 1;\n     }\n-    \n+\n     /*\n      * \n      * 2. When two queue has same accessibility, check who will go first:\n      * Now we simply compare their used resource on the partition to lookAt\n      */\n     float used1 \u003d q1.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n     float used2 \u003d q2.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n     if (Math.abs(used1 - used2) \u003c 1e-6) {\n       // When used capacity is same, compare their guaranteed-capacity\n       float cap1 \u003d q1.getQueueCapacities().getCapacity(partitionToLookAt);\n       float cap2 \u003d q2.getQueueCapacities().getCapacity(partitionToLookAt);\n       \n       // when cap1 \u003d\u003d cap2, we will compare queue\u0027s name\n       if (Math.abs(cap1 - cap2) \u003c 1e-6) {\n         return q1.getQueueName().compareTo(q2.getQueueName());\n       }\n       return Float.compare(cap2, cap1);\n     }\n     \n     return Float.compare(used1, used2);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(CSQueue q1, CSQueue q2) {\n    /*\n     * 1. Check accessible to given partition, if one queue accessible and\n     * the other not, accessible queue goes first.\n     */\n    boolean q1Accessible \u003d\n        q1.getAccessibleNodeLabels().contains(partitionToLookAt)\n            || q1.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n    boolean q2Accessible \u003d\n        q2.getAccessibleNodeLabels().contains(partitionToLookAt)\n            || q2.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY);\n    if (q1Accessible \u0026\u0026 !q2Accessible) {\n      return -1;\n    } else if (!q1Accessible \u0026\u0026 q2Accessible) {\n      return 1;\n    }\n\n    /*\n     * \n     * 2. When two queue has same accessibility, check who will go first:\n     * Now we simply compare their used resource on the partition to lookAt\n     */\n    float used1 \u003d q1.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n    float used2 \u003d q2.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n    if (Math.abs(used1 - used2) \u003c 1e-6) {\n      // When used capacity is same, compare their guaranteed-capacity\n      float cap1 \u003d q1.getQueueCapacities().getCapacity(partitionToLookAt);\n      float cap2 \u003d q2.getQueueCapacities().getCapacity(partitionToLookAt);\n      \n      // when cap1 \u003d\u003d cap2, we will compare queue\u0027s name\n      if (Math.abs(cap1 - cap2) \u003c 1e-6) {\n        return q1.getQueueName().compareTo(q2.getQueueName());\n      }\n      return Float.compare(cap2, cap1);\n    }\n    \n    return Float.compare(used1, used2);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/PartitionedQueueComparator.java",
      "extendedDetails": {}
    },
    "d573f09fb93dbb711d504620af5d73840ea063a6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2696. Queue sorting in CapacityScheduler should consider node label. Contributed by Wangda Tan\n",
      "commitDate": "17/04/15 1:36 PM",
      "commitName": "d573f09fb93dbb711d504620af5d73840ea063a6",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,36 @@\n+  public int compare(CSQueue q1, CSQueue q2) {\n+    /*\n+     * 1. Check accessible to given partition, if one queue accessible and\n+     * the other not, accessible queue goes first.\n+     */\n+    boolean q1Accessible \u003d\n+        q1.getAccessibleNodeLabels().contains(partitionToLookAt);\n+    boolean q2Accessible \u003d\n+        q2.getAccessibleNodeLabels().contains(partitionToLookAt);\n+    if (q1Accessible \u0026\u0026 !q2Accessible) {\n+      return -1;\n+    } else if (!q1Accessible \u0026\u0026 q2Accessible) {\n+      return 1;\n+    }\n+    \n+    /*\n+     * \n+     * 2. When two queue has same accessibility, check who will go first:\n+     * Now we simply compare their used resource on the partition to lookAt\n+     */\n+    float used1 \u003d q1.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n+    float used2 \u003d q2.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n+    if (Math.abs(used1 - used2) \u003c 1e-6) {\n+      // When used capacity is same, compare their guaranteed-capacity\n+      float cap1 \u003d q1.getQueueCapacities().getCapacity(partitionToLookAt);\n+      float cap2 \u003d q2.getQueueCapacities().getCapacity(partitionToLookAt);\n+      \n+      // when cap1 \u003d\u003d cap2, we will compare queue\u0027s name\n+      if (Math.abs(cap1 - cap2) \u003c 1e-6) {\n+        return q1.getQueueName().compareTo(q2.getQueueName());\n+      }\n+      return Float.compare(cap2, cap1);\n+    }\n+    \n+    return Float.compare(used1, used2);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(CSQueue q1, CSQueue q2) {\n    /*\n     * 1. Check accessible to given partition, if one queue accessible and\n     * the other not, accessible queue goes first.\n     */\n    boolean q1Accessible \u003d\n        q1.getAccessibleNodeLabels().contains(partitionToLookAt);\n    boolean q2Accessible \u003d\n        q2.getAccessibleNodeLabels().contains(partitionToLookAt);\n    if (q1Accessible \u0026\u0026 !q2Accessible) {\n      return -1;\n    } else if (!q1Accessible \u0026\u0026 q2Accessible) {\n      return 1;\n    }\n    \n    /*\n     * \n     * 2. When two queue has same accessibility, check who will go first:\n     * Now we simply compare their used resource on the partition to lookAt\n     */\n    float used1 \u003d q1.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n    float used2 \u003d q2.getQueueCapacities().getUsedCapacity(partitionToLookAt);\n    if (Math.abs(used1 - used2) \u003c 1e-6) {\n      // When used capacity is same, compare their guaranteed-capacity\n      float cap1 \u003d q1.getQueueCapacities().getCapacity(partitionToLookAt);\n      float cap2 \u003d q2.getQueueCapacities().getCapacity(partitionToLookAt);\n      \n      // when cap1 \u003d\u003d cap2, we will compare queue\u0027s name\n      if (Math.abs(cap1 - cap2) \u003c 1e-6) {\n        return q1.getQueueName().compareTo(q2.getQueueName());\n      }\n      return Float.compare(cap2, cap1);\n    }\n    \n    return Float.compare(used1, used2);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/PartitionedQueueComparator.java"
    }
  }
}