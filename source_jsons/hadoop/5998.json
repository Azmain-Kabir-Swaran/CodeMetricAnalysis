{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NamenodeFsck.java",
  "functionName": "collectBlocksSummary",
  "functionId": "collectBlocksSummary___parent-String__file-HdfsFileStatus__res-Result__blocks-LocatedBlocks",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
  "functionStartLine": 701,
  "functionEndLine": 943,
  "numCommitsSeen": 120,
  "timeTaken": 11699,
  "changeHistory": [
    "62c801568331e0701122c68c6876c1b15721bb82",
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
    "ffc9c50e074aeca804674c6e1e6b0f1eb629e230",
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
    "c18590fce283378edb09acd4e764706a9a4a8b5f",
    "df857f0d10bda9fbb9c3f6ec77aba0cf46fe3631",
    "886776225611ca3cfff32dd94ea24fe618f14464",
    "796a676d18bd7cd3ed4113d002e0e69cf261d6d1",
    "d806a5bf079bf136114520c5a3a9d1f16ecf2eda",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
    "73b86a5046fe3262dde7b05be46b18575e35fd5f",
    "c8bca62718203a1dad9b70d164bdf10cc71b40cd",
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
    "2470a7bf88c7d7e0889905e35671c440c3ae649b",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
    "d62b63d297bff12d93de560dd50ddd48743b851d",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
    "6e3fcffe291faec40fa9214f4880a35a952836c4",
    "98d340745be682fb251677bb4830aca76119868f",
    "0ed92e5b13f6bbc0ea7475bc67488359413a980e",
    "e53fa769c97416af69ea567aecd44f67e896688b",
    "a38a37c63417a3b19dcdf98251af196c9d7b8c31",
    "9af1f4779b646fb2f09b5e36447c8b8abe920a7c",
    "0c590e1c097462979f7ee054ad9121345d58655b",
    "2ea0f2fc938febd7fbbe03656a91ae3db1409c50",
    "279958b772c25e0633bd967828b7d27d5c0a6a56",
    "ef4e9963b25d7d2e30f1071ddcaa9d92a7fe70f3"
  ],
  "changeHistoryShort": {
    "62c801568331e0701122c68c6876c1b15721bb82": "Ybodychange",
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": "Ybodychange",
    "ffc9c50e074aeca804674c6e1e6b0f1eb629e230": "Ybodychange",
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca": "Ybodychange",
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320": "Ybodychange",
    "c18590fce283378edb09acd4e764706a9a4a8b5f": "Ybodychange",
    "df857f0d10bda9fbb9c3f6ec77aba0cf46fe3631": "Ybodychange",
    "886776225611ca3cfff32dd94ea24fe618f14464": "Ybodychange",
    "796a676d18bd7cd3ed4113d002e0e69cf261d6d1": "Ybodychange",
    "d806a5bf079bf136114520c5a3a9d1f16ecf2eda": "Ybodychange",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": "Ybodychange",
    "73b86a5046fe3262dde7b05be46b18575e35fd5f": "Ybodychange",
    "c8bca62718203a1dad9b70d164bdf10cc71b40cd": "Ybodychange",
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed": "Ybodychange",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": "Ybodychange",
    "2470a7bf88c7d7e0889905e35671c440c3ae649b": "Ybodychange",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": "Ybodychange",
    "d62b63d297bff12d93de560dd50ddd48743b851d": "Ybodychange",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": "Ybodychange",
    "6e3fcffe291faec40fa9214f4880a35a952836c4": "Ybodychange",
    "98d340745be682fb251677bb4830aca76119868f": "Ybodychange",
    "0ed92e5b13f6bbc0ea7475bc67488359413a980e": "Ybodychange",
    "e53fa769c97416af69ea567aecd44f67e896688b": "Ybodychange",
    "a38a37c63417a3b19dcdf98251af196c9d7b8c31": "Ybodychange",
    "9af1f4779b646fb2f09b5e36447c8b8abe920a7c": "Ybodychange",
    "0c590e1c097462979f7ee054ad9121345d58655b": "Ybodychange",
    "2ea0f2fc938febd7fbbe03656a91ae3db1409c50": "Ybodychange",
    "279958b772c25e0633bd967828b7d27d5c0a6a56": "Ybodychange",
    "ef4e9963b25d7d2e30f1071ddcaa9d92a7fe70f3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "62c801568331e0701122c68c6876c1b15721bb82": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15227. NPE if the last block changes from COMMITTED to COMPLETE during FSCK. Contributed by Ayush Saxena.\n",
      "commitDate": "21/03/20 11:14 PM",
      "commitName": "62c801568331e0701122c68c6876c1b15721bb82",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "13/03/20 11:29 AM",
      "commitNameOld": "4b95c242eca540455a4d5d0899aaf73b6064b5ea",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 8.49,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,239 +1,243 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n       Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     List\u003cBlockInfo\u003e misReplicatedBlocks \u003d new LinkedList\u003c\u003e();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       int enteringMaintenanceReplicas \u003d\n           numberReplicas.liveEnteringMaintenanceReplicas();\n       int inMaintenanceReplicas \u003d\n           numberReplicas.maintenanceNotForReadReplicas();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n       res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n       res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n           + decommissioningReplicas\n           + enteringMaintenanceReplicas\n           + inMaintenanceReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block + \". Target Replicas is \"\n             + targetFileReplication + \" but found \"\n             + liveReplicas+ \" live replica(s), \"\n             + decommissionedReplicas + \" decommissioned replica(s), \"\n             + decommissioningReplicas + \" decommissioning replica(s)\"\n             + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n             + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n             + \" in maintenance replica(s).\") : \".\"));\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n         if (doReplicate) {\n           misReplicatedBlocks.add(storedBlock);\n         }\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n-      DatanodeStorageInfo[] storages \u003d storedBlock\n-          .getUnderConstructionFeature().getExpectedStorageLocations();\n-      report.append(\u0027\\n\u0027)\n-          .append(\"Under Construction Block:\\n\")\n-          .append(blockNumber).append(\". \").append(blkName)\n-          .append(\" len\u003d\").append(block.getNumBytes())\n-          .append(\" Expected_repl\u003d\" + storages.length);\n-      String info\u003dgetReplicaInfo(storedBlock);\n-      if (!info.isEmpty()){\n-        report.append(\" \").append(info);\n+      BlockUnderConstructionFeature uc \u003d\n+          storedBlock.getUnderConstructionFeature();\n+      if (uc !\u003d null) {\n+        // BlockUnderConstructionFeature can be null, in case the block was\n+        // in committed state, and the IBR came just after the check.\n+        DatanodeStorageInfo[] storages \u003d uc.getExpectedStorageLocations();\n+        report.append(\u0027\\n\u0027).append(\"Under Construction Block:\\n\")\n+            .append(blockNumber).append(\". \").append(blkName).append(\" len\u003d\")\n+            .append(block.getNumBytes())\n+            .append(\" Expected_repl\u003d\" + storages.length);\n+        String info \u003d getReplicaInfo(storedBlock);\n+        if (!info.isEmpty()) {\n+          report.append(\" \").append(info);\n+        }\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n \n     if (doReplicate \u0026\u0026 !misReplicatedBlocks.isEmpty()) {\n       int processedBlocks \u003d this.blockManager.processMisReplicatedBlocks(\n               misReplicatedBlocks);\n       if (processedBlocks \u003c misReplicatedBlocks.size()) {\n         LOG.warn(\"Fsck: Block manager is able to process only \" +\n                 processedBlocks +\n                 \" mis-replicated blocks (Total count : \" +\n                 misReplicatedBlocks.size() +\n                 \" ) for path \" + path);\n       }\n       res.numBlocksQueuedForReplication +\u003d processedBlocks;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n      Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    List\u003cBlockInfo\u003e misReplicatedBlocks \u003d new LinkedList\u003c\u003e();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      int enteringMaintenanceReplicas \u003d\n          numberReplicas.liveEnteringMaintenanceReplicas();\n      int inMaintenanceReplicas \u003d\n          numberReplicas.maintenanceNotForReadReplicas();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n          + decommissioningReplicas\n          + enteringMaintenanceReplicas\n          + inMaintenanceReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n            + targetFileReplication + \" but found \"\n            + liveReplicas+ \" live replica(s), \"\n            + decommissionedReplicas + \" decommissioned replica(s), \"\n            + decommissioningReplicas + \" decommissioning replica(s)\"\n            + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n            + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n            + \" in maintenance replica(s).\") : \".\"));\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n        if (doReplicate) {\n          misReplicatedBlocks.add(storedBlock);\n        }\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      BlockUnderConstructionFeature uc \u003d\n          storedBlock.getUnderConstructionFeature();\n      if (uc !\u003d null) {\n        // BlockUnderConstructionFeature can be null, in case the block was\n        // in committed state, and the IBR came just after the check.\n        DatanodeStorageInfo[] storages \u003d uc.getExpectedStorageLocations();\n        report.append(\u0027\\n\u0027).append(\"Under Construction Block:\\n\")\n            .append(blockNumber).append(\". \").append(blkName).append(\" len\u003d\")\n            .append(block.getNumBytes())\n            .append(\" Expected_repl\u003d\" + storages.length);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()) {\n          report.append(\" \").append(info);\n        }\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n\n    if (doReplicate \u0026\u0026 !misReplicatedBlocks.isEmpty()) {\n      int processedBlocks \u003d this.blockManager.processMisReplicatedBlocks(\n              misReplicatedBlocks);\n      if (processedBlocks \u003c misReplicatedBlocks.size()) {\n        LOG.warn(\"Fsck: Block manager is able to process only \" +\n                processedBlocks +\n                \" mis-replicated blocks (Total count : \" +\n                misReplicatedBlocks.size() +\n                \" ) for path \" + path);\n      }\n      res.numBlocksQueuedForReplication +\u003d processedBlocks;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16029. Consecutive StringBuilder.append can be reused. Contributed by Ayush Saxena.\n",
      "commitDate": "11/01/19 10:54 AM",
      "commitName": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "30/11/18 11:07 AM",
      "commitNameOld": "99e201dfe2295be830efcc80be34706802da30be",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 41.99,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,239 +1,239 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n       Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     List\u003cBlockInfo\u003e misReplicatedBlocks \u003d new LinkedList\u003c\u003e();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       int enteringMaintenanceReplicas \u003d\n           numberReplicas.liveEnteringMaintenanceReplicas();\n       int inMaintenanceReplicas \u003d\n           numberReplicas.maintenanceNotForReadReplicas();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n       res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n       res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n           + decommissioningReplicas\n           + enteringMaintenanceReplicas\n           + inMaintenanceReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block + \". Target Replicas is \"\n             + targetFileReplication + \" but found \"\n             + liveReplicas+ \" live replica(s), \"\n             + decommissionedReplicas + \" decommissioned replica(s), \"\n             + decommissioningReplicas + \" decommissioning replica(s)\"\n             + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n             + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n             + \" in maintenance replica(s).\") : \".\"));\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n         if (doReplicate) {\n           misReplicatedBlocks.add(storedBlock);\n         }\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n-      report.append(\u0027\\n\u0027);\n-      report.append(\"Under Construction Block:\\n\");\n-      report.append(blockNumber).append(\". \").append(blkName);\n-      report.append(\" len\u003d\").append(block.getNumBytes());\n-      report.append(\" Expected_repl\u003d\" + storages.length);\n+      report.append(\u0027\\n\u0027)\n+          .append(\"Under Construction Block:\\n\")\n+          .append(blockNumber).append(\". \").append(blkName)\n+          .append(\" len\u003d\").append(block.getNumBytes())\n+          .append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n \n     if (doReplicate \u0026\u0026 !misReplicatedBlocks.isEmpty()) {\n       int processedBlocks \u003d this.blockManager.processMisReplicatedBlocks(\n               misReplicatedBlocks);\n       if (processedBlocks \u003c misReplicatedBlocks.size()) {\n         LOG.warn(\"Fsck: Block manager is able to process only \" +\n                 processedBlocks +\n                 \" mis-replicated blocks (Total count : \" +\n                 misReplicatedBlocks.size() +\n                 \" ) for path \" + path);\n       }\n       res.numBlocksQueuedForReplication +\u003d processedBlocks;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n      Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    List\u003cBlockInfo\u003e misReplicatedBlocks \u003d new LinkedList\u003c\u003e();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      int enteringMaintenanceReplicas \u003d\n          numberReplicas.liveEnteringMaintenanceReplicas();\n      int inMaintenanceReplicas \u003d\n          numberReplicas.maintenanceNotForReadReplicas();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n          + decommissioningReplicas\n          + enteringMaintenanceReplicas\n          + inMaintenanceReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n            + targetFileReplication + \" but found \"\n            + liveReplicas+ \" live replica(s), \"\n            + decommissionedReplicas + \" decommissioned replica(s), \"\n            + decommissioningReplicas + \" decommissioning replica(s)\"\n            + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n            + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n            + \" in maintenance replica(s).\") : \".\"));\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n        if (doReplicate) {\n          misReplicatedBlocks.add(storedBlock);\n        }\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027)\n          .append(\"Under Construction Block:\\n\")\n          .append(blockNumber).append(\". \").append(blkName)\n          .append(\" len\u003d\").append(block.getNumBytes())\n          .append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n\n    if (doReplicate \u0026\u0026 !misReplicatedBlocks.isEmpty()) {\n      int processedBlocks \u003d this.blockManager.processMisReplicatedBlocks(\n              misReplicatedBlocks);\n      if (processedBlocks \u003c misReplicatedBlocks.size()) {\n        LOG.warn(\"Fsck: Block manager is able to process only \" +\n                processedBlocks +\n                \" mis-replicated blocks (Total count : \" +\n                misReplicatedBlocks.size() +\n                \" ) for path \" + path);\n      }\n      res.numBlocksQueuedForReplication +\u003d processedBlocks;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "ffc9c50e074aeca804674c6e1e6b0f1eb629e230": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14053. Provide ability for NN to re-replicate based on topology changes. Contributed by Hrishikesh Gadre.\n",
      "commitDate": "05/11/18 9:38 PM",
      "commitName": "ffc9c50e074aeca804674c6e1e6b0f1eb629e230",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "30/10/18 10:43 PM",
      "commitNameOld": "fac9f91b2944cee641049fffcafa6b65e0cf68f2",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 6.0,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,222 +1,239 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n       Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n+    List\u003cBlockInfo\u003e misReplicatedBlocks \u003d new LinkedList\u003c\u003e();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       int enteringMaintenanceReplicas \u003d\n           numberReplicas.liveEnteringMaintenanceReplicas();\n       int inMaintenanceReplicas \u003d\n           numberReplicas.maintenanceNotForReadReplicas();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n       res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n       res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n           + decommissioningReplicas\n           + enteringMaintenanceReplicas\n           + inMaintenanceReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block + \". Target Replicas is \"\n             + targetFileReplication + \" but found \"\n             + liveReplicas+ \" live replica(s), \"\n             + decommissionedReplicas + \" decommissioned replica(s), \"\n             + decommissioningReplicas + \" decommissioning replica(s)\"\n             + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n             + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n             + \" in maintenance replica(s).\") : \".\"));\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n+        if (doReplicate) {\n+          misReplicatedBlocks.add(storedBlock);\n+        }\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n+\n+    if (doReplicate \u0026\u0026 !misReplicatedBlocks.isEmpty()) {\n+      int processedBlocks \u003d this.blockManager.processMisReplicatedBlocks(\n+              misReplicatedBlocks);\n+      if (processedBlocks \u003c misReplicatedBlocks.size()) {\n+        LOG.warn(\"Fsck: Block manager is able to process only \" +\n+                processedBlocks +\n+                \" mis-replicated blocks (Total count : \" +\n+                misReplicatedBlocks.size() +\n+                \" ) for path \" + path);\n+      }\n+      res.numBlocksQueuedForReplication +\u003d processedBlocks;\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n      Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    List\u003cBlockInfo\u003e misReplicatedBlocks \u003d new LinkedList\u003c\u003e();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      int enteringMaintenanceReplicas \u003d\n          numberReplicas.liveEnteringMaintenanceReplicas();\n      int inMaintenanceReplicas \u003d\n          numberReplicas.maintenanceNotForReadReplicas();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n          + decommissioningReplicas\n          + enteringMaintenanceReplicas\n          + inMaintenanceReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n            + targetFileReplication + \" but found \"\n            + liveReplicas+ \" live replica(s), \"\n            + decommissionedReplicas + \" decommissioned replica(s), \"\n            + decommissioningReplicas + \" decommissioning replica(s)\"\n            + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n            + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n            + \" in maintenance replica(s).\") : \".\"));\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n        if (doReplicate) {\n          misReplicatedBlocks.add(storedBlock);\n        }\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n\n    if (doReplicate \u0026\u0026 !misReplicatedBlocks.isEmpty()) {\n      int processedBlocks \u003d this.blockManager.processMisReplicatedBlocks(\n              misReplicatedBlocks);\n      if (processedBlocks \u003c misReplicatedBlocks.size()) {\n        LOG.warn(\"Fsck: Block manager is able to process only \" +\n                processedBlocks +\n                \" mis-replicated blocks (Total count : \" +\n                misReplicatedBlocks.size() +\n                \" ) for path \" + path);\n      }\n      res.numBlocksQueuedForReplication +\u003d processedBlocks;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\n",
      "commitDate": "19/01/17 12:28 AM",
      "commitName": "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "18/01/17 1:31 PM",
      "commitNameOld": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,222 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n-                 Result res, LocatedBlocks blocks) throws IOException {\n+      Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n+      int enteringMaintenanceReplicas \u003d\n+          numberReplicas.liveEnteringMaintenanceReplicas();\n+      int inMaintenanceReplicas \u003d\n+          numberReplicas.maintenanceNotForReadReplicas();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n+      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n+      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n-      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n-          decommissioningReplicas;\n+      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n+          + decommissioningReplicas\n+          + enteringMaintenanceReplicas\n+          + inMaintenanceReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n-        out.println(\" Under replicated \" + block +\n-                    \". Target Replicas is \" +\n-                    targetFileReplication + \" but found \" +\n-                    liveReplicas + \" live replica(s), \" +\n-                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n-                    decommissioningReplicas + \" decommissioning replica(s).\");\n+        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n+            + targetFileReplication + \" but found \"\n+            + liveReplicas+ \" live replica(s), \"\n+            + decommissionedReplicas + \" decommissioned replica(s), \"\n+            + decommissioningReplicas + \" decommissioning replica(s)\"\n+            + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n+            + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n+            + \" in maintenance replica(s).\") : \".\"));\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n      Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      int enteringMaintenanceReplicas \u003d\n          numberReplicas.liveEnteringMaintenanceReplicas();\n      int inMaintenanceReplicas \u003d\n          numberReplicas.maintenanceNotForReadReplicas();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n          + decommissioningReplicas\n          + enteringMaintenanceReplicas\n          + inMaintenanceReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n            + targetFileReplication + \" but found \"\n            + liveReplicas+ \" live replica(s), \"\n            + decommissionedReplicas + \" decommissioned replica(s), \"\n            + decommissioningReplicas + \" decommissioning replica(s)\"\n            + (this.showMaintenanceState ? (enteringMaintenanceReplicas\n            + \", entering maintenance replica(s) and \" + inMaintenanceReplicas\n            + \" in maintenance replica(s).\") : \".\"));\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "15/01/17 11:11 PM",
      "commitNameOld": "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 2.6,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,212 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                  Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n-          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n+          lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                 Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.getBlockType()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\"\n\nThis reverts commit c18590fce283378edb09acd4e764706a9a4a8b5f.\n",
      "commitDate": "15/01/17 11:11 PM",
      "commitName": "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/01/17 3:37 AM",
      "commitNameOld": "c18590fce283378edb09acd4e764706a9a4a8b5f",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,222 +1,212 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n-      Result res, LocatedBlocks blocks) throws IOException {\n+                 Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n-      int enteringMaintenanceReplicas \u003d\n-          numberReplicas.liveEnteringMaintenanceReplicas();\n-      int inMaintenanceReplicas \u003d\n-          numberReplicas.maintenanceNotForReadReplicas();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n-      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n-      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n-      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n-          + decommissioningReplicas\n-          + enteringMaintenanceReplicas\n-          + inMaintenanceReplicas;\n+      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n+          decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n-        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n-            + targetFileReplication + \" but found \"\n-            + liveReplicas+ \" live replica(s), \"\n-            + decommissionedReplicas + \" decommissioned replica(s), \"\n-            + decommissioningReplicas + \" decommissioning replica(s), \"\n-            + enteringMaintenanceReplicas\n-            + \" entering maintenance replica(s) and \"\n-            + inMaintenanceReplicas + \" in maintenance replica(s).\");\n+        out.println(\" Under replicated \" + block +\n+                    \". Target Replicas is \" +\n+                    targetFileReplication + \" but found \" +\n+                    liveReplicas + \" live replica(s), \" +\n+                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n+                    decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                 Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "c18590fce283378edb09acd4e764706a9a4a8b5f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\n",
      "commitDate": "10/01/17 3:37 AM",
      "commitName": "c18590fce283378edb09acd4e764706a9a4a8b5f",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "14/11/16 11:05 AM",
      "commitNameOld": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 56.69,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,222 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n-                 Result res, LocatedBlocks blocks) throws IOException {\n+      Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n+      int enteringMaintenanceReplicas \u003d\n+          numberReplicas.liveEnteringMaintenanceReplicas();\n+      int inMaintenanceReplicas \u003d\n+          numberReplicas.maintenanceNotForReadReplicas();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n+      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n+      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n-      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n-          decommissioningReplicas;\n+      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n+          + decommissioningReplicas\n+          + enteringMaintenanceReplicas\n+          + inMaintenanceReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       boolean isMissing;\n       if (storedBlock.isStriped()) {\n         isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n       } else {\n         isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n       }\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n-        out.println(\" Under replicated \" + block +\n-                    \". Target Replicas is \" +\n-                    targetFileReplication + \" but found \" +\n-                    liveReplicas + \" live replica(s), \" +\n-                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n-                    decommissioningReplicas + \" decommissioning replica(s).\");\n+        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n+            + targetFileReplication + \" but found \"\n+            + liveReplicas+ \" live replica(s), \"\n+            + decommissionedReplicas + \" decommissioned replica(s), \"\n+            + decommissioningReplicas + \" decommissioning replica(s), \"\n+            + enteringMaintenanceReplicas\n+            + \" entering maintenance replica(s) and \"\n+            + inMaintenanceReplicas + \" in maintenance replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n      Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      int enteringMaintenanceReplicas \u003d\n          numberReplicas.liveEnteringMaintenanceReplicas();\n      int inMaintenanceReplicas \u003d\n          numberReplicas.maintenanceNotForReadReplicas();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n      res.enteringMaintenanceReplicas +\u003d enteringMaintenanceReplicas;\n      res.inMaintenanceReplicas +\u003d inMaintenanceReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas\n          + decommissioningReplicas\n          + enteringMaintenanceReplicas\n          + inMaintenanceReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block + \". Target Replicas is \"\n            + targetFileReplication + \" but found \"\n            + liveReplicas+ \" live replica(s), \"\n            + decommissionedReplicas + \" decommissioned replica(s), \"\n            + decommissioningReplicas + \" decommissioning replica(s), \"\n            + enteringMaintenanceReplicas\n            + \" entering maintenance replica(s) and \"\n            + inMaintenanceReplicas + \" in maintenance replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "df857f0d10bda9fbb9c3f6ec77aba0cf46fe3631": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10975. fsck -list-corruptfileblocks does not report corrupt EC files. Contributed by Takanobu Asanuma.\n",
      "commitDate": "21/10/16 3:43 PM",
      "commitName": "df857f0d10bda9fbb9c3f6ec77aba0cf46fe3631",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "20/10/16 1:06 PM",
      "commitNameOld": "5e83a21cb66c78e89ac5af9a130ab0aee596a9f4",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,211 +1,212 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                  Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n+      boolean isMissing;\n+      if (storedBlock.isStriped()) {\n+        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n+      } else {\n+        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n+      }\n+\n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n-      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n+      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n-      boolean isMissing;\n-      if (storedBlock.isStriped()) {\n-        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n-      } else {\n-        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n-      }\n       if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted in the case of replication, and it means the state of the\n         // block group is unrecoverable due to some corrupted intenal blocks in\n         // the case of EC. We don\u0027t mark it as missing given these available\n         // replicas/internal-blocks might still be accessible as the block might\n         // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n         if (storedBlock.isStriped()) {\n           report.append(\" Live_repl\u003d\" + liveReplicas);\n           String info \u003d getReplicaInfo(storedBlock);\n           if (!info.isEmpty()){\n             report.append(\" \").append(info);\n           }\n         }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                 Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 !isMissing) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "886776225611ca3cfff32dd94ea24fe618f14464": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10826. Correctly report missing EC blocks in FSCK. Contributed by Takanobu Asanuma.\n",
      "commitDate": "05/10/16 10:52 AM",
      "commitName": "886776225611ca3cfff32dd94ea24fe618f14464",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/06/16 8:05 PM",
      "commitNameOld": "7d521a29eed62c4329b16034375bd5fb747a92a9",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 112.62,
      "commitsBetweenForRepo": 854,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,211 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                  Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n-      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n+      boolean isMissing;\n+      if (storedBlock.isStriped()) {\n+        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n+      } else {\n+        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n+      }\n+      if (isMissing \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n-        // corrupted. We don\u0027t mark it as missing given these available replicas\n-        // might still be accessible as the block might be incorrectly marked as\n-        // corrupted by client machines.\n+        // corrupted in the case of replication, and it means the state of the\n+        // block group is unrecoverable due to some corrupted intenal blocks in\n+        // the case of EC. We don\u0027t mark it as missing given these available\n+        // replicas/internal-blocks might still be accessible as the block might\n+        // be incorrectly marked as corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n+        if (storedBlock.isStriped()) {\n+          report.append(\" Live_repl\u003d\" + liveReplicas);\n+          String info \u003d getReplicaInfo(storedBlock);\n+          if (!info.isEmpty()){\n+            report.append(\" \").append(info);\n+          }\n+        }\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                 Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      boolean isMissing;\n      if (storedBlock.isStriped()) {\n        isMissing \u003d totalReplicasPerBlock \u003c minReplication;\n      } else {\n        isMissing \u003d totalReplicasPerBlock \u003d\u003d 0;\n      }\n      if (isMissing \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted in the case of replication, and it means the state of the\n        // block group is unrecoverable due to some corrupted intenal blocks in\n        // the case of EC. We don\u0027t mark it as missing given these available\n        // replicas/internal-blocks might still be accessible as the block might\n        // be incorrectly marked as corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n        if (storedBlock.isStriped()) {\n          report.append(\" Live_repl\u003d\" + liveReplicas);\n          String info \u003d getReplicaInfo(storedBlock);\n          if (!info.isEmpty()){\n            report.append(\" \").append(info);\n          }\n        }\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "796a676d18bd7cd3ed4113d002e0e69cf261d6d1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9528. Cleanup namenode audit/log/exception messages. (szetszwo via umamahesh)\n",
      "commitDate": "11/12/15 5:57 PM",
      "commitName": "796a676d18bd7cd3ed4113d002e0e69cf261d6d1",
      "commitAuthor": "Uma Mahesh",
      "commitDateOld": "09/12/15 5:55 PM",
      "commitNameOld": "132478e805ba0f955345217b8ad87c2d17cccb2d",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,196 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                  Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n \n       final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n           block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n-        res.addMissing(block.toString(), block.getNumBytes());\n+        res.addMissing(blkName, block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         String info \u003d getReplicaInfo(storedBlock);\n         if (!info.isEmpty()){\n           report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     //display under construction block info.\n     if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n       ExtendedBlock block \u003d lastBlock.getBlock();\n       String blkName \u003d block.toString();\n       BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n       DatanodeStorageInfo[] storages \u003d storedBlock\n           .getUnderConstructionFeature().getExpectedStorageLocations();\n       report.append(\u0027\\n\u0027);\n       report.append(\"Under Construction Block:\\n\");\n       report.append(blockNumber).append(\". \").append(blkName);\n       report.append(\" len\u003d\").append(block.getNumBytes());\n       report.append(\" Expected_repl\u003d\" + storages.length);\n       String info\u003dgetReplicaInfo(storedBlock);\n       if (!info.isEmpty()){\n         report.append(\" \").append(info);\n       }\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n-        out.print(report.toString() + \"\\n\");\n+        out.print(report + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                 Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(blkName, block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "d806a5bf079bf136114520c5a3a9d1f16ecf2eda": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9070. Allow fsck display pending replica location information for being-written blocks. Contributed by Gao Rui.\n",
      "commitDate": "21/10/15 2:44 PM",
      "commitName": "d806a5bf079bf136114520c5a3a9d1f16ecf2eda",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/10/15 8:06 AM",
      "commitNameOld": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,214 +1,196 @@\n-  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n-      LocatedBlocks blocks) throws IOException {\n+  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n+                 Result res, LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n-      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n-      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n+      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n           block.getLocalBlock());\n-      final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n+      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n-      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n+      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n           lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n           targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n-      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n+      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n+          block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n-        if (showLocations || showRacks || showReplicaDetails) {\n-          StringBuilder sb \u003d new StringBuilder(\"[\");\n-          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n-          for (int i \u003d 0; i \u003c storages.length; i++) {\n-            DatanodeStorageInfo storage \u003d storages[i];\n-            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n-            if (showRacks) {\n-              sb.append(NodeBase.getPath(dnDesc));\n-            } else {\n-              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n-                  .getStorageType()));\n-            }\n-            if (showReplicaDetails) {\n-              LightWeightHashSet\u003cBlockInfo\u003e blocksExcess \u003d\n-                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n-              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n-                  bm.getCorruptReplicas(block.getLocalBlock());\n-              sb.append(\"(\");\n-              if (dnDesc.isDecommissioned()) {\n-                sb.append(\"DECOMMISSIONED)\");\n-              } else if (dnDesc.isDecommissionInProgress()) {\n-                sb.append(\"DECOMMISSIONING)\");\n-              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n-                sb.append(\"CORRUPT)\");\n-              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n-                sb.append(\"EXCESS)\");\n-              } else if (dnDesc.isStale(this.staleInterval)) {\n-                sb.append(\"STALE_NODE)\");\n-              } else if (storage.areBlockContentsStale()) {\n-                sb.append(\"STALE_BLOCK_CONTENT)\");\n-              } else {\n-                sb.append(\"LIVE)\");\n-              }\n-            }\n-            if (i \u003c storages.length - 1) {\n-              sb.append(\", \");\n-            }\n-          }\n-          sb.append(\u0027]\u0027);\n-          report.append(\" \" + sb.toString());\n+        String info \u003d getReplicaInfo(storedBlock);\n+        if (!info.isEmpty()){\n+          report.append(\" \").append(info);\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n+    //display under construction block info.\n+    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n+      ExtendedBlock block \u003d lastBlock.getBlock();\n+      String blkName \u003d block.toString();\n+      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n+          block.getLocalBlock());\n+      DatanodeStorageInfo[] storages \u003d storedBlock\n+          .getUnderConstructionFeature().getExpectedStorageLocations();\n+      report.append(\u0027\\n\u0027);\n+      report.append(\"Under Construction Block:\\n\");\n+      report.append(blockNumber).append(\". \").append(blkName);\n+      report.append(\" len\u003d\").append(block.getNumBytes());\n+      report.append(\" Expected_repl\u003d\" + storages.length);\n+      String info\u003dgetReplicaInfo(storedBlock);\n+      if (!info.isEmpty()){\n+        report.append(\" \").append(info);\n+      }\n+    }\n+\n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file,\n                 Result res, LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n\n      final BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d blockManager.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d blockManager.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" +\n          block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        String info \u003d getReplicaInfo(storedBlock);\n        if (!info.isEmpty()){\n          report.append(\" \").append(info);\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    //display under construction block info.\n    if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null) {\n      ExtendedBlock block \u003d lastBlock.getBlock();\n      String blkName \u003d block.toString();\n      BlockInfo storedBlock \u003d blockManager.getStoredBlock(\n          block.getLocalBlock());\n      DatanodeStorageInfo[] storages \u003d storedBlock\n          .getUnderConstructionFeature().getExpectedStorageLocations();\n      report.append(\u0027\\n\u0027);\n      report.append(\"Under Construction Block:\\n\");\n      report.append(blockNumber).append(\". \").append(blkName);\n      report.append(\" len\u003d\").append(block.getNumBytes());\n      report.append(\" Expected_repl\u003d\" + storages.length);\n      String info\u003dgetReplicaInfo(storedBlock);\n      if (!info.isEmpty()){\n        report.append(\" \").append(info);\n      }\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
      "commitDate": "21/10/15 8:06 AM",
      "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "11/10/15 11:40 PM",
      "commitNameOld": "73b86a5046fe3262dde7b05be46b18575e35fd5f",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 9.35,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,213 +1,214 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n-      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n-          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n+      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n+          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n+          targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightHashSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(\n          lBlk.isStriped()).verifyBlockPlacement(lBlk.getLocations(),\n          targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightHashSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "73b86a5046fe3262dde7b05be46b18575e35fd5f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8988. Use LightWeightHashSet instead of LightWeightLinkedSet in BlockManager#excessReplicateMap. (yliu)\n",
      "commitDate": "11/10/15 11:40 PM",
      "commitName": "73b86a5046fe3262dde7b05be46b18575e35fd5f",
      "commitAuthor": "yliu",
      "commitDateOld": "30/09/15 8:39 AM",
      "commitNameOld": "6c17d315287020368689fa078a40a1eaedf89d5b",
      "commitAuthorOld": "",
      "daysBetweenCommits": 11.63,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,213 +1,213 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     if (isOpen \u0026\u0026 !showOpenFiles) {\n       return;\n     }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n           lastBlock.getBlock().equals(block)) {\n         // this is the last block and this is not complete. ignore it since\n         // it is under construction\n         continue;\n       }\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n       if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n-              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n+              LightWeightHashSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightHashSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "c8bca62718203a1dad9b70d164bdf10cc71b40cd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8809. HDFS fsck reports under construction blocks as CORRUPT. Contributed by Jing Zhao.\n",
      "commitDate": "20/08/15 4:31 PM",
      "commitName": "c8bca62718203a1dad9b70d164bdf10cc71b40cd",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "19/08/15 11:28 AM",
      "commitNameOld": "3aac4758b007a56e3d66998d457b2156effca528",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,205 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n+    if (isOpen \u0026\u0026 !showOpenFiles) {\n+      return;\n+    }\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n+    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n+      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n+          lastBlock.getBlock().equals(block)) {\n+        // this is the last block and this is not complete. ignore it since\n+        // it is under construction\n+        continue;\n+      }\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    if (isOpen \u0026\u0026 !showOpenFiles) {\n      return;\n    }\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    final LocatedBlock lastBlock \u003d blocks.getLastLocatedBlock();\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      if (!blocks.isLastBlockComplete() \u0026\u0026 lastBlock !\u003d null \u0026\u0026\n          lastBlock.getBlock().equals(block)) {\n        // this is the last block and this is not complete. ignore it since\n        // it is under construction\n        continue;\n      }\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8854. Erasure coding: add ECPolicy to replace schema+cellSize in hadoop-hdfs. Contributed by Walter Su.\n",
      "commitDate": "13/08/15 10:04 AM",
      "commitName": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "09/07/15 10:55 AM",
      "commitNameOld": "2470a7bf88c7d7e0889905e35671c440c3ae649b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 34.96,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,203 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n-      if (file.getECSchema() !\u003d null) {\n+      if (file.getErasureCodingPolicy() !\u003d null) {\n         assert storedBlock instanceof BlockInfoStriped;\n         targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n             .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getErasureCodingPolicy() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\"\n\nThis reverts commit de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/07/15 10:13 AM",
      "commitNameOld": "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 30.01,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n-              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n+              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "2470a7bf88c7d7e0889905e35671c440c3ae649b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8563. Erasure Coding: fsck handles file smaller than a full stripe. Contributed by Walter Su.\n",
      "commitDate": "09/07/15 10:55 AM",
      "commitName": "2470a7bf88c7d7e0889905e35671c440c3ae649b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "10/06/15 10:18 PM",
      "commitNameOld": "98d340745be682fb251677bb4830aca76119868f",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 28.53,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,211 +1,203 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n+      final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n-      if(file.getReplication() \u003d\u003d 0) {\n-        final FSNamesystem fsn \u003d namenode.getNamesystem();\n-        final ECSchema ecSchema;\n-        fsn.readLock();\n-        try {\n-          INode inode \u003d namenode.getNamesystem().getFSDirectory()\n-              .getINode(path);\n-          INodesInPath iip \u003d INodesInPath.fromINode(inode);\n-          ecSchema \u003d FSDirErasureCodingOp.getErasureCodingSchema(fsn, iip);\n-        } finally {\n-          fsn.readUnlock();\n-        }\n-        targetFileReplication \u003d (short) (ecSchema.getNumDataUnits() + ecSchema.getNumParityUnits());\n+      if (file.getECSchema() !\u003d null) {\n+        assert storedBlock instanceof BlockInfoStriped;\n+        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n+            .getRealTotalBlockNum();\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n-      if(totalReplicasPerBlock \u003c res.minReplication){\n+      if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n-      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n+      if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      final int minReplication \u003d bm.getMinStorageNum(storedBlock);\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if (file.getECSchema() !\u003d null) {\n        assert storedBlock instanceof BlockInfoStriped;\n        targetFileReplication \u003d ((BlockInfoStriped) storedBlock)\n            .getRealTotalBlockNum();\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\"\n\nThis reverts commit d62b63d297bff12d93de560dd50ddd48743b851d.\n",
      "commitDate": "07/07/15 10:13 AM",
      "commitName": "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/07/15 3:54 PM",
      "commitNameOld": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n-                  bm.getCorruptReplicas(storedBlock);\n+                  bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n-              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(storedBlock)) {\n+              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "d62b63d297bff12d93de560dd50ddd48743b851d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\n",
      "commitDate": "06/07/15 3:54 PM",
      "commitName": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/06/15 10:49 AM",
      "commitNameOld": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 10.21,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n-                  bm.getCorruptReplicas(block.getLocalBlock());\n+                  bm.getCorruptReplicas(storedBlock);\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n-              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n+              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(storedBlock)) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(storedBlock);\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(storedBlock)) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "26/06/15 10:49 AM",
      "commitName": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/06/15 4:38 PM",
      "commitNameOld": "015535dc0ad00c2ba357afb3d1e283e56ddda0d6",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 8.76,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n-              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n+              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "6e3fcffe291faec40fa9214f4880a35a952836c4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8608. Merge HDFS-7912 to trunk and branch-2 (track BlockInfo instead of Block in UnderReplicatedBlocks and PendingReplicationBlocks). Contributed by Zhe Zhang.\n",
      "commitDate": "17/06/15 8:05 AM",
      "commitName": "6e3fcffe291faec40fa9214f4880a35a952836c4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/05/15 3:42 PM",
      "commitNameOld": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 20.68,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n+      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n+          block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n-      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n+      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n-        out.println(\" Replica placement policy is violated for \" + \n+        out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "98d340745be682fb251677bb4830aca76119868f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8450. Erasure Coding: Consolidate erasure coding zone related implementation into a single class (Contributed by Rakesh R)\n",
      "commitDate": "10/06/15 10:18 PM",
      "commitName": "98d340745be682fb251677bb4830aca76119868f",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "26/05/15 12:07 PM",
      "commitNameOld": "0ed92e5b13f6bbc0ea7475bc67488359413a980e",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 15.42,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,211 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication;\n       if(file.getReplication() \u003d\u003d 0) {\n-        INode inode \u003d namenode.getNamesystem().getFSDirectory().getINode(path);\n-        INodesInPath iip \u003d INodesInPath.fromINode(inode);\n-        ECSchema ecSchema \u003d namenode.getNamesystem().getFSDirectory().getECSchema(iip);\n+        final FSNamesystem fsn \u003d namenode.getNamesystem();\n+        final ECSchema ecSchema;\n+        fsn.readLock();\n+        try {\n+          INode inode \u003d namenode.getNamesystem().getFSDirectory()\n+              .getINode(path);\n+          INodesInPath iip \u003d INodesInPath.fromINode(inode);\n+          ecSchema \u003d FSDirErasureCodingOp.getErasureCodingSchema(fsn, iip);\n+        } finally {\n+          fsn.readUnlock();\n+        }\n         targetFileReplication \u003d (short) (ecSchema.getNumDataUnits() + ecSchema.getNumParityUnits());\n       } else {\n         targetFileReplication \u003d file.getReplication();\n       }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if(file.getReplication() \u003d\u003d 0) {\n        final FSNamesystem fsn \u003d namenode.getNamesystem();\n        final ECSchema ecSchema;\n        fsn.readLock();\n        try {\n          INode inode \u003d namenode.getNamesystem().getFSDirectory()\n              .getINode(path);\n          INodesInPath iip \u003d INodesInPath.fromINode(inode);\n          ecSchema \u003d FSDirErasureCodingOp.getErasureCodingSchema(fsn, iip);\n        } finally {\n          fsn.readUnlock();\n        }\n        targetFileReplication \u003d (short) (ecSchema.getNumDataUnits() + ecSchema.getNumParityUnits());\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "0ed92e5b13f6bbc0ea7475bc67488359413a980e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7768. Change fsck to support EC files.  Contributed by Takanobu Asanuma\n",
      "commitDate": "26/05/15 12:07 PM",
      "commitName": "0ed92e5b13f6bbc0ea7475bc67488359413a980e",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "e53fa769c97416af69ea567aecd44f67e896688b",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,203 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n-      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n+      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n-      short targetFileReplication \u003d file.getReplication();\n+      short targetFileReplication;\n+      if(file.getReplication() \u003d\u003d 0) {\n+        INode inode \u003d namenode.getNamesystem().getFSDirectory().getINode(path);\n+        INodesInPath iip \u003d INodesInPath.fromINode(inode);\n+        ECSchema ecSchema \u003d namenode.getNamesystem().getFSDirectory().getECSchema(iip);\n+        targetFileReplication \u003d (short) (ecSchema.getNumDataUnits() + ecSchema.getNumParityUnits());\n+      } else {\n+        targetFileReplication \u003d file.getReplication();\n+      }\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication;\n      if(file.getReplication() \u003d\u003d 0) {\n        INode inode \u003d namenode.getNamesystem().getFSDirectory().getINode(path);\n        INodesInPath iip \u003d INodesInPath.fromINode(inode);\n        ECSchema ecSchema \u003d namenode.getNamesystem().getFSDirectory().getECSchema(iip);\n        targetFileReplication \u003d (short) (ecSchema.getNumDataUnits() + ecSchema.getNumParityUnits());\n      } else {\n        targetFileReplication \u003d file.getReplication();\n      }\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "e53fa769c97416af69ea567aecd44f67e896688b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8186. Erasure coding: Make block placement policy for EC file configurable. Contributed by Walter Su.\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "e53fa769c97416af69ea567aecd44f67e896688b",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "b008348dbf9bdd5070930be5d182116c5d370f6b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       final BlockInfo storedBlock \u003d bm.getStoredBlock(\n           block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n-      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n+      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicies.getPolicy(false)\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "a38a37c63417a3b19dcdf98251af196c9d7b8c31": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7912. Erasure Coding: track BlockInfo instead of Block in UnderReplicatedBlocks and PendingReplicationBlocks. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:41 AM",
      "commitName": "a38a37c63417a3b19dcdf98251af196c9d7b8c31",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "9af1f4779b646fb2f09b5e36447c8b8abe920a7c",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,195 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n+      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n+          block.getLocalBlock());\n       // count decommissionedReplicas / decommissioningReplicas\n-      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n+      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n-        out.println(\" Replica placement policy is violated for \" + \n+        out.println(\" Replica placement policy is violated for \" +\n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n           for (int i \u003d 0; i \u003c storages.length; i++) {\n             DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      final BlockInfo storedBlock \u003d bm.getStoredBlock(\n          block.getLocalBlock());\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(storedBlock);\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" +\n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "9af1f4779b646fb2f09b5e36447c8b8abe920a7c": {
      "type": "Ybodychange",
      "commitMessage": "Addendum fix for HDFS-7749 to be compatible with HDFS-7993\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "9af1f4779b646fb2f09b5e36447c8b8abe920a7c",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,193 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" + \n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n-          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n-          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n-            DatanodeStorageInfo storage \u003d iterator.next();\n+          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n+          for (int i \u003d 0; i \u003c storages.length; i++) {\n+            DatanodeStorageInfo storage \u003d storages[i];\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n-              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n+              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n-            if (iterator.hasNext()) {\n+            if (i \u003c storages.length - 1) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          DatanodeStorageInfo[] storages \u003d bm.getStorages(storedBlock);\n          for (int i \u003d 0; i \u003c storages.length; i++) {\n            DatanodeStorageInfo storage \u003d storages[i];\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlockInfo\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (i \u003c storages.length - 1) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "0c590e1c097462979f7ee054ad9121345d58655b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8405. Fix a typo in NamenodeFsck.  Contributed by Takanobu Asanuma\n",
      "commitDate": "18/05/15 11:57 AM",
      "commitName": "0c590e1c097462979f7ee054ad9121345d58655b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "12/05/15 6:29 AM",
      "commitNameOld": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 6.23,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,193 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n-      if(totalReplicasPerBlock \u003c minReplication){\n+      if(totalReplicasPerBlock \u003c res.minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n-      if (totalReplicasPerBlock \u003e\u003d minReplication)\n+      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n-      // count mis replicated blocks block\n+      // count mis replicated blocks\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" + \n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c res.minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d res.minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "2ea0f2fc938febd7fbbe03656a91ae3db1409c50": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8174. Update replication count to live rep count in fsck report. Contributed by  J.Andreina\n",
      "commitDate": "07/05/15 10:31 PM",
      "commitName": "2ea0f2fc938febd7fbbe03656a91ae3db1409c50",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "01/05/15 8:42 AM",
      "commitNameOld": "279958b772c25e0633bd967828b7d27d5c0a6a56",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 6.58,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,193 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n     long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n         res.addCorrupt(block.getNumBytes());\n         corrupt++;\n         corruptSize +\u003d block.getNumBytes();\n         out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n             block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks block\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" + \n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n       if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n         // If the block is corrupted, it means all its available replicas are\n         // corrupted. We don\u0027t mark it as missing given these available replicas\n         // might still be accessible as the block might be incorrectly marked as\n         // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n-        report.append(\" repl\u003d\" + liveReplicas);\n+        report.append(\" Live_repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n       if (!showFiles) {\n         if (missing \u003e 0) {\n           out.print(\"\\n\" + path + \": MISSING \" + missing\n               + \" blocks of total size \" + missize + \" B.\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n               + \" blocks of total size \" + corruptSize + \" B.\");\n         }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n       if (missing \u003e 0 || corrupt \u003e 0) {\n         if (missing \u003e 0) {\n           out.print(\" MISSING \" + missing + \" blocks of total size \" +\n               missize + \" B\\n\");\n         }\n         if (corrupt \u003e 0) {\n           out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n               corruptSize + \" B\\n\");\n         }\n       } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks block\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" Live_repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "279958b772c25e0633bd967828b7d27d5c0a6a56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7281. Missing block is marked as corrupted block (Ming Ma via Yongjun Zhang)\n",
      "commitDate": "01/05/15 8:42 AM",
      "commitName": "279958b772c25e0633bd967828b7d27d5c0a6a56",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "29/04/15 11:12 AM",
      "commitNameOld": "3dd6395bb2448e5b178a51c864e3c9a3d12e8bc9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.9,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,174 +1,193 @@\n   private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n       LocatedBlocks blocks) throws IOException {\n     String path \u003d file.getFullName(parent);\n     boolean isOpen \u003d blocks.isUnderConstruction();\n     int missing \u003d 0;\n     int corrupt \u003d 0;\n     long missize \u003d 0;\n+    long corruptSize \u003d 0;\n     int underReplicatedPerFile \u003d 0;\n     int misReplicatedPerFile \u003d 0;\n     StringBuilder report \u003d new StringBuilder();\n     int blockNumber \u003d 0;\n     for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n       ExtendedBlock block \u003d lBlk.getBlock();\n       BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n \n       // count decommissionedReplicas / decommissioningReplicas\n       NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n       int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n       int decommissioningReplicas \u003d numberReplicas.decommissioning();\n       res.decommissionedReplicas +\u003d  decommissionedReplicas;\n       res.decommissioningReplicas +\u003d decommissioningReplicas;\n \n       // count total replicas\n       int liveReplicas \u003d numberReplicas.liveReplicas();\n       int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n           decommissioningReplicas;\n       res.totalReplicas +\u003d totalReplicasPerBlock;\n \n       // count expected replicas\n       short targetFileReplication \u003d file.getReplication();\n       res.numExpectedReplicas +\u003d targetFileReplication;\n \n       // count under min repl\u0027d blocks\n       if(totalReplicasPerBlock \u003c minReplication){\n         res.numUnderMinReplicatedBlocks++;\n       }\n \n       // count excessive Replicas / over replicated blocks\n       if (liveReplicas \u003e targetFileReplication) {\n         res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n         res.numOverReplicatedBlocks +\u003d 1;\n       }\n \n       // count corrupt blocks\n       boolean isCorrupt \u003d lBlk.isCorrupt();\n       if (isCorrupt) {\n+        res.addCorrupt(block.getNumBytes());\n         corrupt++;\n-        res.corruptBlocks++;\n-        out.print(\"\\n\" + path + \": CORRUPT blockpool \" + block.getBlockPoolId() + \n-            \" block \" + block.getBlockName()+\"\\n\");\n+        corruptSize +\u003d block.getNumBytes();\n+        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n+            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n       }\n \n       // count minimally replicated blocks\n       if (totalReplicasPerBlock \u003e\u003d minReplication)\n         res.numMinReplicatedBlocks++;\n \n       // count missing replicas / under replicated blocks\n       if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n         res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n         res.numUnderReplicatedBlocks +\u003d 1;\n         underReplicatedPerFile++;\n         if (!showFiles) {\n           out.print(\"\\n\" + path + \": \");\n         }\n         out.println(\" Under replicated \" + block +\n                     \". Target Replicas is \" +\n                     targetFileReplication + \" but found \" +\n                     liveReplicas + \" live replica(s), \" +\n                     decommissionedReplicas + \" decommissioned replica(s) and \" +\n                     decommissioningReplicas + \" decommissioning replica(s).\");\n       }\n \n       // count mis replicated blocks block\n       BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n           .verifyBlockPlacement(path, lBlk, targetFileReplication);\n       if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n         res.numMisReplicatedBlocks++;\n         misReplicatedPerFile++;\n         if (!showFiles) {\n           if(underReplicatedPerFile \u003d\u003d 0)\n             out.println();\n           out.print(path + \": \");\n         }\n         out.println(\" Replica placement policy is violated for \" + \n                     block + \". \" + blockPlacementStatus.getErrorDescription());\n       }\n \n       // count storage summary\n       if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n         countStorageTypeSummary(file, lBlk);\n       }\n \n       // report\n       String blkName \u003d block.toString();\n       report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n-      if (totalReplicasPerBlock \u003d\u003d 0) {\n+      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n+        // If the block is corrupted, it means all its available replicas are\n+        // corrupted. We don\u0027t mark it as missing given these available replicas\n+        // might still be accessible as the block might be incorrectly marked as\n+        // corrupted by client machines.\n         report.append(\" MISSING!\");\n         res.addMissing(block.toString(), block.getNumBytes());\n         missing++;\n         missize +\u003d block.getNumBytes();\n       } else {\n         report.append(\" repl\u003d\" + liveReplicas);\n         if (showLocations || showRacks || showReplicaDetails) {\n           StringBuilder sb \u003d new StringBuilder(\"[\");\n           Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n           for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n             DatanodeStorageInfo storage \u003d iterator.next();\n             DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n             if (showRacks) {\n               sb.append(NodeBase.getPath(dnDesc));\n             } else {\n               sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                   .getStorageType()));\n             }\n             if (showReplicaDetails) {\n               LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                   bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n               Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                   bm.getCorruptReplicas(block.getLocalBlock());\n               sb.append(\"(\");\n               if (dnDesc.isDecommissioned()) {\n                 sb.append(\"DECOMMISSIONED)\");\n               } else if (dnDesc.isDecommissionInProgress()) {\n                 sb.append(\"DECOMMISSIONING)\");\n               } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                 sb.append(\"CORRUPT)\");\n               } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                 sb.append(\"EXCESS)\");\n               } else if (dnDesc.isStale(this.staleInterval)) {\n                 sb.append(\"STALE_NODE)\");\n               } else if (storage.areBlockContentsStale()) {\n                 sb.append(\"STALE_BLOCK_CONTENT)\");\n               } else {\n                 sb.append(\"LIVE)\");\n               }\n             }\n             if (iterator.hasNext()) {\n               sb.append(\", \");\n             }\n           }\n           sb.append(\u0027]\u0027);\n           report.append(\" \" + sb.toString());\n         }\n       }\n       report.append(\u0027\\n\u0027);\n       blockNumber++;\n     }\n \n     // count corrupt file \u0026 move or delete if necessary\n     if ((missing \u003e 0) || (corrupt \u003e 0)) {\n-      if (!showFiles \u0026\u0026 (missing \u003e 0)) {\n-        out.print(\"\\n\" + path + \": MISSING \" + missing\n-            + \" blocks of total size \" + missize + \" B.\");\n+      if (!showFiles) {\n+        if (missing \u003e 0) {\n+          out.print(\"\\n\" + path + \": MISSING \" + missing\n+              + \" blocks of total size \" + missize + \" B.\");\n+        }\n+        if (corrupt \u003e 0) {\n+          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n+              + \" blocks of total size \" + corruptSize + \" B.\");\n+        }\n       }\n       res.corruptFiles++;\n       if (isOpen) {\n         LOG.info(\"Fsck: ignoring open file \" + path);\n       } else {\n         if (doMove) copyBlocksToLostFound(parent, file, blocks);\n         if (doDelete) deleteCorruptedFile(path);\n       }\n     }\n \n     if (showFiles) {\n-      if (missing \u003e 0) {\n-        out.print(\" MISSING \" + missing + \" blocks of total size \" + missize + \" B\\n\");\n-      }  else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n+      if (missing \u003e 0 || corrupt \u003e 0) {\n+        if (missing \u003e 0) {\n+          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n+              missize + \" B\\n\");\n+        }\n+        if (corrupt \u003e 0) {\n+          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n+              corruptSize + \" B\\n\");\n+        }\n+      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n         out.print(\" OK\\n\");\n       }\n       if (showBlocks) {\n         out.print(report.toString() + \"\\n\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    long corruptSize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        res.addCorrupt(block.getNumBytes());\n        corrupt++;\n        corruptSize +\u003d block.getNumBytes();\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" +\n            block.getBlockPoolId() + \" block \" + block.getBlockName() + \"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks block\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0 \u0026\u0026 !isCorrupt) {\n        // If the block is corrupted, it means all its available replicas are\n        // corrupted. We don\u0027t mark it as missing given these available replicas\n        // might still be accessible as the block might be incorrectly marked as\n        // corrupted by client machines.\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles) {\n        if (missing \u003e 0) {\n          out.print(\"\\n\" + path + \": MISSING \" + missing\n              + \" blocks of total size \" + missize + \" B.\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\"\\n\" + path + \": CORRUPT \" + corrupt\n              + \" blocks of total size \" + corruptSize + \" B.\");\n        }\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0 || corrupt \u003e 0) {\n        if (missing \u003e 0) {\n          out.print(\" MISSING \" + missing + \" blocks of total size \" +\n              missize + \" B\\n\");\n        }\n        if (corrupt \u003e 0) {\n          out.print(\" CORRUPT \" + corrupt + \" blocks of total size \" +\n              corruptSize + \" B\\n\");\n        }\n      } else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "ef4e9963b25d7d2e30f1071ddcaa9d92a7fe70f3": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8215. Refactor NamenodeFsck#check method.  Contributed by Takanobu Asanuma\n",
      "commitDate": "23/04/15 2:19 PM",
      "commitName": "ef4e9963b25d7d2e30f1071ddcaa9d92a7fe70f3",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "diff": "@@ -0,0 +1,174 @@\n+  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n+      LocatedBlocks blocks) throws IOException {\n+    String path \u003d file.getFullName(parent);\n+    boolean isOpen \u003d blocks.isUnderConstruction();\n+    int missing \u003d 0;\n+    int corrupt \u003d 0;\n+    long missize \u003d 0;\n+    int underReplicatedPerFile \u003d 0;\n+    int misReplicatedPerFile \u003d 0;\n+    StringBuilder report \u003d new StringBuilder();\n+    int blockNumber \u003d 0;\n+    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n+      ExtendedBlock block \u003d lBlk.getBlock();\n+      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n+\n+      // count decommissionedReplicas / decommissioningReplicas\n+      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n+      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n+      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n+      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n+      res.decommissioningReplicas +\u003d decommissioningReplicas;\n+\n+      // count total replicas\n+      int liveReplicas \u003d numberReplicas.liveReplicas();\n+      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n+          decommissioningReplicas;\n+      res.totalReplicas +\u003d totalReplicasPerBlock;\n+\n+      // count expected replicas\n+      short targetFileReplication \u003d file.getReplication();\n+      res.numExpectedReplicas +\u003d targetFileReplication;\n+\n+      // count under min repl\u0027d blocks\n+      if(totalReplicasPerBlock \u003c minReplication){\n+        res.numUnderMinReplicatedBlocks++;\n+      }\n+\n+      // count excessive Replicas / over replicated blocks\n+      if (liveReplicas \u003e targetFileReplication) {\n+        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n+        res.numOverReplicatedBlocks +\u003d 1;\n+      }\n+\n+      // count corrupt blocks\n+      boolean isCorrupt \u003d lBlk.isCorrupt();\n+      if (isCorrupt) {\n+        corrupt++;\n+        res.corruptBlocks++;\n+        out.print(\"\\n\" + path + \": CORRUPT blockpool \" + block.getBlockPoolId() + \n+            \" block \" + block.getBlockName()+\"\\n\");\n+      }\n+\n+      // count minimally replicated blocks\n+      if (totalReplicasPerBlock \u003e\u003d minReplication)\n+        res.numMinReplicatedBlocks++;\n+\n+      // count missing replicas / under replicated blocks\n+      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n+        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n+        res.numUnderReplicatedBlocks +\u003d 1;\n+        underReplicatedPerFile++;\n+        if (!showFiles) {\n+          out.print(\"\\n\" + path + \": \");\n+        }\n+        out.println(\" Under replicated \" + block +\n+                    \". Target Replicas is \" +\n+                    targetFileReplication + \" but found \" +\n+                    liveReplicas + \" live replica(s), \" +\n+                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n+                    decommissioningReplicas + \" decommissioning replica(s).\");\n+      }\n+\n+      // count mis replicated blocks block\n+      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n+          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n+      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n+        res.numMisReplicatedBlocks++;\n+        misReplicatedPerFile++;\n+        if (!showFiles) {\n+          if(underReplicatedPerFile \u003d\u003d 0)\n+            out.println();\n+          out.print(path + \": \");\n+        }\n+        out.println(\" Replica placement policy is violated for \" + \n+                    block + \". \" + blockPlacementStatus.getErrorDescription());\n+      }\n+\n+      // count storage summary\n+      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n+        countStorageTypeSummary(file, lBlk);\n+      }\n+\n+      // report\n+      String blkName \u003d block.toString();\n+      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n+      if (totalReplicasPerBlock \u003d\u003d 0) {\n+        report.append(\" MISSING!\");\n+        res.addMissing(block.toString(), block.getNumBytes());\n+        missing++;\n+        missize +\u003d block.getNumBytes();\n+      } else {\n+        report.append(\" repl\u003d\" + liveReplicas);\n+        if (showLocations || showRacks || showReplicaDetails) {\n+          StringBuilder sb \u003d new StringBuilder(\"[\");\n+          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n+          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n+            DatanodeStorageInfo storage \u003d iterator.next();\n+            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n+            if (showRacks) {\n+              sb.append(NodeBase.getPath(dnDesc));\n+            } else {\n+              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n+                  .getStorageType()));\n+            }\n+            if (showReplicaDetails) {\n+              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n+                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n+              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n+                  bm.getCorruptReplicas(block.getLocalBlock());\n+              sb.append(\"(\");\n+              if (dnDesc.isDecommissioned()) {\n+                sb.append(\"DECOMMISSIONED)\");\n+              } else if (dnDesc.isDecommissionInProgress()) {\n+                sb.append(\"DECOMMISSIONING)\");\n+              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n+                sb.append(\"CORRUPT)\");\n+              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n+                sb.append(\"EXCESS)\");\n+              } else if (dnDesc.isStale(this.staleInterval)) {\n+                sb.append(\"STALE_NODE)\");\n+              } else if (storage.areBlockContentsStale()) {\n+                sb.append(\"STALE_BLOCK_CONTENT)\");\n+              } else {\n+                sb.append(\"LIVE)\");\n+              }\n+            }\n+            if (iterator.hasNext()) {\n+              sb.append(\", \");\n+            }\n+          }\n+          sb.append(\u0027]\u0027);\n+          report.append(\" \" + sb.toString());\n+        }\n+      }\n+      report.append(\u0027\\n\u0027);\n+      blockNumber++;\n+    }\n+\n+    // count corrupt file \u0026 move or delete if necessary\n+    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n+      if (!showFiles \u0026\u0026 (missing \u003e 0)) {\n+        out.print(\"\\n\" + path + \": MISSING \" + missing\n+            + \" blocks of total size \" + missize + \" B.\");\n+      }\n+      res.corruptFiles++;\n+      if (isOpen) {\n+        LOG.info(\"Fsck: ignoring open file \" + path);\n+      } else {\n+        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n+        if (doDelete) deleteCorruptedFile(path);\n+      }\n+    }\n+\n+    if (showFiles) {\n+      if (missing \u003e 0) {\n+        out.print(\" MISSING \" + missing + \" blocks of total size \" + missize + \" B\\n\");\n+      }  else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n+        out.print(\" OK\\n\");\n+      }\n+      if (showBlocks) {\n+        out.print(report.toString() + \"\\n\");\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectBlocksSummary(String parent, HdfsFileStatus file, Result res,\n      LocatedBlocks blocks) throws IOException {\n    String path \u003d file.getFullName(parent);\n    boolean isOpen \u003d blocks.isUnderConstruction();\n    int missing \u003d 0;\n    int corrupt \u003d 0;\n    long missize \u003d 0;\n    int underReplicatedPerFile \u003d 0;\n    int misReplicatedPerFile \u003d 0;\n    StringBuilder report \u003d new StringBuilder();\n    int blockNumber \u003d 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block \u003d lBlk.getBlock();\n      BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n\n      // count decommissionedReplicas / decommissioningReplicas\n      NumberReplicas numberReplicas \u003d bm.countNodes(block.getLocalBlock());\n      int decommissionedReplicas \u003d numberReplicas.decommissioned();;\n      int decommissioningReplicas \u003d numberReplicas.decommissioning();\n      res.decommissionedReplicas +\u003d  decommissionedReplicas;\n      res.decommissioningReplicas +\u003d decommissioningReplicas;\n\n      // count total replicas\n      int liveReplicas \u003d numberReplicas.liveReplicas();\n      int totalReplicasPerBlock \u003d liveReplicas + decommissionedReplicas +\n          decommissioningReplicas;\n      res.totalReplicas +\u003d totalReplicasPerBlock;\n\n      // count expected replicas\n      short targetFileReplication \u003d file.getReplication();\n      res.numExpectedReplicas +\u003d targetFileReplication;\n\n      // count under min repl\u0027d blocks\n      if(totalReplicasPerBlock \u003c minReplication){\n        res.numUnderMinReplicatedBlocks++;\n      }\n\n      // count excessive Replicas / over replicated blocks\n      if (liveReplicas \u003e targetFileReplication) {\n        res.excessiveReplicas +\u003d (liveReplicas - targetFileReplication);\n        res.numOverReplicatedBlocks +\u003d 1;\n      }\n\n      // count corrupt blocks\n      boolean isCorrupt \u003d lBlk.isCorrupt();\n      if (isCorrupt) {\n        corrupt++;\n        res.corruptBlocks++;\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" + block.getBlockPoolId() + \n            \" block \" + block.getBlockName()+\"\\n\");\n      }\n\n      // count minimally replicated blocks\n      if (totalReplicasPerBlock \u003e\u003d minReplication)\n        res.numMinReplicatedBlocks++;\n\n      // count missing replicas / under replicated blocks\n      if (totalReplicasPerBlock \u003c targetFileReplication \u0026\u0026 totalReplicasPerBlock \u003e 0) {\n        res.missingReplicas +\u003d (targetFileReplication - totalReplicasPerBlock);\n        res.numUnderReplicatedBlocks +\u003d 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    liveReplicas + \" live replica(s), \" +\n                    decommissionedReplicas + \" decommissioned replica(s) and \" +\n                    decommissioningReplicas + \" decommissioning replica(s).\");\n      }\n\n      // count mis replicated blocks block\n      BlockPlacementStatus blockPlacementStatus \u003d bpPolicy\n          .verifyBlockPlacement(path, lBlk, targetFileReplication);\n      if (!blockPlacementStatus.isPlacementPolicySatisfied()) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile \u003d\u003d 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block + \". \" + blockPlacementStatus.getErrorDescription());\n      }\n\n      // count storage summary\n      if (this.showStoragePolcies \u0026\u0026 lBlk.getStorageTypes() !\u003d null) {\n        countStorageTypeSummary(file, lBlk);\n      }\n\n      // report\n      String blkName \u003d block.toString();\n      report.append(blockNumber + \". \" + blkName + \" len\u003d\" + block.getNumBytes());\n      if (totalReplicasPerBlock \u003d\u003d 0) {\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize +\u003d block.getNumBytes();\n      } else {\n        report.append(\" repl\u003d\" + liveReplicas);\n        if (showLocations || showRacks || showReplicaDetails) {\n          StringBuilder sb \u003d new StringBuilder(\"[\");\n          Iterable\u003cDatanodeStorageInfo\u003e storages \u003d bm.getStorages(block.getLocalBlock());\n          for (Iterator\u003cDatanodeStorageInfo\u003e iterator \u003d storages.iterator(); iterator.hasNext();) {\n            DatanodeStorageInfo storage \u003d iterator.next();\n            DatanodeDescriptor dnDesc \u003d storage.getDatanodeDescriptor();\n            if (showRacks) {\n              sb.append(NodeBase.getPath(dnDesc));\n            } else {\n              sb.append(new DatanodeInfoWithStorage(dnDesc, storage.getStorageID(), storage\n                  .getStorageType()));\n            }\n            if (showReplicaDetails) {\n              LightWeightLinkedSet\u003cBlock\u003e blocksExcess \u003d\n                  bm.excessReplicateMap.get(dnDesc.getDatanodeUuid());\n              Collection\u003cDatanodeDescriptor\u003e corruptReplicas \u003d\n                  bm.getCorruptReplicas(block.getLocalBlock());\n              sb.append(\"(\");\n              if (dnDesc.isDecommissioned()) {\n                sb.append(\"DECOMMISSIONED)\");\n              } else if (dnDesc.isDecommissionInProgress()) {\n                sb.append(\"DECOMMISSIONING)\");\n              } else if (corruptReplicas !\u003d null \u0026\u0026 corruptReplicas.contains(dnDesc)) {\n                sb.append(\"CORRUPT)\");\n              } else if (blocksExcess !\u003d null \u0026\u0026 blocksExcess.contains(block.getLocalBlock())) {\n                sb.append(\"EXCESS)\");\n              } else if (dnDesc.isStale(this.staleInterval)) {\n                sb.append(\"STALE_NODE)\");\n              } else if (storage.areBlockContentsStale()) {\n                sb.append(\"STALE_BLOCK_CONTENT)\");\n              } else {\n                sb.append(\"LIVE)\");\n              }\n            }\n            if (iterator.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n          sb.append(\u0027]\u0027);\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append(\u0027\\n\u0027);\n      blockNumber++;\n    }\n\n    // count corrupt file \u0026 move or delete if necessary\n    if ((missing \u003e 0) || (corrupt \u003e 0)) {\n      if (!showFiles \u0026\u0026 (missing \u003e 0)) {\n        out.print(\"\\n\" + path + \": MISSING \" + missing\n            + \" blocks of total size \" + missize + \" B.\");\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n\n    if (showFiles) {\n      if (missing \u003e 0) {\n        out.print(\" MISSING \" + missing + \" blocks of total size \" + missize + \" B\\n\");\n      }  else if (underReplicatedPerFile \u003d\u003d 0 \u0026\u0026 misReplicatedPerFile \u003d\u003d 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java"
    }
  }
}