{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCSQueue.java",
  "functionName": "accept",
  "functionId": "accept___cluster-Resource__request-ResourceCommitRequest__FiCaSchedulerApp,FiCaSchedulerNode__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
  "functionStartLine": 1291,
  "functionEndLine": 1342,
  "numCommitsSeen": 76,
  "timeTaken": 4128,
  "changeHistory": [
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c"
  ],
  "changeHistoryShort": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     // Do we need to check parent queue before making this decision?\n     boolean checkParentQueue \u003d false;\n \n     ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n         request.getFirstAllocatedOrReservedContainer();\n     SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n         allocation.getAllocatedOrReservedContainer();\n \n     // Do not check when allocating new container from a reserved container\n     if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n       Resource required \u003d allocation.getAllocatedOrReservedResource();\n       Resource netAllocated \u003d Resources.subtract(required,\n           request.getTotalReleasedResource());\n \n+      readLock.lock();\n       try {\n-        readLock.lock();\n-\n         String partition \u003d schedulerContainer.getNodePartition();\n         Resource maxResourceLimit;\n         if (allocation.getSchedulingMode()\n             \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n           maxResourceLimit \u003d getQueueMaxResource(partition);\n         } else{\n           maxResourceLimit \u003d labelManager.getResourceByLabel(\n               schedulerContainer.getNodePartition(), cluster);\n         }\n         if (!Resources.fitsIn(resourceCalculator,\n             Resources.add(queueUsage.getUsed(partition), netAllocated),\n             maxResourceLimit)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                 + \" exceeded maxResourceLimit of the queue \u003d\"\n                 + maxResourceLimit);\n           }\n           return false;\n         }\n       } finally {\n         readLock.unlock();\n       }\n \n       // Only check parent queue when something new allocated or reserved.\n       checkParentQueue \u003d true;\n     }\n \n \n     if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n       return parent.accept(cluster, request);\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    // Do we need to check parent queue before making this decision?\n    boolean checkParentQueue \u003d false;\n\n    ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n        request.getFirstAllocatedOrReservedContainer();\n    SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n        allocation.getAllocatedOrReservedContainer();\n\n    // Do not check when allocating new container from a reserved container\n    if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n      Resource required \u003d allocation.getAllocatedOrReservedResource();\n      Resource netAllocated \u003d Resources.subtract(required,\n          request.getTotalReleasedResource());\n\n      readLock.lock();\n      try {\n        String partition \u003d schedulerContainer.getNodePartition();\n        Resource maxResourceLimit;\n        if (allocation.getSchedulingMode()\n            \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n          maxResourceLimit \u003d getQueueMaxResource(partition);\n        } else{\n          maxResourceLimit \u003d labelManager.getResourceByLabel(\n              schedulerContainer.getNodePartition(), cluster);\n        }\n        if (!Resources.fitsIn(resourceCalculator,\n            Resources.add(queueUsage.getUsed(partition), netAllocated),\n            maxResourceLimit)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                + \" exceeded maxResourceLimit of the queue \u003d\"\n                + maxResourceLimit);\n          }\n          return false;\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      // Only check parent queue when something new allocated or reserved.\n      checkParentQueue \u003d true;\n    }\n\n\n    if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n      return parent.accept(cluster, request);\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     // Do we need to check parent queue before making this decision?\n     boolean checkParentQueue \u003d false;\n \n     ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n         request.getFirstAllocatedOrReservedContainer();\n     SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n         allocation.getAllocatedOrReservedContainer();\n \n     // Do not check when allocating new container from a reserved container\n     if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n       Resource required \u003d allocation.getAllocatedOrReservedResource();\n       Resource netAllocated \u003d Resources.subtract(required,\n           request.getTotalReleasedResource());\n \n       try {\n         readLock.lock();\n \n         String partition \u003d schedulerContainer.getNodePartition();\n         Resource maxResourceLimit;\n         if (allocation.getSchedulingMode()\n             \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n-          maxResourceLimit \u003d getQueueMaxResource(partition, cluster);\n+          maxResourceLimit \u003d getQueueMaxResource(partition);\n         } else{\n           maxResourceLimit \u003d labelManager.getResourceByLabel(\n               schedulerContainer.getNodePartition(), cluster);\n         }\n         if (!Resources.fitsIn(resourceCalculator,\n             Resources.add(queueUsage.getUsed(partition), netAllocated),\n             maxResourceLimit)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                 + \" exceeded maxResourceLimit of the queue \u003d\"\n                 + maxResourceLimit);\n           }\n           return false;\n         }\n       } finally {\n         readLock.unlock();\n       }\n \n       // Only check parent queue when something new allocated or reserved.\n       checkParentQueue \u003d true;\n     }\n \n \n     if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n       return parent.accept(cluster, request);\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    // Do we need to check parent queue before making this decision?\n    boolean checkParentQueue \u003d false;\n\n    ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n        request.getFirstAllocatedOrReservedContainer();\n    SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n        allocation.getAllocatedOrReservedContainer();\n\n    // Do not check when allocating new container from a reserved container\n    if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n      Resource required \u003d allocation.getAllocatedOrReservedResource();\n      Resource netAllocated \u003d Resources.subtract(required,\n          request.getTotalReleasedResource());\n\n      try {\n        readLock.lock();\n\n        String partition \u003d schedulerContainer.getNodePartition();\n        Resource maxResourceLimit;\n        if (allocation.getSchedulingMode()\n            \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n          maxResourceLimit \u003d getQueueMaxResource(partition);\n        } else{\n          maxResourceLimit \u003d labelManager.getResourceByLabel(\n              schedulerContainer.getNodePartition(), cluster);\n        }\n        if (!Resources.fitsIn(resourceCalculator,\n            Resources.add(queueUsage.getUsed(partition), netAllocated),\n            maxResourceLimit)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                + \" exceeded maxResourceLimit of the queue \u003d\"\n                + maxResourceLimit);\n          }\n          return false;\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      // Only check parent queue when something new allocated or reserved.\n      checkParentQueue \u003d true;\n    }\n\n\n    if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n      return parent.accept(cluster, request);\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
      "commitDate": "17/09/17 9:20 PM",
      "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/08/17 1:31 PM",
      "commitNameOld": "5558792894169425bff054364a1ab4c48b347fb9",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 34.33,
      "commitsBetweenForRepo": 331,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     // Do we need to check parent queue before making this decision?\n     boolean checkParentQueue \u003d false;\n \n     ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n         request.getFirstAllocatedOrReservedContainer();\n     SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n         allocation.getAllocatedOrReservedContainer();\n \n     // Do not check when allocating new container from a reserved container\n     if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n       Resource required \u003d allocation.getAllocatedOrReservedResource();\n       Resource netAllocated \u003d Resources.subtract(required,\n           request.getTotalReleasedResource());\n \n       try {\n         readLock.lock();\n \n         String partition \u003d schedulerContainer.getNodePartition();\n         Resource maxResourceLimit;\n         if (allocation.getSchedulingMode()\n             \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n           maxResourceLimit \u003d getQueueMaxResource(partition, cluster);\n         } else{\n           maxResourceLimit \u003d labelManager.getResourceByLabel(\n               schedulerContainer.getNodePartition(), cluster);\n         }\n-        if (!Resources.fitsIn(resourceCalculator, cluster,\n+        if (!Resources.fitsIn(resourceCalculator,\n             Resources.add(queueUsage.getUsed(partition), netAllocated),\n             maxResourceLimit)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                 + \" exceeded maxResourceLimit of the queue \u003d\"\n                 + maxResourceLimit);\n           }\n           return false;\n         }\n       } finally {\n         readLock.unlock();\n       }\n \n       // Only check parent queue when something new allocated or reserved.\n       checkParentQueue \u003d true;\n     }\n \n \n     if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n       return parent.accept(cluster, request);\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    // Do we need to check parent queue before making this decision?\n    boolean checkParentQueue \u003d false;\n\n    ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n        request.getFirstAllocatedOrReservedContainer();\n    SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n        allocation.getAllocatedOrReservedContainer();\n\n    // Do not check when allocating new container from a reserved container\n    if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n      Resource required \u003d allocation.getAllocatedOrReservedResource();\n      Resource netAllocated \u003d Resources.subtract(required,\n          request.getTotalReleasedResource());\n\n      try {\n        readLock.lock();\n\n        String partition \u003d schedulerContainer.getNodePartition();\n        Resource maxResourceLimit;\n        if (allocation.getSchedulingMode()\n            \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n          maxResourceLimit \u003d getQueueMaxResource(partition, cluster);\n        } else{\n          maxResourceLimit \u003d labelManager.getResourceByLabel(\n              schedulerContainer.getNodePartition(), cluster);\n        }\n        if (!Resources.fitsIn(resourceCalculator,\n            Resources.add(queueUsage.getUsed(partition), netAllocated),\n            maxResourceLimit)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                + \" exceeded maxResourceLimit of the queue \u003d\"\n                + maxResourceLimit);\n          }\n          return false;\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      // Only check parent queue when something new allocated or reserved.\n      checkParentQueue \u003d true;\n    }\n\n\n    if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n      return parent.accept(cluster, request);\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,53 @@\n+  public boolean accept(Resource cluster,\n+      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+    // Do we need to check parent queue before making this decision?\n+    boolean checkParentQueue \u003d false;\n+\n+    ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n+        request.getFirstAllocatedOrReservedContainer();\n+    SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n+        allocation.getAllocatedOrReservedContainer();\n+\n+    // Do not check when allocating new container from a reserved container\n+    if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n+      Resource required \u003d allocation.getAllocatedOrReservedResource();\n+      Resource netAllocated \u003d Resources.subtract(required,\n+          request.getTotalReleasedResource());\n+\n+      try {\n+        readLock.lock();\n+\n+        String partition \u003d schedulerContainer.getNodePartition();\n+        Resource maxResourceLimit;\n+        if (allocation.getSchedulingMode()\n+            \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n+          maxResourceLimit \u003d getQueueMaxResource(partition, cluster);\n+        } else{\n+          maxResourceLimit \u003d labelManager.getResourceByLabel(\n+              schedulerContainer.getNodePartition(), cluster);\n+        }\n+        if (!Resources.fitsIn(resourceCalculator, cluster,\n+            Resources.add(queueUsage.getUsed(partition), netAllocated),\n+            maxResourceLimit)) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n+                + \" exceeded maxResourceLimit of the queue \u003d\"\n+                + maxResourceLimit);\n+          }\n+          return false;\n+        }\n+      } finally {\n+        readLock.unlock();\n+      }\n+\n+      // Only check parent queue when something new allocated or reserved.\n+      checkParentQueue \u003d true;\n+    }\n+\n+\n+    if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n+      return parent.accept(cluster, request);\n+    }\n+\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    // Do we need to check parent queue before making this decision?\n    boolean checkParentQueue \u003d false;\n\n    ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation \u003d\n        request.getFirstAllocatedOrReservedContainer();\n    SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer \u003d\n        allocation.getAllocatedOrReservedContainer();\n\n    // Do not check when allocating new container from a reserved container\n    if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n      Resource required \u003d allocation.getAllocatedOrReservedResource();\n      Resource netAllocated \u003d Resources.subtract(required,\n          request.getTotalReleasedResource());\n\n      try {\n        readLock.lock();\n\n        String partition \u003d schedulerContainer.getNodePartition();\n        Resource maxResourceLimit;\n        if (allocation.getSchedulingMode()\n            \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n          maxResourceLimit \u003d getQueueMaxResource(partition, cluster);\n        } else{\n          maxResourceLimit \u003d labelManager.getResourceByLabel(\n              schedulerContainer.getNodePartition(), cluster);\n        }\n        if (!Resources.fitsIn(resourceCalculator, cluster,\n            Resources.add(queueUsage.getUsed(partition), netAllocated),\n            maxResourceLimit)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Used resource\u003d\" + queueUsage.getUsed(partition)\n                + \" exceeded maxResourceLimit of the queue \u003d\"\n                + maxResourceLimit);\n          }\n          return false;\n        }\n      } finally {\n        readLock.unlock();\n      }\n\n      // Only check parent queue when something new allocated or reserved.\n      checkParentQueue \u003d true;\n    }\n\n\n    if (parent !\u003d null \u0026\u0026 checkParentQueue) {\n      return parent.accept(cluster, request);\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java"
    }
  }
}