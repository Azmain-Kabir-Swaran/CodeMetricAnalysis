{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PurgeS3GuardDynamoTable.java",
  "functionName": "execute",
  "functionId": "execute",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/PurgeS3GuardDynamoTable.java",
  "functionStartLine": 135,
  "functionEndLine": 194,
  "numCommitsSeen": 2,
  "timeTaken": 2061,
  "changeHistory": [
    "56dee667707926f3796c7757be1a133a362f05c9",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0"
  ],
  "changeHistoryShort": {
    "56dee667707926f3796c7757be1a133a362f05c9": "Ymultichange(Yexceptionschange,Ybodychange)",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56dee667707926f3796c7757be1a133a362f05c9": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
      "commitDate": "13/02/20 11:09 AM",
      "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
          "commitDate": "13/02/20 11:09 AM",
          "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "12/07/19 5:02 AM",
          "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 216.3,
          "commitsBetweenForRepo": 1232,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,60 @@\n-  public int execute() throws ServiceLaunchException {\n+  public int execute() throws ServiceLaunchException, IOException {\n \n     URI uri \u003d getUri();\n     String host \u003d uri.getHost();\n     String prefix \u003d \"/\" + host + \"/\";\n     DynamoDBMetadataStore ddbms \u003d getStore();\n     S3GuardTableAccess tableAccess \u003d new S3GuardTableAccess(ddbms);\n     ExpressionSpecBuilder builder \u003d new ExpressionSpecBuilder();\n     builder.withKeyCondition(\n         ExpressionSpecBuilder.S(PARENT).beginsWith(prefix));\n \n     LOG.info(\"Scanning for entries with prefix {} to delete from {}\",\n         prefix, ddbms);\n \n-    Iterable\u003cDDBPathMetadata\u003e entries \u003d tableAccess.scanMetadata(builder);\n+    Iterable\u003cDDBPathMetadata\u003e entries \u003d\n+        ddbms.wrapWithRetries(tableAccess.scanMetadata(builder));\n     List\u003cPath\u003e list \u003d new ArrayList\u003c\u003e();\n     entries.iterator().forEachRemaining(e -\u003e {\n       if (!(e instanceof S3GuardTableAccess.VersionMarker)) {\n         Path p \u003d e.getFileStatus().getPath();\n         String type \u003d e.getFileStatus().isFile() ? \"file\" : \"directory\";\n         boolean tombstone \u003d e.isDeleted();\n         if (tombstone) {\n           type \u003d \"tombstone \" + type;\n         }\n         LOG.info(\"{} {}\", type, p);\n         list.add(p);\n       }\n     });\n     int count \u003d list.size();\n     filesFound \u003d count;\n     LOG.info(\"Found {} entries{}\",\n         count,\n         (count \u003d\u003d 0 ? \" -nothing to purge\": \"\"));\n     if (count \u003e 0) {\n       if (force) {\n         DurationInfo duration \u003d\n             new DurationInfo(LOG,\n                 \"deleting %s entries from %s\",\n                 count, ddbms.toString());\n-        tableAccess.delete(list);\n+        // sending this in one by one for more efficient retries\n+        for (Path path: list) {\n+          ddbms.getInvoker()\n+              .retry(\"delete\",\n+                  prefix,\n+                  true,\n+                  () -\u003e tableAccess.delete(path));\n+        }\n         duration.close();\n         long durationMillis \u003d duration.value();\n         long timePerEntry \u003d durationMillis / count;\n         LOG.info(\"Time per entry: {} ms\", timePerEntry);\n         filesDeleted \u003d count;\n       } else {\n         LOG.info(\"Delete process will only be executed when \"\n             + FORCE + \" is set\");\n       }\n     }\n     return LauncherExitCodes.EXIT_SUCCESS;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int execute() throws ServiceLaunchException, IOException {\n\n    URI uri \u003d getUri();\n    String host \u003d uri.getHost();\n    String prefix \u003d \"/\" + host + \"/\";\n    DynamoDBMetadataStore ddbms \u003d getStore();\n    S3GuardTableAccess tableAccess \u003d new S3GuardTableAccess(ddbms);\n    ExpressionSpecBuilder builder \u003d new ExpressionSpecBuilder();\n    builder.withKeyCondition(\n        ExpressionSpecBuilder.S(PARENT).beginsWith(prefix));\n\n    LOG.info(\"Scanning for entries with prefix {} to delete from {}\",\n        prefix, ddbms);\n\n    Iterable\u003cDDBPathMetadata\u003e entries \u003d\n        ddbms.wrapWithRetries(tableAccess.scanMetadata(builder));\n    List\u003cPath\u003e list \u003d new ArrayList\u003c\u003e();\n    entries.iterator().forEachRemaining(e -\u003e {\n      if (!(e instanceof S3GuardTableAccess.VersionMarker)) {\n        Path p \u003d e.getFileStatus().getPath();\n        String type \u003d e.getFileStatus().isFile() ? \"file\" : \"directory\";\n        boolean tombstone \u003d e.isDeleted();\n        if (tombstone) {\n          type \u003d \"tombstone \" + type;\n        }\n        LOG.info(\"{} {}\", type, p);\n        list.add(p);\n      }\n    });\n    int count \u003d list.size();\n    filesFound \u003d count;\n    LOG.info(\"Found {} entries{}\",\n        count,\n        (count \u003d\u003d 0 ? \" -nothing to purge\": \"\"));\n    if (count \u003e 0) {\n      if (force) {\n        DurationInfo duration \u003d\n            new DurationInfo(LOG,\n                \"deleting %s entries from %s\",\n                count, ddbms.toString());\n        // sending this in one by one for more efficient retries\n        for (Path path: list) {\n          ddbms.getInvoker()\n              .retry(\"delete\",\n                  prefix,\n                  true,\n                  () -\u003e tableAccess.delete(path));\n        }\n        duration.close();\n        long durationMillis \u003d duration.value();\n        long timePerEntry \u003d durationMillis / count;\n        LOG.info(\"Time per entry: {} ms\", timePerEntry);\n        filesDeleted \u003d count;\n      } else {\n        LOG.info(\"Delete process will only be executed when \"\n            + FORCE + \" is set\");\n      }\n    }\n    return LauncherExitCodes.EXIT_SUCCESS;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/PurgeS3GuardDynamoTable.java",
          "extendedDetails": {
            "oldValue": "[ServiceLaunchException]",
            "newValue": "[ServiceLaunchException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
          "commitDate": "13/02/20 11:09 AM",
          "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "12/07/19 5:02 AM",
          "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 216.3,
          "commitsBetweenForRepo": 1232,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,60 @@\n-  public int execute() throws ServiceLaunchException {\n+  public int execute() throws ServiceLaunchException, IOException {\n \n     URI uri \u003d getUri();\n     String host \u003d uri.getHost();\n     String prefix \u003d \"/\" + host + \"/\";\n     DynamoDBMetadataStore ddbms \u003d getStore();\n     S3GuardTableAccess tableAccess \u003d new S3GuardTableAccess(ddbms);\n     ExpressionSpecBuilder builder \u003d new ExpressionSpecBuilder();\n     builder.withKeyCondition(\n         ExpressionSpecBuilder.S(PARENT).beginsWith(prefix));\n \n     LOG.info(\"Scanning for entries with prefix {} to delete from {}\",\n         prefix, ddbms);\n \n-    Iterable\u003cDDBPathMetadata\u003e entries \u003d tableAccess.scanMetadata(builder);\n+    Iterable\u003cDDBPathMetadata\u003e entries \u003d\n+        ddbms.wrapWithRetries(tableAccess.scanMetadata(builder));\n     List\u003cPath\u003e list \u003d new ArrayList\u003c\u003e();\n     entries.iterator().forEachRemaining(e -\u003e {\n       if (!(e instanceof S3GuardTableAccess.VersionMarker)) {\n         Path p \u003d e.getFileStatus().getPath();\n         String type \u003d e.getFileStatus().isFile() ? \"file\" : \"directory\";\n         boolean tombstone \u003d e.isDeleted();\n         if (tombstone) {\n           type \u003d \"tombstone \" + type;\n         }\n         LOG.info(\"{} {}\", type, p);\n         list.add(p);\n       }\n     });\n     int count \u003d list.size();\n     filesFound \u003d count;\n     LOG.info(\"Found {} entries{}\",\n         count,\n         (count \u003d\u003d 0 ? \" -nothing to purge\": \"\"));\n     if (count \u003e 0) {\n       if (force) {\n         DurationInfo duration \u003d\n             new DurationInfo(LOG,\n                 \"deleting %s entries from %s\",\n                 count, ddbms.toString());\n-        tableAccess.delete(list);\n+        // sending this in one by one for more efficient retries\n+        for (Path path: list) {\n+          ddbms.getInvoker()\n+              .retry(\"delete\",\n+                  prefix,\n+                  true,\n+                  () -\u003e tableAccess.delete(path));\n+        }\n         duration.close();\n         long durationMillis \u003d duration.value();\n         long timePerEntry \u003d durationMillis / count;\n         LOG.info(\"Time per entry: {} ms\", timePerEntry);\n         filesDeleted \u003d count;\n       } else {\n         LOG.info(\"Delete process will only be executed when \"\n             + FORCE + \" is set\");\n       }\n     }\n     return LauncherExitCodes.EXIT_SUCCESS;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int execute() throws ServiceLaunchException, IOException {\n\n    URI uri \u003d getUri();\n    String host \u003d uri.getHost();\n    String prefix \u003d \"/\" + host + \"/\";\n    DynamoDBMetadataStore ddbms \u003d getStore();\n    S3GuardTableAccess tableAccess \u003d new S3GuardTableAccess(ddbms);\n    ExpressionSpecBuilder builder \u003d new ExpressionSpecBuilder();\n    builder.withKeyCondition(\n        ExpressionSpecBuilder.S(PARENT).beginsWith(prefix));\n\n    LOG.info(\"Scanning for entries with prefix {} to delete from {}\",\n        prefix, ddbms);\n\n    Iterable\u003cDDBPathMetadata\u003e entries \u003d\n        ddbms.wrapWithRetries(tableAccess.scanMetadata(builder));\n    List\u003cPath\u003e list \u003d new ArrayList\u003c\u003e();\n    entries.iterator().forEachRemaining(e -\u003e {\n      if (!(e instanceof S3GuardTableAccess.VersionMarker)) {\n        Path p \u003d e.getFileStatus().getPath();\n        String type \u003d e.getFileStatus().isFile() ? \"file\" : \"directory\";\n        boolean tombstone \u003d e.isDeleted();\n        if (tombstone) {\n          type \u003d \"tombstone \" + type;\n        }\n        LOG.info(\"{} {}\", type, p);\n        list.add(p);\n      }\n    });\n    int count \u003d list.size();\n    filesFound \u003d count;\n    LOG.info(\"Found {} entries{}\",\n        count,\n        (count \u003d\u003d 0 ? \" -nothing to purge\": \"\"));\n    if (count \u003e 0) {\n      if (force) {\n        DurationInfo duration \u003d\n            new DurationInfo(LOG,\n                \"deleting %s entries from %s\",\n                count, ddbms.toString());\n        // sending this in one by one for more efficient retries\n        for (Path path: list) {\n          ddbms.getInvoker()\n              .retry(\"delete\",\n                  prefix,\n                  true,\n                  () -\u003e tableAccess.delete(path));\n        }\n        duration.close();\n        long durationMillis \u003d duration.value();\n        long timePerEntry \u003d durationMillis / count;\n        LOG.info(\"Time per entry: {} ms\", timePerEntry);\n        filesDeleted \u003d count;\n      } else {\n        LOG.info(\"Delete process will only be executed when \"\n            + FORCE + \" is set\");\n      }\n    }\n    return LauncherExitCodes.EXIT_SUCCESS;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/PurgeS3GuardDynamoTable.java",
          "extendedDetails": {}
        }
      ]
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,52 @@\n+  public int execute() throws ServiceLaunchException {\n+\n+    URI uri \u003d getUri();\n+    String host \u003d uri.getHost();\n+    String prefix \u003d \"/\" + host + \"/\";\n+    DynamoDBMetadataStore ddbms \u003d getStore();\n+    S3GuardTableAccess tableAccess \u003d new S3GuardTableAccess(ddbms);\n+    ExpressionSpecBuilder builder \u003d new ExpressionSpecBuilder();\n+    builder.withKeyCondition(\n+        ExpressionSpecBuilder.S(PARENT).beginsWith(prefix));\n+\n+    LOG.info(\"Scanning for entries with prefix {} to delete from {}\",\n+        prefix, ddbms);\n+\n+    Iterable\u003cDDBPathMetadata\u003e entries \u003d tableAccess.scanMetadata(builder);\n+    List\u003cPath\u003e list \u003d new ArrayList\u003c\u003e();\n+    entries.iterator().forEachRemaining(e -\u003e {\n+      if (!(e instanceof S3GuardTableAccess.VersionMarker)) {\n+        Path p \u003d e.getFileStatus().getPath();\n+        String type \u003d e.getFileStatus().isFile() ? \"file\" : \"directory\";\n+        boolean tombstone \u003d e.isDeleted();\n+        if (tombstone) {\n+          type \u003d \"tombstone \" + type;\n+        }\n+        LOG.info(\"{} {}\", type, p);\n+        list.add(p);\n+      }\n+    });\n+    int count \u003d list.size();\n+    filesFound \u003d count;\n+    LOG.info(\"Found {} entries{}\",\n+        count,\n+        (count \u003d\u003d 0 ? \" -nothing to purge\": \"\"));\n+    if (count \u003e 0) {\n+      if (force) {\n+        DurationInfo duration \u003d\n+            new DurationInfo(LOG,\n+                \"deleting %s entries from %s\",\n+                count, ddbms.toString());\n+        tableAccess.delete(list);\n+        duration.close();\n+        long durationMillis \u003d duration.value();\n+        long timePerEntry \u003d durationMillis / count;\n+        LOG.info(\"Time per entry: {} ms\", timePerEntry);\n+        filesDeleted \u003d count;\n+      } else {\n+        LOG.info(\"Delete process will only be executed when \"\n+            + FORCE + \" is set\");\n+      }\n+    }\n+    return LauncherExitCodes.EXIT_SUCCESS;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int execute() throws ServiceLaunchException {\n\n    URI uri \u003d getUri();\n    String host \u003d uri.getHost();\n    String prefix \u003d \"/\" + host + \"/\";\n    DynamoDBMetadataStore ddbms \u003d getStore();\n    S3GuardTableAccess tableAccess \u003d new S3GuardTableAccess(ddbms);\n    ExpressionSpecBuilder builder \u003d new ExpressionSpecBuilder();\n    builder.withKeyCondition(\n        ExpressionSpecBuilder.S(PARENT).beginsWith(prefix));\n\n    LOG.info(\"Scanning for entries with prefix {} to delete from {}\",\n        prefix, ddbms);\n\n    Iterable\u003cDDBPathMetadata\u003e entries \u003d tableAccess.scanMetadata(builder);\n    List\u003cPath\u003e list \u003d new ArrayList\u003c\u003e();\n    entries.iterator().forEachRemaining(e -\u003e {\n      if (!(e instanceof S3GuardTableAccess.VersionMarker)) {\n        Path p \u003d e.getFileStatus().getPath();\n        String type \u003d e.getFileStatus().isFile() ? \"file\" : \"directory\";\n        boolean tombstone \u003d e.isDeleted();\n        if (tombstone) {\n          type \u003d \"tombstone \" + type;\n        }\n        LOG.info(\"{} {}\", type, p);\n        list.add(p);\n      }\n    });\n    int count \u003d list.size();\n    filesFound \u003d count;\n    LOG.info(\"Found {} entries{}\",\n        count,\n        (count \u003d\u003d 0 ? \" -nothing to purge\": \"\"));\n    if (count \u003e 0) {\n      if (force) {\n        DurationInfo duration \u003d\n            new DurationInfo(LOG,\n                \"deleting %s entries from %s\",\n                count, ddbms.toString());\n        tableAccess.delete(list);\n        duration.close();\n        long durationMillis \u003d duration.value();\n        long timePerEntry \u003d durationMillis / count;\n        LOG.info(\"Time per entry: {} ms\", timePerEntry);\n        filesDeleted \u003d count;\n      } else {\n        LOG.info(\"Delete process will only be executed when \"\n            + FORCE + \" is set\");\n      }\n    }\n    return LauncherExitCodes.EXIT_SUCCESS;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/PurgeS3GuardDynamoTable.java"
    }
  }
}