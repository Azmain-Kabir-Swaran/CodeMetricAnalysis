{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationInterceptor.java",
  "functionName": "registerAndAllocateWithNewSubClusters",
  "functionId": "registerAndAllocateWithNewSubClusters___requests-Map__SubClusterId,AllocateRequest__(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
  "functionStartLine": 1211,
  "functionEndLine": 1295,
  "numCommitsSeen": 34,
  "timeTaken": 6323,
  "changeHistory": [
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
    "3090922805699b8374a359e92323884a4177dc4e",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
    "f1525825623a1307b5aa55c456b6afa3e0c61135",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32",
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e"
  ],
  "changeHistoryShort": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": "Ybodychange",
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "3090922805699b8374a359e92323884a4177dc4e": "Ybodychange",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": "Ybodychange",
    "f1525825623a1307b5aa55c456b6afa3e0c61135": "Ybodychange",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": "Ybodychange",
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788": "Ybodychange",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Ybodychange",
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "11/11/18 11:12 AM",
      "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthor": "Botong Huang",
      "commitDateOld": "02/11/18 3:30 PM",
      "commitNameOld": "989715ec5066c6ac7868e25ad9234dc64723e61e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,85 @@\n   private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n       final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : requests.keySet()) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId);\n+\n+        // Set sub-cluster to be timed out initially\n+        lastSCResponseTime.put(subClusterId,\n+            clock.getTime() - subClusterTimeOut);\n       }\n     }\n \n     this.uamRegisterFutures.clear();\n     for (final SubClusterId scId : newSubClusters) {\n       Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n         @Override\n         public void run() {\n           String subClusterId \u003d scId.getId();\n \n           // Create a config loaded with federation on and subclusterId\n           // for each UAM\n           YarnConfiguration config \u003d new YarnConfiguration(getConf());\n           FederationProxyProviderUtil.updateConfForFederation(config,\n               subClusterId);\n \n           RegisterApplicationMasterResponse uamResponse \u003d null;\n           Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n           try {\n             // For appNameSuffix, use subClusterId of the home sub-cluster\n             token \u003d uamPool.launchUAM(subClusterId, config,\n                 attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n                 getApplicationContext().getUser(), homeSubClusterId.toString(),\n                 true, subClusterId);\n \n             secondaryRelayers.put(subClusterId,\n                 uamPool.getAMRMClientRelayer(subClusterId));\n \n             uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                 amRegistrationRequest);\n           } catch (Throwable e) {\n             LOG.error(\"Failed to register application master: \" + subClusterId\n                 + \" Application: \" + attemptId, e);\n             // TODO: UAM registration for this sub-cluster RM\n             // failed. For now, we ignore the resource requests and continue\n             // but we need to fix this and handle this situation. One way would\n             // be to send the request to another RM by consulting the policy.\n             return;\n           }\n           uamRegistrations.put(scId, uamResponse);\n           LOG.info(\"Successfully registered unmanaged application master: \"\n               + subClusterId + \" ApplicationId: \" + attemptId);\n \n           try {\n             uamPool.allocateAsync(subClusterId, requests.get(scId),\n                 new HeartbeatCallBack(scId, true));\n           } catch (Throwable e) {\n             LOG.error(\"Failed to allocate async to \" + subClusterId\n                 + \" Application: \" + attemptId, e);\n           }\n \n           // Save the UAM token in registry or NMSS\n           try {\n             if (registryClient !\u003d null) {\n               registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n                   subClusterId, token);\n             } else if (getNMStateStore() !\u003d null) {\n               getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                   NMSS_SECONDARY_SC_PREFIX + subClusterId,\n                   token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n             }\n           } catch (Throwable e) {\n             LOG.error(\"Failed to persist UAM token from \" + subClusterId\n                 + \" Application: \" + attemptId, e);\n           }\n         }\n       });\n       this.uamRegisterFutures.put(scId, future);\n     }\n     return newSubClusters;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : requests.keySet()) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId);\n\n        // Set sub-cluster to be timed out initially\n        lastSCResponseTime.put(subClusterId,\n            clock.getTime() - subClusterTimeOut);\n      }\n    }\n\n    this.uamRegisterFutures.clear();\n    for (final SubClusterId scId : newSubClusters) {\n      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n        @Override\n        public void run() {\n          String subClusterId \u003d scId.getId();\n\n          // Create a config loaded with federation on and subclusterId\n          // for each UAM\n          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n          FederationProxyProviderUtil.updateConfForFederation(config,\n              subClusterId);\n\n          RegisterApplicationMasterResponse uamResponse \u003d null;\n          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n          try {\n            // For appNameSuffix, use subClusterId of the home sub-cluster\n            token \u003d uamPool.launchUAM(subClusterId, config,\n                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n                getApplicationContext().getUser(), homeSubClusterId.toString(),\n                true, subClusterId);\n\n            secondaryRelayers.put(subClusterId,\n                uamPool.getAMRMClientRelayer(subClusterId));\n\n            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                amRegistrationRequest);\n          } catch (Throwable e) {\n            LOG.error(\"Failed to register application master: \" + subClusterId\n                + \" Application: \" + attemptId, e);\n            // TODO: UAM registration for this sub-cluster RM\n            // failed. For now, we ignore the resource requests and continue\n            // but we need to fix this and handle this situation. One way would\n            // be to send the request to another RM by consulting the policy.\n            return;\n          }\n          uamRegistrations.put(scId, uamResponse);\n          LOG.info(\"Successfully registered unmanaged application master: \"\n              + subClusterId + \" ApplicationId: \" + attemptId);\n\n          try {\n            uamPool.allocateAsync(subClusterId, requests.get(scId),\n                new HeartbeatCallBack(scId, true));\n          } catch (Throwable e) {\n            LOG.error(\"Failed to allocate async to \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n\n          // Save the UAM token in registry or NMSS\n          try {\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n                  subClusterId, token);\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n        }\n      });\n      this.uamRegisterFutures.put(scId, future);\n    }\n    return newSubClusters;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "09/10/18 10:29 AM",
      "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
          "commitDate": "09/10/18 10:29 AM",
          "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "01/10/18 1:12 PM",
          "commitNameOld": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,81 @@\n-  private Registrations registerWithNewSubClusters(\n-      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n-\n-    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n-    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n-        successfulRegistrations \u003d new HashMap\u003c\u003e();\n+  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n+      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n-    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n-    for (SubClusterId subClusterId : subClusterSet) {\n+    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId subClusterId : requests.keySet()) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n-        newSubClusters.add(subClusterId.getId());\n+        newSubClusters.add(subClusterId);\n       }\n     }\n \n-    if (newSubClusters.size() \u003e 0) {\n-      final RegisterApplicationMasterRequest registerRequest \u003d\n-          this.amRegistrationRequest;\n-      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n-      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n-          completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n+    this.uamRegisterFutures.clear();\n+    for (final SubClusterId scId : newSubClusters) {\n+      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n+        @Override\n+        public void run() {\n+          String subClusterId \u003d scId.getId();\n \n-      for (final String subClusterId : newSubClusters) {\n-        completionService\n-            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n-              @Override\n-              public RegisterApplicationMasterResponseInfo call()\n-                  throws Exception {\n+          // Create a config loaded with federation on and subclusterId\n+          // for each UAM\n+          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+          FederationProxyProviderUtil.updateConfForFederation(config,\n+              subClusterId);\n \n-                // Create a config loaded with federation on and subclusterId\n-                // for each UAM\n-                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n-                FederationProxyProviderUtil.updateConfForFederation(config,\n-                    subClusterId);\n+          RegisterApplicationMasterResponse uamResponse \u003d null;\n+          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n+          try {\n+            // For appNameSuffix, use subClusterId of the home sub-cluster\n+            token \u003d uamPool.launchUAM(subClusterId, config,\n+                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n+                getApplicationContext().getUser(), homeSubClusterId.toString(),\n+                true, subClusterId);\n \n-                RegisterApplicationMasterResponse uamResponse \u003d null;\n-                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n-                try {\n-                  // For appNameSuffix, use subClusterId of the home sub-cluster\n-                  token \u003d uamPool.launchUAM(subClusterId, config,\n-                      attemptId.getApplicationId(),\n-                      amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString(), true, subClusterId);\n+            secondaryRelayers.put(subClusterId,\n+                uamPool.getAMRMClientRelayer(subClusterId));\n \n-                  secondaryRelayers.put(subClusterId,\n-                      uamPool.getAMRMClientRelayer(subClusterId));\n+            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n+                amRegistrationRequest);\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to register application master: \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n+            // TODO: UAM registration for this sub-cluster RM\n+            // failed. For now, we ignore the resource requests and continue\n+            // but we need to fix this and handle this situation. One way would\n+            // be to send the request to another RM by consulting the policy.\n+            return;\n+          }\n+          uamRegistrations.put(scId, uamResponse);\n+          LOG.info(\"Successfully registered unmanaged application master: \"\n+              + subClusterId + \" ApplicationId: \" + attemptId);\n \n-                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n-                      registerRequest);\n-                } catch (Throwable e) {\n-                  LOG.error(\"Failed to register application master: \"\n-                      + subClusterId + \" Application: \" + attemptId, e);\n-                }\n-                return new RegisterApplicationMasterResponseInfo(uamResponse,\n-                    SubClusterId.newInstance(subClusterId), token);\n-              }\n-            });\n-      }\n-\n-      // Wait for other sub-cluster resource managers to return the\n-      // response and add it to the Map for returning to the caller\n-      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n-        try {\n-          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n-              completionService.take();\n-          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Received register application response from RM: \"\n-                + uamResponse.getSubClusterId());\n+          try {\n+            uamPool.allocateAsync(subClusterId, requests.get(scId),\n+                new HeartbeatCallBack(scId, true));\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to allocate async to \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n \n-          if (uamResponse.getResponse() \u003d\u003d null) {\n-            failedRegistrations.add(uamResponse.getSubClusterId());\n-          } else {\n-            LOG.info(\"Successfully registered unmanaged application master: \"\n-                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n-                + this.attemptId);\n-            successfulRegistrations.put(uamResponse.getSubClusterId(),\n-                uamResponse.getResponse());\n-\n-            // Save the UAM token in registry or NMSS\n+          // Save the UAM token in registry or NMSS\n+          try {\n             if (registryClient !\u003d null) {\n-              registryClient.writeAMRMTokenForUAM(\n-                  this.attemptId.getApplicationId(),\n-                  uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken());\n+              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n+                  subClusterId, token);\n             } else if (getNMStateStore() !\u003d null) {\n-              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n-                  NMSS_SECONDARY_SC_PREFIX\n-                      + uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken().encodeToUrlString()\n-                      .getBytes(STRING_TO_BYTE_FORMAT));\n+              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n+                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n+                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n             }\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n-        } catch (Exception e) {\n-          LOG.warn(\"Failed to register unmanaged application master: \"\n-              + \" ApplicationId: \" + this.attemptId, e);\n         }\n-      }\n+      });\n+      this.uamRegisterFutures.put(scId, future);\n     }\n-\n-    return new Registrations(successfulRegistrations, failedRegistrations);\n+    return newSubClusters;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : requests.keySet()) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId);\n      }\n    }\n\n    this.uamRegisterFutures.clear();\n    for (final SubClusterId scId : newSubClusters) {\n      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n        @Override\n        public void run() {\n          String subClusterId \u003d scId.getId();\n\n          // Create a config loaded with federation on and subclusterId\n          // for each UAM\n          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n          FederationProxyProviderUtil.updateConfForFederation(config,\n              subClusterId);\n\n          RegisterApplicationMasterResponse uamResponse \u003d null;\n          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n          try {\n            // For appNameSuffix, use subClusterId of the home sub-cluster\n            token \u003d uamPool.launchUAM(subClusterId, config,\n                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n                getApplicationContext().getUser(), homeSubClusterId.toString(),\n                true, subClusterId);\n\n            secondaryRelayers.put(subClusterId,\n                uamPool.getAMRMClientRelayer(subClusterId));\n\n            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                amRegistrationRequest);\n          } catch (Throwable e) {\n            LOG.error(\"Failed to register application master: \" + subClusterId\n                + \" Application: \" + attemptId, e);\n            // TODO: UAM registration for this sub-cluster RM\n            // failed. For now, we ignore the resource requests and continue\n            // but we need to fix this and handle this situation. One way would\n            // be to send the request to another RM by consulting the policy.\n            return;\n          }\n          uamRegistrations.put(scId, uamResponse);\n          LOG.info(\"Successfully registered unmanaged application master: \"\n              + subClusterId + \" ApplicationId: \" + attemptId);\n\n          try {\n            uamPool.allocateAsync(subClusterId, requests.get(scId),\n                new HeartbeatCallBack(scId, true));\n          } catch (Throwable e) {\n            LOG.error(\"Failed to allocate async to \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n\n          // Save the UAM token in registry or NMSS\n          try {\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n                  subClusterId, token);\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n        }\n      });\n      this.uamRegisterFutures.put(scId, future);\n    }\n    return newSubClusters;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
          "extendedDetails": {
            "oldValue": "registerWithNewSubClusters",
            "newValue": "registerAndAllocateWithNewSubClusters"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
          "commitDate": "09/10/18 10:29 AM",
          "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "01/10/18 1:12 PM",
          "commitNameOld": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,81 @@\n-  private Registrations registerWithNewSubClusters(\n-      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n-\n-    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n-    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n-        successfulRegistrations \u003d new HashMap\u003c\u003e();\n+  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n+      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n-    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n-    for (SubClusterId subClusterId : subClusterSet) {\n+    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId subClusterId : requests.keySet()) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n-        newSubClusters.add(subClusterId.getId());\n+        newSubClusters.add(subClusterId);\n       }\n     }\n \n-    if (newSubClusters.size() \u003e 0) {\n-      final RegisterApplicationMasterRequest registerRequest \u003d\n-          this.amRegistrationRequest;\n-      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n-      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n-          completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n+    this.uamRegisterFutures.clear();\n+    for (final SubClusterId scId : newSubClusters) {\n+      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n+        @Override\n+        public void run() {\n+          String subClusterId \u003d scId.getId();\n \n-      for (final String subClusterId : newSubClusters) {\n-        completionService\n-            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n-              @Override\n-              public RegisterApplicationMasterResponseInfo call()\n-                  throws Exception {\n+          // Create a config loaded with federation on and subclusterId\n+          // for each UAM\n+          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+          FederationProxyProviderUtil.updateConfForFederation(config,\n+              subClusterId);\n \n-                // Create a config loaded with federation on and subclusterId\n-                // for each UAM\n-                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n-                FederationProxyProviderUtil.updateConfForFederation(config,\n-                    subClusterId);\n+          RegisterApplicationMasterResponse uamResponse \u003d null;\n+          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n+          try {\n+            // For appNameSuffix, use subClusterId of the home sub-cluster\n+            token \u003d uamPool.launchUAM(subClusterId, config,\n+                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n+                getApplicationContext().getUser(), homeSubClusterId.toString(),\n+                true, subClusterId);\n \n-                RegisterApplicationMasterResponse uamResponse \u003d null;\n-                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n-                try {\n-                  // For appNameSuffix, use subClusterId of the home sub-cluster\n-                  token \u003d uamPool.launchUAM(subClusterId, config,\n-                      attemptId.getApplicationId(),\n-                      amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString(), true, subClusterId);\n+            secondaryRelayers.put(subClusterId,\n+                uamPool.getAMRMClientRelayer(subClusterId));\n \n-                  secondaryRelayers.put(subClusterId,\n-                      uamPool.getAMRMClientRelayer(subClusterId));\n+            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n+                amRegistrationRequest);\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to register application master: \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n+            // TODO: UAM registration for this sub-cluster RM\n+            // failed. For now, we ignore the resource requests and continue\n+            // but we need to fix this and handle this situation. One way would\n+            // be to send the request to another RM by consulting the policy.\n+            return;\n+          }\n+          uamRegistrations.put(scId, uamResponse);\n+          LOG.info(\"Successfully registered unmanaged application master: \"\n+              + subClusterId + \" ApplicationId: \" + attemptId);\n \n-                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n-                      registerRequest);\n-                } catch (Throwable e) {\n-                  LOG.error(\"Failed to register application master: \"\n-                      + subClusterId + \" Application: \" + attemptId, e);\n-                }\n-                return new RegisterApplicationMasterResponseInfo(uamResponse,\n-                    SubClusterId.newInstance(subClusterId), token);\n-              }\n-            });\n-      }\n-\n-      // Wait for other sub-cluster resource managers to return the\n-      // response and add it to the Map for returning to the caller\n-      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n-        try {\n-          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n-              completionService.take();\n-          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Received register application response from RM: \"\n-                + uamResponse.getSubClusterId());\n+          try {\n+            uamPool.allocateAsync(subClusterId, requests.get(scId),\n+                new HeartbeatCallBack(scId, true));\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to allocate async to \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n \n-          if (uamResponse.getResponse() \u003d\u003d null) {\n-            failedRegistrations.add(uamResponse.getSubClusterId());\n-          } else {\n-            LOG.info(\"Successfully registered unmanaged application master: \"\n-                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n-                + this.attemptId);\n-            successfulRegistrations.put(uamResponse.getSubClusterId(),\n-                uamResponse.getResponse());\n-\n-            // Save the UAM token in registry or NMSS\n+          // Save the UAM token in registry or NMSS\n+          try {\n             if (registryClient !\u003d null) {\n-              registryClient.writeAMRMTokenForUAM(\n-                  this.attemptId.getApplicationId(),\n-                  uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken());\n+              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n+                  subClusterId, token);\n             } else if (getNMStateStore() !\u003d null) {\n-              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n-                  NMSS_SECONDARY_SC_PREFIX\n-                      + uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken().encodeToUrlString()\n-                      .getBytes(STRING_TO_BYTE_FORMAT));\n+              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n+                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n+                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n             }\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n-        } catch (Exception e) {\n-          LOG.warn(\"Failed to register unmanaged application master: \"\n-              + \" ApplicationId: \" + this.attemptId, e);\n         }\n-      }\n+      });\n+      this.uamRegisterFutures.put(scId, future);\n     }\n-\n-    return new Registrations(successfulRegistrations, failedRegistrations);\n+    return newSubClusters;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : requests.keySet()) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId);\n      }\n    }\n\n    this.uamRegisterFutures.clear();\n    for (final SubClusterId scId : newSubClusters) {\n      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n        @Override\n        public void run() {\n          String subClusterId \u003d scId.getId();\n\n          // Create a config loaded with federation on and subclusterId\n          // for each UAM\n          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n          FederationProxyProviderUtil.updateConfForFederation(config,\n              subClusterId);\n\n          RegisterApplicationMasterResponse uamResponse \u003d null;\n          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n          try {\n            // For appNameSuffix, use subClusterId of the home sub-cluster\n            token \u003d uamPool.launchUAM(subClusterId, config,\n                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n                getApplicationContext().getUser(), homeSubClusterId.toString(),\n                true, subClusterId);\n\n            secondaryRelayers.put(subClusterId,\n                uamPool.getAMRMClientRelayer(subClusterId));\n\n            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                amRegistrationRequest);\n          } catch (Throwable e) {\n            LOG.error(\"Failed to register application master: \" + subClusterId\n                + \" Application: \" + attemptId, e);\n            // TODO: UAM registration for this sub-cluster RM\n            // failed. For now, we ignore the resource requests and continue\n            // but we need to fix this and handle this situation. One way would\n            // be to send the request to another RM by consulting the policy.\n            return;\n          }\n          uamRegistrations.put(scId, uamResponse);\n          LOG.info(\"Successfully registered unmanaged application master: \"\n              + subClusterId + \" ApplicationId: \" + attemptId);\n\n          try {\n            uamPool.allocateAsync(subClusterId, requests.get(scId),\n                new HeartbeatCallBack(scId, true));\n          } catch (Throwable e) {\n            LOG.error(\"Failed to allocate async to \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n\n          // Save the UAM token in registry or NMSS\n          try {\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n                  subClusterId, token);\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n        }\n      });\n      this.uamRegisterFutures.put(scId, future);\n    }\n    return newSubClusters;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
          "extendedDetails": {
            "oldValue": "[subClusterSet-Set\u003cSubClusterId\u003e]",
            "newValue": "[requests-Map\u003cSubClusterId,AllocateRequest\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
          "commitDate": "09/10/18 10:29 AM",
          "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "01/10/18 1:12 PM",
          "commitNameOld": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,81 @@\n-  private Registrations registerWithNewSubClusters(\n-      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n-\n-    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n-    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n-        successfulRegistrations \u003d new HashMap\u003c\u003e();\n+  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n+      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n-    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n-    for (SubClusterId subClusterId : subClusterSet) {\n+    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId subClusterId : requests.keySet()) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n-        newSubClusters.add(subClusterId.getId());\n+        newSubClusters.add(subClusterId);\n       }\n     }\n \n-    if (newSubClusters.size() \u003e 0) {\n-      final RegisterApplicationMasterRequest registerRequest \u003d\n-          this.amRegistrationRequest;\n-      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n-      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n-          completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n+    this.uamRegisterFutures.clear();\n+    for (final SubClusterId scId : newSubClusters) {\n+      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n+        @Override\n+        public void run() {\n+          String subClusterId \u003d scId.getId();\n \n-      for (final String subClusterId : newSubClusters) {\n-        completionService\n-            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n-              @Override\n-              public RegisterApplicationMasterResponseInfo call()\n-                  throws Exception {\n+          // Create a config loaded with federation on and subclusterId\n+          // for each UAM\n+          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+          FederationProxyProviderUtil.updateConfForFederation(config,\n+              subClusterId);\n \n-                // Create a config loaded with federation on and subclusterId\n-                // for each UAM\n-                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n-                FederationProxyProviderUtil.updateConfForFederation(config,\n-                    subClusterId);\n+          RegisterApplicationMasterResponse uamResponse \u003d null;\n+          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n+          try {\n+            // For appNameSuffix, use subClusterId of the home sub-cluster\n+            token \u003d uamPool.launchUAM(subClusterId, config,\n+                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n+                getApplicationContext().getUser(), homeSubClusterId.toString(),\n+                true, subClusterId);\n \n-                RegisterApplicationMasterResponse uamResponse \u003d null;\n-                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n-                try {\n-                  // For appNameSuffix, use subClusterId of the home sub-cluster\n-                  token \u003d uamPool.launchUAM(subClusterId, config,\n-                      attemptId.getApplicationId(),\n-                      amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString(), true, subClusterId);\n+            secondaryRelayers.put(subClusterId,\n+                uamPool.getAMRMClientRelayer(subClusterId));\n \n-                  secondaryRelayers.put(subClusterId,\n-                      uamPool.getAMRMClientRelayer(subClusterId));\n+            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n+                amRegistrationRequest);\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to register application master: \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n+            // TODO: UAM registration for this sub-cluster RM\n+            // failed. For now, we ignore the resource requests and continue\n+            // but we need to fix this and handle this situation. One way would\n+            // be to send the request to another RM by consulting the policy.\n+            return;\n+          }\n+          uamRegistrations.put(scId, uamResponse);\n+          LOG.info(\"Successfully registered unmanaged application master: \"\n+              + subClusterId + \" ApplicationId: \" + attemptId);\n \n-                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n-                      registerRequest);\n-                } catch (Throwable e) {\n-                  LOG.error(\"Failed to register application master: \"\n-                      + subClusterId + \" Application: \" + attemptId, e);\n-                }\n-                return new RegisterApplicationMasterResponseInfo(uamResponse,\n-                    SubClusterId.newInstance(subClusterId), token);\n-              }\n-            });\n-      }\n-\n-      // Wait for other sub-cluster resource managers to return the\n-      // response and add it to the Map for returning to the caller\n-      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n-        try {\n-          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n-              completionService.take();\n-          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Received register application response from RM: \"\n-                + uamResponse.getSubClusterId());\n+          try {\n+            uamPool.allocateAsync(subClusterId, requests.get(scId),\n+                new HeartbeatCallBack(scId, true));\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to allocate async to \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n \n-          if (uamResponse.getResponse() \u003d\u003d null) {\n-            failedRegistrations.add(uamResponse.getSubClusterId());\n-          } else {\n-            LOG.info(\"Successfully registered unmanaged application master: \"\n-                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n-                + this.attemptId);\n-            successfulRegistrations.put(uamResponse.getSubClusterId(),\n-                uamResponse.getResponse());\n-\n-            // Save the UAM token in registry or NMSS\n+          // Save the UAM token in registry or NMSS\n+          try {\n             if (registryClient !\u003d null) {\n-              registryClient.writeAMRMTokenForUAM(\n-                  this.attemptId.getApplicationId(),\n-                  uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken());\n+              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n+                  subClusterId, token);\n             } else if (getNMStateStore() !\u003d null) {\n-              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n-                  NMSS_SECONDARY_SC_PREFIX\n-                      + uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken().encodeToUrlString()\n-                      .getBytes(STRING_TO_BYTE_FORMAT));\n+              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n+                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n+                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n             }\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n-        } catch (Exception e) {\n-          LOG.warn(\"Failed to register unmanaged application master: \"\n-              + \" ApplicationId: \" + this.attemptId, e);\n         }\n-      }\n+      });\n+      this.uamRegisterFutures.put(scId, future);\n     }\n-\n-    return new Registrations(successfulRegistrations, failedRegistrations);\n+    return newSubClusters;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : requests.keySet()) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId);\n      }\n    }\n\n    this.uamRegisterFutures.clear();\n    for (final SubClusterId scId : newSubClusters) {\n      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n        @Override\n        public void run() {\n          String subClusterId \u003d scId.getId();\n\n          // Create a config loaded with federation on and subclusterId\n          // for each UAM\n          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n          FederationProxyProviderUtil.updateConfForFederation(config,\n              subClusterId);\n\n          RegisterApplicationMasterResponse uamResponse \u003d null;\n          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n          try {\n            // For appNameSuffix, use subClusterId of the home sub-cluster\n            token \u003d uamPool.launchUAM(subClusterId, config,\n                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n                getApplicationContext().getUser(), homeSubClusterId.toString(),\n                true, subClusterId);\n\n            secondaryRelayers.put(subClusterId,\n                uamPool.getAMRMClientRelayer(subClusterId));\n\n            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                amRegistrationRequest);\n          } catch (Throwable e) {\n            LOG.error(\"Failed to register application master: \" + subClusterId\n                + \" Application: \" + attemptId, e);\n            // TODO: UAM registration for this sub-cluster RM\n            // failed. For now, we ignore the resource requests and continue\n            // but we need to fix this and handle this situation. One way would\n            // be to send the request to another RM by consulting the policy.\n            return;\n          }\n          uamRegistrations.put(scId, uamResponse);\n          LOG.info(\"Successfully registered unmanaged application master: \"\n              + subClusterId + \" ApplicationId: \" + attemptId);\n\n          try {\n            uamPool.allocateAsync(subClusterId, requests.get(scId),\n                new HeartbeatCallBack(scId, true));\n          } catch (Throwable e) {\n            LOG.error(\"Failed to allocate async to \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n\n          // Save the UAM token in registry or NMSS\n          try {\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n                  subClusterId, token);\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n        }\n      });\n      this.uamRegisterFutures.put(scId, future);\n    }\n    return newSubClusters;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
          "extendedDetails": {
            "oldValue": "Registrations",
            "newValue": "List\u003cSubClusterId\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
          "commitDate": "09/10/18 10:29 AM",
          "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "01/10/18 1:12 PM",
          "commitNameOld": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,81 @@\n-  private Registrations registerWithNewSubClusters(\n-      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n-\n-    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n-    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n-        successfulRegistrations \u003d new HashMap\u003c\u003e();\n+  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n+      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n-    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n-    for (SubClusterId subClusterId : subClusterSet) {\n+    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId subClusterId : requests.keySet()) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n-        newSubClusters.add(subClusterId.getId());\n+        newSubClusters.add(subClusterId);\n       }\n     }\n \n-    if (newSubClusters.size() \u003e 0) {\n-      final RegisterApplicationMasterRequest registerRequest \u003d\n-          this.amRegistrationRequest;\n-      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n-      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n-          completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n+    this.uamRegisterFutures.clear();\n+    for (final SubClusterId scId : newSubClusters) {\n+      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n+        @Override\n+        public void run() {\n+          String subClusterId \u003d scId.getId();\n \n-      for (final String subClusterId : newSubClusters) {\n-        completionService\n-            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n-              @Override\n-              public RegisterApplicationMasterResponseInfo call()\n-                  throws Exception {\n+          // Create a config loaded with federation on and subclusterId\n+          // for each UAM\n+          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+          FederationProxyProviderUtil.updateConfForFederation(config,\n+              subClusterId);\n \n-                // Create a config loaded with federation on and subclusterId\n-                // for each UAM\n-                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n-                FederationProxyProviderUtil.updateConfForFederation(config,\n-                    subClusterId);\n+          RegisterApplicationMasterResponse uamResponse \u003d null;\n+          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n+          try {\n+            // For appNameSuffix, use subClusterId of the home sub-cluster\n+            token \u003d uamPool.launchUAM(subClusterId, config,\n+                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n+                getApplicationContext().getUser(), homeSubClusterId.toString(),\n+                true, subClusterId);\n \n-                RegisterApplicationMasterResponse uamResponse \u003d null;\n-                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n-                try {\n-                  // For appNameSuffix, use subClusterId of the home sub-cluster\n-                  token \u003d uamPool.launchUAM(subClusterId, config,\n-                      attemptId.getApplicationId(),\n-                      amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString(), true, subClusterId);\n+            secondaryRelayers.put(subClusterId,\n+                uamPool.getAMRMClientRelayer(subClusterId));\n \n-                  secondaryRelayers.put(subClusterId,\n-                      uamPool.getAMRMClientRelayer(subClusterId));\n+            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n+                amRegistrationRequest);\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to register application master: \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n+            // TODO: UAM registration for this sub-cluster RM\n+            // failed. For now, we ignore the resource requests and continue\n+            // but we need to fix this and handle this situation. One way would\n+            // be to send the request to another RM by consulting the policy.\n+            return;\n+          }\n+          uamRegistrations.put(scId, uamResponse);\n+          LOG.info(\"Successfully registered unmanaged application master: \"\n+              + subClusterId + \" ApplicationId: \" + attemptId);\n \n-                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n-                      registerRequest);\n-                } catch (Throwable e) {\n-                  LOG.error(\"Failed to register application master: \"\n-                      + subClusterId + \" Application: \" + attemptId, e);\n-                }\n-                return new RegisterApplicationMasterResponseInfo(uamResponse,\n-                    SubClusterId.newInstance(subClusterId), token);\n-              }\n-            });\n-      }\n-\n-      // Wait for other sub-cluster resource managers to return the\n-      // response and add it to the Map for returning to the caller\n-      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n-        try {\n-          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n-              completionService.take();\n-          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Received register application response from RM: \"\n-                + uamResponse.getSubClusterId());\n+          try {\n+            uamPool.allocateAsync(subClusterId, requests.get(scId),\n+                new HeartbeatCallBack(scId, true));\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to allocate async to \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n \n-          if (uamResponse.getResponse() \u003d\u003d null) {\n-            failedRegistrations.add(uamResponse.getSubClusterId());\n-          } else {\n-            LOG.info(\"Successfully registered unmanaged application master: \"\n-                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n-                + this.attemptId);\n-            successfulRegistrations.put(uamResponse.getSubClusterId(),\n-                uamResponse.getResponse());\n-\n-            // Save the UAM token in registry or NMSS\n+          // Save the UAM token in registry or NMSS\n+          try {\n             if (registryClient !\u003d null) {\n-              registryClient.writeAMRMTokenForUAM(\n-                  this.attemptId.getApplicationId(),\n-                  uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken());\n+              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n+                  subClusterId, token);\n             } else if (getNMStateStore() !\u003d null) {\n-              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n-                  NMSS_SECONDARY_SC_PREFIX\n-                      + uamResponse.getSubClusterId().getId(),\n-                  uamResponse.getUamToken().encodeToUrlString()\n-                      .getBytes(STRING_TO_BYTE_FORMAT));\n+              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n+                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n+                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n             }\n+          } catch (Throwable e) {\n+            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n+                + \" Application: \" + attemptId, e);\n           }\n-        } catch (Exception e) {\n-          LOG.warn(\"Failed to register unmanaged application master: \"\n-              + \" ApplicationId: \" + this.attemptId, e);\n         }\n-      }\n+      });\n+      this.uamRegisterFutures.put(scId, future);\n     }\n-\n-    return new Registrations(successfulRegistrations, failedRegistrations);\n+    return newSubClusters;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cSubClusterId\u003e registerAndAllocateWithNewSubClusters(\n      final Map\u003cSubClusterId, AllocateRequest\u003e requests) throws IOException {\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cSubClusterId\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : requests.keySet()) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId);\n      }\n    }\n\n    this.uamRegisterFutures.clear();\n    for (final SubClusterId scId : newSubClusters) {\n      Future\u003c?\u003e future \u003d this.threadpool.submit(new Runnable() {\n        @Override\n        public void run() {\n          String subClusterId \u003d scId.getId();\n\n          // Create a config loaded with federation on and subclusterId\n          // for each UAM\n          YarnConfiguration config \u003d new YarnConfiguration(getConf());\n          FederationProxyProviderUtil.updateConfForFederation(config,\n              subClusterId);\n\n          RegisterApplicationMasterResponse uamResponse \u003d null;\n          Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n          try {\n            // For appNameSuffix, use subClusterId of the home sub-cluster\n            token \u003d uamPool.launchUAM(subClusterId, config,\n                attemptId.getApplicationId(), amRegistrationResponse.getQueue(),\n                getApplicationContext().getUser(), homeSubClusterId.toString(),\n                true, subClusterId);\n\n            secondaryRelayers.put(subClusterId,\n                uamPool.getAMRMClientRelayer(subClusterId));\n\n            uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                amRegistrationRequest);\n          } catch (Throwable e) {\n            LOG.error(\"Failed to register application master: \" + subClusterId\n                + \" Application: \" + attemptId, e);\n            // TODO: UAM registration for this sub-cluster RM\n            // failed. For now, we ignore the resource requests and continue\n            // but we need to fix this and handle this situation. One way would\n            // be to send the request to another RM by consulting the policy.\n            return;\n          }\n          uamRegistrations.put(scId, uamResponse);\n          LOG.info(\"Successfully registered unmanaged application master: \"\n              + subClusterId + \" ApplicationId: \" + attemptId);\n\n          try {\n            uamPool.allocateAsync(subClusterId, requests.get(scId),\n                new HeartbeatCallBack(scId, true));\n          } catch (Throwable e) {\n            LOG.error(\"Failed to allocate async to \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n\n          // Save the UAM token in registry or NMSS\n          try {\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n                  subClusterId, token);\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                  NMSS_SECONDARY_SC_PREFIX + subClusterId,\n                  token.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Failed to persist UAM token from \" + subClusterId\n                + \" Application: \" + attemptId, e);\n          }\n        }\n      });\n      this.uamRegisterFutures.put(scId, future);\n    }\n    return newSubClusters;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
          "extendedDetails": {}
        }
      ]
    },
    "3090922805699b8374a359e92323884a4177dc4e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
      "commitDate": "24/09/18 11:37 AM",
      "commitName": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "12/09/18 11:46 AM",
      "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,105 @@\n   private Registrations registerWithNewSubClusters(\n       Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n \n     List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n         successfulRegistrations \u003d new HashMap\u003c\u003e();\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : subClusterSet) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId.getId());\n       }\n     }\n \n     if (newSubClusters.size() \u003e 0) {\n       final RegisterApplicationMasterRequest registerRequest \u003d\n           this.amRegistrationRequest;\n       final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n       ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n-          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n+          completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n       for (final String subClusterId : newSubClusters) {\n         completionService\n             .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n               @Override\n               public RegisterApplicationMasterResponseInfo call()\n                   throws Exception {\n \n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId);\n \n                 RegisterApplicationMasterResponse uamResponse \u003d null;\n                 Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                 try {\n                   // For appNameSuffix, use subClusterId of the home sub-cluster\n                   token \u003d uamPool.launchUAM(subClusterId, config,\n                       attemptId.getApplicationId(),\n                       amRegistrationResponse.getQueue(), appContext.getUser(),\n                       homeSubClusterId.toString(), true, subClusterId);\n \n                   secondaryRelayers.put(subClusterId,\n                       uamPool.getAMRMClientRelayer(subClusterId));\n \n                   uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                       registerRequest);\n                 } catch (Throwable e) {\n                   LOG.error(\"Failed to register application master: \"\n                       + subClusterId + \" Application: \" + attemptId, e);\n                 }\n                 return new RegisterApplicationMasterResponseInfo(uamResponse,\n                     SubClusterId.newInstance(subClusterId), token);\n               }\n             });\n       }\n \n       // Wait for other sub-cluster resource managers to return the\n       // response and add it to the Map for returning to the caller\n       for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n         try {\n           Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n               completionService.take();\n           RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Received register application response from RM: \"\n                 + uamResponse.getSubClusterId());\n           }\n \n           if (uamResponse.getResponse() \u003d\u003d null) {\n             failedRegistrations.add(uamResponse.getSubClusterId());\n           } else {\n             LOG.info(\"Successfully registered unmanaged application master: \"\n                 + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                 + this.attemptId);\n             successfulRegistrations.put(uamResponse.getSubClusterId(),\n                 uamResponse.getResponse());\n \n             // Save the UAM token in registry or NMSS\n             if (registryClient !\u003d null) {\n               registryClient.writeAMRMTokenForUAM(\n                   this.attemptId.getApplicationId(),\n                   uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken());\n             } else if (getNMStateStore() !\u003d null) {\n               getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n                   NMSS_SECONDARY_SC_PREFIX\n                       + uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken().encodeToUrlString()\n                       .getBytes(STRING_TO_BYTE_FORMAT));\n             }\n           }\n         } catch (Exception e) {\n           LOG.warn(\"Failed to register unmanaged application master: \"\n               + \" ApplicationId: \" + this.attemptId, e);\n         }\n       }\n     }\n \n     return new Registrations(successfulRegistrations, failedRegistrations);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  token \u003d uamPool.launchUAM(subClusterId, config,\n                      attemptId.getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString(), true, subClusterId);\n\n                  secondaryRelayers.put(subClusterId,\n                      uamPool.getAMRMClientRelayer(subClusterId));\n\n                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                      registerRequest);\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \" + attemptId, e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId), token);\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + this.attemptId);\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n\n            // Save the UAM token in registry or NMSS\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(\n                  this.attemptId.getApplicationId(),\n                  uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken());\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n                  NMSS_SECONDARY_SC_PREFIX\n                      + uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken().encodeToUrlString()\n                      .getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \" + this.attemptId, e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.\n",
      "commitDate": "12/09/18 11:46 AM",
      "commitName": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "27/08/18 10:32 AM",
      "commitNameOld": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 16.05,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,105 @@\n   private Registrations registerWithNewSubClusters(\n       Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n \n     List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n         successfulRegistrations \u003d new HashMap\u003c\u003e();\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : subClusterSet) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId.getId());\n       }\n     }\n \n     if (newSubClusters.size() \u003e 0) {\n       final RegisterApplicationMasterRequest registerRequest \u003d\n           this.amRegistrationRequest;\n       final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n       ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n           completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n       for (final String subClusterId : newSubClusters) {\n         completionService\n             .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n               @Override\n               public RegisterApplicationMasterResponseInfo call()\n                   throws Exception {\n \n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId);\n \n                 RegisterApplicationMasterResponse uamResponse \u003d null;\n                 Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                 try {\n                   // For appNameSuffix, use subClusterId of the home sub-cluster\n                   token \u003d uamPool.launchUAM(subClusterId, config,\n                       attemptId.getApplicationId(),\n                       amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString(), true);\n+                      homeSubClusterId.toString(), true, subClusterId);\n \n                   secondaryRelayers.put(subClusterId,\n                       uamPool.getAMRMClientRelayer(subClusterId));\n \n                   uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                       registerRequest);\n                 } catch (Throwable e) {\n                   LOG.error(\"Failed to register application master: \"\n                       + subClusterId + \" Application: \" + attemptId, e);\n                 }\n                 return new RegisterApplicationMasterResponseInfo(uamResponse,\n                     SubClusterId.newInstance(subClusterId), token);\n               }\n             });\n       }\n \n       // Wait for other sub-cluster resource managers to return the\n       // response and add it to the Map for returning to the caller\n       for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n         try {\n           Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n               completionService.take();\n           RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Received register application response from RM: \"\n                 + uamResponse.getSubClusterId());\n           }\n \n           if (uamResponse.getResponse() \u003d\u003d null) {\n             failedRegistrations.add(uamResponse.getSubClusterId());\n           } else {\n             LOG.info(\"Successfully registered unmanaged application master: \"\n                 + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                 + this.attemptId);\n             successfulRegistrations.put(uamResponse.getSubClusterId(),\n                 uamResponse.getResponse());\n \n             // Save the UAM token in registry or NMSS\n             if (registryClient !\u003d null) {\n               registryClient.writeAMRMTokenForUAM(\n                   this.attemptId.getApplicationId(),\n                   uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken());\n             } else if (getNMStateStore() !\u003d null) {\n               getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n                   NMSS_SECONDARY_SC_PREFIX\n                       + uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken().encodeToUrlString()\n                       .getBytes(STRING_TO_BYTE_FORMAT));\n             }\n           }\n         } catch (Exception e) {\n           LOG.warn(\"Failed to register unmanaged application master: \"\n               + \" ApplicationId: \" + this.attemptId, e);\n         }\n       }\n     }\n \n     return new Registrations(successfulRegistrations, failedRegistrations);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  token \u003d uamPool.launchUAM(subClusterId, config,\n                      attemptId.getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString(), true, subClusterId);\n\n                  secondaryRelayers.put(subClusterId,\n                      uamPool.getAMRMClientRelayer(subClusterId));\n\n                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                      registerRequest);\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \" + attemptId, e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId), token);\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + this.attemptId);\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n\n            // Save the UAM token in registry or NMSS\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(\n                  this.attemptId.getApplicationId(),\n                  uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken());\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n                  NMSS_SECONDARY_SC_PREFIX\n                      + uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken().encodeToUrlString()\n                      .getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \" + this.attemptId, e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "f1525825623a1307b5aa55c456b6afa3e0c61135": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8705. Refactor the UAM heartbeat thread in preparation for YARN-8696. Contributed by Botong Huang.\n",
      "commitDate": "27/08/18 10:32 AM",
      "commitName": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 12:22 PM",
      "commitNameOld": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,105 @@\n   private Registrations registerWithNewSubClusters(\n       Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n \n     List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n         successfulRegistrations \u003d new HashMap\u003c\u003e();\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : subClusterSet) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId.getId());\n       }\n     }\n \n     if (newSubClusters.size() \u003e 0) {\n       final RegisterApplicationMasterRequest registerRequest \u003d\n           this.amRegistrationRequest;\n       final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n       ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n           completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n       for (final String subClusterId : newSubClusters) {\n         completionService\n             .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n               @Override\n               public RegisterApplicationMasterResponseInfo call()\n                   throws Exception {\n \n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId);\n \n                 RegisterApplicationMasterResponse uamResponse \u003d null;\n                 Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                 try {\n                   // For appNameSuffix, use subClusterId of the home sub-cluster\n                   token \u003d uamPool.launchUAM(subClusterId, config,\n-                      appContext.getApplicationAttemptId().getApplicationId(),\n+                      attemptId.getApplicationId(),\n                       amRegistrationResponse.getQueue(), appContext.getUser(),\n                       homeSubClusterId.toString(), true);\n \n                   secondaryRelayers.put(subClusterId,\n                       uamPool.getAMRMClientRelayer(subClusterId));\n \n                   uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                       registerRequest);\n                 } catch (Throwable e) {\n                   LOG.error(\"Failed to register application master: \"\n-                      + subClusterId + \" Application: \"\n-                      + appContext.getApplicationAttemptId(), e);\n+                      + subClusterId + \" Application: \" + attemptId, e);\n                 }\n                 return new RegisterApplicationMasterResponseInfo(uamResponse,\n                     SubClusterId.newInstance(subClusterId), token);\n               }\n             });\n       }\n \n       // Wait for other sub-cluster resource managers to return the\n       // response and add it to the Map for returning to the caller\n       for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n         try {\n           Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n               completionService.take();\n           RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Received register application response from RM: \"\n                 + uamResponse.getSubClusterId());\n           }\n \n           if (uamResponse.getResponse() \u003d\u003d null) {\n             failedRegistrations.add(uamResponse.getSubClusterId());\n           } else {\n             LOG.info(\"Successfully registered unmanaged application master: \"\n                 + uamResponse.getSubClusterId() + \" ApplicationId: \"\n-                + getApplicationContext().getApplicationAttemptId());\n+                + this.attemptId);\n             successfulRegistrations.put(uamResponse.getSubClusterId(),\n                 uamResponse.getResponse());\n \n             // Save the UAM token in registry or NMSS\n             if (registryClient !\u003d null) {\n               registryClient.writeAMRMTokenForUAM(\n-                  getApplicationContext().getApplicationAttemptId()\n-                      .getApplicationId(),\n+                  this.attemptId.getApplicationId(),\n                   uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken());\n             } else if (getNMStateStore() !\u003d null) {\n-              getNMStateStore().storeAMRMProxyAppContextEntry(\n-                  getApplicationContext().getApplicationAttemptId(),\n+              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n                   NMSS_SECONDARY_SC_PREFIX\n                       + uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken().encodeToUrlString()\n                       .getBytes(STRING_TO_BYTE_FORMAT));\n             }\n           }\n         } catch (Exception e) {\n           LOG.warn(\"Failed to register unmanaged application master: \"\n-              + \" ApplicationId: \"\n-              + getApplicationContext().getApplicationAttemptId(), e);\n+              + \" ApplicationId: \" + this.attemptId, e);\n         }\n       }\n     }\n \n     return new Registrations(successfulRegistrations, failedRegistrations);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  token \u003d uamPool.launchUAM(subClusterId, config,\n                      attemptId.getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString(), true);\n\n                  secondaryRelayers.put(subClusterId,\n                      uamPool.getAMRMClientRelayer(subClusterId));\n\n                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                      registerRequest);\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \" + attemptId, e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId), token);\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + this.attemptId);\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n\n            // Save the UAM token in registry or NMSS\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(\n                  this.attemptId.getApplicationId(),\n                  uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken());\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(this.attemptId,\n                  NMSS_SECONDARY_SC_PREFIX\n                      + uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken().encodeToUrlString()\n                      .getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \" + this.attemptId, e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7899. [AMRMProxy] Stateful FederationInterceptor for pending requests. Contributed by Botong Huang.\n",
      "commitDate": "09/07/18 12:27 PM",
      "commitName": "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "17/05/18 8:00 PM",
      "commitNameOld": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 52.69,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,109 @@\n   private Registrations registerWithNewSubClusters(\n       Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n \n     List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n         successfulRegistrations \u003d new HashMap\u003c\u003e();\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : subClusterSet) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId.getId());\n       }\n     }\n \n     if (newSubClusters.size() \u003e 0) {\n       final RegisterApplicationMasterRequest registerRequest \u003d\n           this.amRegistrationRequest;\n       final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n       ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n           completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n       for (final String subClusterId : newSubClusters) {\n         completionService\n             .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n               @Override\n               public RegisterApplicationMasterResponseInfo call()\n                   throws Exception {\n \n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId);\n \n                 RegisterApplicationMasterResponse uamResponse \u003d null;\n                 Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                 try {\n                   // For appNameSuffix, use subClusterId of the home sub-cluster\n                   token \u003d uamPool.launchUAM(subClusterId, config,\n                       appContext.getApplicationAttemptId().getApplicationId(),\n                       amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString(), registryClient !\u003d null);\n+                      homeSubClusterId.toString(), true);\n+\n+                  secondaryRelayers.put(subClusterId,\n+                      uamPool.getAMRMClientRelayer(subClusterId));\n \n                   uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                       registerRequest);\n                 } catch (Throwable e) {\n                   LOG.error(\"Failed to register application master: \"\n                       + subClusterId + \" Application: \"\n                       + appContext.getApplicationAttemptId(), e);\n                 }\n                 return new RegisterApplicationMasterResponseInfo(uamResponse,\n                     SubClusterId.newInstance(subClusterId), token);\n               }\n             });\n       }\n \n       // Wait for other sub-cluster resource managers to return the\n       // response and add it to the Map for returning to the caller\n       for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n         try {\n           Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n               completionService.take();\n           RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Received register application response from RM: \"\n                 + uamResponse.getSubClusterId());\n           }\n \n           if (uamResponse.getResponse() \u003d\u003d null) {\n             failedRegistrations.add(uamResponse.getSubClusterId());\n           } else {\n             LOG.info(\"Successfully registered unmanaged application master: \"\n                 + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                 + getApplicationContext().getApplicationAttemptId());\n             successfulRegistrations.put(uamResponse.getSubClusterId(),\n                 uamResponse.getResponse());\n \n             // Save the UAM token in registry or NMSS\n             if (registryClient !\u003d null) {\n               registryClient.writeAMRMTokenForUAM(\n                   getApplicationContext().getApplicationAttemptId()\n                       .getApplicationId(),\n                   uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken());\n             } else if (getNMStateStore() !\u003d null) {\n               getNMStateStore().storeAMRMProxyAppContextEntry(\n                   getApplicationContext().getApplicationAttemptId(),\n                   NMSS_SECONDARY_SC_PREFIX\n                       + uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken().encodeToUrlString()\n                       .getBytes(STRING_TO_BYTE_FORMAT));\n             }\n           }\n         } catch (Exception e) {\n           LOG.warn(\"Failed to register unmanaged application master: \"\n               + \" ApplicationId: \"\n               + getApplicationContext().getApplicationAttemptId(), e);\n         }\n       }\n     }\n \n     return new Registrations(successfulRegistrations, failedRegistrations);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  token \u003d uamPool.launchUAM(subClusterId, config,\n                      appContext.getApplicationAttemptId().getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString(), true);\n\n                  secondaryRelayers.put(subClusterId,\n                      uamPool.getAMRMClientRelayer(subClusterId));\n\n                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                      registerRequest);\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \"\n                      + appContext.getApplicationAttemptId(), e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId), token);\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + getApplicationContext().getApplicationAttemptId());\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n\n            // Save the UAM token in registry or NMSS\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(\n                  getApplicationContext().getApplicationAttemptId()\n                      .getApplicationId(),\n                  uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken());\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(\n                  getApplicationContext().getApplicationAttemptId(),\n                  NMSS_SECONDARY_SC_PREFIX\n                      + uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken().encodeToUrlString()\n                      .getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \"\n              + getApplicationContext().getApplicationAttemptId(), e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6704. Add support for work preserving NM restart when FederationInterceptor is enabled in AMRMProxyService. (Botong Huang via Subru).\n",
      "commitDate": "08/12/17 3:39 PM",
      "commitName": "670e8d4ec7e71fc3b054cd3b2826f869b649a788",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "17/11/17 5:39 PM",
      "commitNameOld": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 20.92,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,106 @@\n   private Registrations registerWithNewSubClusters(\n       Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n \n     List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n         successfulRegistrations \u003d new HashMap\u003c\u003e();\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : subClusterSet) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId.getId());\n       }\n     }\n \n     if (newSubClusters.size() \u003e 0) {\n       final RegisterApplicationMasterRequest registerRequest \u003d\n           this.amRegistrationRequest;\n       final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n       ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n           completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n       for (final String subClusterId : newSubClusters) {\n         completionService\n             .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n               @Override\n               public RegisterApplicationMasterResponseInfo call()\n                   throws Exception {\n \n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId);\n \n                 RegisterApplicationMasterResponse uamResponse \u003d null;\n                 Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                 try {\n                   // For appNameSuffix, use subClusterId of the home sub-cluster\n                   token \u003d uamPool.launchUAM(subClusterId, config,\n                       appContext.getApplicationAttemptId().getApplicationId(),\n                       amRegistrationResponse.getQueue(), appContext.getUser(),\n                       homeSubClusterId.toString(), registryClient !\u003d null);\n \n                   uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                       registerRequest);\n                 } catch (Throwable e) {\n                   LOG.error(\"Failed to register application master: \"\n                       + subClusterId + \" Application: \"\n                       + appContext.getApplicationAttemptId(), e);\n                 }\n                 return new RegisterApplicationMasterResponseInfo(uamResponse,\n                     SubClusterId.newInstance(subClusterId), token);\n               }\n             });\n       }\n \n       // Wait for other sub-cluster resource managers to return the\n       // response and add it to the Map for returning to the caller\n       for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n         try {\n           Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n               completionService.take();\n           RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Received register application response from RM: \"\n                 + uamResponse.getSubClusterId());\n           }\n \n           if (uamResponse.getResponse() \u003d\u003d null) {\n             failedRegistrations.add(uamResponse.getSubClusterId());\n           } else {\n             LOG.info(\"Successfully registered unmanaged application master: \"\n                 + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                 + getApplicationContext().getApplicationAttemptId());\n             successfulRegistrations.put(uamResponse.getSubClusterId(),\n                 uamResponse.getResponse());\n \n+            // Save the UAM token in registry or NMSS\n             if (registryClient !\u003d null) {\n               registryClient.writeAMRMTokenForUAM(\n                   getApplicationContext().getApplicationAttemptId()\n                       .getApplicationId(),\n                   uamResponse.getSubClusterId().getId(),\n                   uamResponse.getUamToken());\n+            } else if (getNMStateStore() !\u003d null) {\n+              getNMStateStore().storeAMRMProxyAppContextEntry(\n+                  getApplicationContext().getApplicationAttemptId(),\n+                  NMSS_SECONDARY_SC_PREFIX\n+                      + uamResponse.getSubClusterId().getId(),\n+                  uamResponse.getUamToken().encodeToUrlString()\n+                      .getBytes(STRING_TO_BYTE_FORMAT));\n             }\n           }\n         } catch (Exception e) {\n           LOG.warn(\"Failed to register unmanaged application master: \"\n               + \" ApplicationId: \"\n               + getApplicationContext().getApplicationAttemptId(), e);\n         }\n       }\n     }\n \n     return new Registrations(successfulRegistrations, failedRegistrations);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  token \u003d uamPool.launchUAM(subClusterId, config,\n                      appContext.getApplicationAttemptId().getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString(), registryClient !\u003d null);\n\n                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                      registerRequest);\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \"\n                      + appContext.getApplicationAttemptId(), e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId), token);\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + getApplicationContext().getApplicationAttemptId());\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n\n            // Save the UAM token in registry or NMSS\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(\n                  getApplicationContext().getApplicationAttemptId()\n                      .getApplicationId(),\n                  uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken());\n            } else if (getNMStateStore() !\u003d null) {\n              getNMStateStore().storeAMRMProxyAppContextEntry(\n                  getApplicationContext().getApplicationAttemptId(),\n                  NMSS_SECONDARY_SC_PREFIX\n                      + uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken().encodeToUrlString()\n                      .getBytes(STRING_TO_BYTE_FORMAT));\n            }\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \"\n              + getApplicationContext().getApplicationAttemptId(), e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "28/09/17 1:04 PM",
      "commitNameOld": "ca669f9f8bc7abe5b7d4648c589aa1756bd336d1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 50.23,
      "commitsBetweenForRepo": 444,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,98 @@\n   private Registrations registerWithNewSubClusters(\n       Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n \n     List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n         successfulRegistrations \u003d new HashMap\u003c\u003e();\n \n     // Check to see if there are any new sub-clusters in this request\n     // list and create and register Unmanaged AM instance for the new ones\n     List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId subClusterId : subClusterSet) {\n       if (!subClusterId.equals(this.homeSubClusterId)\n           \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n         newSubClusters.add(subClusterId.getId());\n       }\n     }\n \n     if (newSubClusters.size() \u003e 0) {\n       final RegisterApplicationMasterRequest registerRequest \u003d\n           this.amRegistrationRequest;\n       final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n       ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n           completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n       for (final String subClusterId : newSubClusters) {\n         completionService\n             .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n               @Override\n               public RegisterApplicationMasterResponseInfo call()\n                   throws Exception {\n \n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId);\n \n                 RegisterApplicationMasterResponse uamResponse \u003d null;\n+                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                 try {\n                   // For appNameSuffix, use subClusterId of the home sub-cluster\n-                  uamResponse \u003d uamPool.createAndRegisterNewUAM(subClusterId,\n-                      registerRequest, config,\n+                  token \u003d uamPool.launchUAM(subClusterId, config,\n                       appContext.getApplicationAttemptId().getApplicationId(),\n                       amRegistrationResponse.getQueue(), appContext.getUser(),\n-                      homeSubClusterId.toString());\n+                      homeSubClusterId.toString(), registryClient !\u003d null);\n+\n+                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n+                      registerRequest);\n                 } catch (Throwable e) {\n                   LOG.error(\"Failed to register application master: \"\n                       + subClusterId + \" Application: \"\n                       + appContext.getApplicationAttemptId(), e);\n                 }\n                 return new RegisterApplicationMasterResponseInfo(uamResponse,\n-                    SubClusterId.newInstance(subClusterId));\n+                    SubClusterId.newInstance(subClusterId), token);\n               }\n             });\n       }\n \n       // Wait for other sub-cluster resource managers to return the\n       // response and add it to the Map for returning to the caller\n       for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n         try {\n           Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n               completionService.take();\n           RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Received register application response from RM: \"\n                 + uamResponse.getSubClusterId());\n           }\n \n           if (uamResponse.getResponse() \u003d\u003d null) {\n             failedRegistrations.add(uamResponse.getSubClusterId());\n           } else {\n             LOG.info(\"Successfully registered unmanaged application master: \"\n                 + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                 + getApplicationContext().getApplicationAttemptId());\n             successfulRegistrations.put(uamResponse.getSubClusterId(),\n                 uamResponse.getResponse());\n+\n+            if (registryClient !\u003d null) {\n+              registryClient.writeAMRMTokenForUAM(\n+                  getApplicationContext().getApplicationAttemptId()\n+                      .getApplicationId(),\n+                  uamResponse.getSubClusterId().getId(),\n+                  uamResponse.getUamToken());\n+            }\n           }\n         } catch (Exception e) {\n           LOG.warn(\"Failed to register unmanaged application master: \"\n               + \" ApplicationId: \"\n               + getApplicationContext().getApplicationAttemptId(), e);\n         }\n       }\n     }\n \n     return new Registrations(successfulRegistrations, failedRegistrations);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                Token\u003cAMRMTokenIdentifier\u003e token \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  token \u003d uamPool.launchUAM(subClusterId, config,\n                      appContext.getApplicationAttemptId().getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString(), registryClient !\u003d null);\n\n                  uamResponse \u003d uamPool.registerApplicationMaster(subClusterId,\n                      registerRequest);\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \"\n                      + appContext.getApplicationAttemptId(), e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId), token);\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + getApplicationContext().getApplicationAttemptId());\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n\n            if (registryClient !\u003d null) {\n              registryClient.writeAMRMTokenForUAM(\n                  getApplicationContext().getApplicationAttemptId()\n                      .getApplicationId(),\n                  uamResponse.getSubClusterId().getId(),\n                  uamResponse.getUamToken());\n            }\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \"\n              + getApplicationContext().getApplicationAttemptId(), e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6511. Federation: transparently spanning application across multiple sub-clusters. (Botong Huang via Subru).\n\n(cherry picked from commit 8c988d235eaf0972783985b1ab24680d029aea79)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "70b1a757f13b01a9192ea5fb0820ba7babfd974e",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,87 @@\n+  private Registrations registerWithNewSubClusters(\n+      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n+\n+    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n+    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n+        successfulRegistrations \u003d new HashMap\u003c\u003e();\n+\n+    // Check to see if there are any new sub-clusters in this request\n+    // list and create and register Unmanaged AM instance for the new ones\n+    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId subClusterId : subClusterSet) {\n+      if (!subClusterId.equals(this.homeSubClusterId)\n+          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n+        newSubClusters.add(subClusterId.getId());\n+      }\n+    }\n+\n+    if (newSubClusters.size() \u003e 0) {\n+      final RegisterApplicationMasterRequest registerRequest \u003d\n+          this.amRegistrationRequest;\n+      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n+      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n+          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n+\n+      for (final String subClusterId : newSubClusters) {\n+        completionService\n+            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n+              @Override\n+              public RegisterApplicationMasterResponseInfo call()\n+                  throws Exception {\n+\n+                // Create a config loaded with federation on and subclusterId\n+                // for each UAM\n+                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+                FederationProxyProviderUtil.updateConfForFederation(config,\n+                    subClusterId);\n+\n+                RegisterApplicationMasterResponse uamResponse \u003d null;\n+                try {\n+                  // For appNameSuffix, use subClusterId of the home sub-cluster\n+                  uamResponse \u003d uamPool.createAndRegisterNewUAM(subClusterId,\n+                      registerRequest, config,\n+                      appContext.getApplicationAttemptId().getApplicationId(),\n+                      amRegistrationResponse.getQueue(), appContext.getUser(),\n+                      homeSubClusterId.toString());\n+                } catch (Throwable e) {\n+                  LOG.error(\"Failed to register application master: \"\n+                      + subClusterId + \" Application: \"\n+                      + appContext.getApplicationAttemptId(), e);\n+                }\n+                return new RegisterApplicationMasterResponseInfo(uamResponse,\n+                    SubClusterId.newInstance(subClusterId));\n+              }\n+            });\n+      }\n+\n+      // Wait for other sub-cluster resource managers to return the\n+      // response and add it to the Map for returning to the caller\n+      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n+        try {\n+          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n+              completionService.take();\n+          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Received register application response from RM: \"\n+                + uamResponse.getSubClusterId());\n+          }\n+\n+          if (uamResponse.getResponse() \u003d\u003d null) {\n+            failedRegistrations.add(uamResponse.getSubClusterId());\n+          } else {\n+            LOG.info(\"Successfully registered unmanaged application master: \"\n+                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n+                + getApplicationContext().getApplicationAttemptId());\n+            successfulRegistrations.put(uamResponse.getSubClusterId(),\n+                uamResponse.getResponse());\n+          }\n+        } catch (Exception e) {\n+          LOG.warn(\"Failed to register unmanaged application master: \"\n+              + \" ApplicationId: \"\n+              + getApplicationContext().getApplicationAttemptId(), e);\n+        }\n+      }\n+    }\n+\n+    return new Registrations(successfulRegistrations, failedRegistrations);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Registrations registerWithNewSubClusters(\n      Set\u003cSubClusterId\u003e subClusterSet) throws IOException {\n\n    List\u003cSubClusterId\u003e failedRegistrations \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, RegisterApplicationMasterResponse\u003e\n        successfulRegistrations \u003d new HashMap\u003c\u003e();\n\n    // Check to see if there are any new sub-clusters in this request\n    // list and create and register Unmanaged AM instance for the new ones\n    List\u003cString\u003e newSubClusters \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId subClusterId : subClusterSet) {\n      if (!subClusterId.equals(this.homeSubClusterId)\n          \u0026\u0026 !this.uamPool.hasUAMId(subClusterId.getId())) {\n        newSubClusters.add(subClusterId.getId());\n      }\n    }\n\n    if (newSubClusters.size() \u003e 0) {\n      final RegisterApplicationMasterRequest registerRequest \u003d\n          this.amRegistrationRequest;\n      final AMRMProxyApplicationContext appContext \u003d getApplicationContext();\n      ExecutorCompletionService\u003cRegisterApplicationMasterResponseInfo\u003e\n          completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n      for (final String subClusterId : newSubClusters) {\n        completionService\n            .submit(new Callable\u003cRegisterApplicationMasterResponseInfo\u003e() {\n              @Override\n              public RegisterApplicationMasterResponseInfo call()\n                  throws Exception {\n\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId);\n\n                RegisterApplicationMasterResponse uamResponse \u003d null;\n                try {\n                  // For appNameSuffix, use subClusterId of the home sub-cluster\n                  uamResponse \u003d uamPool.createAndRegisterNewUAM(subClusterId,\n                      registerRequest, config,\n                      appContext.getApplicationAttemptId().getApplicationId(),\n                      amRegistrationResponse.getQueue(), appContext.getUser(),\n                      homeSubClusterId.toString());\n                } catch (Throwable e) {\n                  LOG.error(\"Failed to register application master: \"\n                      + subClusterId + \" Application: \"\n                      + appContext.getApplicationAttemptId(), e);\n                }\n                return new RegisterApplicationMasterResponseInfo(uamResponse,\n                    SubClusterId.newInstance(subClusterId));\n              }\n            });\n      }\n\n      // Wait for other sub-cluster resource managers to return the\n      // response and add it to the Map for returning to the caller\n      for (int i \u003d 0; i \u003c newSubClusters.size(); ++i) {\n        try {\n          Future\u003cRegisterApplicationMasterResponseInfo\u003e future \u003d\n              completionService.take();\n          RegisterApplicationMasterResponseInfo uamResponse \u003d future.get();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received register application response from RM: \"\n                + uamResponse.getSubClusterId());\n          }\n\n          if (uamResponse.getResponse() \u003d\u003d null) {\n            failedRegistrations.add(uamResponse.getSubClusterId());\n          } else {\n            LOG.info(\"Successfully registered unmanaged application master: \"\n                + uamResponse.getSubClusterId() + \" ApplicationId: \"\n                + getApplicationContext().getApplicationAttemptId());\n            successfulRegistrations.put(uamResponse.getSubClusterId(),\n                uamResponse.getResponse());\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed to register unmanaged application master: \"\n              + \" ApplicationId: \"\n              + getApplicationContext().getApplicationAttemptId(), e);\n        }\n      }\n    }\n\n    return new Registrations(successfulRegistrations, failedRegistrations);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java"
    }
  }
}