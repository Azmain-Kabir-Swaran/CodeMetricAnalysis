{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ParentQueue.java",
  "functionName": "reinitialize",
  "functionId": "reinitialize___newlyParsedQueue-CSQueue__clusterResource-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
  "functionStartLine": 336,
  "functionEndLine": 420,
  "numCommitsSeen": 110,
  "timeTaken": 13898,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "d8f74c3964fa429a4a53c3651d175792cf00ac81",
    "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9",
    "0a3aa40fe7878c939dbf4e6b43466595159ff930",
    "165f07f51a03137d2e73e39ed1cb48385d963f39",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "72054a817dfb43e93916d7036eba19cf2f49cea2",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "18a594257e052e8f10a03e5594e6cc6901dc56be",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "9c22065109a77681bc2534063eabe8692fbcb3cd",
    "cc523683cfa76c1255667a3aedc48b08e5daabc7",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "59b88655bc15535d7bf765987cb9b82f17e16b80",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1",
    "1f46b991da9b91585608a0babd3eda39485dce09",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "d8f74c3964fa429a4a53c3651d175792cf00ac81": "Ybodychange",
    "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9": "Ybodychange",
    "0a3aa40fe7878c939dbf4e6b43466595159ff930": "Ybodychange",
    "165f07f51a03137d2e73e39ed1cb48385d963f39": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ybodychange",
    "72054a817dfb43e93916d7036eba19cf2f49cea2": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "18a594257e052e8f10a03e5594e6cc6901dc56be": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "9c22065109a77681bc2534063eabe8692fbcb3cd": "Ybodychange",
    "cc523683cfa76c1255667a3aedc48b08e5daabc7": "Ymultichange(Yparameterchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "59b88655bc15535d7bf765987cb9b82f17e16b80": "Ybodychange",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": "Ybodychange",
    "1f46b991da9b91585608a0babd3eda39485dce09": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "29/08/19 3:14 AM",
      "commitNameOld": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 209.05,
      "commitsBetweenForRepo": 935,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     writeLock.lock();\n     try {\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n           // Check if the child-queue has been converted into parent queue or\n           // parent Queue has been converted to child queue. The CS has already\n           // checked to ensure that this child-queue is in STOPPED state if\n           // Child queue has been converted to ParentQueue.\n           if ((childQueue instanceof LeafQueue\n               \u0026\u0026 newChildQueue instanceof ParentQueue)\n               || (childQueue instanceof ParentQueue\n                   \u0026\u0026 newChildQueue instanceof LeafQueue)) {\n             // We would convert this LeafQueue to ParentQueue, or vice versa.\n             // consider this as the combination of DELETE then ADD.\n             newChildQueue.setParent(this);\n             currentChildQueues.put(newChildQueueName, newChildQueue);\n             // inform CapacitySchedulerQueueManager\n             CapacitySchedulerQueueManager queueManager \u003d\n                 this.csContext.getCapacitySchedulerQueueManager();\n             queueManager.addQueue(newChildQueueName, newChildQueue);\n             continue;\n           }\n           // Re-init existing queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n-          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n+          LOG.info(getQueuePath() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n-              getQueueName() + \": added new child queue: \" + newChildQueue);\n+              getQueuePath() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n       for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n           .entrySet().iterator(); itr.hasNext();) {\n         Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n           itr.remove();\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n \n       // Make sure we notifies QueueOrderingPolicy\n       queueOrderingPolicy.setQueues(childQueues);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    writeLock.lock();\n    try {\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Check if the child-queue has been converted into parent queue or\n          // parent Queue has been converted to child queue. The CS has already\n          // checked to ensure that this child-queue is in STOPPED state if\n          // Child queue has been converted to ParentQueue.\n          if ((childQueue instanceof LeafQueue\n              \u0026\u0026 newChildQueue instanceof ParentQueue)\n              || (childQueue instanceof ParentQueue\n                  \u0026\u0026 newChildQueue instanceof LeafQueue)) {\n            // We would convert this LeafQueue to ParentQueue, or vice versa.\n            // consider this as the combination of DELETE then ADD.\n            newChildQueue.setParent(this);\n            currentChildQueues.put(newChildQueueName, newChildQueue);\n            // inform CapacitySchedulerQueueManager\n            CapacitySchedulerQueueManager queueManager \u003d\n                this.csContext.getCapacitySchedulerQueueManager();\n            queueManager.addQueue(newChildQueueName, newChildQueue);\n            continue;\n          }\n          // Re-init existing queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueuePath() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueuePath() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n          .entrySet().iterator(); itr.hasNext();) {\n        Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          itr.remove();\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n\n      // Make sure we notifies QueueOrderingPolicy\n      queueOrderingPolicy.setQueues(childQueues);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n           // Check if the child-queue has been converted into parent queue or\n           // parent Queue has been converted to child queue. The CS has already\n           // checked to ensure that this child-queue is in STOPPED state if\n           // Child queue has been converted to ParentQueue.\n           if ((childQueue instanceof LeafQueue\n               \u0026\u0026 newChildQueue instanceof ParentQueue)\n               || (childQueue instanceof ParentQueue\n                   \u0026\u0026 newChildQueue instanceof LeafQueue)) {\n             // We would convert this LeafQueue to ParentQueue, or vice versa.\n             // consider this as the combination of DELETE then ADD.\n             newChildQueue.setParent(this);\n             currentChildQueues.put(newChildQueueName, newChildQueue);\n             // inform CapacitySchedulerQueueManager\n             CapacitySchedulerQueueManager queueManager \u003d\n                 this.csContext.getCapacitySchedulerQueueManager();\n             queueManager.addQueue(newChildQueueName, newChildQueue);\n             continue;\n           }\n           // Re-init existing queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n       for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n           .entrySet().iterator(); itr.hasNext();) {\n         Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n           itr.remove();\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n \n       // Make sure we notifies QueueOrderingPolicy\n       queueOrderingPolicy.setQueues(childQueues);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    writeLock.lock();\n    try {\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Check if the child-queue has been converted into parent queue or\n          // parent Queue has been converted to child queue. The CS has already\n          // checked to ensure that this child-queue is in STOPPED state if\n          // Child queue has been converted to ParentQueue.\n          if ((childQueue instanceof LeafQueue\n              \u0026\u0026 newChildQueue instanceof ParentQueue)\n              || (childQueue instanceof ParentQueue\n                  \u0026\u0026 newChildQueue instanceof LeafQueue)) {\n            // We would convert this LeafQueue to ParentQueue, or vice versa.\n            // consider this as the combination of DELETE then ADD.\n            newChildQueue.setParent(this);\n            currentChildQueues.put(newChildQueueName, newChildQueue);\n            // inform CapacitySchedulerQueueManager\n            CapacitySchedulerQueueManager queueManager \u003d\n                this.csContext.getCapacitySchedulerQueueManager();\n            queueManager.addQueue(newChildQueueName, newChildQueue);\n            continue;\n          }\n          // Re-init existing queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n          .entrySet().iterator(); itr.hasNext();) {\n        Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          itr.remove();\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n\n      // Make sure we notifies QueueOrderingPolicy\n      queueOrderingPolicy.setQueues(childQueues);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "d8f74c3964fa429a4a53c3651d175792cf00ac81": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6741. Deleting all children of a Parent Queue on refresh throws exception. Contributed by Naganarasimha G R.\n",
      "commitDate": "13/08/17 9:09 PM",
      "commitName": "d8f74c3964fa429a4a53c3651d175792cf00ac81",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "30/06/17 11:59 PM",
      "commitNameOld": "fa1aaee87b0141a0255b5f8e5fd8e8f49d7efe86",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 43.88,
      "commitsBetweenForRepo": 278,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,85 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     try {\n       writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n-          // Check if the child-queue has been converted into parent queue.\n-          // The CS has already checked to ensure that this child-queue is in\n-          // STOPPED state.\n-          if (childQueue instanceof LeafQueue\n-              \u0026\u0026 newChildQueue instanceof ParentQueue) {\n-            // We would convert this LeafQueue to ParentQueue, consider this\n-            // as the combination of DELETE then ADD.\n+          // Check if the child-queue has been converted into parent queue or\n+          // parent Queue has been converted to child queue. The CS has already\n+          // checked to ensure that this child-queue is in STOPPED state if\n+          // Child queue has been converted to ParentQueue.\n+          if ((childQueue instanceof LeafQueue\n+              \u0026\u0026 newChildQueue instanceof ParentQueue)\n+              || (childQueue instanceof ParentQueue\n+                  \u0026\u0026 newChildQueue instanceof LeafQueue)) {\n+            // We would convert this LeafQueue to ParentQueue, or vice versa.\n+            // consider this as the combination of DELETE then ADD.\n             newChildQueue.setParent(this);\n             currentChildQueues.put(newChildQueueName, newChildQueue);\n             // inform CapacitySchedulerQueueManager\n-            CapacitySchedulerQueueManager queueManager \u003d this.csContext\n-                .getCapacitySchedulerQueueManager();\n+            CapacitySchedulerQueueManager queueManager \u003d\n+                this.csContext.getCapacitySchedulerQueueManager();\n             queueManager.addQueue(newChildQueueName, newChildQueue);\n             continue;\n           }\n           // Re-init existing queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n       for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n           .entrySet().iterator(); itr.hasNext();) {\n         Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n           itr.remove();\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n \n       // Make sure we notifies QueueOrderingPolicy\n       queueOrderingPolicy.setQueues(childQueues);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Check if the child-queue has been converted into parent queue or\n          // parent Queue has been converted to child queue. The CS has already\n          // checked to ensure that this child-queue is in STOPPED state if\n          // Child queue has been converted to ParentQueue.\n          if ((childQueue instanceof LeafQueue\n              \u0026\u0026 newChildQueue instanceof ParentQueue)\n              || (childQueue instanceof ParentQueue\n                  \u0026\u0026 newChildQueue instanceof LeafQueue)) {\n            // We would convert this LeafQueue to ParentQueue, or vice versa.\n            // consider this as the combination of DELETE then ADD.\n            newChildQueue.setParent(this);\n            currentChildQueues.put(newChildQueueName, newChildQueue);\n            // inform CapacitySchedulerQueueManager\n            CapacitySchedulerQueueManager queueManager \u003d\n                this.csContext.getCapacitySchedulerQueueManager();\n            queueManager.addQueue(newChildQueueName, newChildQueue);\n            continue;\n          }\n          // Re-init existing queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n          .entrySet().iterator(); itr.hasNext();) {\n        Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          itr.remove();\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n\n      // Make sure we notifies QueueOrderingPolicy\n      queueOrderingPolicy.setQueues(childQueues);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6109. Add an ability to convert ChildQueue to ParentQueue. (Xuan Gong via wangda)\n",
      "commitDate": "04/04/17 2:39 PM",
      "commitName": "3fdae0a2b66c5fb6853875b66fcf50bc96d6e2e9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/03/17 12:52 PM",
      "commitNameOld": "0a3aa40fe7878c939dbf4e6b43466595159ff930",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 21.07,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,82 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     try {\n       writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n-          // Re-init existing child queues\n+          // Check if the child-queue has been converted into parent queue.\n+          // The CS has already checked to ensure that this child-queue is in\n+          // STOPPED state.\n+          if (childQueue instanceof LeafQueue\n+              \u0026\u0026 newChildQueue instanceof ParentQueue) {\n+            // We would convert this LeafQueue to ParentQueue, consider this\n+            // as the combination of DELETE then ADD.\n+            newChildQueue.setParent(this);\n+            currentChildQueues.put(newChildQueueName, newChildQueue);\n+            // inform CapacitySchedulerQueueManager\n+            CapacitySchedulerQueueManager queueManager \u003d this.csContext\n+                .getCapacitySchedulerQueueManager();\n+            queueManager.addQueue(newChildQueueName, newChildQueue);\n+            continue;\n+          }\n+          // Re-init existing queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n       for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n           .entrySet().iterator(); itr.hasNext();) {\n         Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n           itr.remove();\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n \n       // Make sure we notifies QueueOrderingPolicy\n       queueOrderingPolicy.setQueues(childQueues);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Check if the child-queue has been converted into parent queue.\n          // The CS has already checked to ensure that this child-queue is in\n          // STOPPED state.\n          if (childQueue instanceof LeafQueue\n              \u0026\u0026 newChildQueue instanceof ParentQueue) {\n            // We would convert this LeafQueue to ParentQueue, consider this\n            // as the combination of DELETE then ADD.\n            newChildQueue.setParent(this);\n            currentChildQueues.put(newChildQueueName, newChildQueue);\n            // inform CapacitySchedulerQueueManager\n            CapacitySchedulerQueueManager queueManager \u003d this.csContext\n                .getCapacitySchedulerQueueManager();\n            queueManager.addQueue(newChildQueueName, newChildQueue);\n            continue;\n          }\n          // Re-init existing queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n          .entrySet().iterator(); itr.hasNext();) {\n        Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          itr.remove();\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n\n      // Make sure we notifies QueueOrderingPolicy\n      queueOrderingPolicy.setQueues(childQueues);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "0a3aa40fe7878c939dbf4e6b43466595159ff930": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6327. Removing queues from CapacitySchedulerQueueManager and ParentQueue should be done with iterator. Contributed by Jonathan Hung.\n",
      "commitDate": "14/03/17 12:52 PM",
      "commitName": "0a3aa40fe7878c939dbf4e6b43466595159ff930",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "28/02/17 10:35 AM",
      "commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 14.05,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     try {\n       writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n           // Re-init existing child queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n-      for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n+      for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n+          .entrySet().iterator(); itr.hasNext();) {\n+        Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n-          currentChildQueues.remove(queueName);\n+          itr.remove();\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n \n       // Make sure we notifies QueueOrderingPolicy\n       queueOrderingPolicy.setQueues(childQueues);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Re-init existing child queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Iterator\u003cMap.Entry\u003cString, CSQueue\u003e\u003e itr \u003d currentChildQueues\n          .entrySet().iterator(); itr.hasNext();) {\n        Map.Entry\u003cString, CSQueue\u003e e \u003d itr.next();\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          itr.remove();\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n\n      // Make sure we notifies QueueOrderingPolicy\n      queueOrderingPolicy.setQueues(childQueues);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "165f07f51a03137d2e73e39ed1cb48385d963f39": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6123. [YARN-5864] Add a test to make sure queues of orderingPolicy will be updated when childQueues is added or removed. Contributed by Wangda Tan.\n",
      "commitDate": "27/01/17 5:07 AM",
      "commitName": "165f07f51a03137d2e73e39ed1cb48385d963f39",
      "commitAuthor": "Sunil G",
      "commitDateOld": "23/01/17 10:52 AM",
      "commitNameOld": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.76,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,65 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     try {\n       writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n           // Re-init existing child queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n       for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n           currentChildQueues.remove(queueName);\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n+\n+      // Make sure we notifies QueueOrderingPolicy\n+      queueOrderingPolicy.setQueues(childQueues);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Re-init existing child queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          currentChildQueues.remove(queueName);\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n\n      // Make sure we notifies QueueOrderingPolicy\n      queueOrderingPolicy.setQueues(childQueues);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/17 1:31 PM",
      "commitNameOld": "72054a817dfb43e93916d7036eba19cf2f49cea2",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 4.89,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     try {\n       writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n-      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n-      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n+      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n+      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n           // Re-init existing child queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n       // remove the deleted queue in the refreshed xml.\n       for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n         String queueName \u003d e.getKey();\n         if (!newChildQueues.containsKey(queueName)) {\n           currentChildQueues.remove(queueName);\n         }\n       }\n \n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueuesMap(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueuesMap(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Re-init existing child queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          currentChildQueues.remove(queueName);\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "72054a817dfb43e93916d7036eba19cf2f49cea2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5556. CapacityScheduler: Support deleting queues without requiring a RM restart. (Naganarasimha G R via wangda)\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "72054a817dfb43e93916d7036eba19cf2f49cea2",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 9:18 PM",
      "commitNameOld": "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.68,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,62 @@\n   public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n     try {\n       writeLock.lock();\n       // Sanity check\n       if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n           .getQueuePath().equals(getQueuePath())) {\n         throw new IOException(\n             \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                 + newlyParsedQueue.getQueuePath());\n       }\n \n       ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n \n       // Set new configs\n       setupQueueConfigs(clusterResource);\n \n       // Re-configure existing child queues and add new ones\n       // The CS has already checked to ensure all existing child queues are present!\n       Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n       Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n           newlyParsedParentQueue.childQueues);\n       for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n         String newChildQueueName \u003d e.getKey();\n         CSQueue newChildQueue \u003d e.getValue();\n \n         CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n \n         // Check if the child-queue already exists\n         if (childQueue !\u003d null) {\n           // Re-init existing child queues\n           childQueue.reinitialize(newChildQueue, clusterResource);\n           LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n         } else{\n           // New child queue, do not re-init\n \n           // Set parent to \u0027this\u0027\n           newChildQueue.setParent(this);\n \n           // Save in list of current child queues\n           currentChildQueues.put(newChildQueueName, newChildQueue);\n \n           LOG.info(\n               getQueueName() + \": added new child queue: \" + newChildQueue);\n         }\n       }\n \n+      // remove the deleted queue in the refreshed xml.\n+      for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n+        String queueName \u003d e.getKey();\n+        if (!newChildQueues.containsKey(queueName)) {\n+          currentChildQueues.remove(queueName);\n+        }\n+      }\n+\n       // Re-sort all queues\n       childQueues.clear();\n       childQueues.addAll(currentChildQueues.values());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Re-init existing child queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // remove the deleted queue in the refreshed xml.\n      for (Map.Entry\u003cString, CSQueue\u003e e : currentChildQueues.entrySet()) {\n        String queueName \u003d e.getKey();\n        if (!newChildQueues.containsKey(queueName)) {\n          currentChildQueues.remove(queueName);\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,54 @@\n-  public synchronized void reinitialize(CSQueue newlyParsedQueue,\n+  public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n-    // Sanity check\n-    if (!(newlyParsedQueue instanceof ParentQueue) ||\n-        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n-      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n-          \" from \" + newlyParsedQueue.getQueuePath());\n-    }\n-\n-    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n-\n-    // Set new configs\n-    setupQueueConfigs(clusterResource);\n-\n-    // Re-configure existing child queues and add new ones\n-    // The CS has already checked to ensure all existing child queues are present!\n-    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n-    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n-        getQueues(newlyParsedParentQueue.childQueues);\n-    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n-      String newChildQueueName \u003d e.getKey();\n-      CSQueue newChildQueue \u003d e.getValue();\n-\n-      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n-      \n-      // Check if the child-queue already exists\n-      if (childQueue !\u003d null) {\n-        // Re-init existing child queues\n-        childQueue.reinitialize(newChildQueue, clusterResource);\n-        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n-      } else {\n-        // New child queue, do not re-init\n-        \n-        // Set parent to \u0027this\u0027\n-        newChildQueue.setParent(this);\n-        \n-        // Save in list of current child queues\n-        currentChildQueues.put(newChildQueueName, newChildQueue);\n-        \n-        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n+    try {\n+      writeLock.lock();\n+      // Sanity check\n+      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n+          .getQueuePath().equals(getQueuePath())) {\n+        throw new IOException(\n+            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n+                + newlyParsedQueue.getQueuePath());\n       }\n-    }\n \n-    // Re-sort all queues\n-    childQueues.clear();\n-    childQueues.addAll(currentChildQueues.values());\n+      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n+\n+      // Set new configs\n+      setupQueueConfigs(clusterResource);\n+\n+      // Re-configure existing child queues and add new ones\n+      // The CS has already checked to ensure all existing child queues are present!\n+      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n+      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n+          newlyParsedParentQueue.childQueues);\n+      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n+        String newChildQueueName \u003d e.getKey();\n+        CSQueue newChildQueue \u003d e.getValue();\n+\n+        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n+\n+        // Check if the child-queue already exists\n+        if (childQueue !\u003d null) {\n+          // Re-init existing child queues\n+          childQueue.reinitialize(newChildQueue, clusterResource);\n+          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n+        } else{\n+          // New child queue, do not re-init\n+\n+          // Set parent to \u0027this\u0027\n+          newChildQueue.setParent(this);\n+\n+          // Save in list of current child queues\n+          currentChildQueues.put(newChildQueueName, newChildQueue);\n+\n+          LOG.info(\n+              getQueueName() + \": added new child queue: \" + newChildQueue);\n+        }\n+      }\n+\n+      // Re-sort all queues\n+      childQueues.clear();\n+      childQueues.addAll(currentChildQueues.values());\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Re-init existing child queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,54 @@\n-  public synchronized void reinitialize(CSQueue newlyParsedQueue,\n+  public void reinitialize(CSQueue newlyParsedQueue,\n       Resource clusterResource) throws IOException {\n-    // Sanity check\n-    if (!(newlyParsedQueue instanceof ParentQueue) ||\n-        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n-      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n-          \" from \" + newlyParsedQueue.getQueuePath());\n-    }\n-\n-    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n-\n-    // Set new configs\n-    setupQueueConfigs(clusterResource);\n-\n-    // Re-configure existing child queues and add new ones\n-    // The CS has already checked to ensure all existing child queues are present!\n-    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n-    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n-        getQueues(newlyParsedParentQueue.childQueues);\n-    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n-      String newChildQueueName \u003d e.getKey();\n-      CSQueue newChildQueue \u003d e.getValue();\n-\n-      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n-      \n-      // Check if the child-queue already exists\n-      if (childQueue !\u003d null) {\n-        // Re-init existing child queues\n-        childQueue.reinitialize(newChildQueue, clusterResource);\n-        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n-      } else {\n-        // New child queue, do not re-init\n-        \n-        // Set parent to \u0027this\u0027\n-        newChildQueue.setParent(this);\n-        \n-        // Save in list of current child queues\n-        currentChildQueues.put(newChildQueueName, newChildQueue);\n-        \n-        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n+    try {\n+      writeLock.lock();\n+      // Sanity check\n+      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n+          .getQueuePath().equals(getQueuePath())) {\n+        throw new IOException(\n+            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n+                + newlyParsedQueue.getQueuePath());\n       }\n-    }\n \n-    // Re-sort all queues\n-    childQueues.clear();\n-    childQueues.addAll(currentChildQueues.values());\n+      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n+\n+      // Set new configs\n+      setupQueueConfigs(clusterResource);\n+\n+      // Re-configure existing child queues and add new ones\n+      // The CS has already checked to ensure all existing child queues are present!\n+      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n+      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n+          newlyParsedParentQueue.childQueues);\n+      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n+        String newChildQueueName \u003d e.getKey();\n+        CSQueue newChildQueue \u003d e.getValue();\n+\n+        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n+\n+        // Check if the child-queue already exists\n+        if (childQueue !\u003d null) {\n+          // Re-init existing child queues\n+          childQueue.reinitialize(newChildQueue, clusterResource);\n+          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n+        } else{\n+          // New child queue, do not re-init\n+\n+          // Set parent to \u0027this\u0027\n+          newChildQueue.setParent(this);\n+\n+          // Save in list of current child queues\n+          currentChildQueues.put(newChildQueueName, newChildQueue);\n+\n+          LOG.info(\n+              getQueueName() + \": added new child queue: \" + newChildQueue);\n+        }\n+      }\n+\n+      // Re-sort all queues\n+      childQueues.clear();\n+      childQueues.addAll(currentChildQueues.values());\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    try {\n      writeLock.lock();\n      // Sanity check\n      if (!(newlyParsedQueue instanceof ParentQueue) || !newlyParsedQueue\n          .getQueuePath().equals(getQueuePath())) {\n        throw new IOException(\n            \"Trying to reinitialize \" + getQueuePath() + \" from \"\n                + newlyParsedQueue.getQueuePath());\n      }\n\n      ParentQueue newlyParsedParentQueue \u003d (ParentQueue) newlyParsedQueue;\n\n      // Set new configs\n      setupQueueConfigs(clusterResource);\n\n      // Re-configure existing child queues and add new ones\n      // The CS has already checked to ensure all existing child queues are present!\n      Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n      Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(\n          newlyParsedParentQueue.childQueues);\n      for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n        String newChildQueueName \u003d e.getKey();\n        CSQueue newChildQueue \u003d e.getValue();\n\n        CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n\n        // Check if the child-queue already exists\n        if (childQueue !\u003d null) {\n          // Re-init existing child queues\n          childQueue.reinitialize(newChildQueue, clusterResource);\n          LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n        } else{\n          // New child queue, do not re-init\n\n          // Set parent to \u0027this\u0027\n          newChildQueue.setParent(this);\n\n          // Save in list of current child queues\n          currentChildQueues.put(newChildQueueName, newChildQueue);\n\n          LOG.info(\n              getQueueName() + \": added new child queue: \" + newChildQueue);\n        }\n      }\n\n      // Re-sort all queues\n      childQueues.clear();\n      childQueues.addAll(currentChildQueues.values());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "18a594257e052e8f10a03e5594e6cc6901dc56be": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
      "commitDate": "12/02/15 2:58 PM",
      "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/02/15 8:34 PM",
      "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,47 @@\n-  public synchronized void reinitialize(\n-      CSQueue newlyParsedQueue, Resource clusterResource)\n-  throws IOException {\n+  public synchronized void reinitialize(CSQueue newlyParsedQueue,\n+      Resource clusterResource) throws IOException {\n     // Sanity check\n     if (!(newlyParsedQueue instanceof ParentQueue) ||\n         !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + newlyParsedQueue.getQueuePath());\n     }\n \n     ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n \n     // Set new configs\n-    setupQueueConfigs(clusterResource,\n-        newlyParsedParentQueue.capacity, \n-        newlyParsedParentQueue.absoluteCapacity,\n-        newlyParsedParentQueue.maximumCapacity, \n-        newlyParsedParentQueue.absoluteMaxCapacity,\n-        newlyParsedParentQueue.state, \n-        newlyParsedParentQueue.acls,\n-        newlyParsedParentQueue.accessibleLabels,\n-        newlyParsedParentQueue.defaultLabelExpression,\n-        newlyParsedParentQueue.capacitiyByNodeLabels,\n-        newlyParsedParentQueue.maxCapacityByNodeLabels,\n-        newlyParsedParentQueue.reservationsContinueLooking);\n+    setupQueueConfigs(clusterResource);\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n     Map\u003cString, CSQueue\u003e newChildQueues \u003d \n         getQueues(newlyParsedParentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       \n       // Check if the child-queue already exists\n       if (childQueue !\u003d null) {\n         // Re-init existing child queues\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         // New child queue, do not re-init\n         \n         // Set parent to \u0027this\u0027\n         newChildQueue.setParent(this);\n         \n         // Save in list of current child queues\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         \n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource) throws IOException {\n    // Sanity check\n    if (!(newlyParsedQueue instanceof ParentQueue) ||\n        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + newlyParsedQueue.getQueuePath());\n    }\n\n    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n        getQueues(newlyParsedParentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      \n      // Check if the child-queue already exists\n      if (childQueue !\u003d null) {\n        // Re-init existing child queues\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        // New child queue, do not re-init\n        \n        // Set parent to \u0027this\u0027\n        newChildQueue.setParent(this);\n        \n        // Save in list of current child queues\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        \n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/10/14 3:41 PM",
      "commitNameOld": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthorOld": "carlo curino",
      "daysBetweenCommits": 12.12,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,59 @@\n   public synchronized void reinitialize(\n       CSQueue newlyParsedQueue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n     if (!(newlyParsedQueue instanceof ParentQueue) ||\n         !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + newlyParsedQueue.getQueuePath());\n     }\n \n     ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n \n     // Set new configs\n     setupQueueConfigs(clusterResource,\n         newlyParsedParentQueue.capacity, \n         newlyParsedParentQueue.absoluteCapacity,\n         newlyParsedParentQueue.maximumCapacity, \n         newlyParsedParentQueue.absoluteMaxCapacity,\n         newlyParsedParentQueue.state, \n         newlyParsedParentQueue.acls,\n+        newlyParsedParentQueue.accessibleLabels,\n+        newlyParsedParentQueue.defaultLabelExpression,\n+        newlyParsedParentQueue.capacitiyByNodeLabels,\n+        newlyParsedParentQueue.maxCapacityByNodeLabels,\n         newlyParsedParentQueue.reservationsContinueLooking);\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n     Map\u003cString, CSQueue\u003e newChildQueues \u003d \n         getQueues(newlyParsedParentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       \n       // Check if the child-queue already exists\n       if (childQueue !\u003d null) {\n         // Re-init existing child queues\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         // New child queue, do not re-init\n         \n         // Set parent to \u0027this\u0027\n         newChildQueue.setParent(this);\n         \n         // Save in list of current child queues\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         \n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(\n      CSQueue newlyParsedQueue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(newlyParsedQueue instanceof ParentQueue) ||\n        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + newlyParsedQueue.getQueuePath());\n    }\n\n    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        newlyParsedParentQueue.capacity, \n        newlyParsedParentQueue.absoluteCapacity,\n        newlyParsedParentQueue.maximumCapacity, \n        newlyParsedParentQueue.absoluteMaxCapacity,\n        newlyParsedParentQueue.state, \n        newlyParsedParentQueue.acls,\n        newlyParsedParentQueue.accessibleLabels,\n        newlyParsedParentQueue.defaultLabelExpression,\n        newlyParsedParentQueue.capacitiyByNodeLabels,\n        newlyParsedParentQueue.maxCapacityByNodeLabels,\n        newlyParsedParentQueue.reservationsContinueLooking);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n        getQueues(newlyParsedParentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      \n      // Check if the child-queue already exists\n      if (childQueue !\u003d null) {\n        // Re-init existing child queues\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        // New child queue, do not re-init\n        \n        // Set parent to \u0027this\u0027\n        newChildQueue.setParent(this);\n        \n        // Save in list of current child queues\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        \n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "9c22065109a77681bc2534063eabe8692fbcb3cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
      "commitDate": "29/09/14 7:12 AM",
      "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "14/08/14 11:00 PM",
      "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 45.34,
      "commitsBetweenForRepo": 409,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,55 @@\n   public synchronized void reinitialize(\n       CSQueue newlyParsedQueue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n     if (!(newlyParsedQueue instanceof ParentQueue) ||\n         !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + newlyParsedQueue.getQueuePath());\n     }\n \n     ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n \n     // Set new configs\n     setupQueueConfigs(clusterResource,\n         newlyParsedParentQueue.capacity, \n         newlyParsedParentQueue.absoluteCapacity,\n         newlyParsedParentQueue.maximumCapacity, \n         newlyParsedParentQueue.absoluteMaxCapacity,\n         newlyParsedParentQueue.state, \n-        newlyParsedParentQueue.acls);\n+        newlyParsedParentQueue.acls,\n+        newlyParsedParentQueue.reservationsContinueLooking);\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n     Map\u003cString, CSQueue\u003e newChildQueues \u003d \n         getQueues(newlyParsedParentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       \n       // Check if the child-queue already exists\n       if (childQueue !\u003d null) {\n         // Re-init existing child queues\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         // New child queue, do not re-init\n         \n         // Set parent to \u0027this\u0027\n         newChildQueue.setParent(this);\n         \n         // Save in list of current child queues\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         \n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(\n      CSQueue newlyParsedQueue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(newlyParsedQueue instanceof ParentQueue) ||\n        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + newlyParsedQueue.getQueuePath());\n    }\n\n    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        newlyParsedParentQueue.capacity, \n        newlyParsedParentQueue.absoluteCapacity,\n        newlyParsedParentQueue.maximumCapacity, \n        newlyParsedParentQueue.absoluteMaxCapacity,\n        newlyParsedParentQueue.state, \n        newlyParsedParentQueue.acls,\n        newlyParsedParentQueue.reservationsContinueLooking);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n        getQueues(newlyParsedParentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      \n      // Check if the child-queue already exists\n      if (childQueue !\u003d null) {\n        // Re-init existing child queues\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        // New child queue, do not re-init\n        \n        // Set parent to \u0027this\u0027\n        newChildQueue.setParent(this);\n        \n        // Save in list of current child queues\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        \n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "cc523683cfa76c1255667a3aedc48b08e5daabc7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-177. CapacityScheduler - adding a queue while the RM is running has wacky results (acmurthy vai tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1401668 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/10/12 6:21 AM",
      "commitName": "cc523683cfa76c1255667a3aedc48b08e5daabc7",
      "commitAuthor": "Thomas Graves",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-177. CapacityScheduler - adding a queue while the RM is running has wacky results (acmurthy vai tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1401668 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/10/12 6:21 AM",
          "commitName": "cc523683cfa76c1255667a3aedc48b08e5daabc7",
          "commitAuthor": "Thomas Graves",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 77.33,
          "commitsBetweenForRepo": 488,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,54 @@\n-  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n+  public synchronized void reinitialize(\n+      CSQueue newlyParsedQueue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n-    if (!(queue instanceof ParentQueue) ||\n-        !queue.getQueuePath().equals(getQueuePath())) {\n+    if (!(newlyParsedQueue instanceof ParentQueue) ||\n+        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n-          \" from \" + queue.getQueuePath());\n+          \" from \" + newlyParsedQueue.getQueuePath());\n     }\n \n-    ParentQueue parentQueue \u003d (ParentQueue)queue;\n+    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n \n     // Set new configs\n     setupQueueConfigs(clusterResource,\n-        parentQueue.capacity, parentQueue.absoluteCapacity,\n-        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n-        parentQueue.state, parentQueue.acls);\n+        newlyParsedParentQueue.capacity, \n+        newlyParsedParentQueue.absoluteCapacity,\n+        newlyParsedParentQueue.maximumCapacity, \n+        newlyParsedParentQueue.absoluteMaxCapacity,\n+        newlyParsedParentQueue.state, \n+        newlyParsedParentQueue.acls);\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n-    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n+    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n+        getQueues(newlyParsedParentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n-      if (childQueue !\u003d null){\n+      \n+      // Check if the child-queue already exists\n+      if (childQueue !\u003d null) {\n+        // Re-init existing child queues\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n+        // New child queue, do not re-init\n+        \n+        // Set parent to \u0027this\u0027\n+        newChildQueue.setParent(this);\n+        \n+        // Save in list of current child queues\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n+        \n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reinitialize(\n      CSQueue newlyParsedQueue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(newlyParsedQueue instanceof ParentQueue) ||\n        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + newlyParsedQueue.getQueuePath());\n    }\n\n    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        newlyParsedParentQueue.capacity, \n        newlyParsedParentQueue.absoluteCapacity,\n        newlyParsedParentQueue.maximumCapacity, \n        newlyParsedParentQueue.absoluteMaxCapacity,\n        newlyParsedParentQueue.state, \n        newlyParsedParentQueue.acls);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n        getQueues(newlyParsedParentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      \n      // Check if the child-queue already exists\n      if (childQueue !\u003d null) {\n        // Re-init existing child queues\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        // New child queue, do not re-init\n        \n        // Set parent to \u0027this\u0027\n        newChildQueue.setParent(this);\n        \n        // Save in list of current child queues\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        \n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[queue-CSQueue, clusterResource-Resource]",
            "newValue": "[newlyParsedQueue-CSQueue, clusterResource-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-177. CapacityScheduler - adding a queue while the RM is running has wacky results (acmurthy vai tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1401668 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/10/12 6:21 AM",
          "commitName": "cc523683cfa76c1255667a3aedc48b08e5daabc7",
          "commitAuthor": "Thomas Graves",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 77.33,
          "commitsBetweenForRepo": 488,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,54 @@\n-  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n+  public synchronized void reinitialize(\n+      CSQueue newlyParsedQueue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n-    if (!(queue instanceof ParentQueue) ||\n-        !queue.getQueuePath().equals(getQueuePath())) {\n+    if (!(newlyParsedQueue instanceof ParentQueue) ||\n+        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n-          \" from \" + queue.getQueuePath());\n+          \" from \" + newlyParsedQueue.getQueuePath());\n     }\n \n-    ParentQueue parentQueue \u003d (ParentQueue)queue;\n+    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n \n     // Set new configs\n     setupQueueConfigs(clusterResource,\n-        parentQueue.capacity, parentQueue.absoluteCapacity,\n-        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n-        parentQueue.state, parentQueue.acls);\n+        newlyParsedParentQueue.capacity, \n+        newlyParsedParentQueue.absoluteCapacity,\n+        newlyParsedParentQueue.maximumCapacity, \n+        newlyParsedParentQueue.absoluteMaxCapacity,\n+        newlyParsedParentQueue.state, \n+        newlyParsedParentQueue.acls);\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n-    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n+    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n+        getQueues(newlyParsedParentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n-      if (childQueue !\u003d null){\n+      \n+      // Check if the child-queue already exists\n+      if (childQueue !\u003d null) {\n+        // Re-init existing child queues\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n+        // New child queue, do not re-init\n+        \n+        // Set parent to \u0027this\u0027\n+        newChildQueue.setParent(this);\n+        \n+        // Save in list of current child queues\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n+        \n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reinitialize(\n      CSQueue newlyParsedQueue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(newlyParsedQueue instanceof ParentQueue) ||\n        !newlyParsedQueue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + newlyParsedQueue.getQueuePath());\n    }\n\n    ParentQueue newlyParsedParentQueue \u003d (ParentQueue)newlyParsedQueue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        newlyParsedParentQueue.capacity, \n        newlyParsedParentQueue.absoluteCapacity,\n        newlyParsedParentQueue.maximumCapacity, \n        newlyParsedParentQueue.absoluteMaxCapacity,\n        newlyParsedParentQueue.state, \n        newlyParsedParentQueue.acls);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d \n        getQueues(newlyParsedParentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      \n      // Check if the child-queue already exists\n      if (childQueue !\u003d null) {\n        // Re-init existing child queues\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        // New child queue, do not re-init\n        \n        // Set parent to \u0027this\u0027\n        newChildQueue.setParent(this);\n        \n        // Save in list of current child queues\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        \n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
      }
    },
    "59b88655bc15535d7bf765987cb9b82f17e16b80": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3833. Fixed a bug in reinitiaziling of queues. Contributed by Jason Lowe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1241659 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/12 2:08 PM",
      "commitName": "59b88655bc15535d7bf765987cb9b82f17e16b80",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "05/02/12 7:38 PM",
      "commitNameOld": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n     if (!(queue instanceof ParentQueue) ||\n         !queue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + queue.getQueuePath());\n     }\n \n     ParentQueue parentQueue \u003d (ParentQueue)queue;\n \n+    // Set new configs\n+    setupQueueConfigs(clusterResource,\n+        parentQueue.capacity, parentQueue.absoluteCapacity,\n+        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n+        parentQueue.state, parentQueue.acls);\n+\n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n     Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       if (childQueue !\u003d null){\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n-\n-    // Set new configs\n-    setupQueueConfigs(clusterResource,\n-        parentQueue.capacity, parentQueue.absoluteCapacity,\n-        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n-        parentQueue.state, parentQueue.acls);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3747. Initialize queue metrics upfront and added start/finish time to RM Web-UI. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240886 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/02/12 7:38 PM",
      "commitName": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/01/12 5:32 PM",
      "commitNameOld": "5262b7ba4d018562d4e7d60772af4ddc3d770a23",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 9.09,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,39 @@\n   public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n     if (!(queue instanceof ParentQueue) ||\n         !queue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + queue.getQueuePath());\n     }\n \n     ParentQueue parentQueue \u003d (ParentQueue)queue;\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n     Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n     Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n     for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n       CSQueue newChildQueue \u003d e.getValue();\n \n       CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       if (childQueue !\u003d null){\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n \n     // Set new configs\n-    setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n+    setupQueueConfigs(clusterResource,\n+        parentQueue.capacity, parentQueue.absoluteCapacity,\n         parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n         parentQueue.state, parentQueue.acls);\n-\n-    // Update\n-    updateResource(clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n\n    // Set new configs\n    setupQueueConfigs(clusterResource,\n        parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "1f46b991da9b91585608a0babd3eda39485dce09": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 11:26 AM",
      "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/09/11 11:26 AM",
          "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "05/09/11 12:49 PM",
          "commitNameOld": "6b608aad7d52b524fa94955a538e8b3524d42d93",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 2.94,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n-  public synchronized void reinitialize(Queue queue, Resource clusterResource)\n+  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n     if (!(queue instanceof ParentQueue) ||\n         !queue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + queue.getQueuePath());\n     }\n \n     ParentQueue parentQueue \u003d (ParentQueue)queue;\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n-    Map\u003cString, Queue\u003e currentChildQueues \u003d getQueues(childQueues);\n-    Map\u003cString, Queue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n-    for (Map.Entry\u003cString, Queue\u003e e : newChildQueues.entrySet()) {\n+    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n+    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n+    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n-      Queue newChildQueue \u003d e.getValue();\n+      CSQueue newChildQueue \u003d e.getValue();\n \n-      Queue childQueue \u003d currentChildQueues.get(newChildQueueName);\n+      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       if (childQueue !\u003d null){\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n \n     // Set new configs\n     setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n         parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n         parentQueue.state, parentQueue.acls);\n \n     // Update\n     updateResource(clusterResource);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n\n    // Set new configs\n    setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n\n    // Update\n    updateResource(clusterResource);\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[queue-Queue, clusterResource-Resource]",
            "newValue": "[queue-CSQueue, clusterResource-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/09/11 11:26 AM",
          "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "05/09/11 12:49 PM",
          "commitNameOld": "6b608aad7d52b524fa94955a538e8b3524d42d93",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 2.94,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n-  public synchronized void reinitialize(Queue queue, Resource clusterResource)\n+  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n   throws IOException {\n     // Sanity check\n     if (!(queue instanceof ParentQueue) ||\n         !queue.getQueuePath().equals(getQueuePath())) {\n       throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n           \" from \" + queue.getQueuePath());\n     }\n \n     ParentQueue parentQueue \u003d (ParentQueue)queue;\n \n     // Re-configure existing child queues and add new ones\n     // The CS has already checked to ensure all existing child queues are present!\n-    Map\u003cString, Queue\u003e currentChildQueues \u003d getQueues(childQueues);\n-    Map\u003cString, Queue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n-    for (Map.Entry\u003cString, Queue\u003e e : newChildQueues.entrySet()) {\n+    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n+    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n+    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n       String newChildQueueName \u003d e.getKey();\n-      Queue newChildQueue \u003d e.getValue();\n+      CSQueue newChildQueue \u003d e.getValue();\n \n-      Queue childQueue \u003d currentChildQueues.get(newChildQueueName);\n+      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n       if (childQueue !\u003d null){\n         childQueue.reinitialize(newChildQueue, clusterResource);\n         LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n       } else {\n         currentChildQueues.put(newChildQueueName, newChildQueue);\n         LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n       }\n     }\n \n     // Re-sort all queues\n     childQueues.clear();\n     childQueues.addAll(currentChildQueues.values());\n \n     // Set new configs\n     setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n         parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n         parentQueue.state, parentQueue.acls);\n \n     // Update\n     updateResource(clusterResource);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reinitialize(CSQueue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, CSQueue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, CSQueue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, CSQueue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      CSQueue newChildQueue \u003d e.getValue();\n\n      CSQueue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n\n    // Set new configs\n    setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n\n    // Update\n    updateResource(clusterResource);\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized void reinitialize(Queue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, Queue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, Queue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, Queue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      Queue newChildQueue \u003d e.getValue();\n\n      Queue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n\n    // Set new configs\n    setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n\n    // Update\n    updateResource(clusterResource);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,41 @@\n+  public synchronized void reinitialize(Queue queue, Resource clusterResource)\n+  throws IOException {\n+    // Sanity check\n+    if (!(queue instanceof ParentQueue) ||\n+        !queue.getQueuePath().equals(getQueuePath())) {\n+      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n+          \" from \" + queue.getQueuePath());\n+    }\n+\n+    ParentQueue parentQueue \u003d (ParentQueue)queue;\n+\n+    // Re-configure existing child queues and add new ones\n+    // The CS has already checked to ensure all existing child queues are present!\n+    Map\u003cString, Queue\u003e currentChildQueues \u003d getQueues(childQueues);\n+    Map\u003cString, Queue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n+    for (Map.Entry\u003cString, Queue\u003e e : newChildQueues.entrySet()) {\n+      String newChildQueueName \u003d e.getKey();\n+      Queue newChildQueue \u003d e.getValue();\n+\n+      Queue childQueue \u003d currentChildQueues.get(newChildQueueName);\n+      if (childQueue !\u003d null){\n+        childQueue.reinitialize(newChildQueue, clusterResource);\n+        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n+      } else {\n+        currentChildQueues.put(newChildQueueName, newChildQueue);\n+        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n+      }\n+    }\n+\n+    // Re-sort all queues\n+    childQueues.clear();\n+    childQueues.addAll(currentChildQueues.values());\n+\n+    // Set new configs\n+    setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n+        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n+        parentQueue.state, parentQueue.acls);\n+\n+    // Update\n+    updateResource(clusterResource);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Queue queue, Resource clusterResource)\n  throws IOException {\n    // Sanity check\n    if (!(queue instanceof ParentQueue) ||\n        !queue.getQueuePath().equals(getQueuePath())) {\n      throw new IOException(\"Trying to reinitialize \" + getQueuePath() +\n          \" from \" + queue.getQueuePath());\n    }\n\n    ParentQueue parentQueue \u003d (ParentQueue)queue;\n\n    // Re-configure existing child queues and add new ones\n    // The CS has already checked to ensure all existing child queues are present!\n    Map\u003cString, Queue\u003e currentChildQueues \u003d getQueues(childQueues);\n    Map\u003cString, Queue\u003e newChildQueues \u003d getQueues(parentQueue.childQueues);\n    for (Map.Entry\u003cString, Queue\u003e e : newChildQueues.entrySet()) {\n      String newChildQueueName \u003d e.getKey();\n      Queue newChildQueue \u003d e.getValue();\n\n      Queue childQueue \u003d currentChildQueues.get(newChildQueueName);\n      if (childQueue !\u003d null){\n        childQueue.reinitialize(newChildQueue, clusterResource);\n        LOG.info(getQueueName() + \": re-configured queue: \" + childQueue);\n      } else {\n        currentChildQueues.put(newChildQueueName, newChildQueue);\n        LOG.info(getQueueName() + \": added new child queue: \" + newChildQueue);\n      }\n    }\n\n    // Re-sort all queues\n    childQueues.clear();\n    childQueues.addAll(currentChildQueues.values());\n\n    // Set new configs\n    setupQueueConfigs(parentQueue.capacity, parentQueue.absoluteCapacity,\n        parentQueue.maximumCapacity, parentQueue.absoluteMaxCapacity,\n        parentQueue.state, parentQueue.acls);\n\n    // Update\n    updateResource(clusterResource);\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
    }
  }
}