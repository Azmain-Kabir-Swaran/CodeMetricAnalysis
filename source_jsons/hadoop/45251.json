{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientImpl.java",
  "functionName": "allocate",
  "functionId": "allocate___progressIndicator-float",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
  "functionStartLine": 271,
  "functionEndLine": 437,
  "numCommitsSeen": 69,
  "timeTaken": 6671,
  "changeHistory": [
    "3e06a5dcea8224ba71aec284df23b47d536bb06d",
    "3159bffce23abf35754da2d7d51de7d8c2631ae3",
    "29d9e4d5814900d5c59d77fe05d32186d4ad9385",
    "aaf106fde35ec97e2e2ea4d7a67434038c4273ac",
    "ede1a473f5061cf40f6affc1c8c30a645c1fef6c",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661",
    "19c743c1bbcaf3df8f1d63e557143c960a538c42",
    "51432779588fdd741b4840601f5db637ec783d92",
    "7ff280fca9af45b98cee2336e78803da46b0f8a5",
    "d468c9aaf15e977f12e6214b47996412c907e069",
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
    "ca3381de61ff53604d9389694049a1a4dedc7571",
    "0f3b6900be1a3b2e4624f31f84656f4a32dadce9",
    "a5ec3d080978a67837946a991843a081ea712539",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
    "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574",
    "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc",
    "bafd302208fbbbf1f2dccfc969a71d862cc8ce67",
    "ac914f79bc80b152e71e7de5497b73f22824f4a7",
    "1fe8e2d7eed74453cfe172853881fafc360a10b6",
    "fe735f237c735a375d2bd194ed80ef9949fb1a68",
    "2adee634269588b85c351e8a3bd2c0c26ad2ba1b",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
    "769a0bd8314cd7317c083a9b74abf47242acb58c",
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
    "1bd345d6e3855ab330963efd32e0fac102e61d1a",
    "0a61990855c23ebfa065145fa01084e84781b51c"
  ],
  "changeHistoryShort": {
    "3e06a5dcea8224ba71aec284df23b47d536bb06d": "Ybodychange",
    "3159bffce23abf35754da2d7d51de7d8c2631ae3": "Ybodychange",
    "29d9e4d5814900d5c59d77fe05d32186d4ad9385": "Ybodychange",
    "aaf106fde35ec97e2e2ea4d7a67434038c4273ac": "Ybodychange",
    "ede1a473f5061cf40f6affc1c8c30a645c1fef6c": "Ybodychange",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": "Ybodychange",
    "19c743c1bbcaf3df8f1d63e557143c960a538c42": "Ybodychange",
    "51432779588fdd741b4840601f5db637ec783d92": "Ybodychange",
    "7ff280fca9af45b98cee2336e78803da46b0f8a5": "Ybodychange",
    "d468c9aaf15e977f12e6214b47996412c907e069": "Ybodychange",
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488": "Ybodychange",
    "ca3381de61ff53604d9389694049a1a4dedc7571": "Ybodychange",
    "0f3b6900be1a3b2e4624f31f84656f4a32dadce9": "Ybodychange",
    "a5ec3d080978a67837946a991843a081ea712539": "Ybodychange",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": "Ybodychange",
    "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574": "Ybodychange",
    "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc": "Ybodychange",
    "bafd302208fbbbf1f2dccfc969a71d862cc8ce67": "Ybodychange",
    "ac914f79bc80b152e71e7de5497b73f22824f4a7": "Ybodychange",
    "1fe8e2d7eed74453cfe172853881fafc360a10b6": "Ybodychange",
    "fe735f237c735a375d2bd194ed80ef9949fb1a68": "Ybodychange",
    "2adee634269588b85c351e8a3bd2c0c26ad2ba1b": "Ybodychange",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": "Yfilerename",
    "769a0bd8314cd7317c083a9b74abf47242acb58c": "Ybodychange",
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "d33534c4fb35cb82ff8d56abeeb63a949e72a031": "Ybodychange",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": "Yexceptionschange",
    "1bd345d6e3855ab330963efd32e0fac102e61d1a": "Ybodychange",
    "0a61990855c23ebfa065145fa01084e84781b51c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3e06a5dcea8224ba71aec284df23b47d536bb06d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7974. Allow updating application tracking url after registration. Contributed by Jonathan Hung\n",
      "commitDate": "30/07/18 5:44 PM",
      "commitName": "3e06a5dcea8224ba71aec284df23b47d536bb06d",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "21/06/18 6:24 PM",
      "commitNameOld": "99948565cb5d5706241d7a8fc591e1617c499e03",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 38.97,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,167 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     List\u003cSchedulingRequest\u003e schedulingRequestList \u003d new LinkedList\u003c\u003e();\n \n     try {\n       synchronized (this) {\n         askList \u003d cloneAsks();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         schedulingRequestList \u003d new ArrayList\u003c\u003e(schedulingRequests);\n \n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n         schedulingRequests.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(lastResponseId).progress(progressIndicator)\n             .askList(askList).resourceBlacklistRequest(blacklistRequest)\n             .releaseList(releaseList).updateRequests(updateList)\n             .schedulingRequests(schedulingRequestList).build();\n \n+        if (this.newTrackingUrl !\u003d null) {\n+          allocateRequest.setTrackingUrl(this.newTrackingUrl);\n+          this.appTrackingUrl \u003d this.newTrackingUrl;\n+          this.newTrackingUrl \u003d null;\n+        }\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (RemoteRequestsTable remoteRequestsTable :\n               remoteRequests.values()) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                 remoteRequestsTable.iterator();\n             while (reqIter.hasNext()) {\n               addResourceRequestToAsk(reqIter.next().remoteRequest);\n             }\n           }\n           change.putAll(this.pendingChange);\n           for (List\u003cSchedulingRequest\u003e schedReqs :\n               this.outstandingSchedRequests.values()) {\n             this.schedulingRequests.addAll(schedReqs);\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getUpdatedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getAllocatedContainers(),\n             this.outstandingSchedRequests);\n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getContainersFromPreviousAttempts(),\n             this.outstandingSchedRequests);\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId,\n               SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n \n           schedulingRequests.addAll(schedulingRequestList);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    List\u003cSchedulingRequest\u003e schedulingRequestList \u003d new LinkedList\u003c\u003e();\n\n    try {\n      synchronized (this) {\n        askList \u003d cloneAsks();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        schedulingRequestList \u003d new ArrayList\u003c\u003e(schedulingRequests);\n\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n        schedulingRequests.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(lastResponseId).progress(progressIndicator)\n            .askList(askList).resourceBlacklistRequest(blacklistRequest)\n            .releaseList(releaseList).updateRequests(updateList)\n            .schedulingRequests(schedulingRequestList).build();\n\n        if (this.newTrackingUrl !\u003d null) {\n          allocateRequest.setTrackingUrl(this.newTrackingUrl);\n          this.appTrackingUrl \u003d this.newTrackingUrl;\n          this.newTrackingUrl \u003d null;\n        }\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n          for (List\u003cSchedulingRequest\u003e schedReqs :\n              this.outstandingSchedRequests.values()) {\n            this.schedulingRequests.addAll(schedReqs);\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getUpdatedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers(),\n            this.outstandingSchedRequests);\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts(),\n            this.outstandingSchedRequests);\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId,\n              SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n\n          schedulingRequests.addAll(schedulingRequestList);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "3159bffce23abf35754da2d7d51de7d8c2631ae3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7900. [AMRMProxy] AMRMClientRelayer for stateful FederationInterceptor. (Botong Huang via asuresh)\n",
      "commitDate": "17/05/18 8:00 PM",
      "commitName": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "27/04/18 1:07 PM",
      "commitNameOld": "b1833d9ba2c078582161da45ac392dd5c361dcdf",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 20.29,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,162 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n+    List\u003cSchedulingRequest\u003e schedulingRequestList \u003d new LinkedList\u003c\u003e();\n+\n     try {\n       synchronized (this) {\n         askList \u003d cloneAsks();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n+        schedulingRequestList \u003d new ArrayList\u003c\u003e(schedulingRequests);\n+\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n+        schedulingRequests.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(lastResponseId).progress(progressIndicator)\n             .askList(askList).resourceBlacklistRequest(blacklistRequest)\n-            .releaseList(releaseList).updateRequests(updateList).build();\n-        populateSchedulingRequests(allocateRequest);\n+            .releaseList(releaseList).updateRequests(updateList)\n+            .schedulingRequests(schedulingRequestList).build();\n+\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n-        removeFromOutstandingSchedulingRequests(\n-            allocateResponse.getAllocatedContainers());\n-        removeFromOutstandingSchedulingRequests(\n-            allocateResponse.getContainersFromPreviousAttempts());\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (RemoteRequestsTable remoteRequestsTable :\n               remoteRequests.values()) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                 remoteRequestsTable.iterator();\n             while (reqIter.hasNext()) {\n               addResourceRequestToAsk(reqIter.next().remoteRequest);\n             }\n           }\n           change.putAll(this.pendingChange);\n+          for (List\u003cSchedulingRequest\u003e schedReqs :\n+              this.outstandingSchedRequests.values()) {\n+            this.schedulingRequests.addAll(schedReqs);\n+          }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getUpdatedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n+        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n+            allocateResponse.getAllocatedContainers(),\n+            this.outstandingSchedRequests);\n+        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n+            allocateResponse.getContainersFromPreviousAttempts(),\n+            this.outstandingSchedRequests);\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId,\n               SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n+\n+          schedulingRequests.addAll(schedulingRequestList);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    List\u003cSchedulingRequest\u003e schedulingRequestList \u003d new LinkedList\u003c\u003e();\n\n    try {\n      synchronized (this) {\n        askList \u003d cloneAsks();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        schedulingRequestList \u003d new ArrayList\u003c\u003e(schedulingRequests);\n\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n        schedulingRequests.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(lastResponseId).progress(progressIndicator)\n            .askList(askList).resourceBlacklistRequest(blacklistRequest)\n            .releaseList(releaseList).updateRequests(updateList)\n            .schedulingRequests(schedulingRequestList).build();\n\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n          for (List\u003cSchedulingRequest\u003e schedReqs :\n              this.outstandingSchedRequests.values()) {\n            this.schedulingRequests.addAll(schedReqs);\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getUpdatedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers(),\n            this.outstandingSchedRequests);\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts(),\n            this.outstandingSchedRequests);\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId,\n              SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n\n          schedulingRequests.addAll(schedulingRequestList);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "29d9e4d5814900d5c59d77fe05d32186d4ad9385": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6619. AMRMClient Changes to use the PlacementConstraint and SchcedulingRequest objects. (Arun Suresh via wangda)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "29d9e4d5814900d5c59d77fe05d32186d4ad9385",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/10/17 1:09 AM",
      "commitNameOld": "c02d2ba50db8a355ea03081c3984b2ea0c375a3f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 92.06,
      "commitsBetweenForRepo": 618,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,148 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n         askList \u003d cloneAsks();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(lastResponseId).progress(progressIndicator)\n             .askList(askList).resourceBlacklistRequest(blacklistRequest)\n             .releaseList(releaseList).updateRequests(updateList).build();\n+        populateSchedulingRequests(allocateRequest);\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n+        removeFromOutstandingSchedulingRequests(\n+            allocateResponse.getAllocatedContainers());\n+        removeFromOutstandingSchedulingRequests(\n+            allocateResponse.getContainersFromPreviousAttempts());\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (RemoteRequestsTable remoteRequestsTable :\n               remoteRequests.values()) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                 remoteRequestsTable.iterator();\n             while (reqIter.hasNext()) {\n               addResourceRequestToAsk(reqIter.next().remoteRequest);\n             }\n           }\n           change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getUpdatedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId,\n               SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d cloneAsks();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(lastResponseId).progress(progressIndicator)\n            .askList(askList).resourceBlacklistRequest(blacklistRequest)\n            .releaseList(releaseList).updateRequests(updateList).build();\n        populateSchedulingRequests(allocateRequest);\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n        removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers());\n        removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts());\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getUpdatedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId,\n              SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "aaf106fde35ec97e2e2ea4d7a67434038c4273ac": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5966. AMRMClient changes to support ExecutionType update. (asuresh)\n",
      "commitDate": "14/02/17 6:09 AM",
      "commitName": "aaf106fde35ec97e2e2ea4d7a67434038c4273ac",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "11/11/16 1:34 PM",
      "commitNameOld": "ede1a473f5061cf40f6affc1c8c30a645c1fef6c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 94.69,
      "commitsBetweenForRepo": 465,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,143 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n-    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n+    Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n         askList \u003d cloneAsks();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(lastResponseId).progress(progressIndicator)\n             .askList(askList).resourceBlacklistRequest(blacklistRequest)\n             .releaseList(releaseList).updateRequests(updateList).build();\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (RemoteRequestsTable remoteRequestsTable :\n               remoteRequests.values()) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                 remoteRequestsTable.iterator();\n             while (reqIter.hasNext()) {\n               addResourceRequestToAsk(reqIter.next().remoteRequest);\n             }\n           }\n           change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getUpdatedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n-          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n+          for (Map.Entry\u003cContainerId,\n+              SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n-            Resource oldResource \u003d entry.getValue().getValue();\n+            UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n-                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n+                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d cloneAsks();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(lastResponseId).progress(progressIndicator)\n            .askList(askList).resourceBlacklistRequest(blacklistRequest)\n            .releaseList(releaseList).updateRequests(updateList).build();\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getUpdatedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId,\n              SimpleEntry\u003cContainer, UpdateContainerRequest\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            UpdateContainerRequest oldupdate \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldupdate));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "ede1a473f5061cf40f6affc1c8c30a645c1fef6c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5552. Add Builder methods for common yarn API records. (Tao Jie via wangda)\n",
      "commitDate": "11/11/16 1:34 PM",
      "commitName": "ede1a473f5061cf40f6affc1c8c30a645c1fef6c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "25/10/16 11:59 PM",
      "commitNameOld": "44fdf009642ae4e99b15f89ec0ca43834f991ef3",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 16.61,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,142 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n         askList \u003d cloneAsks();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n-        \n-        allocateRequest \u003d\n-            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n-                askList, releaseList, blacklistRequest, updateList);\n+\n+        allocateRequest \u003d AllocateRequest.newBuilder()\n+            .responseId(lastResponseId).progress(progressIndicator)\n+            .askList(askList).resourceBlacklistRequest(blacklistRequest)\n+            .releaseList(releaseList).updateRequests(updateList).build();\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (RemoteRequestsTable remoteRequestsTable :\n               remoteRequests.values()) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                 remoteRequestsTable.iterator();\n             while (reqIter.hasNext()) {\n               addResourceRequestToAsk(reqIter.next().remoteRequest);\n             }\n           }\n           change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getUpdatedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             Resource oldResource \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d cloneAsks();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(lastResponseId).progress(progressIndicator)\n            .askList(askList).resourceBlacklistRequest(blacklistRequest)\n            .releaseList(releaseList).updateRequests(updateList).build();\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getUpdatedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            Resource oldResource \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5221. Expose UpdateResourceRequest API to allow AM to request for change in container properties. (asuresh)\n",
      "commitDate": "30/08/16 3:52 PM",
      "commitName": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "26/08/16 5:14 PM",
      "commitNameOld": "19c743c1bbcaf3df8f1d63e557143c960a538c42",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.94,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,141 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n-        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n-        for(ResourceRequest r : ask) {\n-          // create a copy of ResourceRequest as we might change it while the \n-          // RPC layer is using it to send info across\n-          ResourceRequest rr \u003d ResourceRequest.newInstance(r.getPriority(),\n-              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n-              r.getRelaxLocality(), r.getNodeLabelExpression(),\n-              r.getExecutionTypeRequest());\n-          rr.setAllocationRequestId(r.getAllocationRequestId());\n-          askList.add(rr);\n-        }\n-        List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n-        List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n+        askList \u003d cloneAsks();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n-        for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n-            change.entrySet()) {\n-          Container container \u003d entry.getValue().getKey();\n-          Resource original \u003d container.getResource();\n-          Resource target \u003d entry.getValue().getValue();\n-          if (Resources.fitsIn(target, original)) {\n-            // This is a decrease request\n-            decreaseList.add(ContainerResourceChangeRequest.newInstance(\n-                container.getId(), target));\n-          } else {\n-            // This is an increase request\n-            increaseList.add(ContainerResourceChangeRequest.newInstance(\n-                container.getId(), target));\n-          }\n-        }\n+        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n-                askList, releaseList, blacklistRequest,\n-                    increaseList, decreaseList);\n+                askList, releaseList, blacklistRequest, updateList);\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (RemoteRequestsTable remoteRequestsTable :\n               remoteRequests.values()) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                 remoteRequestsTable.iterator();\n             while (reqIter.hasNext()) {\n               addResourceRequestToAsk(reqIter.next().remoteRequest);\n             }\n           }\n           change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n-          List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n-          changed.addAll(allocateResponse.getIncreasedContainers());\n-          changed.addAll(allocateResponse.getDecreasedContainers());\n+          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n+          changed.addAll(allocateResponse.getUpdatedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             Resource oldResource \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d cloneAsks();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        List\u003cUpdateContainerRequest\u003e updateList \u003d createUpdateList();\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n                askList, releaseList, blacklistRequest, updateList);\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getUpdatedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            Resource oldResource \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "19c743c1bbcaf3df8f1d63e557143c960a538c42": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4889. Changes in AMRMClient for identifying resource-requests explicitly. (Arun Suresh via wangda)\n",
      "commitDate": "26/08/16 5:14 PM",
      "commitName": "19c743c1bbcaf3df8f1d63e557143c960a538c42",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/06/16 9:42 AM",
      "commitNameOld": "51432779588fdd741b4840601f5db637ec783d92",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 75.31,
      "commitsBetweenForRepo": 650,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,169 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n-          askList.add(ResourceRequest.newInstance(r.getPriority(),\n+          ResourceRequest rr \u003d ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality(), r.getNodeLabelExpression(),\n-              r.getExecutionTypeRequest()));\n+              r.getExecutionTypeRequest());\n+          rr.setAllocationRequestId(r.getAllocationRequestId());\n+          askList.add(rr);\n         }\n         List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n         List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n             change.entrySet()) {\n           Container container \u003d entry.getValue().getKey();\n           Resource original \u003d container.getResource();\n           Resource target \u003d entry.getValue().getValue();\n           if (Resources.fitsIn(target, original)) {\n             // This is a decrease request\n             decreaseList.add(ContainerResourceChangeRequest.newInstance(\n                 container.getId(), target));\n           } else {\n             // This is an increase request\n             increaseList.add(ContainerResourceChangeRequest.newInstance(\n                 container.getId(), target));\n           }\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n                 askList, releaseList, blacklistRequest,\n                     increaseList, decreaseList);\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n-          @SuppressWarnings(\"unchecked\")\n-          Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n-              remoteRequestsTable.iterator();\n-          while (reqIter.hasNext()) {\n-            addResourceRequestToAsk(reqIter.next().remoteRequest);\n+          for (RemoteRequestsTable remoteRequestsTable :\n+              remoteRequests.values()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n+                remoteRequestsTable.iterator();\n+            while (reqIter.hasNext()) {\n+              addResourceRequestToAsk(reqIter.next().remoteRequest);\n+            }\n           }\n           change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getIncreasedContainers());\n           changed.addAll(allocateResponse.getDecreasedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             Resource oldResource \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          ResourceRequest rr \u003d ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression(),\n              r.getExecutionTypeRequest());\n          rr.setAllocationRequestId(r.getAllocationRequestId());\n          askList.add(rr);\n        }\n        List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n        List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n            change.entrySet()) {\n          Container container \u003d entry.getValue().getKey();\n          Resource original \u003d container.getResource();\n          Resource target \u003d entry.getValue().getValue();\n          if (Resources.fitsIn(target, original)) {\n            // This is a decrease request\n            decreaseList.add(ContainerResourceChangeRequest.newInstance(\n                container.getId(), target));\n          } else {\n            // This is an increase request\n            increaseList.add(ContainerResourceChangeRequest.newInstance(\n                container.getId(), target));\n          }\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n                askList, releaseList, blacklistRequest,\n                    increaseList, decreaseList);\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (RemoteRequestsTable remoteRequestsTable :\n              remoteRequests.values()) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n                remoteRequestsTable.iterator();\n            while (reqIter.hasNext()) {\n              addResourceRequestToAsk(reqIter.next().remoteRequest);\n            }\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getIncreasedContainers());\n          changed.addAll(allocateResponse.getDecreasedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            Resource oldResource \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "51432779588fdd741b4840601f5db637ec783d92": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5124. Modify AMRMClient to set the ExecutionType in the ResourceRequest. (asuresh)\n",
      "commitDate": "12/06/16 9:42 AM",
      "commitName": "51432779588fdd741b4840601f5db637ec783d92",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 14.03,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,165 +1,164 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n         new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n-              r.getRelaxLocality(), r.getNodeLabelExpression()));\n+              r.getRelaxLocality(), r.getNodeLabelExpression(),\n+              r.getExecutionTypeRequest()));\n         }\n         List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n         List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n         // Save the current change for recovery\n         oldChange.putAll(change);\n         for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n             change.entrySet()) {\n           Container container \u003d entry.getValue().getKey();\n           Resource original \u003d container.getResource();\n           Resource target \u003d entry.getValue().getValue();\n           if (Resources.fitsIn(target, original)) {\n             // This is a decrease request\n             decreaseList.add(ContainerResourceChangeRequest.newInstance(\n                 container.getId(), target));\n           } else {\n             // This is an increase request\n             increaseList.add(ContainerResourceChangeRequest.newInstance(\n                 container.getId(), target));\n           }\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n                 askList, releaseList, blacklistRequest,\n                     increaseList, decreaseList);\n         // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n-          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n-            .values()) {\n-            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n-              for (ResourceRequestInfo request : capabalities.values()) {\n-                addResourceRequestToAsk(request.remoteRequest);\n-              }\n-            }\n+          @SuppressWarnings(\"unchecked\")\n+          Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n+              remoteRequestsTable.iterator();\n+          while (reqIter.hasNext()) {\n+            addResourceRequestToAsk(reqIter.next().remoteRequest);\n           }\n           change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n         if (!pendingChange.isEmpty()) {\n           List\u003cContainerStatus\u003e completed \u003d\n               allocateResponse.getCompletedContainersStatuses();\n           List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n           changed.addAll(allocateResponse.getIncreasedContainers());\n           changed.addAll(allocateResponse.getDecreasedContainers());\n           // remove all pending change requests that belong to the completed\n           // containers\n           for (ContainerStatus status : completed) {\n             ContainerId containerId \u003d status.getContainerId();\n             pendingChange.remove(containerId);\n           }\n           // remove all pending change requests that have been satisfied\n           if (!changed.isEmpty()) {\n             removePendingChangeRequests(changed);\n           }\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           // change requests could have been added during the allocate call.\n           // Those are the newest requests which take precedence\n           // over requests cached in the oldChange map.\n           //\n           // Only insert entries from the cached oldChange map\n           // that do not exist in the current change map:\n           for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n               oldChange.entrySet()) {\n             ContainerId oldContainerId \u003d entry.getKey();\n             Container oldContainer \u003d entry.getValue().getKey();\n             Resource oldResource \u003d entry.getValue().getValue();\n             if (change.get(oldContainerId) \u003d\u003d null) {\n               change.put(\n                   oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n             }\n           }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression(),\n              r.getExecutionTypeRequest()));\n        }\n        List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n        List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n            change.entrySet()) {\n          Container container \u003d entry.getValue().getKey();\n          Resource original \u003d container.getResource();\n          Resource target \u003d entry.getValue().getValue();\n          if (Resources.fitsIn(target, original)) {\n            // This is a decrease request\n            decreaseList.add(ContainerResourceChangeRequest.newInstance(\n                container.getId(), target));\n          } else {\n            // This is an increase request\n            increaseList.add(ContainerResourceChangeRequest.newInstance(\n                container.getId(), target));\n          }\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n                askList, releaseList, blacklistRequest,\n                    increaseList, decreaseList);\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          @SuppressWarnings(\"unchecked\")\n          Iterator\u003cResourceRequestInfo\u003cT\u003e\u003e reqIter \u003d\n              remoteRequestsTable.iterator();\n          while (reqIter.hasNext()) {\n            addResourceRequestToAsk(reqIter.next().remoteRequest);\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getIncreasedContainers());\n          changed.addAll(allocateResponse.getDecreasedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            Resource oldResource \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "7ff280fca9af45b98cee2336e78803da46b0f8a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1509. Make AMRMClient support send increase container request and get increased/decreased containers. (Meng Ding via wangda)\n",
      "commitDate": "12/11/15 11:50 AM",
      "commitName": "7ff280fca9af45b98cee2336e78803da46b0f8a5",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "21/09/15 8:54 PM",
      "commitNameOld": "dfd807afab0fae3839c9cc5d552aa0304444f956",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 51.66,
      "commitsBetweenForRepo": 425,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,165 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n-    \n+    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n+        new HashMap\u003c\u003e();\n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality(), r.getNodeLabelExpression()));\n         }\n+        List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n+        List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n+        // Save the current change for recovery\n+        oldChange.putAll(change);\n+        for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n+            change.entrySet()) {\n+          Container container \u003d entry.getValue().getKey();\n+          Resource original \u003d container.getResource();\n+          Resource target \u003d entry.getValue().getValue();\n+          if (Resources.fitsIn(target, original)) {\n+            // This is a decrease request\n+            decreaseList.add(ContainerResourceChangeRequest.newInstance(\n+                container.getId(), target));\n+          } else {\n+            // This is an increase request\n+            increaseList.add(ContainerResourceChangeRequest.newInstance(\n+                container.getId(), target));\n+          }\n+        }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n+        change.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove);\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n-              askList, releaseList, blacklistRequest);\n-        // clear blacklistAdditions and blacklistRemovals before \n+                askList, releaseList, blacklistRequest,\n+                    increaseList, decreaseList);\n+        // clear blacklistAdditions and blacklistRemovals before\n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n             .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n+          change.putAll(this.pendingChange);\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n+        if (!pendingChange.isEmpty()) {\n+          List\u003cContainerStatus\u003e completed \u003d\n+              allocateResponse.getCompletedContainersStatuses();\n+          List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n+          changed.addAll(allocateResponse.getIncreasedContainers());\n+          changed.addAll(allocateResponse.getDecreasedContainers());\n+          // remove all pending change requests that belong to the completed\n+          // containers\n+          for (ContainerStatus status : completed) {\n+            ContainerId containerId \u003d status.getContainerId();\n+            pendingChange.remove(containerId);\n+          }\n+          // remove all pending change requests that have been satisfied\n+          if (!changed.isEmpty()) {\n+            removePendingChangeRequests(changed);\n+          }\n+        }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n-          \n+          // change requests could have been added during the allocate call.\n+          // Those are the newest requests which take precedence\n+          // over requests cached in the oldChange map.\n+          //\n+          // Only insert entries from the cached oldChange map\n+          // that do not exist in the current change map:\n+          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n+              oldChange.entrySet()) {\n+            ContainerId oldContainerId \u003d entry.getKey();\n+            Container oldContainer \u003d entry.getValue().getKey();\n+            Resource oldResource \u003d entry.getValue().getValue();\n+            if (change.get(oldContainerId) \u003d\u003d null) {\n+              change.put(\n+                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n+            }\n+          }\n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    Map\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e oldChange \u003d\n        new HashMap\u003c\u003e();\n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression()));\n        }\n        List\u003cContainerResourceChangeRequest\u003e increaseList \u003d new ArrayList\u003c\u003e();\n        List\u003cContainerResourceChangeRequest\u003e decreaseList \u003d new ArrayList\u003c\u003e();\n        // Save the current change for recovery\n        oldChange.putAll(change);\n        for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n            change.entrySet()) {\n          Container container \u003d entry.getValue().getKey();\n          Resource original \u003d container.getResource();\n          Resource target \u003d entry.getValue().getValue();\n          if (Resources.fitsIn(target, original)) {\n            // This is a decrease request\n            decreaseList.add(ContainerResourceChangeRequest.newInstance(\n                container.getId(), target));\n          } else {\n            // This is an increase request\n            increaseList.add(ContainerResourceChangeRequest.newInstance(\n                container.getId(), target));\n          }\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        change.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n                askList, releaseList, blacklistRequest,\n                    increaseList, decreaseList);\n        // clear blacklistAdditions and blacklistRemovals before\n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n            .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n          change.putAll(this.pendingChange);\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n        if (!pendingChange.isEmpty()) {\n          List\u003cContainerStatus\u003e completed \u003d\n              allocateResponse.getCompletedContainersStatuses();\n          List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n          changed.addAll(allocateResponse.getIncreasedContainers());\n          changed.addAll(allocateResponse.getDecreasedContainers());\n          // remove all pending change requests that belong to the completed\n          // containers\n          for (ContainerStatus status : completed) {\n            ContainerId containerId \u003d status.getContainerId();\n            pendingChange.remove(containerId);\n          }\n          // remove all pending change requests that have been satisfied\n          if (!changed.isEmpty()) {\n            removePendingChangeRequests(changed);\n          }\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          // change requests could have been added during the allocate call.\n          // Those are the newest requests which take precedence\n          // over requests cached in the oldChange map.\n          //\n          // Only insert entries from the cached oldChange map\n          // that do not exist in the current change map:\n          for (Map.Entry\u003cContainerId, SimpleEntry\u003cContainer, Resource\u003e\u003e entry :\n              oldChange.entrySet()) {\n            ContainerId oldContainerId \u003d entry.getKey();\n            Container oldContainer \u003d entry.getValue().getKey();\n            Resource oldResource \u003d entry.getValue().getValue();\n            if (change.get(oldContainerId) \u003d\u003d null) {\n              change.put(\n                  oldContainerId, new SimpleEntry\u003c\u003e(oldContainer, oldResource));\n            }\n          }\n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "d468c9aaf15e977f12e6214b47996412c907e069": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2940. Fix new findbugs warnings in rest of the hadoop-yarn components. (Contributed by Li Lu)\n",
      "commitDate": "23/12/14 8:04 PM",
      "commitName": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/12/14 8:02 PM",
      "commitNameOld": "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,110 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality(), r.getNodeLabelExpression()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n-        ResourceBlacklistRequest blacklistRequest \u003d \n-            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n+        ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n-                blacklistToRemove) : null;\n+                blacklistToRemove);\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n             .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n            .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488": {
      "type": "Ybodychange",
      "commitMessage": "Revert ca3381de61ff53604d9389694049a1a4dedc7571 and 20674255ad891bb693ecb2faa5bdb37477073dac as missing JIRA number in commit message\n",
      "commitDate": "23/12/14 8:02 PM",
      "commitName": "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/12/14 6:57 PM",
      "commitNameOld": "ca3381de61ff53604d9389694049a1a4dedc7571",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,111 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality(), r.getNodeLabelExpression()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n-        ResourceBlacklistRequest blacklistRequest \u003d\n+        ResourceBlacklistRequest blacklistRequest \u003d \n+            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n-                blacklistToRemove);\n+                blacklistToRemove) : null;\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n             .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n            .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "ca3381de61ff53604d9389694049a1a4dedc7571": {
      "type": "Ybodychange",
      "commitMessage": "Fix new findbugs warnings in rest of the hadoop-yarn components. (Contributed by Li Lu)\n",
      "commitDate": "23/12/14 6:57 PM",
      "commitName": "ca3381de61ff53604d9389694049a1a4dedc7571",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/10/14 9:56 PM",
      "commitNameOld": "0f3b6900be1a3b2e4624f31f84656f4a32dadce9",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 60.92,
      "commitsBetweenForRepo": 500,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,110 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality(), r.getNodeLabelExpression()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n-        ResourceBlacklistRequest blacklistRequest \u003d \n-            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n+        ResourceBlacklistRequest blacklistRequest \u003d\n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n-                blacklistToRemove) : null;\n+                blacklistToRemove);\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       try {\n         allocateResponse \u003d rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n             .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         allocateResponse \u003d allocate(progressIndicator);\n         return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d\n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove);\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n            .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "0f3b6900be1a3b2e4624f31f84656f4a32dadce9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2209. Replaced AM resync/shutdown command with corresponding exceptions and made related MR changes. Contributed by Jian He.\n",
      "commitDate": "23/10/14 9:56 PM",
      "commitName": "0f3b6900be1a3b2e4624f31f84656f4a32dadce9",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "10/10/14 7:57 PM",
      "commitNameOld": "a5ec3d080978a67837946a991843a081ea712539",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 13.08,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,111 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality(), r.getNodeLabelExpression()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d \n             (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove) : null;\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n-      allocateResponse \u003d rmClient.allocate(allocateRequest);\n-      if (isResyncCommand(allocateResponse)) {\n+      try {\n+        allocateResponse \u003d rmClient.allocate(allocateRequest);\n+      } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n-              .values()) {\n+            .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n-        return allocate(progressIndicator);\n+        allocateResponse \u003d allocate(progressIndicator);\n+        return allocateResponse;\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      try {\n        allocateResponse \u003d rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n            .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        allocateResponse \u003d allocate(progressIndicator);\n        return allocateResponse;\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "a5ec3d080978a67837946a991843a081ea712539": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2501. Enhanced AMRMClient library to support requests against node labels. Contributed by Wangda Tan.\n",
      "commitDate": "10/10/14 7:57 PM",
      "commitName": "a5ec3d080978a67837946a991843a081ea712539",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/09/14 10:16 AM",
      "commitNameOld": "a3d9934f916471a845dc679449d08f94dead550d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 22.4,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n-              r.getRelaxLocality()));\n+              r.getRelaxLocality(), r.getNodeLabelExpression()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d \n             (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove) : null;\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n       if (isResyncCommand(allocateResponse)) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n               .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         return allocate(progressIndicator);\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n         if (allocateResponse.getAMRMToken() !\u003d null) {\n           updateAMRMToken(allocateResponse.getAMRMToken());\n         }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality(), r.getNodeLabelExpression()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n      if (isResyncCommand(allocateResponse)) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n              .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        return allocate(progressIndicator);\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2212: ApplicationMaster needs to find a way to update the AMRMToken periodically. Contributed by Xuan Gong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616892 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 2:38 PM",
      "commitName": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
      "commitAuthor": "Xuan Gong",
      "commitDateOld": "09/07/14 11:25 AM",
      "commitNameOld": "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 30.13,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,109 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d \n             (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove) : null;\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n       if (isResyncCommand(allocateResponse)) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n         synchronized (this) {\n           release.addAll(this.pendingRelease);\n           blacklistAdditions.addAll(this.blacklistedNodes);\n           for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n               .values()) {\n             for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n               for (ResourceRequestInfo request : capabalities.values()) {\n                 addResourceRequestToAsk(request.remoteRequest);\n               }\n             }\n           }\n         }\n         // re register with RM\n         registerApplicationMaster();\n         return allocate(progressIndicator);\n       }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n+        if (allocateResponse.getAMRMToken() !\u003d null) {\n+          updateAMRMToken(allocateResponse.getAMRMToken());\n+        }\n         if (!pendingRelease.isEmpty()\n             \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n           removePendingReleaseRequests(allocateResponse\n               .getCompletedContainersStatuses());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n      if (isResyncCommand(allocateResponse)) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n              .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        return allocate(progressIndicator);\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (allocateResponse.getAMRMToken() !\u003d null) {\n          updateAMRMToken(allocateResponse.getAMRMToken());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1366. Changed AMRMClient to re-register with RM and send outstanding requests back to RM on work-preserving RM restart. Contributed by Rohith\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1609254 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/14 11:25 AM",
      "commitName": "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574",
      "commitAuthor": "Jian He",
      "commitDateOld": "17/03/14 3:22 PM",
      "commitNameOld": "92317e3459b502f33a3575c247f05d64e5d39a00",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 113.84,
      "commitsBetweenForRepo": 699,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,106 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d \n             (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove) : null;\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n+      if (isResyncCommand(allocateResponse)) {\n+        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n+            + \" hence resyncing.\");\n+        synchronized (this) {\n+          release.addAll(this.pendingRelease);\n+          blacklistAdditions.addAll(this.blacklistedNodes);\n+          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n+              .values()) {\n+            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n+              for (ResourceRequestInfo request : capabalities.values()) {\n+                addResourceRequestToAsk(request.remoteRequest);\n+              }\n+            }\n+          }\n+        }\n+        // re register with RM\n+        registerApplicationMaster();\n+        return allocate(progressIndicator);\n+      }\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse.getNMTokens());\n         }\n+        if (!pendingRelease.isEmpty()\n+            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n+          removePendingReleaseRequests(allocateResponse\n+              .getCompletedContainersStatuses());\n+        }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n      if (isResyncCommand(allocateResponse)) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n        synchronized (this) {\n          release.addAll(this.pendingRelease);\n          blacklistAdditions.addAll(this.blacklistedNodes);\n          for (Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e rr : remoteRequestsTable\n              .values()) {\n            for (Map\u003cResource, ResourceRequestInfo\u003e capabalities : rr.values()) {\n              for (ResourceRequestInfo request : capabalities.values()) {\n                addResourceRequestToAsk(request.remoteRequest);\n              }\n            }\n          }\n        }\n        // re register with RM\n        registerApplicationMaster();\n        return allocate(progressIndicator);\n      }\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n        if (!pendingRelease.isEmpty()\n            \u0026\u0026 !allocateResponse.getCompletedContainersStatuses().isEmpty()) {\n          removePendingReleaseRequests(allocateResponse\n              .getCompletedContainersStatuses());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1588. Enhanced RM and the scheduling protocol to also send NMTokens of transferred containers from previous app-attempts to new AMs after YARN-1490. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1572230 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/14 12:20 PM",
      "commitName": "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/10/13 1:45 PM",
      "commitNameOld": "9a204f8c51c6015d15d603bf413e86a15f1cd32b",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 117.98,
      "commitsBetweenForRepo": 745,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     List\u003cResourceRequest\u003e askList \u003d null;\n     List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n     List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n \n         blacklistToAdd.addAll(blacklistAdditions);\n         blacklistToRemove.addAll(blacklistRemovals);\n         \n         ResourceBlacklistRequest blacklistRequest \u003d \n             (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n             ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                 blacklistToRemove) : null;\n         \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n               askList, releaseList, blacklistRequest);\n         // clear blacklistAdditions and blacklistRemovals before \n         // unsynchronized part\n         blacklistAdditions.clear();\n         blacklistRemovals.clear();\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n-          populateNMTokens(allocateResponse);\n+          populateNMTokens(allocateResponse.getNMTokens());\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n           \n           blacklistAdditions.addAll(blacklistToAdd);\n           blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse.getNMTokens());\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "bafd302208fbbbf1f2dccfc969a71d862cc8ce67": {
      "type": "Ybodychange",
      "commitMessage": "YARN-771. AMRMClient support for resource blacklisting (Junping Du via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519107 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/08/13 3:58 PM",
      "commitName": "bafd302208fbbbf1f2dccfc969a71d862cc8ce67",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "03/08/13 3:31 PM",
      "commitNameOld": "41e2518e0c7282ad2d4ac778759f91fd64d90fb1",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 27.02,
      "commitsBetweenForRepo": 165,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,82 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n-    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n-    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n+    List\u003cResourceRequest\u003e askList \u003d null;\n+    List\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n+    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n+    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n+\n+        blacklistToAdd.addAll(blacklistAdditions);\n+        blacklistToRemove.addAll(blacklistRemovals);\n+        \n+        ResourceBlacklistRequest blacklistRequest \u003d \n+            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n+            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n+                blacklistToRemove) : null;\n+        \n         allocateRequest \u003d\n             AllocateRequest.newInstance(lastResponseId, progressIndicator,\n-              askList, releaseList, null);\n+              askList, releaseList, blacklistRequest);\n+        // clear blacklistAdditions and blacklistRemovals before \n+        // unsynchronized part\n+        blacklistAdditions.clear();\n+        blacklistRemovals.clear();\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse);\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n+          \n+          blacklistAdditions.addAll(blacklistToAdd);\n+          blacklistRemovals.addAll(blacklistToRemove);\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    List\u003cResourceRequest\u003e askList \u003d null;\n    List\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    List\u003cString\u003e blacklistToAdd \u003d new ArrayList\u003cString\u003e();\n    List\u003cString\u003e blacklistToRemove \u003d new ArrayList\u003cString\u003e();\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n\n        blacklistToAdd.addAll(blacklistAdditions);\n        blacklistToRemove.addAll(blacklistRemovals);\n        \n        ResourceBlacklistRequest blacklistRequest \u003d \n            (blacklistToAdd !\u003d null) || (blacklistToRemove !\u003d null) ? \n            ResourceBlacklistRequest.newInstance(blacklistToAdd,\n                blacklistToRemove) : null;\n        \n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, blacklistRequest);\n        // clear blacklistAdditions and blacklistRemovals before \n        // unsynchronized part\n        blacklistAdditions.clear();\n        blacklistRemovals.clear();\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n          \n          blacklistAdditions.addAll(blacklistToAdd);\n          blacklistRemovals.addAll(blacklistToRemove);\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "ac914f79bc80b152e71e7de5497b73f22824f4a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-918. Remove ApplicationAttemptId from RegisterApplicationMasterRequestProto. Contributed by Vinod K V.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504735 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 5:57 PM",
      "commitName": "ac914f79bc80b152e71e7de5497b73f22824f4a7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "16/07/13 5:47 PM",
      "commitNameOld": "3520039979188c4ca6e69654223b3ac794e8bf8f",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 2.01,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n-            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n-              progressIndicator, askList, releaseList, null);\n+            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n+              askList, releaseList, null);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse);\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(lastResponseId, progressIndicator,\n              askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "1fe8e2d7eed74453cfe172853881fafc360a10b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-521. Augment AM - RM client module to be able to request containers only at specific locations (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503526 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/13 5:23 PM",
      "commitName": "1fe8e2d7eed74453cfe172853881fafc360a10b6",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "15/07/13 10:13 AM",
      "commitNameOld": "fe735f237c735a375d2bd194ed80ef9949fb1a68",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n-    Preconditions.checkArgument(progressIndicator \u003e 0,\n+    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n         \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n             AllocateRequest.newInstance(appAttemptId, lastResponseId,\n               progressIndicator, askList, releaseList, null);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse);\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e\u003d 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "fe735f237c735a375d2bd194ed80ef9949fb1a68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-654. AMRMClient: Perform sanity checks for parameters of public methods (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/13 10:13 AM",
      "commitName": "fe735f237c735a375d2bd194ed80ef9949fb1a68",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "13/07/13 3:31 PM",
      "commitNameOld": "2adee634269588b85c351e8a3bd2c0c26ad2ba1b",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,64 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n+    Preconditions.checkArgument(progressIndicator \u003e 0,\n+        \"Progress indicator should not be negative\");\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n         for(ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the \n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.newInstance(r.getPriority(),\n               r.getResourceName(), r.getCapability(), r.getNumContainers(),\n               r.getRelaxLocality()));\n         }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n             AllocateRequest.newInstance(appAttemptId, lastResponseId,\n               progressIndicator, askList, releaseList, null);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse);\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    Preconditions.checkArgument(progressIndicator \u003e 0,\n        \"Progress indicator should not be negative\");\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "2adee634269588b85c351e8a3bd2c0c26ad2ba1b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-541. getAllocatedContainers() is not returning all the allocated containers (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502906 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/07/13 3:31 PM",
      "commitName": "2adee634269588b85c351e8a3bd2c0c26ad2ba1b",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "20/06/13 5:08 PM",
      "commitNameOld": "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 22.93,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,62 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n-        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n+        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n+        for(ResourceRequest r : ask) {\n+          // create a copy of ResourceRequest as we might change it while the \n+          // RPC layer is using it to send info across\n+          askList.add(ResourceRequest.newInstance(r.getPriority(),\n+              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n+              r.getRelaxLocality()));\n+        }\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n             AllocateRequest.newInstance(appAttemptId, lastResponseId,\n               progressIndicator, askList, releaseList, null);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n         if (!allocateResponse.getNMTokens().isEmpty()) {\n           populateNMTokens(allocateResponse);\n         }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask.size());\n        for(ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the \n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newInstance(r.getPriority(),\n              r.getResourceName(), r.getCapability(), r.getNumContainers(),\n              r.getRelaxLocality()));\n        }\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": {
      "type": "Yfilerename",
      "commitMessage": "YARN-834. Fixed annotations for yarn-client module, reorganized packages and clearly differentiated *Async apis. Contributed by Arun C Murthy and Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494017 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 9:02 PM",
      "commitName": "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 8:10 PM",
      "commitNameOld": "2b14656ab5050dd75935b64681cdc25fb49db94f",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java"
      }
    },
    "769a0bd8314cd7317c083a9b74abf47242acb58c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-693. Modified RM to send NMTokens on allocate call so that AMs can then use them for authentication with NMs. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/06/13 8:11 PM",
      "commitName": "769a0bd8314cd7317c083a9b74abf47242acb58c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/06/13 9:57 PM",
      "commitNameOld": "c2d0cf1b20489fada91c80d2da5c7fed757d6c27",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,55 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n             AllocateRequest.newInstance(appAttemptId, lastResponseId,\n               progressIndicator, askList, releaseList, null);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n+        if (!allocateResponse.getNMTokens().isEmpty()) {\n+          populateNMTokens(allocateResponse);\n+        }\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n        if (!allocateResponse.getNMTokens().isEmpty()) {\n          populateNMTokens(allocateResponse);\n        }\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/13 11:46 AM",
      "commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.61,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n             AllocateRequest.newInstance(appAttemptId, lastResponseId,\n-              progressIndicator, askList, releaseList);\n+              progressIndicator, askList, releaseList, null);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList, null);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public AllocateResponse allocate(float progressIndicator) \n-      throws YarnRemoteException, IOException {\n+      throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d\n             AllocateRequest.newInstance(appAttemptId, lastResponseId,\n               progressIndicator, askList, releaseList);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "d33534c4fb35cb82ff8d56abeeb63a949e72a031": {
      "type": "Ybodychange",
      "commitMessage": "YARN-748. Moved BuilderUtils from yarn-common to yarn-server-common for eventual retirement. Contributed by Jian He.\nMAPREDUCE-5297. Updated MR App since BuilderUtils is no longer public after YARN-748. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489257 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 5:34 PM",
      "commitName": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/06/13 1:23 AM",
      "commitNameOld": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 2.67,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnRemoteException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n-        allocateRequest \u003d BuilderUtils\n-            .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n-                askList, releaseList);\n+        allocateRequest \u003d\n+            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n+              progressIndicator, askList, releaseList);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnRemoteException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d\n            AllocateRequest.newInstance(appAttemptId, lastResponseId,\n              progressIndicator, askList, releaseList);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-630. Changed AMRMProtocol api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\nMAPREDUCE-5226. Handling YarnRemoteException separately from IOException in MR App\u0027s use of AMRMProtocol after YARN-630. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480529 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 10:32 PM",
      "commitName": "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/04/13 7:46 PM",
      "commitNameOld": "be256a181985737ade3f8231b472a2438659c3b2",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public AllocateResponse allocate(float progressIndicator) \n-      throws YarnRemoteException {\n+      throws YarnRemoteException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d BuilderUtils\n             .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n                 askList, releaseList);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n         lastResponseId \u003d allocateResponse.getResponseId();\n         clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnRemoteException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d BuilderUtils\n            .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n                askList, releaseList);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "1bd345d6e3855ab330963efd32e0fac102e61d1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-396. Rationalize AllocateResponse in RM Scheduler API. Contributed by Zhijie Shen.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/13 1:44 PM",
      "commitName": "1bd345d6e3855ab330963efd32e0fac102e61d1a",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "07/02/13 12:21 PM",
      "commitNameOld": "bdfe23235e73a37e319e9f383a6d96e6004bf798",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 41.02,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   public AllocateResponse allocate(float progressIndicator) \n       throws YarnRemoteException {\n     AllocateResponse allocateResponse \u003d null;\n     ArrayList\u003cResourceRequest\u003e askList \u003d null;\n     ArrayList\u003cContainerId\u003e releaseList \u003d null;\n     AllocateRequest allocateRequest \u003d null;\n     \n     try {\n       synchronized (this) {\n         askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n         releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n         // optimistically clear this collection assuming no RPC failure\n         ask.clear();\n         release.clear();\n         allocateRequest \u003d BuilderUtils\n             .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n                 askList, releaseList);\n       }\n \n       allocateResponse \u003d rmClient.allocate(allocateRequest);\n-      AMResponse response \u003d allocateResponse.getAMResponse();\n \n       synchronized (this) {\n         // update these on successful RPC\n         clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n-        lastResponseId \u003d response.getResponseId();\n-        clusterAvailableResources \u003d response.getAvailableResources();\n+        lastResponseId \u003d allocateResponse.getResponseId();\n+        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n       }\n     } finally {\n       // TODO how to differentiate remote yarn exception vs error in rpc\n       if(allocateResponse \u003d\u003d null) {\n         // we hit an exception in allocate()\n         // preserve ask and release for next call to allocate()\n         synchronized (this) {\n           release.addAll(releaseList);\n           // requests could have been added or deleted during call to allocate\n           // If requests were added/removed then there is nothing to do since\n           // the ResourceRequest object in ask would have the actual new value.\n           // If ask does not have this ResourceRequest then it was unchanged and\n           // so we can add the value back safely.\n           // This assumes that there will no concurrent calls to allocate() and\n           // so we dont have to worry about ask being changed in the\n           // synchronized block at the beginning of this method.\n           for(ResourceRequest oldAsk : askList) {\n             if(!ask.contains(oldAsk)) {\n               ask.add(oldAsk);\n             }\n           }\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnRemoteException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d BuilderUtils\n            .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n                askList, releaseList);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d allocateResponse.getResponseId();\n        clusterAvailableResources \u003d allocateResponse.getAvailableResources();\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "0a61990855c23ebfa065145fa01084e84781b51c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-103. Add a yarn AM-RM client module. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1428554 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/01/13 11:11 AM",
      "commitName": "0a61990855c23ebfa065145fa01084e84781b51c",
      "commitAuthor": "Siddharth Seth",
      "diff": "@@ -0,0 +1,53 @@\n+  public AllocateResponse allocate(float progressIndicator) \n+      throws YarnRemoteException {\n+    AllocateResponse allocateResponse \u003d null;\n+    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n+    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n+    AllocateRequest allocateRequest \u003d null;\n+    \n+    try {\n+      synchronized (this) {\n+        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n+        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n+        // optimistically clear this collection assuming no RPC failure\n+        ask.clear();\n+        release.clear();\n+        allocateRequest \u003d BuilderUtils\n+            .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n+                askList, releaseList);\n+      }\n+\n+      allocateResponse \u003d rmClient.allocate(allocateRequest);\n+      AMResponse response \u003d allocateResponse.getAMResponse();\n+\n+      synchronized (this) {\n+        // update these on successful RPC\n+        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n+        lastResponseId \u003d response.getResponseId();\n+        clusterAvailableResources \u003d response.getAvailableResources();\n+      }\n+    } finally {\n+      // TODO how to differentiate remote yarn exception vs error in rpc\n+      if(allocateResponse \u003d\u003d null) {\n+        // we hit an exception in allocate()\n+        // preserve ask and release for next call to allocate()\n+        synchronized (this) {\n+          release.addAll(releaseList);\n+          // requests could have been added or deleted during call to allocate\n+          // If requests were added/removed then there is nothing to do since\n+          // the ResourceRequest object in ask would have the actual new value.\n+          // If ask does not have this ResourceRequest then it was unchanged and\n+          // so we can add the value back safely.\n+          // This assumes that there will no concurrent calls to allocate() and\n+          // so we dont have to worry about ask being changed in the\n+          // synchronized block at the beginning of this method.\n+          for(ResourceRequest oldAsk : askList) {\n+            if(!ask.contains(oldAsk)) {\n+              ask.add(oldAsk);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    return allocateResponse;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(float progressIndicator) \n      throws YarnRemoteException {\n    AllocateResponse allocateResponse \u003d null;\n    ArrayList\u003cResourceRequest\u003e askList \u003d null;\n    ArrayList\u003cContainerId\u003e releaseList \u003d null;\n    AllocateRequest allocateRequest \u003d null;\n    \n    try {\n      synchronized (this) {\n        askList \u003d new ArrayList\u003cResourceRequest\u003e(ask);\n        releaseList \u003d new ArrayList\u003cContainerId\u003e(release);\n        // optimistically clear this collection assuming no RPC failure\n        ask.clear();\n        release.clear();\n        allocateRequest \u003d BuilderUtils\n            .newAllocateRequest(appAttemptId, lastResponseId, progressIndicator,\n                askList, releaseList);\n      }\n\n      allocateResponse \u003d rmClient.allocate(allocateRequest);\n      AMResponse response \u003d allocateResponse.getAMResponse();\n\n      synchronized (this) {\n        // update these on successful RPC\n        clusterNodeCount \u003d allocateResponse.getNumClusterNodes();\n        lastResponseId \u003d response.getResponseId();\n        clusterAvailableResources \u003d response.getAvailableResources();\n      }\n    } finally {\n      // TODO how to differentiate remote yarn exception vs error in rpc\n      if(allocateResponse \u003d\u003d null) {\n        // we hit an exception in allocate()\n        // preserve ask and release for next call to allocate()\n        synchronized (this) {\n          release.addAll(releaseList);\n          // requests could have been added or deleted during call to allocate\n          // If requests were added/removed then there is nothing to do since\n          // the ResourceRequest object in ask would have the actual new value.\n          // If ask does not have this ResourceRequest then it was unchanged and\n          // so we can add the value back safely.\n          // This assumes that there will no concurrent calls to allocate() and\n          // so we dont have to worry about ask being changed in the\n          // synchronized block at the beginning of this method.\n          for(ResourceRequest oldAsk : askList) {\n            if(!ask.contains(oldAsk)) {\n              ask.add(oldAsk);\n            }\n          }\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java"
    }
  }
}