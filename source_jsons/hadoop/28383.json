{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientRelayer.java",
  "functionName": "updateMetrics",
  "functionId": "updateMetrics___allocateResponse-AllocateResponse__startTime-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
  "functionStartLine": 434,
  "functionEndLine": 497,
  "numCommitsSeen": 8,
  "timeTaken": 1124,
  "changeHistory": [
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09"
  ],
  "changeHistoryShort": {
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": "Yintroduced"
  },
  "changeHistoryDetails": {
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.\n",
      "commitDate": "12/09/18 11:46 AM",
      "commitName": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "diff": "@@ -0,0 +1,64 @@\n+  private void updateMetrics(AllocateResponse allocateResponse,\n+      long startTime) {\n+    this.metrics.addHeartbeatSuccess(this.rmId,\n+        System.currentTimeMillis() - startTime);\n+    // Process the allocate response from RM\n+    if (allocateResponse.getAllocatedContainers() !\u003d null) {\n+      for (Container container : allocateResponse\n+          .getAllocatedContainers()) {\n+        // Do not update metrics aggressively for AllocationRequestId zero\n+        // case. Also avoid double count to due to re-send\n+        if (this.knownContainers.add(container.getId())) {\n+          this.metrics.addFulfilledQPS(this.rmId, AMRMClientRelayerMetrics\n+              .getRequestType(container.getExecutionType()), 1);\n+          if (container.getAllocationRequestId() !\u003d 0) {\n+            Integer count \u003d this.pendingCountForMetrics\n+                .get(container.getAllocationRequestId());\n+            if (count !\u003d null \u0026\u0026 count \u003e 0) {\n+              this.pendingCountForMetrics\n+                  .put(container.getAllocationRequestId(), --count);\n+              this.metrics.decrClientPending(this.rmId,\n+                  AMRMClientRelayerMetrics\n+                      .getRequestType(container.getExecutionType()), 1);\n+              this.metrics.addFulfillLatency(this.rmId,\n+                  AMRMClientRelayerMetrics\n+                      .getRequestType(container.getExecutionType()),\n+                  System.currentTimeMillis() - this.askTimeStamp\n+                      .get(container.getAllocationRequestId()));\n+            }\n+          }\n+        }\n+      }\n+    }\n+    if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n+      for (ContainerStatus container : allocateResponse\n+          .getCompletedContainersStatuses()) {\n+        this.remotePendingRelease.remove(container.getContainerId());\n+        UpdateContainerRequest req \u003d\n+            this.remotePendingChange.remove(container.getContainerId());\n+        if (req !\u003d null) {\n+          this.metrics\n+              .decrClientPending(rmId, req.getContainerUpdateType(), 1);\n+        }\n+        this.knownContainers.remove(container.getContainerId());\n+      }\n+    }\n+\n+    if (allocateResponse.getUpdatedContainers() !\u003d null) {\n+      for (UpdatedContainer updatedContainer : allocateResponse\n+          .getUpdatedContainers()) {\n+        UpdateContainerRequest req \u003d this.remotePendingChange\n+            .remove(updatedContainer.getContainer().getId());\n+        if (req !\u003d null) {\n+          this.metrics\n+              .decrClientPending(rmId, req.getContainerUpdateType(), 1);\n+          this.metrics.addFulfillLatency(rmId, req.getContainerUpdateType(),\n+              System.currentTimeMillis() - this.changeTimeStamp\n+                  .remove(req.getContainerId()));\n+          this.metrics\n+              .addFulfilledQPS(rmId, req.getContainerUpdateType(), 1);\n+        }\n+      }\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateMetrics(AllocateResponse allocateResponse,\n      long startTime) {\n    this.metrics.addHeartbeatSuccess(this.rmId,\n        System.currentTimeMillis() - startTime);\n    // Process the allocate response from RM\n    if (allocateResponse.getAllocatedContainers() !\u003d null) {\n      for (Container container : allocateResponse\n          .getAllocatedContainers()) {\n        // Do not update metrics aggressively for AllocationRequestId zero\n        // case. Also avoid double count to due to re-send\n        if (this.knownContainers.add(container.getId())) {\n          this.metrics.addFulfilledQPS(this.rmId, AMRMClientRelayerMetrics\n              .getRequestType(container.getExecutionType()), 1);\n          if (container.getAllocationRequestId() !\u003d 0) {\n            Integer count \u003d this.pendingCountForMetrics\n                .get(container.getAllocationRequestId());\n            if (count !\u003d null \u0026\u0026 count \u003e 0) {\n              this.pendingCountForMetrics\n                  .put(container.getAllocationRequestId(), --count);\n              this.metrics.decrClientPending(this.rmId,\n                  AMRMClientRelayerMetrics\n                      .getRequestType(container.getExecutionType()), 1);\n              this.metrics.addFulfillLatency(this.rmId,\n                  AMRMClientRelayerMetrics\n                      .getRequestType(container.getExecutionType()),\n                  System.currentTimeMillis() - this.askTimeStamp\n                      .get(container.getAllocationRequestId()));\n            }\n          }\n        }\n      }\n    }\n    if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n      for (ContainerStatus container : allocateResponse\n          .getCompletedContainersStatuses()) {\n        this.remotePendingRelease.remove(container.getContainerId());\n        UpdateContainerRequest req \u003d\n            this.remotePendingChange.remove(container.getContainerId());\n        if (req !\u003d null) {\n          this.metrics\n              .decrClientPending(rmId, req.getContainerUpdateType(), 1);\n        }\n        this.knownContainers.remove(container.getContainerId());\n      }\n    }\n\n    if (allocateResponse.getUpdatedContainers() !\u003d null) {\n      for (UpdatedContainer updatedContainer : allocateResponse\n          .getUpdatedContainers()) {\n        UpdateContainerRequest req \u003d this.remotePendingChange\n            .remove(updatedContainer.getContainer().getId());\n        if (req !\u003d null) {\n          this.metrics\n              .decrClientPending(rmId, req.getContainerUpdateType(), 1);\n          this.metrics.addFulfillLatency(rmId, req.getContainerUpdateType(),\n              System.currentTimeMillis() - this.changeTimeStamp\n                  .remove(req.getContainerId()));\n          this.metrics\n              .addFulfilledQPS(rmId, req.getContainerUpdateType(), 1);\n        }\n      }\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java"
    }
  }
}