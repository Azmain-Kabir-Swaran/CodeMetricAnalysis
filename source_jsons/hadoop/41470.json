{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "allocate",
  "functionId": "allocate___appAttemptId-ApplicationAttemptId__ask-List__ResourceRequest____schedulingRequests-List__SchedulingRequest____release-List__ContainerId____blacklistAdditions-List__String____blacklistRemovals-List__String____updateRequests-ContainerUpdates",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 864,
  "functionEndLine": 973,
  "numCommitsSeen": 897,
  "timeTaken": 16911,
  "changeHistory": [
    "ef950b086354c8a02eecd6745f6ab0fe5449f7b0",
    "fd6be5898ad1a650e3bceacb8169a53520da57e5",
    "c7ebcd76bf3dd14127336951f2be3de772e7826a",
    "f48fec83d0f2d1a781a141ad7216463c5526321f",
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "fedabcad42067ac7dd24de40fab6be2d3485a540",
    "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "a77f432449aad67da31bd8bf8644b71def741bde",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
    "25f9872be63423ada6a18481eaad2888e731fdac",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "4174b9756c8c7877797545c4356b1f40df603ec5",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661",
    "620325e81696fca140195b74929ed9eda2d5eb16",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434",
    "81df7b586a16f8226c7b01c139c1c70c060399c3",
    "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06",
    "972f1f1ab94a26ec446a272ad030fe13f03ed442",
    "658097d6da1b1aac8e01db459f0c3b456e99652f",
    "51881535e659940b1b332d0c5952ee1f9958cc7f",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd",
    "85d4c787e0f8ed913aaa61a6874ccf0408577b8d",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "5fd5c9900cfd299428acbc8dff767273e44647c0",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "025f1719472282a30aa26ae3e235e404f04ba932",
    "b9753e509ce2487aa71174d2dab440c33c6a17a4",
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
    "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f",
    "bc6777dd5bdcbaef09897b506bc6511ae456033d",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "ef950b086354c8a02eecd6745f6ab0fe5449f7b0": "Ybodychange",
    "fd6be5898ad1a650e3bceacb8169a53520da57e5": "Ybodychange",
    "c7ebcd76bf3dd14127336951f2be3de772e7826a": "Ybodychange",
    "f48fec83d0f2d1a781a141ad7216463c5526321f": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ymultichange(Yparameterchange,Ybodychange)",
    "fedabcad42067ac7dd24de40fab6be2d3485a540": "Ybodychange",
    "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b": "Ybodychange",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ybodychange",
    "a77f432449aad67da31bd8bf8644b71def741bde": "Ybodychange",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Ymultichange(Yparameterchange,Ybodychange)",
    "25f9872be63423ada6a18481eaad2888e731fdac": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ybodychange",
    "4174b9756c8c7877797545c4356b1f40df603ec5": "Ybodychange",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": "Yparameterchange",
    "620325e81696fca140195b74929ed9eda2d5eb16": "Ybodychange",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": "Ybodychange",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Ymultichange(Yparameterchange,Ybodychange)",
    "81df7b586a16f8226c7b01c139c1c70c060399c3": "Ybodychange",
    "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06": "Ybodychange",
    "972f1f1ab94a26ec446a272ad030fe13f03ed442": "Ybodychange",
    "658097d6da1b1aac8e01db459f0c3b456e99652f": "Ybodychange",
    "51881535e659940b1b332d0c5952ee1f9958cc7f": "Ybodychange",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": "Ybodychange",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": "Ybodychange",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ybodychange",
    "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd": "Ybodychange",
    "85d4c787e0f8ed913aaa61a6874ccf0408577b8d": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "5fd5c9900cfd299428acbc8dff767273e44647c0": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ybodychange",
    "025f1719472282a30aa26ae3e235e404f04ba932": "Ybodychange",
    "b9753e509ce2487aa71174d2dab440c33c6a17a4": "Ybodychange",
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": "Yparameterchange",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": "Ybodychange",
    "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f": "Ybodychange",
    "bc6777dd5bdcbaef09897b506bc6511ae456033d": "Ybodychange",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ef950b086354c8a02eecd6745f6ab0fe5449f7b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9290. Invalid SchedulingRequest not rejected in Scheduler PlacementConstraintsHandler. Contributed by Prabhu Joseph\n",
      "commitDate": "26/11/19 1:04 PM",
      "commitName": "ef950b086354c8a02eecd6745f6ab0fe5449f7b0",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "19/11/19 12:40 AM",
      "commitNameOld": "ea68756c0cd3e6e20b8e7045a8b7edd180ea4708",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 7.52,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n       List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     ApplicationId applicationId \u003d application.getApplicationId();\n     FSLeafQueue queue \u003d application.getQueue();\n     List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n             validateResourceRequests(ask, queue);\n \n     // We need to be fail-fast here if any invalid ask is detected.\n     // If we would have thrown exception later, this could be problematic as\n     // tokens and promoted / demoted containers would have been lost because\n     // scheduler would clear them right away and AM\n     // would not get this information.\n     if (!invalidAsks.isEmpty()) {\n       throw new SchedulerInvalidResoureRequestException(String.format(\n               \"Resource request is invalid for application %s because queue %s \"\n                       + \"has 0 amount of resource for a resource type! \"\n                       + \"Validation result: %s\",\n               applicationId, queue.getName(), invalidAsks));\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n     normalizeResourceRequests(ask, queue.getName());\n \n     // TODO, normalize SchedulingRequest\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         // TODO, handle SchedulingRequest\n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n \n     List\u003cContainer\u003e previousAttemptContainers \u003d application\n         .pullPreviousAttemptContainers();\n     List\u003cNMToken\u003e updatedNMTokens \u003d application.pullUpdatedNMTokens();\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         updatedNMTokens, null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers(),\n-        previousAttemptContainers);\n+        previousAttemptContainers, null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    ApplicationId applicationId \u003d application.getApplicationId();\n    FSLeafQueue queue \u003d application.getQueue();\n    List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n            validateResourceRequests(ask, queue);\n\n    // We need to be fail-fast here if any invalid ask is detected.\n    // If we would have thrown exception later, this could be problematic as\n    // tokens and promoted / demoted containers would have been lost because\n    // scheduler would clear them right away and AM\n    // would not get this information.\n    if (!invalidAsks.isEmpty()) {\n      throw new SchedulerInvalidResoureRequestException(String.format(\n              \"Resource request is invalid for application %s because queue %s \"\n                      + \"has 0 amount of resource for a resource type! \"\n                      + \"Validation result: %s\",\n              applicationId, queue.getName(), invalidAsks));\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeResourceRequests(ask, queue.getName());\n\n    // TODO, normalize SchedulingRequest\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        // TODO, handle SchedulingRequest\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n\n    List\u003cContainer\u003e previousAttemptContainers \u003d application\n        .pullPreviousAttemptContainers();\n    List\u003cNMToken\u003e updatedNMTokens \u003d application.pullUpdatedNMTokens();\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        updatedNMTokens, null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        previousAttemptContainers, null);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "fd6be5898ad1a650e3bceacb8169a53520da57e5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8468. Enable the use of queue based maximum container allocation limit and implement it in FairScheduler. Contributed by Antal Bálint Steinbach.\n",
      "commitDate": "29/09/18 2:47 AM",
      "commitName": "fd6be5898ad1a650e3bceacb8169a53520da57e5",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "02/08/18 10:10 AM",
      "commitNameOld": "889df6f1949921371d6d55dff93d3818d03be3bb",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 528,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n       List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     ApplicationId applicationId \u003d application.getApplicationId();\n     FSLeafQueue queue \u003d application.getQueue();\n     List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n             validateResourceRequests(ask, queue);\n \n     // We need to be fail-fast here if any invalid ask is detected.\n     // If we would have thrown exception later, this could be problematic as\n     // tokens and promoted / demoted containers would have been lost because\n     // scheduler would clear them right away and AM\n     // would not get this information.\n     if (!invalidAsks.isEmpty()) {\n       throw new SchedulerInvalidResoureRequestException(String.format(\n               \"Resource request is invalid for application %s because queue %s \"\n                       + \"has 0 amount of resource for a resource type! \"\n                       + \"Validation result: %s\",\n               applicationId, queue.getName(), invalidAsks));\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n-    normalizeResourceRequests(ask);\n+    normalizeResourceRequests(ask, queue.getName());\n \n     // TODO, normalize SchedulingRequest\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         // TODO, handle SchedulingRequest\n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n \n     List\u003cContainer\u003e previousAttemptContainers \u003d application\n         .pullPreviousAttemptContainers();\n     List\u003cNMToken\u003e updatedNMTokens \u003d application.pullUpdatedNMTokens();\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         updatedNMTokens, null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers(),\n         previousAttemptContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    ApplicationId applicationId \u003d application.getApplicationId();\n    FSLeafQueue queue \u003d application.getQueue();\n    List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n            validateResourceRequests(ask, queue);\n\n    // We need to be fail-fast here if any invalid ask is detected.\n    // If we would have thrown exception later, this could be problematic as\n    // tokens and promoted / demoted containers would have been lost because\n    // scheduler would clear them right away and AM\n    // would not get this information.\n    if (!invalidAsks.isEmpty()) {\n      throw new SchedulerInvalidResoureRequestException(String.format(\n              \"Resource request is invalid for application %s because queue %s \"\n                      + \"has 0 amount of resource for a resource type! \"\n                      + \"Validation result: %s\",\n              applicationId, queue.getName(), invalidAsks));\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeResourceRequests(ask, queue.getName());\n\n    // TODO, normalize SchedulingRequest\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        // TODO, handle SchedulingRequest\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n\n    List\u003cContainer\u003e previousAttemptContainers \u003d application\n        .pullPreviousAttemptContainers();\n    List\u003cNMToken\u003e updatedNMTokens \u003d application.pullUpdatedNMTokens();\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        updatedNMTokens, null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        previousAttemptContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "c7ebcd76bf3dd14127336951f2be3de772e7826a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8579.  Recover NMToken of previous attempted component data.\n            Contributed by Gour Saha\n",
      "commitDate": "31/07/18 3:01 PM",
      "commitName": "c7ebcd76bf3dd14127336951f2be3de772e7826a",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "24/07/18 12:46 PM",
      "commitNameOld": "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 7.09,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,110 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n       List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     ApplicationId applicationId \u003d application.getApplicationId();\n     FSLeafQueue queue \u003d application.getQueue();\n     List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n             validateResourceRequests(ask, queue);\n \n     // We need to be fail-fast here if any invalid ask is detected.\n     // If we would have thrown exception later, this could be problematic as\n     // tokens and promoted / demoted containers would have been lost because\n     // scheduler would clear them right away and AM\n     // would not get this information.\n     if (!invalidAsks.isEmpty()) {\n       throw new SchedulerInvalidResoureRequestException(String.format(\n               \"Resource request is invalid for application %s because queue %s \"\n                       + \"has 0 amount of resource for a resource type! \"\n                       + \"Validation result: %s\",\n               applicationId, queue.getName(), invalidAsks));\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n     normalizeResourceRequests(ask);\n \n     // TODO, normalize SchedulingRequest\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         // TODO, handle SchedulingRequest\n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n \n+    List\u003cContainer\u003e previousAttemptContainers \u003d application\n+        .pullPreviousAttemptContainers();\n+    List\u003cNMToken\u003e updatedNMTokens \u003d application.pullUpdatedNMTokens();\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n-        application.pullUpdatedNMTokens(), null, null,\n+        updatedNMTokens, null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers(),\n-        application.pullPreviousAttemptContainers());\n+        previousAttemptContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    ApplicationId applicationId \u003d application.getApplicationId();\n    FSLeafQueue queue \u003d application.getQueue();\n    List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n            validateResourceRequests(ask, queue);\n\n    // We need to be fail-fast here if any invalid ask is detected.\n    // If we would have thrown exception later, this could be problematic as\n    // tokens and promoted / demoted containers would have been lost because\n    // scheduler would clear them right away and AM\n    // would not get this information.\n    if (!invalidAsks.isEmpty()) {\n      throw new SchedulerInvalidResoureRequestException(String.format(\n              \"Resource request is invalid for application %s because queue %s \"\n                      + \"has 0 amount of resource for a resource type! \"\n                      + \"Validation result: %s\",\n              applicationId, queue.getName(), invalidAsks));\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeResourceRequests(ask);\n\n    // TODO, normalize SchedulingRequest\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        // TODO, handle SchedulingRequest\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n\n    List\u003cContainer\u003e previousAttemptContainers \u003d application\n        .pullPreviousAttemptContainers();\n    List\u003cNMToken\u003e updatedNMTokens \u003d application.pullUpdatedNMTokens();\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        updatedNMTokens, null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        previousAttemptContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f48fec83d0f2d1a781a141ad7216463c5526321f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8248. Job hangs when a job requests a resource that its queue does not have. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "21/05/18 8:10 AM",
      "commitName": "f48fec83d0f2d1a781a141ad7216463c5526321f",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 110.24,
      "commitsBetweenForRepo": 1383,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,107 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n       List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n-\n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n+    ApplicationId applicationId \u003d application.getApplicationId();\n+    FSLeafQueue queue \u003d application.getQueue();\n+    List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n+            validateResourceRequests(ask, queue);\n+\n+    // We need to be fail-fast here if any invalid ask is detected.\n+    // If we would have thrown exception later, this could be problematic as\n+    // tokens and promoted / demoted containers would have been lost because\n+    // scheduler would clear them right away and AM\n+    // would not get this information.\n+    if (!invalidAsks.isEmpty()) {\n+      throw new SchedulerInvalidResoureRequestException(String.format(\n+              \"Resource request is invalid for application %s because queue %s \"\n+                      + \"has 0 amount of resource for a resource type! \"\n+                      + \"Validation result: %s\",\n+              applicationId, queue.getName(), invalidAsks));\n+    }\n+\n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n     normalizeResourceRequests(ask);\n \n     // TODO, normalize SchedulingRequest\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         // TODO, handle SchedulingRequest\n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n+\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers(),\n         application.pullPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    ApplicationId applicationId \u003d application.getApplicationId();\n    FSLeafQueue queue \u003d application.getQueue();\n    List\u003cMaxResourceValidationResult\u003e invalidAsks \u003d\n            validateResourceRequests(ask, queue);\n\n    // We need to be fail-fast here if any invalid ask is detected.\n    // If we would have thrown exception later, this could be problematic as\n    // tokens and promoted / demoted containers would have been lost because\n    // scheduler would clear them right away and AM\n    // would not get this information.\n    if (!invalidAsks.isEmpty()) {\n      throw new SchedulerInvalidResoureRequestException(String.format(\n              \"Resource request is invalid for application %s because queue %s \"\n                      + \"has 0 amount of resource for a resource type! \"\n                      + \"Validation result: %s\",\n              applicationId, queue.getName(), invalidAsks));\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeResourceRequests(ask);\n\n    // TODO, normalize SchedulingRequest\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        // TODO, handle SchedulingRequest\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        application.pullPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "18/01/18 5:43 PM",
          "commitNameOld": "bc93ac229e17b1be440052217e51820b95c179ec",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 12.32,
          "commitsBetweenForRepo": 86,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,89 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n-      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n-      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      ContainerUpdates updateRequests) {\n+      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n+      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n+      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    normalizeResourceRequests(ask);\n+\n+    // TODO, normalize SchedulingRequest\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n+        // TODO, handle SchedulingRequest\n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers(),\n         application.pullPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeResourceRequests(ask);\n\n    // TODO, normalize SchedulingRequest\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        // TODO, handle SchedulingRequest\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        application.pullPreviousAttemptContainers());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, updateRequests-ContainerUpdates]",
            "newValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, schedulingRequests-List\u003cSchedulingRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, updateRequests-ContainerUpdates]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "18/01/18 5:43 PM",
          "commitNameOld": "bc93ac229e17b1be440052217e51820b95c179ec",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 12.32,
          "commitsBetweenForRepo": 86,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,89 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n-      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n-      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      ContainerUpdates updateRequests) {\n+      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n+      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n+      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    normalizeResourceRequests(ask);\n+\n+    // TODO, normalize SchedulingRequest\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n+        // TODO, handle SchedulingRequest\n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers(),\n         application.pullPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions,\n      List\u003cString\u003e blacklistRemovals, ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeResourceRequests(ask);\n\n    // TODO, normalize SchedulingRequest\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        // TODO, handle SchedulingRequest\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        application.pullPreviousAttemptContainers());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "fedabcad42067ac7dd24de40fab6be2d3485a540": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6168. Restarted RM may not inform AM about all existing containers. Contributed by Chandni Singh\n",
      "commitDate": "27/11/17 10:19 AM",
      "commitName": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/11/17 2:18 PM",
      "commitNameOld": "4cc9479dae2bfb7d14d29b55d103eea9fa35a586",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,86 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           appAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n-        application.pullNewlyDemotedContainers());\n+        application.pullNewlyDemotedContainers(),\n+        application.pullPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers(),\n        application.pullPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6959. RM may allocate wrong AM Container for new attempt. Contributed by Yuqi Wang\n",
      "commitDate": "14/08/17 10:51 AM",
      "commitName": "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
      "commitAuthor": "Jian He",
      "commitDateOld": "02/08/17 9:25 AM",
      "commitNameOld": "45535f8afae4e5bf4f60597fc29ba94b4e7743f3",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 12.06,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,85 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n-      LOG.info(\"Calling allocate on removed \" +\n-          \"or non existent application \" + appAttemptId);\n+      LOG.error(\"Calling allocate on removed or non existent application \" +\n+          appAttemptId.getApplicationId());\n+      return EMPTY_ALLOCATION;\n+    }\n+\n+    // The allocate may be the leftover from previous attempt, and it will\n+    // impact current attempt, such as confuse the request and allocation for\n+    // current attempt\u0027s AM container.\n+    // Note outside precondition check for the attempt id may be\n+    // outdated here, so double check it here is necessary.\n+    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n+      LOG.error(\"Calling allocate on previous or removed \" +\n+          \"or non existent application attempt \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Handle promotions and demotions\n     handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          appAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(appAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/02/17 8:16 PM",
      "commitNameOld": "815d53506fb0c5ca029c993d6b094db2ac0ca6eb",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 1.6,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,74 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Handle promotions and demotions\n-    handleExecutionTypeUpdates(\n-        application, updateRequests.getPromotionRequests(),\n-        updateRequests.getDemotionRequests());\n+    handleContainerUpdates(application, updateRequests);\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n     lock.lock();\n     try {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n       lock.unlock();\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d\n         application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleContainerUpdates(application, updateRequests);\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a77f432449aad67da31bd8bf8644b71def741bde": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6171. ConcurrentModificationException on FSAppAttempt.containersToPreempt. (Miklos Szegedi via kasha)\n",
      "commitDate": "16/02/17 2:54 PM",
      "commitName": "a77f432449aad67da31bd8bf8644b71def741bde",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "16/02/17 12:03 AM",
      "commitNameOld": "74dd14225059322825f706120aa57cf673820daf",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.62,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Handle promotions and demotions\n     handleExecutionTypeUpdates(\n         application, updateRequests.getPromotionRequests(),\n         updateRequests.getDemotionRequests());\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n+    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n+    lock.lock();\n     try {\n-      application.getWriteLock().lock();\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n-      application.getWriteLock().unlock();\n+      lock.unlock();\n     }\n \n+    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n+        application.getPreemptionContainerIds();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n-      LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n+      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n           + \" container(s)\");\n     }\n \n-    Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n-    for (RMContainer container : application.getPreemptionContainers()) {\n-      preemptionContainerIds.add(container.getContainerId());\n-    }\n-\n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens(), null, null,\n         application.pullNewlyPromotedContainers(),\n         application.pullNewlyDemotedContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleExecutionTypeUpdates(\n        application, updateRequests.getPromotionRequests(),\n        updateRequests.getDemotionRequests());\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    ReentrantReadWriteLock.WriteLock lock \u003d application.getWriteLock();\n    lock.lock();\n    try {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d\n        application.getPreemptionContainerIds();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + preemptionContainerIds.size()\n          + \" container(s)\");\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "05/01/17 10:31 AM",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
          "commitDate": "05/01/17 10:31 AM",
          "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "03/01/17 2:53 PM",
          "commitNameOld": "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 1.82,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,78 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      List\u003cUpdateContainerRequest\u003e increaseRequests,\n-      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n+      ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n+    // Handle promotions and demotions\n+    handleExecutionTypeUpdates(\n+        application, updateRequests.getPromotionRequests(),\n+        updateRequests.getDemotionRequests());\n+\n     // Sanity check\n     normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     try {\n       application.getWriteLock().lock();\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n       application.getWriteLock().unlock();\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n           + \" container(s)\");\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n     for (RMContainer container : application.getPreemptionContainers()) {\n       preemptionContainerIds.add(container.getContainerId());\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n-        application.pullUpdatedNMTokens());\n+        application.pullUpdatedNMTokens(), null, null,\n+        application.pullNewlyPromotedContainers(),\n+        application.pullNewlyDemotedContainers());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleExecutionTypeUpdates(\n        application, updateRequests.getPromotionRequests(),\n        updateRequests.getDemotionRequests());\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    try {\n      application.getWriteLock().lock();\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      application.getWriteLock().unlock();\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n          + \" container(s)\");\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n    for (RMContainer container : application.getPreemptionContainers()) {\n      preemptionContainerIds.add(container.getContainerId());\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cUpdateContainerRequest\u003e, decreaseRequests-List\u003cUpdateContainerRequest\u003e]",
            "newValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, updateRequests-ContainerUpdates]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
          "commitDate": "05/01/17 10:31 AM",
          "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "03/01/17 2:53 PM",
          "commitNameOld": "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 1.82,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,78 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      List\u003cUpdateContainerRequest\u003e increaseRequests,\n-      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n+      ContainerUpdates updateRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n+    // Handle promotions and demotions\n+    handleExecutionTypeUpdates(\n+        application, updateRequests.getPromotionRequests(),\n+        updateRequests.getDemotionRequests());\n+\n     // Sanity check\n     normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     try {\n       application.getWriteLock().lock();\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n       application.getWriteLock().unlock();\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n           + \" container(s)\");\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n     for (RMContainer container : application.getPreemptionContainers()) {\n       preemptionContainerIds.add(container.getContainerId());\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n-        application.pullUpdatedNMTokens());\n+        application.pullUpdatedNMTokens(), null, null,\n+        application.pullNewlyPromotedContainers(),\n+        application.pullNewlyDemotedContainers());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Handle promotions and demotions\n    handleExecutionTypeUpdates(\n        application, updateRequests.getPromotionRequests(),\n        updateRequests.getDemotionRequests());\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    try {\n      application.getWriteLock().lock();\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      application.getWriteLock().unlock();\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n          + \" container(s)\");\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n    for (RMContainer container : application.getPreemptionContainers()) {\n      preemptionContainerIds.add(container.getContainerId());\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens(), null, null,\n        application.pullNewlyPromotedContainers(),\n        application.pullNewlyDemotedContainers());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "25f9872be63423ada6a18481eaad2888e731fdac": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5774. MR Job stuck in ACCEPTED status without any progress in Fair Scheduler\nif set yarn.scheduler.minimum-allocation-mb to 0. (Contributed by Yufei Gu via Daniel Templeton)\n",
      "commitDate": "29/11/16 9:40 AM",
      "commitName": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "23/11/16 9:48 PM",
      "commitNameOld": "10468529a9b858bd945e7ecb063c9c1438efa474",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 5.49,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,72 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cUpdateContainerRequest\u003e increaseRequests,\n       List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n-        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n-        incrAllocation);\n+    normalizeRequests(ask);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     try {\n       application.getWriteLock().lock();\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                   + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n     } finally {\n       application.getWriteLock().unlock();\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\n           \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n               + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n               .getCurrentReservation());\n \n       LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n           + \" container(s)\");\n     }\n \n     Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n     for (RMContainer container : application.getPreemptionContainers()) {\n       preemptionContainerIds.add(container.getContainerId());\n     }\n \n     application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n     List\u003cContainer\u003e newlyAllocatedContainers \u003d\n         application.pullNewlyAllocatedContainers();\n     // Record container allocation time\n     if (!(newlyAllocatedContainers.isEmpty())) {\n       application.recordContainerAllocationTime(getClock().getTime());\n     }\n \n     Resource headroom \u003d application.getHeadroom();\n     application.setApplicationHeadroomForMetrics(headroom);\n     return new Allocation(newlyAllocatedContainers, headroom,\n         preemptionContainerIds, null, null,\n         application.pullUpdatedNMTokens());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    try {\n      application.getWriteLock().lock();\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      application.getWriteLock().unlock();\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n          + \" container(s)\");\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n    for (RMContainer container : application.getPreemptionContainers()) {\n      preemptionContainerIds.add(container.getContainerId());\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/10/16 6:03 AM",
      "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 1.47,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,74 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cUpdateContainerRequest\u003e increaseRequests,\n       List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n-    synchronized (application) {\n+    try {\n+      application.getWriteLock().lock();\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"allocate: pre-update\" +\n-              \" applicationAttemptId\u003d\" + appAttemptId +\n-              \" application\u003d\" + application.getApplicationId());\n+          LOG.debug(\n+              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n+                  + \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"allocate: post-update\" +\n-            \" applicationAttemptId\u003d\" + appAttemptId +\n-            \" #ask\u003d\" + ask.size() +\n-            \" reservation\u003d \" + application.getCurrentReservation());\n-\n-        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n-            + \" container(s)\");\n-      }\n-\n-      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n-      for (RMContainer container : application.getPreemptionContainers()) {\n-        preemptionContainerIds.add(container.getContainerId());\n-      }\n-\n-      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-\n-      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n-          application.pullNewlyAllocatedContainers();\n-      // Record container allocation time\n-      if (!(newlyAllocatedContainers.isEmpty())) {\n-        application.recordContainerAllocationTime(getClock().getTime());\n-      }\n-\n-      Resource headroom \u003d application.getHeadroom();\n-      application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(newlyAllocatedContainers, headroom,\n-          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n+    } finally {\n+      application.getWriteLock().unlock();\n     }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\n+          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n+              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n+              .getCurrentReservation());\n+\n+      LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n+          + \" container(s)\");\n+    }\n+\n+    Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n+    for (RMContainer container : application.getPreemptionContainers()) {\n+      preemptionContainerIds.add(container.getContainerId());\n+    }\n+\n+    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+\n+    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n+        application.pullNewlyAllocatedContainers();\n+    // Record container allocation time\n+    if (!(newlyAllocatedContainers.isEmpty())) {\n+      application.recordContainerAllocationTime(getClock().getTime());\n+    }\n+\n+    Resource headroom \u003d application.getHeadroom();\n+    application.setApplicationHeadroomForMetrics(headroom);\n+    return new Allocation(newlyAllocatedContainers, headroom,\n+        preemptionContainerIds, null, null,\n+        application.pullUpdatedNMTokens());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    try {\n      application.getWriteLock().lock();\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"allocate: pre-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n                  + \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n    } finally {\n      application.getWriteLock().unlock();\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"allocate: post-update\" + \" applicationAttemptId\u003d\" + appAttemptId\n              + \" #ask\u003d\" + ask.size() + \" reservation\u003d \" + application\n              .getCurrentReservation());\n\n      LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n          + \" container(s)\");\n    }\n\n    Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n    for (RMContainer container : application.getPreemptionContainers()) {\n      preemptionContainerIds.add(container.getContainerId());\n    }\n\n    application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n    List\u003cContainer\u003e newlyAllocatedContainers \u003d\n        application.pullNewlyAllocatedContainers();\n    // Record container allocation time\n    if (!(newlyAllocatedContainers.isEmpty())) {\n      application.recordContainerAllocationTime(getClock().getTime());\n    }\n\n    Resource headroom \u003d application.getHeadroom();\n    application.setApplicationHeadroomForMetrics(headroom);\n    return new Allocation(newlyAllocatedContainers, headroom,\n        preemptionContainerIds, null, null,\n        application.pullUpdatedNMTokens());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "4174b9756c8c7877797545c4356b1f40df603ec5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5642. Typos in 9 log messages. Contributed by Mehran Hassani\n",
      "commitDate": "16/09/16 10:05 PM",
      "commitName": "4174b9756c8c7877797545c4356b1f40df603ec5",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "06/09/16 10:40 PM",
      "commitNameOld": "c0e492e50fa98d423c8a61c94d2d1f9553558b6d",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 9.98,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cUpdateContainerRequest\u003e increaseRequests,\n       List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n-          \"or non existant application \" + appAttemptId);\n+          \"or non existent application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       List\u003cContainer\u003e newlyAllocatedContainers \u003d\n           application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n       if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(newlyAllocatedContainers, headroom,\n           preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existent application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-5221. Expose UpdateResourceRequest API to allow AM to request for change in container properties. (asuresh)\n",
      "commitDate": "30/08/16 3:52 PM",
      "commitName": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "17/08/16 5:40 PM",
      "commitNameOld": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 12.93,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n-      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n+      List\u003cUpdateContainerRequest\u003e increaseRequests,\n+      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       List\u003cContainer\u003e newlyAllocatedContainers \u003d\n           application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n       if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(newlyAllocatedContainers, headroom,\n           preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cContainerResourceChangeRequest\u003e, decreaseRequests-List\u003cContainerResourceChangeRequest\u003e]",
        "newValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cUpdateContainerRequest\u003e, decreaseRequests-List\u003cUpdateContainerRequest\u003e]"
      }
    },
    "620325e81696fca140195b74929ed9eda2d5eb16": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4837. User facing aspects of \u0027AM blacklisting\u0027 feature need fixing. (vinodkv via wangda)\n",
      "commitDate": "07/06/16 3:06 PM",
      "commitName": "620325e81696fca140195b74929ed9eda2d5eb16",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 9.26,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,70 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n       List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n-      if (application.isWaitingForAMContainer()) {\n-        // Allocate is for AM and update AM blacklist for this\n-        application.updateAMBlacklist(\n-            blacklistAdditions, blacklistRemovals);\n-      } else {\n-        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-      }\n+      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       List\u003cContainer\u003e newlyAllocatedContainers \u003d\n           application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n       if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(newlyAllocatedContainers, headroom,\n           preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "14/03/16 2:19 PM",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "06/03/16 7:46 PM",
      "commitNameOld": "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264",
      "commitAuthorOld": "Zhihai Xu",
      "daysBetweenCommits": 7.73,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n       List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n-        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n+        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       if (application.isWaitingForAMContainer()) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n       List\u003cContainer\u003e newlyAllocatedContainers \u003d\n           application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n       if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(newlyAllocatedContainers, headroom,\n           preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      if (application.isWaitingForAMContainer()) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app\u0027s diagnostic message. (Naganarasimha G R via wangda)\n",
      "commitDate": "14/12/15 10:52 AM",
      "commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/11/15 2:24 AM",
      "commitNameOld": "28dfe721b86ccbaf2ddcfb7e709b226ac766803a",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 20.35,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n       List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n-      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n+      if (application.isWaitingForAMContainer()) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n       List\u003cContainer\u003e newlyAllocatedContainers \u003d\n           application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n       if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(newlyAllocatedContainers, headroom,\n           preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      if (application.isWaitingForAMContainer()) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
          "commitDate": "23/09/15 1:29 PM",
          "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
          "commitAuthor": "Jian He",
          "commitDateOld": "18/09/15 2:02 PM",
          "commitNameOld": "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 4.98,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n-      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n+      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n+      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n+      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       if (application.isWaitingForAMContainer(application.getApplicationId())) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n-      ContainersAndNMTokensAllocation allocation \u003d\n-          application.pullNewlyAllocatedContainersAndNMTokens();\n-\n+      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n+          application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n-      if (!(allocation.getContainerList().isEmpty())) {\n+      if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(allocation.getContainerList(), headroom,\n-          preemptionContainerIds, null, null, allocation.getNMTokenList());\n+      return new Allocation(newlyAllocatedContainers, headroom,\n+          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e]",
            "newValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cContainerResourceChangeRequest\u003e, decreaseRequests-List\u003cContainerResourceChangeRequest\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
          "commitDate": "23/09/15 1:29 PM",
          "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
          "commitAuthor": "Jian He",
          "commitDateOld": "18/09/15 2:02 PM",
          "commitNameOld": "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 4.98,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n-      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n+      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n+      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n+      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       if (application.isWaitingForAMContainer(application.getApplicationId())) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n-      ContainersAndNMTokensAllocation allocation \u003d\n-          application.pullNewlyAllocatedContainersAndNMTokens();\n-\n+      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n+          application.pullNewlyAllocatedContainers();\n       // Record container allocation time\n-      if (!(allocation.getContainerList().isEmpty())) {\n+      if (!(newlyAllocatedContainers.isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(allocation.getContainerList(), headroom,\n-          preemptionContainerIds, null, null, allocation.getNMTokenList());\n+      return new Allocation(newlyAllocatedContainers, headroom,\n+          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      List\u003cContainer\u003e newlyAllocatedContainers \u003d\n          application.pullNewlyAllocatedContainers();\n      // Record container allocation time\n      if (!(newlyAllocatedContainers.isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(newlyAllocatedContainers, headroom,\n          preemptionContainerIds, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "81df7b586a16f8226c7b01c139c1c70c060399c3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2005. Blacklisting support for scheduling AMs. (Anubhav Dhoot via kasha)\n",
      "commitDate": "13/09/15 5:03 PM",
      "commitName": "81df7b586a16f8226c7b01c139c1c70c060399c3",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/07/15 4:31 AM",
      "commitNameOld": "9b272ccae78918e7d756d84920a9322187d61eed",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 58.52,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,75 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n-      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n+        // Allocate is for AM and update AM blacklist for this\n+        application.updateAMBlacklist(\n+            blacklistAdditions, blacklistRemovals);\n+      } else {\n+        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+      }\n+\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n \n       // Record container allocation time\n       if (!(allocation.getContainerList().isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(allocation.getContainerList(), headroom,\n           preemptionContainerIds, null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n\n      // Record container allocation time\n      if (!(allocation.getContainerList().isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(allocation.getContainerList(), headroom,\n          preemptionContainerIds, null, null, allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3415. Non-AM containers can be counted towards amResourceUsage of a fairscheduler queue (Zhihai Xu via Sandy Ryza)\n",
      "commitDate": "02/04/15 1:56 PM",
      "commitName": "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06",
      "commitAuthor": "Sandy Ryza",
      "commitDateOld": "23/03/15 2:07 PM",
      "commitNameOld": "972f1f1ab94a26ec446a272ad030fe13f03ed442",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 9.99,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,68 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Record container allocation start time\n     application.recordContainerRequestTime(getClock().getTime());\n \n-    // Set amResource for this app\n-    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n-        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n-      application.setAMResource(ask.get(0).getCapability());\n-    }\n-\n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n \n       // Record container allocation time\n       if (!(allocation.getContainerList().isEmpty())) {\n         application.recordContainerAllocationTime(getClock().getTime());\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(allocation.getContainerList(), headroom,\n           preemptionContainerIds, null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n\n      // Record container allocation time\n      if (!(allocation.getContainerList().isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(allocation.getContainerList(), headroom,\n          preemptionContainerIds, null, null, allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "972f1f1ab94a26ec446a272ad030fe13f03ed442": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2868. FairScheduler: Metric for latency to allocate first container for an application. (Ray Chiang via kasha)\n",
      "commitDate": "23/03/15 2:07 PM",
      "commitName": "972f1f1ab94a26ec446a272ad030fe13f03ed442",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "23/03/15 1:22 PM",
      "commitNameOld": "2bc097cd14692e6ceb06bff959f28531534eb307",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,74 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n+    // Record container allocation start time\n+    application.recordContainerRequestTime(getClock().getTime());\n+\n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n-      \n+\n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n+\n+      // Record container allocation time\n+      if (!(allocation.getContainerList().isEmpty())) {\n+        application.recordContainerAllocationTime(getClock().getTime());\n+      }\n+\n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(allocation.getContainerList(), headroom,\n           preemptionContainerIds, null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Record container allocation start time\n    application.recordContainerRequestTime(getClock().getTime());\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n\n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n\n      // Record container allocation time\n      if (!(allocation.getContainerList().isEmpty())) {\n        application.recordContainerAllocationTime(getClock().getTime());\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(allocation.getContainerList(), headroom,\n          preemptionContainerIds, null, null, allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "658097d6da1b1aac8e01db459f0c3b456e99652f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3273. Improve scheduler UI to facilitate scheduling analysis and debugging. Contributed Rohith Sharmaks\n",
      "commitDate": "17/03/15 9:30 PM",
      "commitName": "658097d6da1b1aac8e01db459f0c3b456e99652f",
      "commitAuthor": "Jian He",
      "commitDateOld": "04/03/15 6:06 PM",
      "commitNameOld": "22426a1c9f4bd616558089b6862fd34ab42d19a7",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 13.1,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n-      return new Allocation(allocation.getContainerList(),\n-        application.getHeadroom(), preemptionContainerIds, null, null,\n-        allocation.getNMTokenList());\n+      Resource headroom \u003d application.getHeadroom();\n+      application.setApplicationHeadroomForMetrics(headroom);\n+      return new Allocation(allocation.getContainerList(), headroom,\n+          preemptionContainerIds, null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(allocation.getContainerList(), headroom,\n          preemptionContainerIds, null, null, allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "51881535e659940b1b332d0c5952ee1f9958cc7f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2643. Don\u0027t create a new DominantResourceCalculator on every FairScheduler.allocate call. (kasha via rkanter)\n",
      "commitDate": "12/01/15 5:51 PM",
      "commitName": "51881535e659940b1b332d0c5952ee1f9958cc7f",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "07/01/15 2:12 PM",
      "commitNameOld": "e13a484a2be64fb781c5eca5ae7056cbe194ac5e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 5.15,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,64 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n-      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n+      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n+      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n+    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n         clusterResource, minimumAllocation, getMaximumResourceCapability(),\n         incrAllocation);\n \n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
      "commitDate": "21/11/14 10:32 AM",
      "commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "14/11/14 3:18 PM",
      "commitNameOld": "1a47f890ba3cb22b6262f47c1f1af2990559bb89",
      "commitAuthorOld": "Sandy Ryza",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n-        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n+        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n+        incrAllocation);\n \n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterResource, minimumAllocation, getMaximumResourceCapability(),\n        incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2249. Avoided AM release requests being lost on work preserving RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618972 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/14 1:33 PM",
      "commitName": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "12/08/14 6:38 PM",
      "commitNameOld": "5197f8c3c53f18701f041dd2301b454930a5025b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.79,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,62 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n-    for (ContainerId releasedContainerId : release) {\n-      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n-      if (rmContainer \u003d\u003d null) {\n-        RMAuditLogger.logFailure(application.getUser(),\n-            AuditConstants.RELEASE_CONTAINER,\n-            \"Unauthorized access or invalid container\", \"FairScheduler\",\n-            \"Trying to release container not owned by app or with invalid id\",\n-            application.getApplicationId(), releasedContainerId);\n-      }\n-      completedContainer(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              releasedContainerId,\n-              SchedulerUtils.RELEASED_CONTAINER),\n-          RMContainerEventType.RELEASED);\n-    }\n+    releaseContainers(release, application);\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/08/14 7:17 AM",
      "commitNameOld": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n-    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n+    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size() +\n             \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSAppAttempt application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2274. FairScheduler: Add debug information about cluster capacity, availability and reservations. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1609942 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/14 8:10 AM",
      "commitName": "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/07/14 8:16 AM",
      "commitNameOld": "5644f529f33b49e7da8ce6fe4067c6ad5b3f2b2c",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 8.0,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Set amResource for this app\n     if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n         \u0026\u0026 application.getLiveContainers().isEmpty()) {\n       application.setAMResource(ask.get(0).getCapability());\n     }\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n-        LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"allocate:\" +\n+        LOG.debug(\"allocate: post-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n-            \" #ask\u003d\" + ask.size());\n+            \" #ask\u003d\" + ask.size() +\n+            \" reservation\u003d \" + application.getCurrentReservation());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size() +\n            \" reservation\u003d \" + application.getCurrentReservation());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "85d4c787e0f8ed913aaa61a6874ccf0408577b8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2128. FairScheduler: Incorrect calculation of amResource usage. (Wei Yan via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601050 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/14 6:21 PM",
      "commitName": "85d4c787e0f8ed913aaa61a6874ccf0408577b8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "31/05/14 12:33 PM",
      "commitNameOld": "a4ba451802c6c61a0c804809740d46dd76059f25",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.24,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,76 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n \n+    // Set amResource for this app\n+    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n+        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n+      application.setAMResource(ask.get(0).getCapability());\n+    }\n+\n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Set amResource for this app\n    if (!application.getUnmanagedAM() \u0026\u0026 ask.size() \u003d\u003d 1\n        \u0026\u0026 application.getLiveContainers().isEmpty()) {\n      application.setAMResource(ask.get(0).getCapability());\n    }\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n-        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n+        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), preemptionContainerIds, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterResource, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "5fd5c9900cfd299428acbc8dff767273e44647c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-713. Fixed ResourceManager to not crash while building tokens when DNS issues happen transmittently. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1569979 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/02/14 3:39 PM",
      "commitName": "5fd5c9900cfd299428acbc8dff767273e44647c0",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/02/14 10:00 AM",
      "commitNameOld": "bbbe808a511b8d84964e11e5818811734e2493bd",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,70 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-      \n-      return new Allocation(application.pullNewlyAllocatedContainers(),\n-          application.getHeadroom(), preemptionContainerIds);\n+      ContainersAndNMTokensAllocation allocation \u003d\n+          application.pullNewlyAllocatedContainersAndNMTokens();\n+      return new Allocation(allocation.getContainerList(),\n+        application.getHeadroom(), preemptionContainerIds, null, null,\n+        allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), preemptionContainerIds, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n-    FSSchedulerApp application \u003d appAttempts.get(appAttemptId);\n+    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d getSchedulerApp(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/12/13 5:44 PM",
      "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 20.77,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n-    FSSchedulerApp application \u003d applications.get(appAttemptId);\n+    FSSchedulerApp application \u003d appAttempts.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d appAttempts.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "025f1719472282a30aa26ae3e235e404f04ba932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1333. Support blacklisting in the Fair Scheduler (Tsuyoshi Ozawa via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1535899 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/13 5:27 PM",
      "commitName": "025f1719472282a30aa26ae3e235e404f04ba932",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "10/10/13 3:49 PM",
      "commitNameOld": "f218527fff9faa45e9399f716cc41dcad19b9029",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 15.07,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n+\n+      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "b9753e509ce2487aa71174d2dab440c33c6a17a4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-789. Enable zero capabilities resource requests in fair scheduler. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493219 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/06/13 12:16 PM",
      "commitName": "b9753e509ce2487aa71174d2dab440c33c6a17a4",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "14/06/13 10:07 AM",
      "commitNameOld": "334de8d21189109dcd2423d13fab56477980872b",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n-        clusterCapacity, minimumAllocation, maximumAllocation);\n+        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n       \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation, incrAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/13 11:46 AM",
      "commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "03/06/13 10:33 AM",
      "commitNameOld": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 3.05,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n-      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n+      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n         clusterCapacity, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n       \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e]",
        "newValue": "[appAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e]"
      }
    },
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": {
      "type": "Ybodychange",
      "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:33 AM",
      "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/05/13 3:15 PM",
      "commitNameOld": "51ccb87031eda6a2b75be098a88f1d89ea82c610",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 24.8,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask, minimumAllocation.getMemory(),\n-        maximumAllocation.getMemory());\n+    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n+        clusterCapacity, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n \n         LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n             + \" container(s)\");\n       }\n       \n       Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n       for (RMContainer container : application.getPreemptionContainers()) {\n         preemptionContainerIds.add(container.getContainerId());\n       }\n       \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, new DominantResourceCalculator(),\n        clusterCapacity, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-568. Add support for work preserving preemption to the FairScheduler.\nContributed by Carlo Curino and Sandy Ryza\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480778 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 2:21 PM",
      "commitName": "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "25/04/13 2:15 AM",
      "commitNameOld": "d10428cab26c4c75328ecca118744041f2848251",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 14.5,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,66 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask, minimumAllocation.getMemory(),\n         maximumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n-      }\n \n+        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n+            + \" container(s)\");\n+      }\n+      \n+      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n+      for (RMContainer container : application.getPreemptionContainers()) {\n+        preemptionContainerIds.add(container.getContainerId());\n+      }\n+      \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n-          application.getHeadroom());\n+          application.getHeadroom(), preemptionContainerIds);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask, minimumAllocation.getMemory(),\n        maximumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n\n        LOG.debug(\"Preempting \" + application.getPreemptionContainers().size()\n            + \" container(s)\");\n      }\n      \n      Set\u003cContainerId\u003e preemptionContainerIds \u003d new HashSet\u003cContainerId\u003e();\n      for (RMContainer container : application.getPreemptionContainers()) {\n        preemptionContainerIds.add(container.getContainerId());\n      }\n      \n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom(), preemptionContainerIds);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "bc6777dd5bdcbaef09897b506bc6511ae456033d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-193. Scheduler.normalizeRequest does not account for allocation requests that exceed maximumAllocation limits (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465067 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/04/13 10:45 AM",
      "commitName": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "27/03/13 7:42 AM",
      "commitNameOld": "414458ff9dd1f8f2e3e0b9079eabbc8c391222a2",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 9.13,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,58 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask, minimumAllocation.getMemory());\n+    normalizeRequests(ask, minimumAllocation.getMemory(),\n+        maximumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask, minimumAllocation.getMemory(),\n        maximumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "03/01/13 7:07 AM",
      "commitNameOld": "0768f96a833c16bf6136253d9ed846c72c4565bc",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n \n     // Make sure this application exists\n     FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n+    normalizeRequests(ask, minimumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n               \" applicationAttemptId\u003d\" + appAttemptId +\n               \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n        RMAuditLogger.logFailure(application.getUser(),\n            AuditConstants.RELEASE_CONTAINER,\n            \"Unauthorized access or invalid container\", \"FairScheduler\",\n            \"Trying to release container not owned by app or with invalid id\",\n            application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n              \" applicationAttemptId\u003d\" + appAttemptId +\n              \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      if (!ask.isEmpty()) {\n\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n          \" applicationAttemptId\u003d\" + appAttemptId +\n          \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(),\n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/07/12 5:43 PM",
      "commitNameOld": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public Allocation allocate(ApplicationAttemptId appAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n \n     // Make sure this application exists\n-    SchedulerApp application \u003d applications.get(appAttemptId);\n+    FSSchedulerApp application \u003d applications.get(appAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.info(\"Calling allocate on removed \" +\n           \"or non existant application \" + appAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainerId : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER,\n              \"Unauthorized access or invalid container\", \"FairScheduler\",\n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainerId);\n       }\n       completedContainer(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainerId,\n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       if (!ask.isEmpty()) {\n \n         if(LOG.isDebugEnabled()) {\n           LOG.debug(\"allocate: pre-update\" +\n             \" applicationAttemptId\u003d\" + appAttemptId +\n             \" application\u003d\" + application.getApplicationId());\n         }\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\");\n         application.showRequests();\n       }\n \n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"allocate:\" +\n           \" applicationAttemptId\u003d\" + appAttemptId +\n           \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(),\n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    FSSchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      if (!ask.isEmpty()) {\n\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n          \" applicationAttemptId\u003d\" + appAttemptId +\n          \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(),\n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,60 @@\n+  public Allocation allocate(ApplicationAttemptId appAttemptId,\n+      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n+\n+    // Make sure this application exists\n+    SchedulerApp application \u003d applications.get(appAttemptId);\n+    if (application \u003d\u003d null) {\n+      LOG.info(\"Calling allocate on removed \" +\n+          \"or non existant application \" + appAttemptId);\n+      return EMPTY_ALLOCATION;\n+    }\n+\n+    // Sanity check\n+    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n+\n+    // Release containers\n+    for (ContainerId releasedContainerId : release) {\n+      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n+      if (rmContainer \u003d\u003d null) {\n+         RMAuditLogger.logFailure(application.getUser(),\n+             AuditConstants.RELEASE_CONTAINER,\n+             \"Unauthorized access or invalid container\", \"FairScheduler\",\n+             \"Trying to release container not owned by app or with invalid id\",\n+             application.getApplicationId(), releasedContainerId);\n+      }\n+      completedContainer(rmContainer,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              releasedContainerId,\n+              SchedulerUtils.RELEASED_CONTAINER),\n+          RMContainerEventType.RELEASED);\n+    }\n+\n+    synchronized (application) {\n+\n+      if (!ask.isEmpty()) {\n+\n+        if(LOG.isDebugEnabled()) {\n+          LOG.debug(\"allocate: pre-update\" +\n+            \" applicationAttemptId\u003d\" + appAttemptId +\n+            \" application\u003d\" + application.getApplicationId());\n+        }\n+        application.showRequests();\n+\n+        // Update application requests\n+        application.updateResourceRequests(ask);\n+\n+        LOG.debug(\"allocate: post-update\");\n+        application.showRequests();\n+      }\n+\n+      if(LOG.isDebugEnabled()) {\n+        LOG.debug(\"allocate:\" +\n+          \" applicationAttemptId\u003d\" + appAttemptId +\n+          \" #ask\u003d\" + ask.size());\n+      }\n+\n+      return new Allocation(\n+          application.pullNewlyAllocatedContainers(),\n+          application.getHeadroom());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(ApplicationAttemptId appAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release) {\n\n    // Make sure this application exists\n    SchedulerApp application \u003d applications.get(appAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.info(\"Calling allocate on removed \" +\n          \"or non existant application \" + appAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainerId : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainerId);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER,\n             \"Unauthorized access or invalid container\", \"FairScheduler\",\n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainerId);\n      }\n      completedContainer(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainerId,\n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      if (!ask.isEmpty()) {\n\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"allocate: pre-update\" +\n            \" applicationAttemptId\u003d\" + appAttemptId +\n            \" application\u003d\" + application.getApplicationId());\n        }\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\");\n        application.showRequests();\n      }\n\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate:\" +\n          \" applicationAttemptId\u003d\" + appAttemptId +\n          \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(),\n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}