{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AppPriorityACLConfigurationParser.java",
  "functionName": "getPriorityAcl",
  "functionId": "getPriorityAcl___clusterMaxPriority-Priority__aclString-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AppPriorityACLConfigurationParser.java",
  "functionStartLine": 65,
  "functionEndLine": 127,
  "numCommitsSeen": 2,
  "timeTaken": 1196,
  "changeHistory": [
    "287d3d6804a869723ae36605a3c2d2b3eae3941e"
  ],
  "changeHistoryShort": {
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
      "commitDate": "09/01/17 8:40 AM",
      "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,63 @@\n+  public List\u003cAppPriorityACLGroup\u003e getPriorityAcl(Priority clusterMaxPriority,\n+      String aclString) {\n+\n+    List\u003cAppPriorityACLGroup\u003e aclList \u003d new ArrayList\u003cAppPriorityACLGroup\u003e();\n+    Matcher matcher \u003d Pattern.compile(PATTERN_FOR_PRIORITY_ACL)\n+        .matcher(aclString);\n+\n+    /*\n+     * Each ACL group will be separated by \"[]\". Syntax of each ACL group could\n+     * be like below \"user\u003db1,b2 group\u003dg1 max-priority\u003da2 default-priority\u003da1\"\n+     * Ideally this means \"for this given user/group, maximum possible priority\n+     * is a2 and if the user has not specified any priority, then it is a1.\"\n+     */\n+    while (matcher.find()) {\n+      // Get the first ACL sub-group.\n+      String aclSubGroup \u003d matcher.group(1);\n+      if (aclSubGroup.trim().isEmpty()) {\n+        continue;\n+      }\n+\n+      /*\n+       * Internal storage is PriorityACLGroup which stores each parsed priority\n+       * ACLs group. This will help while looking for a user to priority mapping\n+       * during app submission time. ACLs will be passed in below order only. 1.\n+       * user/group 2. max-priority 3. default-priority\n+       */\n+      AppPriorityACLGroup userPriorityACL \u003d new AppPriorityACLGroup();\n+\n+      // userAndGroupName will hold user acl and group acl as interim storage\n+      // since both user/group acl comes with separate key value pairs.\n+      List\u003cStringBuilder\u003e userAndGroupName \u003d new ArrayList\u003c\u003e();\n+\n+      for (String kvPair : aclSubGroup.trim().split(\" +\")) {\n+        /*\n+         * There are 3 possible options for key here: 1. user/group 2.\n+         * max-priority 3. default-priority\n+         */\n+        String[] splits \u003d kvPair.split(\"\u003d\");\n+\n+        // Ensure that each ACL sub string is key value pair separated by \u0027\u003d\u0027.\n+        if (splits !\u003d null \u0026\u0026 splits.length \u003e 1) {\n+          parsePriorityACLType(userPriorityACL, splits, userAndGroupName);\n+        }\n+      }\n+\n+      // If max_priority is higher to clusterMaxPriority, its better to\n+      // handle here.\n+      if (userPriorityACL.getMaxPriority().getPriority() \u003e clusterMaxPriority\n+          .getPriority()) {\n+        LOG.warn(\"ACL configuration for \u0027\" + userPriorityACL.getMaxPriority()\n+            + \"\u0027 is greater that cluster max priority. Resetting ACLs to \"\n+            + clusterMaxPriority);\n+        userPriorityACL.setMaxPriority(\n+            Priority.newInstance(clusterMaxPriority.getPriority()));\n+      }\n+\n+      AccessControlList acl \u003d createACLStringForPriority(userAndGroupName);\n+      userPriorityACL.setACLList(acl);\n+      aclList.add(userPriorityACL);\n+    }\n+\n+    return aclList;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cAppPriorityACLGroup\u003e getPriorityAcl(Priority clusterMaxPriority,\n      String aclString) {\n\n    List\u003cAppPriorityACLGroup\u003e aclList \u003d new ArrayList\u003cAppPriorityACLGroup\u003e();\n    Matcher matcher \u003d Pattern.compile(PATTERN_FOR_PRIORITY_ACL)\n        .matcher(aclString);\n\n    /*\n     * Each ACL group will be separated by \"[]\". Syntax of each ACL group could\n     * be like below \"user\u003db1,b2 group\u003dg1 max-priority\u003da2 default-priority\u003da1\"\n     * Ideally this means \"for this given user/group, maximum possible priority\n     * is a2 and if the user has not specified any priority, then it is a1.\"\n     */\n    while (matcher.find()) {\n      // Get the first ACL sub-group.\n      String aclSubGroup \u003d matcher.group(1);\n      if (aclSubGroup.trim().isEmpty()) {\n        continue;\n      }\n\n      /*\n       * Internal storage is PriorityACLGroup which stores each parsed priority\n       * ACLs group. This will help while looking for a user to priority mapping\n       * during app submission time. ACLs will be passed in below order only. 1.\n       * user/group 2. max-priority 3. default-priority\n       */\n      AppPriorityACLGroup userPriorityACL \u003d new AppPriorityACLGroup();\n\n      // userAndGroupName will hold user acl and group acl as interim storage\n      // since both user/group acl comes with separate key value pairs.\n      List\u003cStringBuilder\u003e userAndGroupName \u003d new ArrayList\u003c\u003e();\n\n      for (String kvPair : aclSubGroup.trim().split(\" +\")) {\n        /*\n         * There are 3 possible options for key here: 1. user/group 2.\n         * max-priority 3. default-priority\n         */\n        String[] splits \u003d kvPair.split(\"\u003d\");\n\n        // Ensure that each ACL sub string is key value pair separated by \u0027\u003d\u0027.\n        if (splits !\u003d null \u0026\u0026 splits.length \u003e 1) {\n          parsePriorityACLType(userPriorityACL, splits, userAndGroupName);\n        }\n      }\n\n      // If max_priority is higher to clusterMaxPriority, its better to\n      // handle here.\n      if (userPriorityACL.getMaxPriority().getPriority() \u003e clusterMaxPriority\n          .getPriority()) {\n        LOG.warn(\"ACL configuration for \u0027\" + userPriorityACL.getMaxPriority()\n            + \"\u0027 is greater that cluster max priority. Resetting ACLs to \"\n            + clusterMaxPriority);\n        userPriorityACL.setMaxPriority(\n            Priority.newInstance(clusterMaxPriority.getPriority()));\n      }\n\n      AccessControlList acl \u003d createACLStringForPriority(userAndGroupName);\n      userPriorityACL.setACLList(acl);\n      aclList.add(userPriorityACL);\n    }\n\n    return aclList;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AppPriorityACLConfigurationParser.java"
    }
  }
}