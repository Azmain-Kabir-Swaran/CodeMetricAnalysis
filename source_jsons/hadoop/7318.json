{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StandbyCheckpointer.java",
  "functionName": "doCheckpoint",
  "functionId": "doCheckpoint",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
  "functionStartLine": 194,
  "functionEndLine": 347,
  "numCommitsSeen": 97,
  "timeTaken": 9427,
  "changeHistory": [
    "65c4660bcd897e139fc175ca438cff75ec0c6be8",
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "bb6a3c83305f97090f980c53adaaf37baf18c698",
    "d9014bda93760f223789d2ec9f5e35f40de157d4",
    "d8a33098309f17dfb0e3a000934f68394de44bf7",
    "e0fa49234fd37aca88e1caa95bac77bca192bae4",
    "2536ece7b67ccfeac44314615a5f9dbe771ce373",
    "49dfad942970459297f72632ed8dfd353e0c86de",
    "f43a20c529ac3f104add95b222de6580757b3763",
    "97f58955a6045b373ab73653bf26ab5922b00cf3",
    "01af3a31772ee820e932ac70973072e9509a30fa",
    "94a1632fcb677fda6f4d812614026417f1d0a360",
    "dbd22b23c2d68b97b4da47215897906f06f978e3",
    "0f595915a388305edbb3ce928415571811d304e8",
    "90b399c4bd1d7a7856a7b9230fa1437a30b4eb88",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
    "49a892056df7d73207f7a65ae5b4b905ba5e6ab8",
    "15ddb6634f8bdab37ce43f99f8338d84422c7232",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae"
  ],
  "changeHistoryShort": {
    "65c4660bcd897e139fc175ca438cff75ec0c6be8": "Ybodychange",
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a": "Ymultichange(Yparameterchange,Ybodychange)",
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "bb6a3c83305f97090f980c53adaaf37baf18c698": "Ybodychange",
    "d9014bda93760f223789d2ec9f5e35f40de157d4": "Ybodychange",
    "d8a33098309f17dfb0e3a000934f68394de44bf7": "Ybodychange",
    "e0fa49234fd37aca88e1caa95bac77bca192bae4": "Ybodychange",
    "2536ece7b67ccfeac44314615a5f9dbe771ce373": "Ybodychange",
    "49dfad942970459297f72632ed8dfd353e0c86de": "Ymultichange(Yparameterchange,Ybodychange)",
    "f43a20c529ac3f104add95b222de6580757b3763": "Ybodychange",
    "97f58955a6045b373ab73653bf26ab5922b00cf3": "Ybodychange",
    "01af3a31772ee820e932ac70973072e9509a30fa": "Ybodychange",
    "94a1632fcb677fda6f4d812614026417f1d0a360": "Ybodychange",
    "dbd22b23c2d68b97b4da47215897906f06f978e3": "Ybodychange",
    "0f595915a388305edbb3ce928415571811d304e8": "Ybodychange",
    "90b399c4bd1d7a7856a7b9230fa1437a30b4eb88": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": "Ybodychange",
    "49a892056df7d73207f7a65ae5b4b905ba5e6ab8": "Ybodychange",
    "15ddb6634f8bdab37ce43f99f8338d84422c7232": "Ybodychange",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": "Yintroduced"
  },
  "changeHistoryDetails": {
    "65c4660bcd897e139fc175ca438cff75ec0c6be8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15036. Active NameNode should not silently fail the image transfer. Contributed by Chen Liang.\n",
      "commitDate": "12/12/19 10:22 AM",
      "commitName": "65c4660bcd897e139fc175ca438cff75ec0c6be8",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "17/07/19 2:37 PM",
      "commitNameOld": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 147.86,
      "commitsBetweenForRepo": 996,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,154 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid {}. \" +\n             \"Skipping...\", thisCheckpointTxId);\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         try {\n           img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n         } catch (IOException ioe) {\n           LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                   + \"continuing with other checkpointing steps\", ioe);\n         }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     HashMap\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new HashMap\u003c\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       // Upload image if at least 1 of 2 following conditions met:\n       // 1. has been quiet for long enough, try to contact the node.\n       // 2. this standby IS the primary checkpointer of target NN.\n       String addressString \u003d activeNNAddress.toString();\n       assert checkpointReceivers.containsKey(addressString);\n       CheckpointReceiverEntry receiverEntry \u003d\n           checkpointReceivers.get(addressString);\n       long secsSinceLastUpload \u003d\n           TimeUnit.MILLISECONDS.toSeconds(\n               monotonicNow() - receiverEntry.getLastUploadTime());\n       boolean shouldUpload \u003d receiverEntry.isPrimary() ||\n           secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n       if (shouldUpload) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n             executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n               @Override\n               public TransferFsImage.TransferResult call()\n                   throws IOException, InterruptedException {\n                 CheckpointFaultInjector.getInstance().duringUploadInProgess();\n                 return TransferFsImage.uploadImageFromStorage(activeNNAddress,\n                     conf, namesystem.getFSImage().getStorage(), imageType, txid,\n                     canceler);\n               }\n             });\n         uploads.put(addressString, upload);\n       }\n     }\n     InterruptedException ie \u003d null;\n     List\u003cIOException\u003e ioes \u003d Lists.newArrayList();\n     for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n         uploads.entrySet()) {\n       String url \u003d entry.getKey();\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n       try {\n         // TODO should there be some smarts here about retries nodes that\n         //  are not the active NN?\n         CheckpointReceiverEntry receiverEntry \u003d checkpointReceivers.get(url);\n-        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n+        TransferFsImage.TransferResult uploadResult \u003d upload.get();\n+        if (uploadResult \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           receiverEntry.setLastUploadTime(monotonicNow());\n           receiverEntry.setIsPrimary(true);\n         } else {\n+          // Getting here means image upload is explicitly rejected\n+          // by the other node. This could happen if:\n+          // 1. the other is also a standby, or\n+          // 2. the other is active, but already accepted another\n+          // newer image, or\n+          // 3. the other is active but has a recent enough image.\n+          // All these are valid cases, just log for information.\n+          LOG.info(\"Image upload rejected by the other NameNode: {}\",\n+              uploadResult);\n           receiverEntry.setIsPrimary(false);\n         }\n       } catch (ExecutionException e) {\n         // Even if exception happens, still proceeds to next NN url.\n         // so that fail to upload to previous NN does not cause the\n         // remaining NN not getting the fsImage.\n         ioes.add(new IOException(\"Exception during image upload\", e));\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n           uploads.entrySet()) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       throw ie;\n     }\n \n     if (!ioes.isEmpty()) {\n       throw MultipleIOException.createIOException(ioes);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid {}. \" +\n            \"Skipping...\", thisCheckpointTxId);\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    HashMap\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new HashMap\u003c\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      // Upload image if at least 1 of 2 following conditions met:\n      // 1. has been quiet for long enough, try to contact the node.\n      // 2. this standby IS the primary checkpointer of target NN.\n      String addressString \u003d activeNNAddress.toString();\n      assert checkpointReceivers.containsKey(addressString);\n      CheckpointReceiverEntry receiverEntry \u003d\n          checkpointReceivers.get(addressString);\n      long secsSinceLastUpload \u003d\n          TimeUnit.MILLISECONDS.toSeconds(\n              monotonicNow() - receiverEntry.getLastUploadTime());\n      boolean shouldUpload \u003d receiverEntry.isPrimary() ||\n          secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n      if (shouldUpload) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n            executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n              @Override\n              public TransferFsImage.TransferResult call()\n                  throws IOException, InterruptedException {\n                CheckpointFaultInjector.getInstance().duringUploadInProgess();\n                return TransferFsImage.uploadImageFromStorage(activeNNAddress,\n                    conf, namesystem.getFSImage().getStorage(), imageType, txid,\n                    canceler);\n              }\n            });\n        uploads.put(addressString, upload);\n      }\n    }\n    InterruptedException ie \u003d null;\n    List\u003cIOException\u003e ioes \u003d Lists.newArrayList();\n    for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n        uploads.entrySet()) {\n      String url \u003d entry.getKey();\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n      try {\n        // TODO should there be some smarts here about retries nodes that\n        //  are not the active NN?\n        CheckpointReceiverEntry receiverEntry \u003d checkpointReceivers.get(url);\n        TransferFsImage.TransferResult uploadResult \u003d upload.get();\n        if (uploadResult \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          receiverEntry.setLastUploadTime(monotonicNow());\n          receiverEntry.setIsPrimary(true);\n        } else {\n          // Getting here means image upload is explicitly rejected\n          // by the other node. This could happen if:\n          // 1. the other is also a standby, or\n          // 2. the other is active, but already accepted another\n          // newer image, or\n          // 3. the other is active but has a recent enough image.\n          // All these are valid cases, just log for information.\n          LOG.info(\"Image upload rejected by the other NameNode: {}\",\n              uploadResult);\n          receiverEntry.setIsPrimary(false);\n        }\n      } catch (ExecutionException e) {\n        // Even if exception happens, still proceeds to next NN url.\n        // so that fail to upload to previous NN does not cause the\n        // remaining NN not getting the fsImage.\n        ioes.add(new IOException(\"Exception during image upload\", e));\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n          uploads.entrySet()) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      throw ie;\n    }\n\n    if (!ioes.isEmpty()) {\n      throw MultipleIOException.createIOException(ioes);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12979. [SBN read] StandbyNode should upload FsImage to ObserverNode after checkpointing. Contributed by Chen Liang.\n",
      "commitDate": "17/07/19 2:37 PM",
      "commitName": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
      "commitAuthor": "Chen Liang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12979. [SBN read] StandbyNode should upload FsImage to ObserverNode after checkpointing. Contributed by Chen Liang.\n",
          "commitDate": "17/07/19 2:37 PM",
          "commitName": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
          "commitAuthor": "Chen Liang",
          "commitDateOld": "14/02/18 8:20 AM",
          "commitNameOld": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 518.22,
          "commitsBetweenForRepo": 4504,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,135 +1,144 @@\n-  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n+  private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid {}. \" +\n             \"Skipping...\", thisCheckpointTxId);\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         try {\n           img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n         } catch (IOException ioe) {\n           LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                   + \"continuing with other checkpointing steps\", ioe);\n         }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n-    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n-    if(!sendCheckpoint){\n-      return;\n-    }\n-\n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n-    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n-        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n+    HashMap\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n+        new HashMap\u003c\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n-      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n-          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n-            @Override\n-            public TransferFsImage.TransferResult call()\n-                throws IOException, InterruptedException {\n-              CheckpointFaultInjector.getInstance().duringUploadInProgess();\n-              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n-                  .getFSImage().getStorage(), imageType, txid, canceler);\n-            }\n-          });\n-      uploads.add(upload);\n+      // Upload image if at least 1 of 2 following conditions met:\n+      // 1. has been quiet for long enough, try to contact the node.\n+      // 2. this standby IS the primary checkpointer of target NN.\n+      String addressString \u003d activeNNAddress.toString();\n+      assert checkpointReceivers.containsKey(addressString);\n+      CheckpointReceiverEntry receiverEntry \u003d\n+          checkpointReceivers.get(addressString);\n+      long secsSinceLastUpload \u003d\n+          TimeUnit.MILLISECONDS.toSeconds(\n+              monotonicNow() - receiverEntry.getLastUploadTime());\n+      boolean shouldUpload \u003d receiverEntry.isPrimary() ||\n+          secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n+      if (shouldUpload) {\n+        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n+            executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n+              @Override\n+              public TransferFsImage.TransferResult call()\n+                  throws IOException, InterruptedException {\n+                CheckpointFaultInjector.getInstance().duringUploadInProgess();\n+                return TransferFsImage.uploadImageFromStorage(activeNNAddress,\n+                    conf, namesystem.getFSImage().getStorage(), imageType, txid,\n+                    canceler);\n+              }\n+            });\n+        uploads.put(addressString, upload);\n+      }\n     }\n     InterruptedException ie \u003d null;\n-    IOException ioe\u003d null;\n-    int i \u003d 0;\n-    boolean success \u003d false;\n-    for (; i \u003c uploads.size(); i++) {\n-      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+    List\u003cIOException\u003e ioes \u003d Lists.newArrayList();\n+    for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n+        uploads.entrySet()) {\n+      String url \u003d entry.getKey();\n+      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n       try {\n-        // TODO should there be some smarts here about retries nodes that are not the active NN?\n+        // TODO should there be some smarts here about retries nodes that\n+        //  are not the active NN?\n+        CheckpointReceiverEntry receiverEntry \u003d checkpointReceivers.get(url);\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n-          success \u003d true;\n-          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n-          break;\n+          receiverEntry.setLastUploadTime(monotonicNow());\n+          receiverEntry.setIsPrimary(true);\n+        } else {\n+          receiverEntry.setIsPrimary(false);\n         }\n-\n       } catch (ExecutionException e) {\n-        ioe \u003d new IOException(\"Exception during image upload\", e);\n-        break;\n+        // Even if exception happens, still proceeds to next NN url.\n+        // so that fail to upload to previous NN does not cause the\n+        // remaining NN not getting the fsImage.\n+        ioes.add(new IOException(\"Exception during image upload\", e));\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n-    if (ie \u003d\u003d null \u0026\u0026 ioe \u003d\u003d null) {\n-      //Update only when response from remote about success or\n-      lastUploadTime \u003d monotonicNow();\n-      // we are primary if we successfully updated the ANN\n-      this.isPrimaryCheckPointer \u003d success;\n-    }\n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n-    if (ie !\u003d null || ioe !\u003d null) {\n+    if (ie !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n-      for (; i \u003c uploads.size(); i++) {\n-        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+      for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n+          uploads.entrySet()) {\n+        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n-      if (ie !\u003d null) {\n-        throw ie;\n-      } else if (ioe !\u003d null) {\n-        throw ioe;\n-      }\n+      throw ie;\n+    }\n+\n+    if (!ioes.isEmpty()) {\n+      throw MultipleIOException.createIOException(ioes);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid {}. \" +\n            \"Skipping...\", thisCheckpointTxId);\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    HashMap\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new HashMap\u003c\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      // Upload image if at least 1 of 2 following conditions met:\n      // 1. has been quiet for long enough, try to contact the node.\n      // 2. this standby IS the primary checkpointer of target NN.\n      String addressString \u003d activeNNAddress.toString();\n      assert checkpointReceivers.containsKey(addressString);\n      CheckpointReceiverEntry receiverEntry \u003d\n          checkpointReceivers.get(addressString);\n      long secsSinceLastUpload \u003d\n          TimeUnit.MILLISECONDS.toSeconds(\n              monotonicNow() - receiverEntry.getLastUploadTime());\n      boolean shouldUpload \u003d receiverEntry.isPrimary() ||\n          secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n      if (shouldUpload) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n            executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n              @Override\n              public TransferFsImage.TransferResult call()\n                  throws IOException, InterruptedException {\n                CheckpointFaultInjector.getInstance().duringUploadInProgess();\n                return TransferFsImage.uploadImageFromStorage(activeNNAddress,\n                    conf, namesystem.getFSImage().getStorage(), imageType, txid,\n                    canceler);\n              }\n            });\n        uploads.put(addressString, upload);\n      }\n    }\n    InterruptedException ie \u003d null;\n    List\u003cIOException\u003e ioes \u003d Lists.newArrayList();\n    for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n        uploads.entrySet()) {\n      String url \u003d entry.getKey();\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n      try {\n        // TODO should there be some smarts here about retries nodes that\n        //  are not the active NN?\n        CheckpointReceiverEntry receiverEntry \u003d checkpointReceivers.get(url);\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          receiverEntry.setLastUploadTime(monotonicNow());\n          receiverEntry.setIsPrimary(true);\n        } else {\n          receiverEntry.setIsPrimary(false);\n        }\n      } catch (ExecutionException e) {\n        // Even if exception happens, still proceeds to next NN url.\n        // so that fail to upload to previous NN does not cause the\n        // remaining NN not getting the fsImage.\n        ioes.add(new IOException(\"Exception during image upload\", e));\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n          uploads.entrySet()) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      throw ie;\n    }\n\n    if (!ioes.isEmpty()) {\n      throw MultipleIOException.createIOException(ioes);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
          "extendedDetails": {
            "oldValue": "[sendCheckpoint-boolean]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12979. [SBN read] StandbyNode should upload FsImage to ObserverNode after checkpointing. Contributed by Chen Liang.\n",
          "commitDate": "17/07/19 2:37 PM",
          "commitName": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
          "commitAuthor": "Chen Liang",
          "commitDateOld": "14/02/18 8:20 AM",
          "commitNameOld": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 518.22,
          "commitsBetweenForRepo": 4504,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,135 +1,144 @@\n-  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n+  private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid {}. \" +\n             \"Skipping...\", thisCheckpointTxId);\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         try {\n           img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n         } catch (IOException ioe) {\n           LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                   + \"continuing with other checkpointing steps\", ioe);\n         }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n-    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n-    if(!sendCheckpoint){\n-      return;\n-    }\n-\n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n-    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n-        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n+    HashMap\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n+        new HashMap\u003c\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n-      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n-          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n-            @Override\n-            public TransferFsImage.TransferResult call()\n-                throws IOException, InterruptedException {\n-              CheckpointFaultInjector.getInstance().duringUploadInProgess();\n-              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n-                  .getFSImage().getStorage(), imageType, txid, canceler);\n-            }\n-          });\n-      uploads.add(upload);\n+      // Upload image if at least 1 of 2 following conditions met:\n+      // 1. has been quiet for long enough, try to contact the node.\n+      // 2. this standby IS the primary checkpointer of target NN.\n+      String addressString \u003d activeNNAddress.toString();\n+      assert checkpointReceivers.containsKey(addressString);\n+      CheckpointReceiverEntry receiverEntry \u003d\n+          checkpointReceivers.get(addressString);\n+      long secsSinceLastUpload \u003d\n+          TimeUnit.MILLISECONDS.toSeconds(\n+              monotonicNow() - receiverEntry.getLastUploadTime());\n+      boolean shouldUpload \u003d receiverEntry.isPrimary() ||\n+          secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n+      if (shouldUpload) {\n+        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n+            executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n+              @Override\n+              public TransferFsImage.TransferResult call()\n+                  throws IOException, InterruptedException {\n+                CheckpointFaultInjector.getInstance().duringUploadInProgess();\n+                return TransferFsImage.uploadImageFromStorage(activeNNAddress,\n+                    conf, namesystem.getFSImage().getStorage(), imageType, txid,\n+                    canceler);\n+              }\n+            });\n+        uploads.put(addressString, upload);\n+      }\n     }\n     InterruptedException ie \u003d null;\n-    IOException ioe\u003d null;\n-    int i \u003d 0;\n-    boolean success \u003d false;\n-    for (; i \u003c uploads.size(); i++) {\n-      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+    List\u003cIOException\u003e ioes \u003d Lists.newArrayList();\n+    for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n+        uploads.entrySet()) {\n+      String url \u003d entry.getKey();\n+      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n       try {\n-        // TODO should there be some smarts here about retries nodes that are not the active NN?\n+        // TODO should there be some smarts here about retries nodes that\n+        //  are not the active NN?\n+        CheckpointReceiverEntry receiverEntry \u003d checkpointReceivers.get(url);\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n-          success \u003d true;\n-          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n-          break;\n+          receiverEntry.setLastUploadTime(monotonicNow());\n+          receiverEntry.setIsPrimary(true);\n+        } else {\n+          receiverEntry.setIsPrimary(false);\n         }\n-\n       } catch (ExecutionException e) {\n-        ioe \u003d new IOException(\"Exception during image upload\", e);\n-        break;\n+        // Even if exception happens, still proceeds to next NN url.\n+        // so that fail to upload to previous NN does not cause the\n+        // remaining NN not getting the fsImage.\n+        ioes.add(new IOException(\"Exception during image upload\", e));\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n-    if (ie \u003d\u003d null \u0026\u0026 ioe \u003d\u003d null) {\n-      //Update only when response from remote about success or\n-      lastUploadTime \u003d monotonicNow();\n-      // we are primary if we successfully updated the ANN\n-      this.isPrimaryCheckPointer \u003d success;\n-    }\n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n-    if (ie !\u003d null || ioe !\u003d null) {\n+    if (ie !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n-      for (; i \u003c uploads.size(); i++) {\n-        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+      for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n+          uploads.entrySet()) {\n+        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n-      if (ie !\u003d null) {\n-        throw ie;\n-      } else if (ioe !\u003d null) {\n-        throw ioe;\n-      }\n+      throw ie;\n+    }\n+\n+    if (!ioes.isEmpty()) {\n+      throw MultipleIOException.createIOException(ioes);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid {}. \" +\n            \"Skipping...\", thisCheckpointTxId);\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    HashMap\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new HashMap\u003c\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      // Upload image if at least 1 of 2 following conditions met:\n      // 1. has been quiet for long enough, try to contact the node.\n      // 2. this standby IS the primary checkpointer of target NN.\n      String addressString \u003d activeNNAddress.toString();\n      assert checkpointReceivers.containsKey(addressString);\n      CheckpointReceiverEntry receiverEntry \u003d\n          checkpointReceivers.get(addressString);\n      long secsSinceLastUpload \u003d\n          TimeUnit.MILLISECONDS.toSeconds(\n              monotonicNow() - receiverEntry.getLastUploadTime());\n      boolean shouldUpload \u003d receiverEntry.isPrimary() ||\n          secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n      if (shouldUpload) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n            executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n              @Override\n              public TransferFsImage.TransferResult call()\n                  throws IOException, InterruptedException {\n                CheckpointFaultInjector.getInstance().duringUploadInProgess();\n                return TransferFsImage.uploadImageFromStorage(activeNNAddress,\n                    conf, namesystem.getFSImage().getStorage(), imageType, txid,\n                    canceler);\n              }\n            });\n        uploads.put(addressString, upload);\n      }\n    }\n    InterruptedException ie \u003d null;\n    List\u003cIOException\u003e ioes \u003d Lists.newArrayList();\n    for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n        uploads.entrySet()) {\n      String url \u003d entry.getKey();\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n      try {\n        // TODO should there be some smarts here about retries nodes that\n        //  are not the active NN?\n        CheckpointReceiverEntry receiverEntry \u003d checkpointReceivers.get(url);\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          receiverEntry.setLastUploadTime(monotonicNow());\n          receiverEntry.setIsPrimary(true);\n        } else {\n          receiverEntry.setIsPrimary(false);\n        }\n      } catch (ExecutionException e) {\n        // Even if exception happens, still proceeds to next NN url.\n        // so that fail to upload to previous NN does not cause the\n        // remaining NN not getting the fsImage.\n        ioes.add(new IOException(\"Exception during image upload\", e));\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (Map.Entry\u003cString, Future\u003cTransferFsImage.TransferResult\u003e\u003e entry :\n          uploads.entrySet()) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d entry.getValue();\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      throw ie;\n    }\n\n    if (!ioes.isEmpty()) {\n      throw MultipleIOException.createIOException(ioes);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
          "extendedDetails": {}
        }
      ]
    },
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "03/11/17 8:34 PM",
      "commitNameOld": "169cdaa38eca1c0b78f608754eb15d4e6ca87bd9",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 102.53,
      "commitsBetweenForRepo": 673,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,135 @@\n   private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n-            \"received any transactions since the last checkpoint at txid \" +\n-            thisCheckpointTxId + \". Skipping...\");\n+            \"received any transactions since the last checkpoint at txid {}. \" +\n+            \"Skipping...\", thisCheckpointTxId);\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         try {\n           img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n         } catch (IOException ioe) {\n           LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                   + \"continuing with other checkpointing steps\", ioe);\n         }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n     if(!sendCheckpoint){\n       return;\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n           executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n             @Override\n             public TransferFsImage.TransferResult call()\n                 throws IOException, InterruptedException {\n               CheckpointFaultInjector.getInstance().duringUploadInProgess();\n               return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                   .getFSImage().getStorage(), imageType, txid, canceler);\n             }\n           });\n       uploads.add(upload);\n     }\n     InterruptedException ie \u003d null;\n     IOException ioe\u003d null;\n     int i \u003d 0;\n     boolean success \u003d false;\n     for (; i \u003c uploads.size(); i++) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n       try {\n         // TODO should there be some smarts here about retries nodes that are not the active NN?\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           success \u003d true;\n           //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n           break;\n         }\n \n       } catch (ExecutionException e) {\n-        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n-            e.getCause());\n+        ioe \u003d new IOException(\"Exception during image upload\", e);\n         break;\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n     if (ie \u003d\u003d null \u0026\u0026 ioe \u003d\u003d null) {\n       //Update only when response from remote about success or\n       lastUploadTime \u003d monotonicNow();\n       // we are primary if we successfully updated the ANN\n       this.isPrimaryCheckPointer \u003d success;\n     }\n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null || ioe !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (; i \u003c uploads.size(); i++) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       if (ie !\u003d null) {\n         throw ie;\n       } else if (ioe !\u003d null) {\n         throw ioe;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid {}. \" +\n            \"Skipping...\", thisCheckpointTxId);\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call()\n                throws IOException, InterruptedException {\n              CheckpointFaultInjector.getInstance().duringUploadInProgess();\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload\", e);\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    if (ie \u003d\u003d null \u0026\u0026 ioe \u003d\u003d null) {\n      //Update only when response from remote about success or\n      lastUploadTime \u003d monotonicNow();\n      // we are primary if we successfully updated the ANN\n      this.isPrimaryCheckPointer \u003d success;\n    }\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "bb6a3c83305f97090f980c53adaaf37baf18c698": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12248. SNN will not upload fsimage on IOE and Interrupted exceptions. (Brahma Reddy Battula)\n",
      "commitDate": "25/08/17 10:47 PM",
      "commitName": "bb6a3c83305f97090f980c53adaaf37baf18c698",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "02/05/17 6:34 PM",
      "commitNameOld": "d9014bda93760f223789d2ec9f5e35f40de157d4",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 115.18,
      "commitsBetweenForRepo": 655,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,136 @@\n   private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         try {\n           img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n         } catch (IOException ioe) {\n           LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                   + \"continuing with other checkpointing steps\", ioe);\n         }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n     if(!sendCheckpoint){\n       return;\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n           executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n             @Override\n-            public TransferFsImage.TransferResult call() throws IOException {\n+            public TransferFsImage.TransferResult call()\n+                throws IOException, InterruptedException {\n+              CheckpointFaultInjector.getInstance().duringUploadInProgess();\n               return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                   .getFSImage().getStorage(), imageType, txid, canceler);\n             }\n           });\n       uploads.add(upload);\n     }\n     InterruptedException ie \u003d null;\n     IOException ioe\u003d null;\n     int i \u003d 0;\n     boolean success \u003d false;\n     for (; i \u003c uploads.size(); i++) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n       try {\n         // TODO should there be some smarts here about retries nodes that are not the active NN?\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           success \u003d true;\n           //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n           break;\n         }\n \n       } catch (ExecutionException e) {\n         ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n             e.getCause());\n         break;\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n-    lastUploadTime \u003d monotonicNow();\n-\n-    // we are primary if we successfully updated the ANN\n-    this.isPrimaryCheckPointer \u003d success;\n-\n+    if (ie \u003d\u003d null \u0026\u0026 ioe \u003d\u003d null) {\n+      //Update only when response from remote about success or\n+      lastUploadTime \u003d monotonicNow();\n+      // we are primary if we successfully updated the ANN\n+      this.isPrimaryCheckPointer \u003d success;\n+    }\n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null || ioe !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (; i \u003c uploads.size(); i++) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       if (ie !\u003d null) {\n         throw ie;\n       } else if (ioe !\u003d null) {\n         throw ioe;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call()\n                throws IOException, InterruptedException {\n              CheckpointFaultInjector.getInstance().duringUploadInProgess();\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    if (ie \u003d\u003d null \u0026\u0026 ioe \u003d\u003d null) {\n      //Update only when response from remote about success or\n      lastUploadTime \u003d monotonicNow();\n      // we are primary if we successfully updated the ANN\n      this.isPrimaryCheckPointer \u003d success;\n    }\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "d9014bda93760f223789d2ec9f5e35f40de157d4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11717. Add unit test for HDFS-11709 StandbyCheckpointer should handle non-existing legacyOivImageDir gracefully. Contributed by Erik Krogen.",
      "commitDate": "02/05/17 6:34 PM",
      "commitName": "d9014bda93760f223789d2ec9f5e35f40de157d4",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "27/04/17 9:50 AM",
      "commitNameOld": "d8a33098309f17dfb0e3a000934f68394de44bf7",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 5.36,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         try {\n           img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n         } catch (IOException ioe) {\n-          LOG.error(\"Exception encountered while saving legacy OIV image; \"\n+          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                   + \"continuing with other checkpointing steps\", ioe);\n         }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n     if(!sendCheckpoint){\n       return;\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n           executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n             @Override\n             public TransferFsImage.TransferResult call() throws IOException {\n               return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                   .getFSImage().getStorage(), imageType, txid, canceler);\n             }\n           });\n       uploads.add(upload);\n     }\n     InterruptedException ie \u003d null;\n     IOException ioe\u003d null;\n     int i \u003d 0;\n     boolean success \u003d false;\n     for (; i \u003c uploads.size(); i++) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n       try {\n         // TODO should there be some smarts here about retries nodes that are not the active NN?\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           success \u003d true;\n           //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n           break;\n         }\n \n       } catch (ExecutionException e) {\n         ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n             e.getCause());\n         break;\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n     lastUploadTime \u003d monotonicNow();\n \n     // we are primary if we successfully updated the ANN\n     this.isPrimaryCheckPointer \u003d success;\n \n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null || ioe !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (; i \u003c uploads.size(); i++) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       if (ie !\u003d null) {\n         throw ie;\n       } else if (ioe !\u003d null) {\n         throw ioe;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.warn(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call() throws IOException {\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    lastUploadTime \u003d monotonicNow();\n\n    // we are primary if we successfully updated the ANN\n    this.isPrimaryCheckPointer \u003d success;\n\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "d8a33098309f17dfb0e3a000934f68394de44bf7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11709. StandbyCheckpointer should handle an non-existing legacyOivImageDir gracefully. Contributed by Erik Krogen.\n",
      "commitDate": "27/04/17 9:50 AM",
      "commitName": "d8a33098309f17dfb0e3a000934f68394de44bf7",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "01/12/16 6:08 AM",
      "commitNameOld": "e0fa49234fd37aca88e1caa95bac77bca192bae4",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 147.11,
      "commitsBetweenForRepo": 781,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,133 @@\n   private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n-        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n+        try {\n+          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n+        } catch (IOException ioe) {\n+          LOG.error(\"Exception encountered while saving legacy OIV image; \"\n+                  + \"continuing with other checkpointing steps\", ioe);\n+        }\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n     if(!sendCheckpoint){\n       return;\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n           executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n             @Override\n             public TransferFsImage.TransferResult call() throws IOException {\n               return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                   .getFSImage().getStorage(), imageType, txid, canceler);\n             }\n           });\n       uploads.add(upload);\n     }\n     InterruptedException ie \u003d null;\n     IOException ioe\u003d null;\n     int i \u003d 0;\n     boolean success \u003d false;\n     for (; i \u003c uploads.size(); i++) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n       try {\n         // TODO should there be some smarts here about retries nodes that are not the active NN?\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           success \u003d true;\n           //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n           break;\n         }\n \n       } catch (ExecutionException e) {\n         ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n             e.getCause());\n         break;\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n     lastUploadTime \u003d monotonicNow();\n \n     // we are primary if we successfully updated the ANN\n     this.isPrimaryCheckPointer \u003d success;\n \n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null || ioe !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (; i \u003c uploads.size(); i++) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       if (ie !\u003d null) {\n         throw ie;\n       } else if (ioe !\u003d null) {\n         throw ioe;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        try {\n          img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n        } catch (IOException ioe) {\n          LOG.error(\"Exception encountered while saving legacy OIV image; \"\n                  + \"continuing with other checkpointing steps\", ioe);\n        }\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call() throws IOException {\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    lastUploadTime \u003d monotonicNow();\n\n    // we are primary if we successfully updated the ANN\n    this.isPrimaryCheckPointer \u003d success;\n\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "e0fa49234fd37aca88e1caa95bac77bca192bae4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11180. Intermittent deadlock in NameNode when failover happens.\n",
      "commitDate": "01/12/16 6:08 AM",
      "commitName": "e0fa49234fd37aca88e1caa95bac77bca192bae4",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "16/02/16 9:11 PM",
      "commitNameOld": "2536ece7b67ccfeac44314615a5f9dbe771ce373",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 288.37,
      "commitsBetweenForRepo": 2092,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,128 @@\n   private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n-      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n+      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n     if(!sendCheckpoint){\n       return;\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n           executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n             @Override\n             public TransferFsImage.TransferResult call() throws IOException {\n               return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                   .getFSImage().getStorage(), imageType, txid, canceler);\n             }\n           });\n       uploads.add(upload);\n     }\n     InterruptedException ie \u003d null;\n     IOException ioe\u003d null;\n     int i \u003d 0;\n     boolean success \u003d false;\n     for (; i \u003c uploads.size(); i++) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n       try {\n         // TODO should there be some smarts here about retries nodes that are not the active NN?\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           success \u003d true;\n           //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n           break;\n         }\n \n       } catch (ExecutionException e) {\n         ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n             e.getCause());\n         break;\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n     lastUploadTime \u003d monotonicNow();\n \n     // we are primary if we successfully updated the ANN\n     this.isPrimaryCheckPointer \u003d success;\n \n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null || ioe !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (; i \u003c uploads.size(); i++) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       if (ie !\u003d null) {\n         throw ie;\n       } else if (ioe !\u003d null) {\n         throw ioe;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getCorrectLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call() throws IOException {\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    lastUploadTime \u003d monotonicNow();\n\n    // we are primary if we successfully updated the ANN\n    this.isPrimaryCheckPointer \u003d success;\n\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "2536ece7b67ccfeac44314615a5f9dbe771ce373": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9787. SNNs stop uploading FSImage to ANN once isPrimaryCheckPointer changed to false. (Contributed by Guocui Mi)\n",
      "commitDate": "16/02/16 9:11 PM",
      "commitName": "2536ece7b67ccfeac44314615a5f9dbe771ce373",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "23/06/15 5:26 PM",
      "commitNameOld": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 238.2,
      "commitsBetweenForRepo": 1600,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,128 @@\n   private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n \n       FSImage img \u003d namesystem.getFSImage();\n \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n           thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n \n     //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n     if(!sendCheckpoint){\n       return;\n     }\n \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n     // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n     ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n         TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n         uploadThreadFactory);\n     // for right now, just match the upload to the nn address by convention. There is no need to\n     // directly tie them together by adding a pair class.\n     List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n         new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n     for (final URL activeNNAddress : activeNNAddresses) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n           executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n             @Override\n             public TransferFsImage.TransferResult call() throws IOException {\n               return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                   .getFSImage().getStorage(), imageType, txid, canceler);\n             }\n           });\n       uploads.add(upload);\n     }\n     InterruptedException ie \u003d null;\n     IOException ioe\u003d null;\n     int i \u003d 0;\n     boolean success \u003d false;\n     for (; i \u003c uploads.size(); i++) {\n       Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n       try {\n         // TODO should there be some smarts here about retries nodes that are not the active NN?\n         if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n           success \u003d true;\n           //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n           break;\n         }\n \n       } catch (ExecutionException e) {\n         ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n             e.getCause());\n         break;\n       } catch (InterruptedException e) {\n         ie \u003d e;\n         break;\n       }\n     }\n+    lastUploadTime \u003d monotonicNow();\n \n     // we are primary if we successfully updated the ANN\n     this.isPrimaryCheckPointer \u003d success;\n \n     // cleaner than copying code for multiple catch statements and better than catching all\n     // exceptions, so we just handle the ones we expect.\n     if (ie !\u003d null || ioe !\u003d null) {\n \n       // cancel the rest of the tasks, and close the pool\n       for (; i \u003c uploads.size(); i++) {\n         Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n         // The background thread may be blocked waiting in the throttler, so\n         // interrupt it.\n         upload.cancel(true);\n       }\n \n       // shutdown so we interrupt anything running and don\u0027t start anything new\n       executor.shutdownNow();\n       // this is a good bit longer than the thread timeout, just to make sure all the threads\n       // that are not doing any work also stop\n       executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n \n       // re-throw the exception we got, since one of these two must be non-null\n       if (ie !\u003d null) {\n         throw ie;\n       } else if (ioe !\u003d null) {\n         throw ioe;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call() throws IOException {\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n    lastUploadTime \u003d monotonicNow();\n\n    // we are primary if we successfully updated the ANN\n    this.isPrimaryCheckPointer \u003d success;\n\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "49dfad942970459297f72632ed8dfd353e0c86de": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
      "commitDate": "23/06/15 5:26 PM",
      "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthor": "Aaron T. Myers",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
          "commitDate": "23/06/15 5:26 PM",
          "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
          "commitAuthor": "Aaron T. Myers",
          "commitDateOld": "25/11/14 3:37 PM",
          "commitNameOld": "f43a20c529ac3f104add95b222de6580757b3763",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 210.03,
          "commitsBetweenForRepo": 1722,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,127 @@\n-  private void doCheckpoint() throws InterruptedException, IOException {\n+  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n-    \n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n-      \n+\n       FSImage img \u003d namesystem.getFSImage();\n-      \n+\n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n-        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n+          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n-    \n+\n+    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n+    if(!sendCheckpoint){\n+      return;\n+    }\n+\n     // Upload the saved checkpoint back to the active\n-    // Do this in a separate thread to avoid blocking transition to active\n+    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n+    // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n-    ExecutorService executor \u003d\n-        Executors.newSingleThreadExecutor(uploadThreadFactory);\n-    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n-      @Override\n-      public Void call() throws IOException {\n-        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n-            namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n-        return null;\n+    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n+        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n+        uploadThreadFactory);\n+    // for right now, just match the upload to the nn address by convention. There is no need to\n+    // directly tie them together by adding a pair class.\n+    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n+        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n+    for (final URL activeNNAddress : activeNNAddresses) {\n+      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n+          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n+            @Override\n+            public TransferFsImage.TransferResult call() throws IOException {\n+              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n+                  .getFSImage().getStorage(), imageType, txid, canceler);\n+            }\n+          });\n+      uploads.add(upload);\n+    }\n+    InterruptedException ie \u003d null;\n+    IOException ioe\u003d null;\n+    int i \u003d 0;\n+    boolean success \u003d false;\n+    for (; i \u003c uploads.size(); i++) {\n+      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+      try {\n+        // TODO should there be some smarts here about retries nodes that are not the active NN?\n+        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n+          success \u003d true;\n+          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n+          break;\n+        }\n+\n+      } catch (ExecutionException e) {\n+        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n+            e.getCause());\n+        break;\n+      } catch (InterruptedException e) {\n+        ie \u003d e;\n+        break;\n       }\n-    });\n-    executor.shutdown();\n-    try {\n-      upload.get();\n-    } catch (InterruptedException e) {\n-      // The background thread may be blocked waiting in the throttler, so\n-      // interrupt it.\n-      upload.cancel(true);\n-      throw e;\n-    } catch (ExecutionException e) {\n-      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n-          e.getCause());\n+    }\n+\n+    // we are primary if we successfully updated the ANN\n+    this.isPrimaryCheckPointer \u003d success;\n+\n+    // cleaner than copying code for multiple catch statements and better than catching all\n+    // exceptions, so we just handle the ones we expect.\n+    if (ie !\u003d null || ioe !\u003d null) {\n+\n+      // cancel the rest of the tasks, and close the pool\n+      for (; i \u003c uploads.size(); i++) {\n+        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+        // The background thread may be blocked waiting in the throttler, so\n+        // interrupt it.\n+        upload.cancel(true);\n+      }\n+\n+      // shutdown so we interrupt anything running and don\u0027t start anything new\n+      executor.shutdownNow();\n+      // this is a good bit longer than the thread timeout, just to make sure all the threads\n+      // that are not doing any work also stop\n+      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n+\n+      // re-throw the exception we got, since one of these two must be non-null\n+      if (ie !\u003d null) {\n+        throw ie;\n+      } else if (ioe !\u003d null) {\n+        throw ioe;\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call() throws IOException {\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n\n    // we are primary if we successfully updated the ANN\n    this.isPrimaryCheckPointer \u003d success;\n\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[sendCheckpoint-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
          "commitDate": "23/06/15 5:26 PM",
          "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
          "commitAuthor": "Aaron T. Myers",
          "commitDateOld": "25/11/14 3:37 PM",
          "commitNameOld": "f43a20c529ac3f104add95b222de6580757b3763",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 210.03,
          "commitsBetweenForRepo": 1722,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,127 @@\n-  private void doCheckpoint() throws InterruptedException, IOException {\n+  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n-    \n     // Acquire cpLock to make sure no one is modifying the name system.\n     // It does not need the full namesystem write lock, since the only thing\n     // that modifies namesystem on standby node is edit log replaying.\n     namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n-      \n+\n       FSImage img \u003d namesystem.getFSImage();\n-      \n+\n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n-        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n+          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n       }\n     } finally {\n       namesystem.cpUnlock();\n     }\n-    \n+\n+    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n+    if(!sendCheckpoint){\n+      return;\n+    }\n+\n     // Upload the saved checkpoint back to the active\n-    // Do this in a separate thread to avoid blocking transition to active\n+    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n+    // than the expected number of tasks to run or queue up\n     // See HDFS-4816\n-    ExecutorService executor \u003d\n-        Executors.newSingleThreadExecutor(uploadThreadFactory);\n-    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n-      @Override\n-      public Void call() throws IOException {\n-        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n-            namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n-        return null;\n+    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n+        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n+        uploadThreadFactory);\n+    // for right now, just match the upload to the nn address by convention. There is no need to\n+    // directly tie them together by adding a pair class.\n+    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n+        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n+    for (final URL activeNNAddress : activeNNAddresses) {\n+      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n+          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n+            @Override\n+            public TransferFsImage.TransferResult call() throws IOException {\n+              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n+                  .getFSImage().getStorage(), imageType, txid, canceler);\n+            }\n+          });\n+      uploads.add(upload);\n+    }\n+    InterruptedException ie \u003d null;\n+    IOException ioe\u003d null;\n+    int i \u003d 0;\n+    boolean success \u003d false;\n+    for (; i \u003c uploads.size(); i++) {\n+      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+      try {\n+        // TODO should there be some smarts here about retries nodes that are not the active NN?\n+        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n+          success \u003d true;\n+          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n+          break;\n+        }\n+\n+      } catch (ExecutionException e) {\n+        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n+            e.getCause());\n+        break;\n+      } catch (InterruptedException e) {\n+        ie \u003d e;\n+        break;\n       }\n-    });\n-    executor.shutdown();\n-    try {\n-      upload.get();\n-    } catch (InterruptedException e) {\n-      // The background thread may be blocked waiting in the throttler, so\n-      // interrupt it.\n-      upload.cancel(true);\n-      throw e;\n-    } catch (ExecutionException e) {\n-      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n-          e.getCause());\n+    }\n+\n+    // we are primary if we successfully updated the ANN\n+    this.isPrimaryCheckPointer \u003d success;\n+\n+    // cleaner than copying code for multiple catch statements and better than catching all\n+    // exceptions, so we just handle the ones we expect.\n+    if (ie !\u003d null || ioe !\u003d null) {\n+\n+      // cancel the rest of the tasks, and close the pool\n+      for (; i \u003c uploads.size(); i++) {\n+        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n+        // The background thread may be blocked waiting in the throttler, so\n+        // interrupt it.\n+        upload.cancel(true);\n+      }\n+\n+      // shutdown so we interrupt anything running and don\u0027t start anything new\n+      executor.shutdownNow();\n+      // this is a good bit longer than the thread timeout, just to make sure all the threads\n+      // that are not doing any work also stop\n+      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n+\n+      // re-throw the exception we got, since one of these two must be non-null\n+      if (ie !\u003d null) {\n+        throw ie;\n+      } else if (ioe !\u003d null) {\n+        throw ioe;\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doCheckpoint(boolean sendCheckpoint) throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n\n      FSImage img \u003d namesystem.getFSImage();\n\n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n          thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n\n    //early exit if we shouldn\u0027t actually send the checkpoint to the ANN\n    if(!sendCheckpoint){\n      return;\n    }\n\n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active, but don\u0027t allow more\n    // than the expected number of tasks to run or queue up\n    // See HDFS-4816\n    ExecutorService executor \u003d new ThreadPoolExecutor(0, activeNNAddresses.size(), 100,\n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e(activeNNAddresses.size()),\n        uploadThreadFactory);\n    // for right now, just match the upload to the nn address by convention. There is no need to\n    // directly tie them together by adding a pair class.\n    List\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e uploads \u003d\n        new ArrayList\u003cFuture\u003cTransferFsImage.TransferResult\u003e\u003e();\n    for (final URL activeNNAddress : activeNNAddresses) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d\n          executor.submit(new Callable\u003cTransferFsImage.TransferResult\u003e() {\n            @Override\n            public TransferFsImage.TransferResult call() throws IOException {\n              return TransferFsImage.uploadImageFromStorage(activeNNAddress, conf, namesystem\n                  .getFSImage().getStorage(), imageType, txid, canceler);\n            }\n          });\n      uploads.add(upload);\n    }\n    InterruptedException ie \u003d null;\n    IOException ioe\u003d null;\n    int i \u003d 0;\n    boolean success \u003d false;\n    for (; i \u003c uploads.size(); i++) {\n      Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n      try {\n        // TODO should there be some smarts here about retries nodes that are not the active NN?\n        if (upload.get() \u003d\u003d TransferFsImage.TransferResult.SUCCESS) {\n          success \u003d true;\n          //avoid getting the rest of the results - we don\u0027t care since we had a successful upload\n          break;\n        }\n\n      } catch (ExecutionException e) {\n        ioe \u003d new IOException(\"Exception during image upload: \" + e.getMessage(),\n            e.getCause());\n        break;\n      } catch (InterruptedException e) {\n        ie \u003d e;\n        break;\n      }\n    }\n\n    // we are primary if we successfully updated the ANN\n    this.isPrimaryCheckPointer \u003d success;\n\n    // cleaner than copying code for multiple catch statements and better than catching all\n    // exceptions, so we just handle the ones we expect.\n    if (ie !\u003d null || ioe !\u003d null) {\n\n      // cancel the rest of the tasks, and close the pool\n      for (; i \u003c uploads.size(); i++) {\n        Future\u003cTransferFsImage.TransferResult\u003e upload \u003d uploads.get(i);\n        // The background thread may be blocked waiting in the throttler, so\n        // interrupt it.\n        upload.cancel(true);\n      }\n\n      // shutdown so we interrupt anything running and don\u0027t start anything new\n      executor.shutdownNow();\n      // this is a good bit longer than the thread timeout, just to make sure all the threads\n      // that are not doing any work also stop\n      executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n\n      // re-throw the exception we got, since one of these two must be non-null\n      if (ie !\u003d null) {\n        throw ie;\n      } else if (ioe !\u003d null) {\n        throw ioe;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
          "extendedDetails": {}
        }
      ]
    },
    "f43a20c529ac3f104add95b222de6580757b3763": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7097. Allow block reports to be processed during checkpointing on standby name node. (kihwal via wang)\n",
      "commitDate": "25/11/14 3:37 PM",
      "commitName": "f43a20c529ac3f104add95b222de6580757b3763",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "13/05/14 6:15 PM",
      "commitNameOld": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 195.93,
      "commitsBetweenForRepo": 1698,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,74 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n-    namesystem.longReadLockInterruptibly();\n+    // Acquire cpLock to make sure no one is modifying the name system.\n+    // It does not need the full namesystem write lock, since the only thing\n+    // that modifies namesystem on standby node is edit log replaying.\n+    namesystem.cpLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n \n       // Save the legacy OIV image, if the output dir is defined.\n       String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n       if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n         img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n       }\n     } finally {\n-      namesystem.longReadUnlock();\n+      namesystem.cpUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n         TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n             namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (InterruptedException e) {\n       // The background thread may be blocked waiting in the throttler, so\n       // interrupt it.\n       upload.cancel(true);\n       throw e;\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    // Acquire cpLock to make sure no one is modifying the name system.\n    // It does not need the full namesystem write lock, since the only thing\n    // that modifies namesystem on standby node is edit log replaying.\n    namesystem.cpLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n      }\n    } finally {\n      namesystem.cpUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n            namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (InterruptedException e) {\n      // The background thread may be blocked waiting in the throttler, so\n      // interrupt it.\n      upload.cancel(true);\n      throw e;\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "97f58955a6045b373ab73653bf26ab5922b00cf3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6293. Issues with OIV processing PB-based fsimages. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594439 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 6:15 PM",
      "commitName": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "14/04/14 9:49 PM",
      "commitNameOld": "01af3a31772ee820e932ac70973072e9509a30fa",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 28.85,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,71 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n     namesystem.longReadLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n+\n+      // Save the legacy OIV image, if the output dir is defined.\n+      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n+      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n+        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n+      }\n     } finally {\n       namesystem.longReadUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n         TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n             namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (InterruptedException e) {\n       // The background thread may be blocked waiting in the throttler, so\n       // interrupt it.\n       upload.cancel(true);\n       throw e;\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.longReadLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n\n      // Save the legacy OIV image, if the output dir is defined.\n      String outputDir \u003d checkpointConf.getLegacyOivImageDir();\n      if (outputDir !\u003d null \u0026\u0026 !outputDir.isEmpty()) {\n        img.saveLegacyOIVImage(namesystem, outputDir, canceler);\n      }\n    } finally {\n      namesystem.longReadUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n            namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (InterruptedException e) {\n      // The background thread may be blocked waiting in the throttler, so\n      // interrupt it.\n      upload.cancel(true);\n      throw e;\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "01af3a31772ee820e932ac70973072e9509a30fa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6243. HA NameNode transition to active or shutdown may leave lingering image transfer thread. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1587410 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/04/14 9:49 PM",
      "commitName": "01af3a31772ee820e932ac70973072e9509a30fa",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "02/04/14 1:33 AM",
      "commitNameOld": "64c50d9dfb2247852b9e03fd3e41ce426f872e94",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 12.84,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,65 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n     namesystem.longReadLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.longReadUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n         TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n-            namesystem.getFSImage().getStorage(), imageType, txid);\n+            namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n+    } catch (InterruptedException e) {\n+      // The background thread may be blocked waiting in the throttler, so\n+      // interrupt it.\n+      upload.cancel(true);\n+      throw e;\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.longReadLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.longReadUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n            namesystem.getFSImage().getStorage(), imageType, txid, canceler);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (InterruptedException e) {\n      // The background thread may be blocked waiting in the throttler, so\n      // interrupt it.\n      upload.cancel(true);\n      throw e;\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "94a1632fcb677fda6f4d812614026417f1d0a360": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:25 PM",
      "commitName": "94a1632fcb677fda6f4d812614026417f1d0a360",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "08/03/14 1:15 PM",
      "commitNameOld": "dbd22b23c2d68b97b4da47215897906f06f978e3",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n     namesystem.longReadLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.longReadUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n-        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n+        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n             namesystem.getFSImage().getStorage(), imageType, txid);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.longReadLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.longReadUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n            namesystem.getFSImage().getStorage(), imageType, txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "dbd22b23c2d68b97b4da47215897906f06f978e3": {
      "type": "Ybodychange",
      "commitMessage": "Revert HDFS-3405 for recommit with correct renamed files\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575610 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:15 PM",
      "commitName": "dbd22b23c2d68b97b4da47215897906f06f978e3",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/03/14 4:39 PM",
      "commitNameOld": "0f595915a388305edbb3ce928415571811d304e8",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.86,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n     namesystem.longReadLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.longReadUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n-        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n+        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n             namesystem.getFSImage().getStorage(), imageType, txid);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.longReadLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.longReadUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n            namesystem.getFSImage().getStorage(), imageType, txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "0f595915a388305edbb3ce928415571811d304e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575457 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 4:39 PM",
      "commitName": "0f595915a388305edbb3ce928415571811d304e8",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/03/14 3:35 PM",
      "commitNameOld": "90b399c4bd1d7a7856a7b9230fa1437a30b4eb88",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n     namesystem.longReadLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.longReadUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n-        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n+        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n             namesystem.getFSImage().getStorage(), imageType, txid);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.longReadLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.longReadUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, conf,\n            namesystem.getFSImage().getStorage(), imageType, txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "90b399c4bd1d7a7856a7b9230fa1437a30b4eb88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5064. Standby checkpoints should not block concurrent readers. Contributed by Aaron Twining Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 3:35 PM",
      "commitName": "90b399c4bd1d7a7856a7b9230fa1437a30b4eb88",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "26/02/14 10:20 AM",
      "commitNameOld": "dedcc09e717fa810260ecf83a4abca746dbedd49",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 9.22,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     final NameNodeFile imageType;\n     \n-    namesystem.writeLockInterruptibly();\n+    namesystem.longReadLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       if (namesystem.isRollingUpgrade()\n           \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n         // if we will do rolling upgrade but have not created the rollback image\n         // yet, name this checkpoint as fsimage_rollback\n         imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n       } else {\n         imageType \u003d NameNodeFile.IMAGE;\n       }\n       img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n-      namesystem.writeUnlock();\n+      namesystem.longReadUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n         TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n             namesystem.getFSImage().getStorage(), imageType, txid);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.longReadLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.longReadUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n            namesystem.getFSImage().getStorage(), imageType, txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/02/14 12:04 AM",
      "commitNameOld": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 12.58,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,60 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n+    final NameNodeFile imageType;\n     \n     namesystem.writeLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n-      img.saveNamespace(namesystem, NameNodeFile.IMAGE, canceler);\n+      if (namesystem.isRollingUpgrade()\n+          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n+        // if we will do rolling upgrade but have not created the rollback image\n+        // yet, name this checkpoint as fsimage_rollback\n+        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n+      } else {\n+        imageType \u003d NameNodeFile.IMAGE;\n+      }\n+      img.saveNamespace(namesystem, imageType, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.writeUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n         TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n-            namesystem.getFSImage().getStorage(), txid);\n+            namesystem.getFSImage().getStorage(), imageType, txid);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    final NameNodeFile imageType;\n    \n    namesystem.writeLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      if (namesystem.isRollingUpgrade()\n          \u0026\u0026 !namesystem.getFSImage().hasRollbackFSImage()) {\n        // if we will do rolling upgrade but have not created the rollback image\n        // yet, name this checkpoint as fsimage_rollback\n        imageType \u003d NameNodeFile.IMAGE_ROLLBACK;\n      } else {\n        imageType \u003d NameNodeFile.IMAGE;\n      }\n      img.saveNamespace(namesystem, imageType, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.writeUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n            namesystem.getFSImage().getStorage(), imageType, txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5889. When starting rolling upgrade, create a fs image for rollback so that the standby namenode can create checkpoints during upgrade.  Contributed by szetszwo \u0026 jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1567861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/02/14 12:04 AM",
      "commitName": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/12/13 10:01 AM",
      "commitNameOld": "045dc880e13271737b3cf316296e92fb95806663",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 68.59,
      "commitsBetweenForRepo": 348,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,51 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n     final long txid;\n     \n     namesystem.writeLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n-      img.saveNamespace(namesystem, canceler);\n+      img.saveNamespace(namesystem, NameNodeFile.IMAGE, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.writeUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     // Do this in a separate thread to avoid blocking transition to active\n     // See HDFS-4816\n     ExecutorService executor \u003d\n         Executors.newSingleThreadExecutor(uploadThreadFactory);\n     Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n       @Override\n       public Void call() throws IOException {\n-        TransferFsImage.uploadImageFromStorage(\n-            activeNNAddress, myNNAddress,\n+        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n             namesystem.getFSImage().getStorage(), txid);\n         return null;\n       }\n     });\n     executor.shutdown();\n     try {\n       upload.get();\n     } catch (ExecutionException e) {\n       throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n           e.getCause());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    \n    namesystem.writeLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      img.saveNamespace(namesystem, NameNodeFile.IMAGE, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.writeUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(activeNNAddress, myNNAddress,\n            namesystem.getFSImage().getStorage(), txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "49a892056df7d73207f7a65ae5b4b905ba5e6ab8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4816. transitionToActive blocks if the SBN is doing checkpoint image transfer. (Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514095 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/13 4:32 PM",
      "commitName": "49a892056df7d73207f7a65ae5b4b905ba5e6ab8",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "28/05/13 8:47 AM",
      "commitNameOld": "45b9d19f9d2b14e4d3c386af9de3df817da3c9df",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 78.32,
      "commitsBetweenForRepo": 510,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,52 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n     assert canceler !\u003d null;\n-    long txid;\n+    final long txid;\n     \n     namesystem.writeLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n \n       img.saveNamespace(namesystem, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.writeUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n-    TransferFsImage.uploadImageFromStorage(\n-        activeNNAddress, myNNAddress,\n-        namesystem.getFSImage().getStorage(), txid);\n+    // Do this in a separate thread to avoid blocking transition to active\n+    // See HDFS-4816\n+    ExecutorService executor \u003d\n+        Executors.newSingleThreadExecutor(uploadThreadFactory);\n+    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n+      @Override\n+      public Void call() throws IOException {\n+        TransferFsImage.uploadImageFromStorage(\n+            activeNNAddress, myNNAddress,\n+            namesystem.getFSImage().getStorage(), txid);\n+        return null;\n+      }\n+    });\n+    executor.shutdown();\n+    try {\n+      upload.get();\n+    } catch (ExecutionException e) {\n+      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n+          e.getCause());\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    final long txid;\n    \n    namesystem.writeLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      img.saveNamespace(namesystem, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.writeUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    // Do this in a separate thread to avoid blocking transition to active\n    // See HDFS-4816\n    ExecutorService executor \u003d\n        Executors.newSingleThreadExecutor(uploadThreadFactory);\n    Future\u003cVoid\u003e upload \u003d executor.submit(new Callable\u003cVoid\u003e() {\n      @Override\n      public Void call() throws IOException {\n        TransferFsImage.uploadImageFromStorage(\n            activeNNAddress, myNNAddress,\n            namesystem.getFSImage().getStorage(), txid);\n        return null;\n      }\n    });\n    executor.shutdown();\n    try {\n      upload.get();\n    } catch (ExecutionException e) {\n      throw new IOException(\"Exception during image upload: \" + e.getMessage(),\n          e.getCause());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "15ddb6634f8bdab37ce43f99f8338d84422c7232": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2800. Fix cancellation of checkpoints in the standby node to be more reliable. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1339745 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/12 10:49 AM",
      "commitName": "15ddb6634f8bdab37ce43f99f8338d84422c7232",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "12/05/12 7:51 PM",
      "commitNameOld": "f22341ab1a9060a727abb0924a4cd996b2bd7fe7",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 4.62,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n   private void doCheckpoint() throws InterruptedException, IOException {\n+    assert canceler !\u003d null;\n     long txid;\n     \n     namesystem.writeLockInterruptibly();\n     try {\n       assert namesystem.getEditLog().isOpenForRead() :\n         \"Standby Checkpointer should only attempt a checkpoint when \" +\n         \"NN is in standby mode, but the edit logs are in an unexpected state\";\n       \n       FSImage img \u003d namesystem.getFSImage();\n       \n       long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n       long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n       assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n       if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n         LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n             \"received any transactions since the last checkpoint at txid \" +\n             thisCheckpointTxId + \". Skipping...\");\n         return;\n       }\n-      \n-      img.saveNamespace(namesystem);\n+\n+      img.saveNamespace(namesystem, canceler);\n       txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n       assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n         thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n     } finally {\n       namesystem.writeUnlock();\n     }\n     \n     // Upload the saved checkpoint back to the active\n     TransferFsImage.uploadImageFromStorage(\n         activeNNAddress, myNNAddress,\n         namesystem.getFSImage().getStorage(), txid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    assert canceler !\u003d null;\n    long txid;\n    \n    namesystem.writeLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n\n      img.saveNamespace(namesystem, canceler);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.writeUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    TransferFsImage.uploadImageFromStorage(\n        activeNNAddress, myNNAddress,\n        namesystem.getFSImage().getStorage(), txid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 4:22 PM",
      "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,34 @@\n+  private void doCheckpoint() throws InterruptedException, IOException {\n+    long txid;\n+    \n+    namesystem.writeLockInterruptibly();\n+    try {\n+      assert namesystem.getEditLog().isOpenForRead() :\n+        \"Standby Checkpointer should only attempt a checkpoint when \" +\n+        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n+      \n+      FSImage img \u003d namesystem.getFSImage();\n+      \n+      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n+      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n+      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n+      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n+        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n+            \"received any transactions since the last checkpoint at txid \" +\n+            thisCheckpointTxId + \". Skipping...\");\n+        return;\n+      }\n+      \n+      img.saveNamespace(namesystem);\n+      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n+      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n+        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n+    } finally {\n+      namesystem.writeUnlock();\n+    }\n+    \n+    // Upload the saved checkpoint back to the active\n+    TransferFsImage.uploadImageFromStorage(\n+        activeNNAddress, myNNAddress,\n+        namesystem.getFSImage().getStorage(), txid);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doCheckpoint() throws InterruptedException, IOException {\n    long txid;\n    \n    namesystem.writeLockInterruptibly();\n    try {\n      assert namesystem.getEditLog().isOpenForRead() :\n        \"Standby Checkpointer should only attempt a checkpoint when \" +\n        \"NN is in standby mode, but the edit logs are in an unexpected state\";\n      \n      FSImage img \u003d namesystem.getFSImage();\n      \n      long prevCheckpointTxId \u003d img.getStorage().getMostRecentCheckpointTxId();\n      long thisCheckpointTxId \u003d img.getLastAppliedOrWrittenTxId();\n      assert thisCheckpointTxId \u003e\u003d prevCheckpointTxId;\n      if (thisCheckpointTxId \u003d\u003d prevCheckpointTxId) {\n        LOG.info(\"A checkpoint was triggered but the Standby Node has not \" +\n            \"received any transactions since the last checkpoint at txid \" +\n            thisCheckpointTxId + \". Skipping...\");\n        return;\n      }\n      \n      img.saveNamespace(namesystem);\n      txid \u003d img.getStorage().getMostRecentCheckpointTxId();\n      assert txid \u003d\u003d thisCheckpointTxId : \"expected to save checkpoint at txid\u003d\" +\n        thisCheckpointTxId + \" but instead saved at txid\u003d\" + txid;\n    } finally {\n      namesystem.writeUnlock();\n    }\n    \n    // Upload the saved checkpoint back to the active\n    TransferFsImage.uploadImageFromStorage(\n        activeNNAddress, myNNAddress,\n        namesystem.getFSImage().getStorage(), txid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java"
    }
  }
}