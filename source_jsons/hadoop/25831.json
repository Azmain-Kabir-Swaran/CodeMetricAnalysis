{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMContainerAllocator.java",
  "functionName": "scheduleReduces",
  "functionId": "scheduleReduces___totalMaps-int__completedMaps-int__scheduledMaps-int__scheduledReduces-int__assignedMaps-int__assignedReduces-int__mapResourceReqt-Resource__reduceResourceReqt-Resource__numPendingReduces-int__maxReduceRampupLimit-float__reduceSlowStart-float",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
  "functionStartLine": 641,
  "functionEndLine": 748,
  "numCommitsSeen": 140,
  "timeTaken": 8962,
  "changeHistory": [
    "4aa9b3e75ca86917125e56e1b438668273a5d87f",
    "376233cdd4a4ddbde5a92a0627f78338cb4c38b7",
    "b2f7a66e50bd09d26b2ad22e66ced73a6254de77",
    "03f2f9b5809fb324227651fc936a61bd583fad5f",
    "55e94dc5ef4171c4e7b57942f22ead9a01dd9012",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "4aa9b3e75ca86917125e56e1b438668273a5d87f": "Ybodychange",
    "376233cdd4a4ddbde5a92a0627f78338cb4c38b7": "Ymultichange(Yparameterchange,Ybodychange)",
    "b2f7a66e50bd09d26b2ad22e66ced73a6254de77": "Ybodychange",
    "03f2f9b5809fb324227651fc936a61bd583fad5f": "Ybodychange",
    "55e94dc5ef4171c4e7b57942f22ead9a01dd9012": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4aa9b3e75ca86917125e56e1b438668273a5d87f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6302. Incorrect headroom can lead to a deadlock between map and reduce allocations. (kasha)\n",
      "commitDate": "09/10/15 7:37 AM",
      "commitName": "4aa9b3e75ca86917125e56e1b438668273a5d87f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/09/15 8:54 PM",
      "commitNameOld": "dfd807afab0fae3839c9cc5d552aa0304444f956",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 17.45,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,108 @@\n   public void scheduleReduces(\n       int totalMaps, int completedMaps,\n       int scheduledMaps, int scheduledReduces,\n       int assignedMaps, int assignedReduces,\n       Resource mapResourceReqt, Resource reduceResourceReqt,\n       int numPendingReduces,\n       float maxReduceRampupLimit, float reduceSlowStart) {\n     \n     if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n     // get available resources for this job\n     Resource headRoom \u003d getAvailableResources();\n-    if (headRoom \u003d\u003d null) {\n-      headRoom \u003d Resources.none();\n-    }\n \n     LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n     \n     //check for slow start\n     if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n               \"completedMapsForReduceSlowstart \" + \n             completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n         setIsReduceStarted(true);\n       }\n     }\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the\n     //headroom\n     if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n       LOG.info(\"All maps assigned. \" +\n           \"Ramping up all remaining reduces:\" + numPendingReduces);\n       scheduleAllReduces();\n       return;\n     }\n \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n     Resource netScheduledMapResource \u003d\n         Resources.multiply(mapResourceReqt, (scheduledMaps + assignedMaps));\n \n     Resource netScheduledReduceResource \u003d\n         Resources.multiply(reduceResourceReqt,\n           (scheduledReduces + assignedReduces));\n \n     Resource finalMapResourceLimit;\n     Resource finalReduceResourceLimit;\n \n     // ramp up the reduces based on completed map percentage\n     Resource totalResourceLimit \u003d getResourceLimit();\n \n     Resource idealReduceResourceLimit \u003d\n         Resources.multiply(totalResourceLimit,\n           Math.min(completedMapPercent, maxReduceRampupLimit));\n     Resource ideaMapResourceLimit \u003d\n         Resources.subtract(totalResourceLimit, idealReduceResourceLimit);\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n     // to reduce.\n     // Even when container number equals, there may be unused resources in one\n     // dimension\n     if (ResourceCalculatorUtils.computeAvailableContainers(ideaMapResourceLimit,\n       mapResourceReqt, getSchedulerResourceTypes()) \u003e\u003d (scheduledMaps + assignedMaps)) {\n       // enough resource given to maps, given the remaining to reduces\n       Resource unusedMapResourceLimit \u003d\n           Resources.subtract(ideaMapResourceLimit, netScheduledMapResource);\n       finalReduceResourceLimit \u003d\n           Resources.add(idealReduceResourceLimit, unusedMapResourceLimit);\n       finalMapResourceLimit \u003d\n           Resources.subtract(totalResourceLimit, finalReduceResourceLimit);\n     } else {\n       finalMapResourceLimit \u003d ideaMapResourceLimit;\n       finalReduceResourceLimit \u003d idealReduceResourceLimit;\n     }\n \n     LOG.info(\"completedMapPercent \" + completedMapPercent\n         + \" totalResourceLimit:\" + totalResourceLimit\n         + \" finalMapResourceLimit:\" + finalMapResourceLimit\n         + \" finalReduceResourceLimit:\" + finalReduceResourceLimit\n         + \" netScheduledMapResource:\" + netScheduledMapResource\n         + \" netScheduledReduceResource:\" + netScheduledReduceResource);\n \n     int rampUp \u003d\n         ResourceCalculatorUtils.computeAvailableContainers(Resources.subtract(\n                 finalReduceResourceLimit, netScheduledReduceResource),\n             reduceResourceReqt, getSchedulerResourceTypes());\n \n     if (rampUp \u003e 0) {\n       rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n       rampUpReduces(rampUp);\n     } else if (rampUp \u003c 0) {\n       int rampDown \u003d -1 * rampUp;\n       rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n       rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      Resource mapResourceReqt, Resource reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    // get available resources for this job\n    Resource headRoom \u003d getAvailableResources();\n\n    LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the\n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n          \"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n\n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    Resource netScheduledMapResource \u003d\n        Resources.multiply(mapResourceReqt, (scheduledMaps + assignedMaps));\n\n    Resource netScheduledReduceResource \u003d\n        Resources.multiply(reduceResourceReqt,\n          (scheduledReduces + assignedReduces));\n\n    Resource finalMapResourceLimit;\n    Resource finalReduceResourceLimit;\n\n    // ramp up the reduces based on completed map percentage\n    Resource totalResourceLimit \u003d getResourceLimit();\n\n    Resource idealReduceResourceLimit \u003d\n        Resources.multiply(totalResourceLimit,\n          Math.min(completedMapPercent, maxReduceRampupLimit));\n    Resource ideaMapResourceLimit \u003d\n        Resources.subtract(totalResourceLimit, idealReduceResourceLimit);\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce.\n    // Even when container number equals, there may be unused resources in one\n    // dimension\n    if (ResourceCalculatorUtils.computeAvailableContainers(ideaMapResourceLimit,\n      mapResourceReqt, getSchedulerResourceTypes()) \u003e\u003d (scheduledMaps + assignedMaps)) {\n      // enough resource given to maps, given the remaining to reduces\n      Resource unusedMapResourceLimit \u003d\n          Resources.subtract(ideaMapResourceLimit, netScheduledMapResource);\n      finalReduceResourceLimit \u003d\n          Resources.add(idealReduceResourceLimit, unusedMapResourceLimit);\n      finalMapResourceLimit \u003d\n          Resources.subtract(totalResourceLimit, finalReduceResourceLimit);\n    } else {\n      finalMapResourceLimit \u003d ideaMapResourceLimit;\n      finalReduceResourceLimit \u003d idealReduceResourceLimit;\n    }\n\n    LOG.info(\"completedMapPercent \" + completedMapPercent\n        + \" totalResourceLimit:\" + totalResourceLimit\n        + \" finalMapResourceLimit:\" + finalMapResourceLimit\n        + \" finalReduceResourceLimit:\" + finalReduceResourceLimit\n        + \" netScheduledMapResource:\" + netScheduledMapResource\n        + \" netScheduledReduceResource:\" + netScheduledReduceResource);\n\n    int rampUp \u003d\n        ResourceCalculatorUtils.computeAvailableContainers(Resources.subtract(\n                finalReduceResourceLimit, netScheduledReduceResource),\n            reduceResourceReqt, getSchedulerResourceTypes());\n\n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0) {\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "376233cdd4a4ddbde5a92a0627f78338cb4c38b7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5279. Made MR headroom calculation honor cpu dimension when YARN scheduler resource type is memory plus cpu. Contributed by Peng Zhang and Varun Vasudev.\n",
      "commitDate": "22/09/14 9:28 AM",
      "commitName": "376233cdd4a4ddbde5a92a0627f78338cb4c38b7",
      "commitAuthor": "Zhijie Shen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-5279. Made MR headroom calculation honor cpu dimension when YARN scheduler resource type is memory plus cpu. Contributed by Peng Zhang and Varun Vasudev.\n",
          "commitDate": "22/09/14 9:28 AM",
          "commitName": "376233cdd4a4ddbde5a92a0627f78338cb4c38b7",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "08/08/14 2:38 PM",
          "commitNameOld": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
          "commitAuthorOld": "Xuan Gong",
          "daysBetweenCommits": 44.78,
          "commitsBetweenForRepo": 414,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,111 @@\n   public void scheduleReduces(\n       int totalMaps, int completedMaps,\n       int scheduledMaps, int scheduledReduces,\n       int assignedMaps, int assignedReduces,\n-      int mapResourceReqt, int reduceResourceReqt,\n+      Resource mapResourceReqt, Resource reduceResourceReqt,\n       int numPendingReduces,\n       float maxReduceRampupLimit, float reduceSlowStart) {\n     \n     if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n-    int headRoom \u003d getAvailableResources() !\u003d null ?\n-        getAvailableResources().getMemory() : 0;\n+    // get available resources for this job\n+    Resource headRoom \u003d getAvailableResources();\n+    if (headRoom \u003d\u003d null) {\n+      headRoom \u003d Resources.none();\n+    }\n+\n     LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n     \n     //check for slow start\n     if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n               \"completedMapsForReduceSlowstart \" + \n             completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n         setIsReduceStarted(true);\n       }\n     }\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the\n     //headroom\n     if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n       LOG.info(\"All maps assigned. \" +\n           \"Ramping up all remaining reduces:\" + numPendingReduces);\n       scheduleAllReduces();\n       return;\n     }\n \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n-    int netScheduledMapMem \u003d \n-        (scheduledMaps + assignedMaps) * mapResourceReqt;\n+    Resource netScheduledMapResource \u003d\n+        Resources.multiply(mapResourceReqt, (scheduledMaps + assignedMaps));\n \n-    int netScheduledReduceMem \u003d \n-        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n+    Resource netScheduledReduceResource \u003d\n+        Resources.multiply(reduceResourceReqt,\n+          (scheduledReduces + assignedReduces));\n \n-    int finalMapMemLimit \u003d 0;\n-    int finalReduceMemLimit \u003d 0;\n-    \n+    Resource finalMapResourceLimit;\n+    Resource finalReduceResourceLimit;\n+\n     // ramp up the reduces based on completed map percentage\n-    int totalMemLimit \u003d getMemLimit();\n-    int idealReduceMemLimit \u003d \n-        Math.min(\n-            (int)(completedMapPercent * totalMemLimit),\n-            (int) (maxReduceRampupLimit * totalMemLimit));\n-    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n+    Resource totalResourceLimit \u003d getResourceLimit();\n+\n+    Resource idealReduceResourceLimit \u003d\n+        Resources.multiply(totalResourceLimit,\n+          Math.min(completedMapPercent, maxReduceRampupLimit));\n+    Resource ideaMapResourceLimit \u003d\n+        Resources.subtract(totalResourceLimit, idealReduceResourceLimit);\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n-    // to reduce\n-    if (idealMapMemLimit \u003e netScheduledMapMem) {\n-      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n-      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n-      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n+    // to reduce.\n+    // Even when container number equals, there may be unused resources in one\n+    // dimension\n+    if (ResourceCalculatorUtils.computeAvailableContainers(ideaMapResourceLimit,\n+      mapResourceReqt, getSchedulerResourceTypes()) \u003e\u003d (scheduledMaps + assignedMaps)) {\n+      // enough resource given to maps, given the remaining to reduces\n+      Resource unusedMapResourceLimit \u003d\n+          Resources.subtract(ideaMapResourceLimit, netScheduledMapResource);\n+      finalReduceResourceLimit \u003d\n+          Resources.add(idealReduceResourceLimit, unusedMapResourceLimit);\n+      finalMapResourceLimit \u003d\n+          Resources.subtract(totalResourceLimit, finalReduceResourceLimit);\n     } else {\n-      finalMapMemLimit \u003d idealMapMemLimit;\n-      finalReduceMemLimit \u003d idealReduceMemLimit;\n+      finalMapResourceLimit \u003d ideaMapResourceLimit;\n+      finalReduceResourceLimit \u003d idealReduceResourceLimit;\n     }\n-    \n-    LOG.info(\"completedMapPercent \" + completedMapPercent +\n-        \" totalMemLimit:\" + totalMemLimit +\n-        \" finalMapMemLimit:\" + finalMapMemLimit +\n-        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n-        \" netScheduledMapMem:\" + netScheduledMapMem +\n-        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n-    \n-    int rampUp \u003d \n-        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n-    \n+\n+    LOG.info(\"completedMapPercent \" + completedMapPercent\n+        + \" totalResourceLimit:\" + totalResourceLimit\n+        + \" finalMapResourceLimit:\" + finalMapResourceLimit\n+        + \" finalReduceResourceLimit:\" + finalReduceResourceLimit\n+        + \" netScheduledMapResource:\" + netScheduledMapResource\n+        + \" netScheduledReduceResource:\" + netScheduledReduceResource);\n+\n+    int rampUp \u003d\n+        ResourceCalculatorUtils.computeAvailableContainers(Resources.subtract(\n+                finalReduceResourceLimit, netScheduledReduceResource),\n+            reduceResourceReqt, getSchedulerResourceTypes());\n+\n     if (rampUp \u003e 0) {\n       rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n       rampUpReduces(rampUp);\n-    } else if (rampUp \u003c 0){\n+    } else if (rampUp \u003c 0) {\n       int rampDown \u003d -1 * rampUp;\n       rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n       rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      Resource mapResourceReqt, Resource reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    // get available resources for this job\n    Resource headRoom \u003d getAvailableResources();\n    if (headRoom \u003d\u003d null) {\n      headRoom \u003d Resources.none();\n    }\n\n    LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the\n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n          \"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n\n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    Resource netScheduledMapResource \u003d\n        Resources.multiply(mapResourceReqt, (scheduledMaps + assignedMaps));\n\n    Resource netScheduledReduceResource \u003d\n        Resources.multiply(reduceResourceReqt,\n          (scheduledReduces + assignedReduces));\n\n    Resource finalMapResourceLimit;\n    Resource finalReduceResourceLimit;\n\n    // ramp up the reduces based on completed map percentage\n    Resource totalResourceLimit \u003d getResourceLimit();\n\n    Resource idealReduceResourceLimit \u003d\n        Resources.multiply(totalResourceLimit,\n          Math.min(completedMapPercent, maxReduceRampupLimit));\n    Resource ideaMapResourceLimit \u003d\n        Resources.subtract(totalResourceLimit, idealReduceResourceLimit);\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce.\n    // Even when container number equals, there may be unused resources in one\n    // dimension\n    if (ResourceCalculatorUtils.computeAvailableContainers(ideaMapResourceLimit,\n      mapResourceReqt, getSchedulerResourceTypes()) \u003e\u003d (scheduledMaps + assignedMaps)) {\n      // enough resource given to maps, given the remaining to reduces\n      Resource unusedMapResourceLimit \u003d\n          Resources.subtract(ideaMapResourceLimit, netScheduledMapResource);\n      finalReduceResourceLimit \u003d\n          Resources.add(idealReduceResourceLimit, unusedMapResourceLimit);\n      finalMapResourceLimit \u003d\n          Resources.subtract(totalResourceLimit, finalReduceResourceLimit);\n    } else {\n      finalMapResourceLimit \u003d ideaMapResourceLimit;\n      finalReduceResourceLimit \u003d idealReduceResourceLimit;\n    }\n\n    LOG.info(\"completedMapPercent \" + completedMapPercent\n        + \" totalResourceLimit:\" + totalResourceLimit\n        + \" finalMapResourceLimit:\" + finalMapResourceLimit\n        + \" finalReduceResourceLimit:\" + finalReduceResourceLimit\n        + \" netScheduledMapResource:\" + netScheduledMapResource\n        + \" netScheduledReduceResource:\" + netScheduledReduceResource);\n\n    int rampUp \u003d\n        ResourceCalculatorUtils.computeAvailableContainers(Resources.subtract(\n                finalReduceResourceLimit, netScheduledReduceResource),\n            reduceResourceReqt, getSchedulerResourceTypes());\n\n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0) {\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[totalMaps-int, completedMaps-int, scheduledMaps-int, scheduledReduces-int, assignedMaps-int, assignedReduces-int, mapResourceReqt-int, reduceResourceReqt-int, numPendingReduces-int, maxReduceRampupLimit-float, reduceSlowStart-float]",
            "newValue": "[totalMaps-int, completedMaps-int, scheduledMaps-int, scheduledReduces-int, assignedMaps-int, assignedReduces-int, mapResourceReqt-Resource, reduceResourceReqt-Resource, numPendingReduces-int, maxReduceRampupLimit-float, reduceSlowStart-float]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5279. Made MR headroom calculation honor cpu dimension when YARN scheduler resource type is memory plus cpu. Contributed by Peng Zhang and Varun Vasudev.\n",
          "commitDate": "22/09/14 9:28 AM",
          "commitName": "376233cdd4a4ddbde5a92a0627f78338cb4c38b7",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "08/08/14 2:38 PM",
          "commitNameOld": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
          "commitAuthorOld": "Xuan Gong",
          "daysBetweenCommits": 44.78,
          "commitsBetweenForRepo": 414,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,111 @@\n   public void scheduleReduces(\n       int totalMaps, int completedMaps,\n       int scheduledMaps, int scheduledReduces,\n       int assignedMaps, int assignedReduces,\n-      int mapResourceReqt, int reduceResourceReqt,\n+      Resource mapResourceReqt, Resource reduceResourceReqt,\n       int numPendingReduces,\n       float maxReduceRampupLimit, float reduceSlowStart) {\n     \n     if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n-    int headRoom \u003d getAvailableResources() !\u003d null ?\n-        getAvailableResources().getMemory() : 0;\n+    // get available resources for this job\n+    Resource headRoom \u003d getAvailableResources();\n+    if (headRoom \u003d\u003d null) {\n+      headRoom \u003d Resources.none();\n+    }\n+\n     LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n     \n     //check for slow start\n     if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n               \"completedMapsForReduceSlowstart \" + \n             completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n         setIsReduceStarted(true);\n       }\n     }\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the\n     //headroom\n     if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n       LOG.info(\"All maps assigned. \" +\n           \"Ramping up all remaining reduces:\" + numPendingReduces);\n       scheduleAllReduces();\n       return;\n     }\n \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n-    int netScheduledMapMem \u003d \n-        (scheduledMaps + assignedMaps) * mapResourceReqt;\n+    Resource netScheduledMapResource \u003d\n+        Resources.multiply(mapResourceReqt, (scheduledMaps + assignedMaps));\n \n-    int netScheduledReduceMem \u003d \n-        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n+    Resource netScheduledReduceResource \u003d\n+        Resources.multiply(reduceResourceReqt,\n+          (scheduledReduces + assignedReduces));\n \n-    int finalMapMemLimit \u003d 0;\n-    int finalReduceMemLimit \u003d 0;\n-    \n+    Resource finalMapResourceLimit;\n+    Resource finalReduceResourceLimit;\n+\n     // ramp up the reduces based on completed map percentage\n-    int totalMemLimit \u003d getMemLimit();\n-    int idealReduceMemLimit \u003d \n-        Math.min(\n-            (int)(completedMapPercent * totalMemLimit),\n-            (int) (maxReduceRampupLimit * totalMemLimit));\n-    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n+    Resource totalResourceLimit \u003d getResourceLimit();\n+\n+    Resource idealReduceResourceLimit \u003d\n+        Resources.multiply(totalResourceLimit,\n+          Math.min(completedMapPercent, maxReduceRampupLimit));\n+    Resource ideaMapResourceLimit \u003d\n+        Resources.subtract(totalResourceLimit, idealReduceResourceLimit);\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n-    // to reduce\n-    if (idealMapMemLimit \u003e netScheduledMapMem) {\n-      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n-      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n-      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n+    // to reduce.\n+    // Even when container number equals, there may be unused resources in one\n+    // dimension\n+    if (ResourceCalculatorUtils.computeAvailableContainers(ideaMapResourceLimit,\n+      mapResourceReqt, getSchedulerResourceTypes()) \u003e\u003d (scheduledMaps + assignedMaps)) {\n+      // enough resource given to maps, given the remaining to reduces\n+      Resource unusedMapResourceLimit \u003d\n+          Resources.subtract(ideaMapResourceLimit, netScheduledMapResource);\n+      finalReduceResourceLimit \u003d\n+          Resources.add(idealReduceResourceLimit, unusedMapResourceLimit);\n+      finalMapResourceLimit \u003d\n+          Resources.subtract(totalResourceLimit, finalReduceResourceLimit);\n     } else {\n-      finalMapMemLimit \u003d idealMapMemLimit;\n-      finalReduceMemLimit \u003d idealReduceMemLimit;\n+      finalMapResourceLimit \u003d ideaMapResourceLimit;\n+      finalReduceResourceLimit \u003d idealReduceResourceLimit;\n     }\n-    \n-    LOG.info(\"completedMapPercent \" + completedMapPercent +\n-        \" totalMemLimit:\" + totalMemLimit +\n-        \" finalMapMemLimit:\" + finalMapMemLimit +\n-        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n-        \" netScheduledMapMem:\" + netScheduledMapMem +\n-        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n-    \n-    int rampUp \u003d \n-        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n-    \n+\n+    LOG.info(\"completedMapPercent \" + completedMapPercent\n+        + \" totalResourceLimit:\" + totalResourceLimit\n+        + \" finalMapResourceLimit:\" + finalMapResourceLimit\n+        + \" finalReduceResourceLimit:\" + finalReduceResourceLimit\n+        + \" netScheduledMapResource:\" + netScheduledMapResource\n+        + \" netScheduledReduceResource:\" + netScheduledReduceResource);\n+\n+    int rampUp \u003d\n+        ResourceCalculatorUtils.computeAvailableContainers(Resources.subtract(\n+                finalReduceResourceLimit, netScheduledReduceResource),\n+            reduceResourceReqt, getSchedulerResourceTypes());\n+\n     if (rampUp \u003e 0) {\n       rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n       rampUpReduces(rampUp);\n-    } else if (rampUp \u003c 0){\n+    } else if (rampUp \u003c 0) {\n       int rampDown \u003d -1 * rampUp;\n       rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n       rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      Resource mapResourceReqt, Resource reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    // get available resources for this job\n    Resource headRoom \u003d getAvailableResources();\n    if (headRoom \u003d\u003d null) {\n      headRoom \u003d Resources.none();\n    }\n\n    LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the\n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n          \"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n\n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    Resource netScheduledMapResource \u003d\n        Resources.multiply(mapResourceReqt, (scheduledMaps + assignedMaps));\n\n    Resource netScheduledReduceResource \u003d\n        Resources.multiply(reduceResourceReqt,\n          (scheduledReduces + assignedReduces));\n\n    Resource finalMapResourceLimit;\n    Resource finalReduceResourceLimit;\n\n    // ramp up the reduces based on completed map percentage\n    Resource totalResourceLimit \u003d getResourceLimit();\n\n    Resource idealReduceResourceLimit \u003d\n        Resources.multiply(totalResourceLimit,\n          Math.min(completedMapPercent, maxReduceRampupLimit));\n    Resource ideaMapResourceLimit \u003d\n        Resources.subtract(totalResourceLimit, idealReduceResourceLimit);\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce.\n    // Even when container number equals, there may be unused resources in one\n    // dimension\n    if (ResourceCalculatorUtils.computeAvailableContainers(ideaMapResourceLimit,\n      mapResourceReqt, getSchedulerResourceTypes()) \u003e\u003d (scheduledMaps + assignedMaps)) {\n      // enough resource given to maps, given the remaining to reduces\n      Resource unusedMapResourceLimit \u003d\n          Resources.subtract(ideaMapResourceLimit, netScheduledMapResource);\n      finalReduceResourceLimit \u003d\n          Resources.add(idealReduceResourceLimit, unusedMapResourceLimit);\n      finalMapResourceLimit \u003d\n          Resources.subtract(totalResourceLimit, finalReduceResourceLimit);\n    } else {\n      finalMapResourceLimit \u003d ideaMapResourceLimit;\n      finalReduceResourceLimit \u003d idealReduceResourceLimit;\n    }\n\n    LOG.info(\"completedMapPercent \" + completedMapPercent\n        + \" totalResourceLimit:\" + totalResourceLimit\n        + \" finalMapResourceLimit:\" + finalMapResourceLimit\n        + \" finalReduceResourceLimit:\" + finalReduceResourceLimit\n        + \" netScheduledMapResource:\" + netScheduledMapResource\n        + \" netScheduledReduceResource:\" + netScheduledReduceResource);\n\n    int rampUp \u003d\n        ResourceCalculatorUtils.computeAvailableContainers(Resources.subtract(\n                finalReduceResourceLimit, netScheduledReduceResource),\n            reduceResourceReqt, getSchedulerResourceTypes());\n\n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0) {\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "b2f7a66e50bd09d26b2ad22e66ced73a6254de77": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4517. Too many INFO messages written out during AM to RM heartbeat (Jason Lowe via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1409032 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 3:47 PM",
      "commitName": "b2f7a66e50bd09d26b2ad22e66ced73a6254de77",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "31/10/12 7:57 AM",
      "commitNameOld": "aac5c149c7ca500b8eb810b7d4b561ff1e38ea02",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 13.37,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n   public void scheduleReduces(\n       int totalMaps, int completedMaps,\n       int scheduledMaps, int scheduledReduces,\n       int assignedMaps, int assignedReduces,\n       int mapResourceReqt, int reduceResourceReqt,\n       int numPendingReduces,\n       float maxReduceRampupLimit, float reduceSlowStart) {\n     \n     if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n-    LOG.info(\"Recalculating schedule...\");\n+    int headRoom \u003d getAvailableResources() !\u003d null ?\n+        getAvailableResources().getMemory() : 0;\n+    LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n     \n     //check for slow start\n     if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n               \"completedMapsForReduceSlowstart \" + \n             completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n         setIsReduceStarted(true);\n       }\n     }\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the\n     //headroom\n     if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n       LOG.info(\"All maps assigned. \" +\n           \"Ramping up all remaining reduces:\" + numPendingReduces);\n       scheduleAllReduces();\n       return;\n     }\n \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n     int netScheduledMapMem \u003d \n         (scheduledMaps + assignedMaps) * mapResourceReqt;\n \n     int netScheduledReduceMem \u003d \n         (scheduledReduces + assignedReduces) * reduceResourceReqt;\n \n     int finalMapMemLimit \u003d 0;\n     int finalReduceMemLimit \u003d 0;\n     \n     // ramp up the reduces based on completed map percentage\n     int totalMemLimit \u003d getMemLimit();\n     int idealReduceMemLimit \u003d \n         Math.min(\n             (int)(completedMapPercent * totalMemLimit),\n             (int) (maxReduceRampupLimit * totalMemLimit));\n     int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n     // to reduce\n     if (idealMapMemLimit \u003e netScheduledMapMem) {\n       int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n       finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n       finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n     } else {\n       finalMapMemLimit \u003d idealMapMemLimit;\n       finalReduceMemLimit \u003d idealReduceMemLimit;\n     }\n     \n     LOG.info(\"completedMapPercent \" + completedMapPercent +\n         \" totalMemLimit:\" + totalMemLimit +\n         \" finalMapMemLimit:\" + finalMapMemLimit +\n         \" finalReduceMemLimit:\" + finalReduceMemLimit + \n         \" netScheduledMapMem:\" + netScheduledMapMem +\n         \" netScheduledReduceMem:\" + netScheduledReduceMem);\n     \n     int rampUp \u003d \n         (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n     \n     if (rampUp \u003e 0) {\n       rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n       rampUpReduces(rampUp);\n     } else if (rampUp \u003c 0){\n       int rampDown \u003d -1 * rampUp;\n       rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n       rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      int mapResourceReqt, int reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    int headRoom \u003d getAvailableResources() !\u003d null ?\n        getAvailableResources().getMemory() : 0;\n    LOG.info(\"Recalculating schedule, headroom\u003d\" + headRoom);\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the\n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n          \"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n\n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d \n        (scheduledMaps + assignedMaps) * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d \n        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d \n        Math.min(\n            (int)(completedMapPercent * totalMemLimit),\n            (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d \n        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "03f2f9b5809fb324227651fc936a61bd583fad5f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4228. mapreduce.job.reduce.slowstart.completedmaps is not working properly (Jason Lowe via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354181 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/06/12 12:17 PM",
      "commitName": "03f2f9b5809fb324227651fc936a61bd583fad5f",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "11/06/12 4:14 PM",
      "commitNameOld": "eff9fa1aad7e22d445a11e4ba732b4d49cdaca65",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 14.84,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n   public void scheduleReduces(\n       int totalMaps, int completedMaps,\n       int scheduledMaps, int scheduledReduces,\n       int assignedMaps, int assignedReduces,\n       int mapResourceReqt, int reduceResourceReqt,\n       int numPendingReduces,\n       float maxReduceRampupLimit, float reduceSlowStart) {\n     \n     if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n     LOG.info(\"Recalculating schedule...\");\n     \n-    //if all maps are assigned, then ramp up all reduces irrespective of the \n-    //headroom\n-    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n-      LOG.info(\"All maps assigned. \" +\n-      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n-      scheduleAllReduces();\n-      return;\n-    }\n-    \n     //check for slow start\n     if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n               \"completedMapsForReduceSlowstart \" + \n             completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n         setIsReduceStarted(true);\n       }\n     }\n     \n+    //if all maps are assigned, then ramp up all reduces irrespective of the\n+    //headroom\n+    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n+      LOG.info(\"All maps assigned. \" +\n+          \"Ramping up all remaining reduces:\" + numPendingReduces);\n+      scheduleAllReduces();\n+      return;\n+    }\n+\n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n     int netScheduledMapMem \u003d \n         (scheduledMaps + assignedMaps) * mapResourceReqt;\n \n     int netScheduledReduceMem \u003d \n         (scheduledReduces + assignedReduces) * reduceResourceReqt;\n \n     int finalMapMemLimit \u003d 0;\n     int finalReduceMemLimit \u003d 0;\n     \n     // ramp up the reduces based on completed map percentage\n     int totalMemLimit \u003d getMemLimit();\n     int idealReduceMemLimit \u003d \n         Math.min(\n             (int)(completedMapPercent * totalMemLimit),\n             (int) (maxReduceRampupLimit * totalMemLimit));\n     int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n     // to reduce\n     if (idealMapMemLimit \u003e netScheduledMapMem) {\n       int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n       finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n       finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n     } else {\n       finalMapMemLimit \u003d idealMapMemLimit;\n       finalReduceMemLimit \u003d idealReduceMemLimit;\n     }\n     \n     LOG.info(\"completedMapPercent \" + completedMapPercent +\n         \" totalMemLimit:\" + totalMemLimit +\n         \" finalMapMemLimit:\" + finalMapMemLimit +\n         \" finalReduceMemLimit:\" + finalReduceMemLimit + \n         \" netScheduledMapMem:\" + netScheduledMapMem +\n         \" netScheduledReduceMem:\" + netScheduledReduceMem);\n     \n     int rampUp \u003d \n         (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n     \n     if (rampUp \u003e 0) {\n       rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n       rampUpReduces(rampUp);\n     } else if (rampUp \u003c 0){\n       int rampDown \u003d -1 * rampUp;\n       rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n       rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      int mapResourceReqt, int reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    LOG.info(\"Recalculating schedule...\");\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the\n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n          \"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n\n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d \n        (scheduledMaps + assignedMaps) * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d \n        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d \n        Math.min(\n            (int)(completedMapPercent * totalMemLimit),\n            (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d \n        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "55e94dc5ef4171c4e7b57942f22ead9a01dd9012": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3490. Fixed MapReduce AM to count failed maps also towards Reduce ramp up. Contributed by Sharad Agarwal and Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1227226 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 9:10 AM",
      "commitName": "55e94dc5ef4171c4e7b57942f22ead9a01dd9012",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3490. Fixed MapReduce AM to count failed maps also towards Reduce ramp up. Contributed by Sharad Agarwal and Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1227226 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/01/12 9:10 AM",
          "commitName": "55e94dc5ef4171c4e7b57942f22ead9a01dd9012",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/12/11 3:27 PM",
          "commitNameOld": "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.74,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,94 @@\n-  private void scheduleReduces() {\n+  public void scheduleReduces(\n+      int totalMaps, int completedMaps,\n+      int scheduledMaps, int scheduledReduces,\n+      int assignedMaps, int assignedReduces,\n+      int mapResourceReqt, int reduceResourceReqt,\n+      int numPendingReduces,\n+      float maxReduceRampupLimit, float reduceSlowStart) {\n     \n-    if (pendingReduces.size() \u003d\u003d 0) {\n+    if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n     LOG.info(\"Recalculating schedule...\");\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the \n     //headroom\n-    if (scheduledRequests.maps.size() \u003d\u003d 0 \u0026\u0026 pendingReduces.size() \u003e 0) {\n-      LOG.info(\"All maps assigned. Ramping up all remaining reduces:\" + pendingReduces.size());\n-      for (ContainerRequest req : pendingReduces) {\n-        scheduledRequests.addReduce(req);\n-      }\n-      pendingReduces.clear();\n+    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n+      LOG.info(\"All maps assigned. \" +\n+      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n+      scheduleAllReduces();\n       return;\n     }\n     \n-    \n-    int totalMaps \u003d assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();\n-    \n     //check for slow start\n-    if (!reduceStarted) {//not set yet\n+    if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n-              \"completedMapsForReduceSlowstart \" + completedMapsForReduceSlowstart);\n+              \"completedMapsForReduceSlowstart \" + \n+            completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n-        reduceStarted \u003d true;\n+        setIsReduceStarted(true);\n       }\n     }\n     \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n-    int netScheduledMapMem \u003d scheduledRequests.maps.size() * mapResourceReqt\n-        + assignedRequests.maps.size() * mapResourceReqt;\n+    int netScheduledMapMem \u003d \n+        (scheduledMaps + assignedMaps) * mapResourceReqt;\n \n-    int netScheduledReduceMem \u003d scheduledRequests.reduces.size()\n-        * reduceResourceReqt + assignedRequests.reduces.size()\n-        * reduceResourceReqt;\n+    int netScheduledReduceMem \u003d \n+        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n \n     int finalMapMemLimit \u003d 0;\n     int finalReduceMemLimit \u003d 0;\n     \n     // ramp up the reduces based on completed map percentage\n     int totalMemLimit \u003d getMemLimit();\n-    int idealReduceMemLimit \u003d Math.min((int)(completedMapPercent * totalMemLimit),\n-        (int) (maxReduceRampupLimit * totalMemLimit));\n+    int idealReduceMemLimit \u003d \n+        Math.min(\n+            (int)(completedMapPercent * totalMemLimit),\n+            (int) (maxReduceRampupLimit * totalMemLimit));\n     int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n     // to reduce\n     if (idealMapMemLimit \u003e netScheduledMapMem) {\n       int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n       finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n       finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n     } else {\n       finalMapMemLimit \u003d idealMapMemLimit;\n       finalReduceMemLimit \u003d idealReduceMemLimit;\n     }\n     \n     LOG.info(\"completedMapPercent \" + completedMapPercent +\n         \" totalMemLimit:\" + totalMemLimit +\n         \" finalMapMemLimit:\" + finalMapMemLimit +\n         \" finalReduceMemLimit:\" + finalReduceMemLimit + \n         \" netScheduledMapMem:\" + netScheduledMapMem +\n         \" netScheduledReduceMem:\" + netScheduledReduceMem);\n     \n-    int rampUp \u003d (finalReduceMemLimit - netScheduledReduceMem)\n-        / reduceResourceReqt;\n+    int rampUp \u003d \n+        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n     \n     if (rampUp \u003e 0) {\n-      rampUp \u003d Math.min(rampUp, pendingReduces.size());\n+      rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n-      //more reduce to be scheduled\n-      for (int i \u003d 0; i \u003c rampUp; i++) {\n-        ContainerRequest request \u003d pendingReduces.removeFirst();\n-        scheduledRequests.addReduce(request);\n-      }\n+      rampUpReduces(rampUp);\n     } else if (rampUp \u003c 0){\n       int rampDown \u003d -1 * rampUp;\n-      rampDown \u003d Math.min(rampDown, scheduledRequests.reduces.size());\n+      rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n-      //remove from the scheduled and move back to pending\n-      for (int i \u003d 0; i \u003c rampDown; i++) {\n-        ContainerRequest request \u003d scheduledRequests.removeReduce();\n-        pendingReduces.add(request);\n-      }\n+      rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      int mapResourceReqt, int reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    LOG.info(\"Recalculating schedule...\");\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the \n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d \n        (scheduledMaps + assignedMaps) * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d \n        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d \n        Math.min(\n            (int)(completedMapPercent * totalMemLimit),\n            (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d \n        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[totalMaps-int, completedMaps-int, scheduledMaps-int, scheduledReduces-int, assignedMaps-int, assignedReduces-int, mapResourceReqt-int, reduceResourceReqt-int, numPendingReduces-int, maxReduceRampupLimit-float, reduceSlowStart-float]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE-3490. Fixed MapReduce AM to count failed maps also towards Reduce ramp up. Contributed by Sharad Agarwal and Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1227226 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/01/12 9:10 AM",
          "commitName": "55e94dc5ef4171c4e7b57942f22ead9a01dd9012",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/12/11 3:27 PM",
          "commitNameOld": "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.74,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,94 @@\n-  private void scheduleReduces() {\n+  public void scheduleReduces(\n+      int totalMaps, int completedMaps,\n+      int scheduledMaps, int scheduledReduces,\n+      int assignedMaps, int assignedReduces,\n+      int mapResourceReqt, int reduceResourceReqt,\n+      int numPendingReduces,\n+      float maxReduceRampupLimit, float reduceSlowStart) {\n     \n-    if (pendingReduces.size() \u003d\u003d 0) {\n+    if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n     LOG.info(\"Recalculating schedule...\");\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the \n     //headroom\n-    if (scheduledRequests.maps.size() \u003d\u003d 0 \u0026\u0026 pendingReduces.size() \u003e 0) {\n-      LOG.info(\"All maps assigned. Ramping up all remaining reduces:\" + pendingReduces.size());\n-      for (ContainerRequest req : pendingReduces) {\n-        scheduledRequests.addReduce(req);\n-      }\n-      pendingReduces.clear();\n+    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n+      LOG.info(\"All maps assigned. \" +\n+      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n+      scheduleAllReduces();\n       return;\n     }\n     \n-    \n-    int totalMaps \u003d assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();\n-    \n     //check for slow start\n-    if (!reduceStarted) {//not set yet\n+    if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n-              \"completedMapsForReduceSlowstart \" + completedMapsForReduceSlowstart);\n+              \"completedMapsForReduceSlowstart \" + \n+            completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n-        reduceStarted \u003d true;\n+        setIsReduceStarted(true);\n       }\n     }\n     \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n-    int netScheduledMapMem \u003d scheduledRequests.maps.size() * mapResourceReqt\n-        + assignedRequests.maps.size() * mapResourceReqt;\n+    int netScheduledMapMem \u003d \n+        (scheduledMaps + assignedMaps) * mapResourceReqt;\n \n-    int netScheduledReduceMem \u003d scheduledRequests.reduces.size()\n-        * reduceResourceReqt + assignedRequests.reduces.size()\n-        * reduceResourceReqt;\n+    int netScheduledReduceMem \u003d \n+        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n \n     int finalMapMemLimit \u003d 0;\n     int finalReduceMemLimit \u003d 0;\n     \n     // ramp up the reduces based on completed map percentage\n     int totalMemLimit \u003d getMemLimit();\n-    int idealReduceMemLimit \u003d Math.min((int)(completedMapPercent * totalMemLimit),\n-        (int) (maxReduceRampupLimit * totalMemLimit));\n+    int idealReduceMemLimit \u003d \n+        Math.min(\n+            (int)(completedMapPercent * totalMemLimit),\n+            (int) (maxReduceRampupLimit * totalMemLimit));\n     int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n     // to reduce\n     if (idealMapMemLimit \u003e netScheduledMapMem) {\n       int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n       finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n       finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n     } else {\n       finalMapMemLimit \u003d idealMapMemLimit;\n       finalReduceMemLimit \u003d idealReduceMemLimit;\n     }\n     \n     LOG.info(\"completedMapPercent \" + completedMapPercent +\n         \" totalMemLimit:\" + totalMemLimit +\n         \" finalMapMemLimit:\" + finalMapMemLimit +\n         \" finalReduceMemLimit:\" + finalReduceMemLimit + \n         \" netScheduledMapMem:\" + netScheduledMapMem +\n         \" netScheduledReduceMem:\" + netScheduledReduceMem);\n     \n-    int rampUp \u003d (finalReduceMemLimit - netScheduledReduceMem)\n-        / reduceResourceReqt;\n+    int rampUp \u003d \n+        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n     \n     if (rampUp \u003e 0) {\n-      rampUp \u003d Math.min(rampUp, pendingReduces.size());\n+      rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n-      //more reduce to be scheduled\n-      for (int i \u003d 0; i \u003c rampUp; i++) {\n-        ContainerRequest request \u003d pendingReduces.removeFirst();\n-        scheduledRequests.addReduce(request);\n-      }\n+      rampUpReduces(rampUp);\n     } else if (rampUp \u003c 0){\n       int rampDown \u003d -1 * rampUp;\n-      rampDown \u003d Math.min(rampDown, scheduledRequests.reduces.size());\n+      rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n-      //remove from the scheduled and move back to pending\n-      for (int i \u003d 0; i \u003c rampDown; i++) {\n-        ContainerRequest request \u003d scheduledRequests.removeReduce();\n-        pendingReduces.add(request);\n-      }\n+      rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      int mapResourceReqt, int reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    LOG.info(\"Recalculating schedule...\");\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the \n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d \n        (scheduledMaps + assignedMaps) * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d \n        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d \n        Math.min(\n            (int)(completedMapPercent * totalMemLimit),\n            (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d \n        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3490. Fixed MapReduce AM to count failed maps also towards Reduce ramp up. Contributed by Sharad Agarwal and Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1227226 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/01/12 9:10 AM",
          "commitName": "55e94dc5ef4171c4e7b57942f22ead9a01dd9012",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/12/11 3:27 PM",
          "commitNameOld": "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.74,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,94 @@\n-  private void scheduleReduces() {\n+  public void scheduleReduces(\n+      int totalMaps, int completedMaps,\n+      int scheduledMaps, int scheduledReduces,\n+      int assignedMaps, int assignedReduces,\n+      int mapResourceReqt, int reduceResourceReqt,\n+      int numPendingReduces,\n+      float maxReduceRampupLimit, float reduceSlowStart) {\n     \n-    if (pendingReduces.size() \u003d\u003d 0) {\n+    if (numPendingReduces \u003d\u003d 0) {\n       return;\n     }\n     \n     LOG.info(\"Recalculating schedule...\");\n     \n     //if all maps are assigned, then ramp up all reduces irrespective of the \n     //headroom\n-    if (scheduledRequests.maps.size() \u003d\u003d 0 \u0026\u0026 pendingReduces.size() \u003e 0) {\n-      LOG.info(\"All maps assigned. Ramping up all remaining reduces:\" + pendingReduces.size());\n-      for (ContainerRequest req : pendingReduces) {\n-        scheduledRequests.addReduce(req);\n-      }\n-      pendingReduces.clear();\n+    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n+      LOG.info(\"All maps assigned. \" +\n+      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n+      scheduleAllReduces();\n       return;\n     }\n     \n-    \n-    int totalMaps \u003d assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();\n-    \n     //check for slow start\n-    if (!reduceStarted) {//not set yet\n+    if (!getIsReduceStarted()) {//not set yet\n       int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                       totalMaps);\n       if(completedMaps \u003c completedMapsForReduceSlowstart) {\n         LOG.info(\"Reduce slow start threshold not met. \" +\n-              \"completedMapsForReduceSlowstart \" + completedMapsForReduceSlowstart);\n+              \"completedMapsForReduceSlowstart \" + \n+            completedMapsForReduceSlowstart);\n         return;\n       } else {\n         LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n-        reduceStarted \u003d true;\n+        setIsReduceStarted(true);\n       }\n     }\n     \n     float completedMapPercent \u003d 0f;\n     if (totalMaps !\u003d 0) {//support for 0 maps\n       completedMapPercent \u003d (float)completedMaps/totalMaps;\n     } else {\n       completedMapPercent \u003d 1;\n     }\n     \n-    int netScheduledMapMem \u003d scheduledRequests.maps.size() * mapResourceReqt\n-        + assignedRequests.maps.size() * mapResourceReqt;\n+    int netScheduledMapMem \u003d \n+        (scheduledMaps + assignedMaps) * mapResourceReqt;\n \n-    int netScheduledReduceMem \u003d scheduledRequests.reduces.size()\n-        * reduceResourceReqt + assignedRequests.reduces.size()\n-        * reduceResourceReqt;\n+    int netScheduledReduceMem \u003d \n+        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n \n     int finalMapMemLimit \u003d 0;\n     int finalReduceMemLimit \u003d 0;\n     \n     // ramp up the reduces based on completed map percentage\n     int totalMemLimit \u003d getMemLimit();\n-    int idealReduceMemLimit \u003d Math.min((int)(completedMapPercent * totalMemLimit),\n-        (int) (maxReduceRampupLimit * totalMemLimit));\n+    int idealReduceMemLimit \u003d \n+        Math.min(\n+            (int)(completedMapPercent * totalMemLimit),\n+            (int) (maxReduceRampupLimit * totalMemLimit));\n     int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n \n     // check if there aren\u0027t enough maps scheduled, give the free map capacity\n     // to reduce\n     if (idealMapMemLimit \u003e netScheduledMapMem) {\n       int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n       finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n       finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n     } else {\n       finalMapMemLimit \u003d idealMapMemLimit;\n       finalReduceMemLimit \u003d idealReduceMemLimit;\n     }\n     \n     LOG.info(\"completedMapPercent \" + completedMapPercent +\n         \" totalMemLimit:\" + totalMemLimit +\n         \" finalMapMemLimit:\" + finalMapMemLimit +\n         \" finalReduceMemLimit:\" + finalReduceMemLimit + \n         \" netScheduledMapMem:\" + netScheduledMapMem +\n         \" netScheduledReduceMem:\" + netScheduledReduceMem);\n     \n-    int rampUp \u003d (finalReduceMemLimit - netScheduledReduceMem)\n-        / reduceResourceReqt;\n+    int rampUp \u003d \n+        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n     \n     if (rampUp \u003e 0) {\n-      rampUp \u003d Math.min(rampUp, pendingReduces.size());\n+      rampUp \u003d Math.min(rampUp, numPendingReduces);\n       LOG.info(\"Ramping up \" + rampUp);\n-      //more reduce to be scheduled\n-      for (int i \u003d 0; i \u003c rampUp; i++) {\n-        ContainerRequest request \u003d pendingReduces.removeFirst();\n-        scheduledRequests.addReduce(request);\n-      }\n+      rampUpReduces(rampUp);\n     } else if (rampUp \u003c 0){\n       int rampDown \u003d -1 * rampUp;\n-      rampDown \u003d Math.min(rampDown, scheduledRequests.reduces.size());\n+      rampDown \u003d Math.min(rampDown, scheduledReduces);\n       LOG.info(\"Ramping down \" + rampDown);\n-      //remove from the scheduled and move back to pending\n-      for (int i \u003d 0; i \u003c rampDown; i++) {\n-        ContainerRequest request \u003d scheduledRequests.removeReduce();\n-        pendingReduces.add(request);\n-      }\n+      rampDownReduces(rampDown);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void scheduleReduces(\n      int totalMaps, int completedMaps,\n      int scheduledMaps, int scheduledReduces,\n      int assignedMaps, int assignedReduces,\n      int mapResourceReqt, int reduceResourceReqt,\n      int numPendingReduces,\n      float maxReduceRampupLimit, float reduceSlowStart) {\n    \n    if (numPendingReduces \u003d\u003d 0) {\n      return;\n    }\n    \n    LOG.info(\"Recalculating schedule...\");\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the \n    //headroom\n    if (scheduledMaps \u003d\u003d 0 \u0026\u0026 numPendingReduces \u003e 0) {\n      LOG.info(\"All maps assigned. \" +\n      \t\t\"Ramping up all remaining reduces:\" + numPendingReduces);\n      scheduleAllReduces();\n      return;\n    }\n    \n    //check for slow start\n    if (!getIsReduceStarted()) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + \n            completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        setIsReduceStarted(true);\n      }\n    }\n    \n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d \n        (scheduledMaps + assignedMaps) * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d \n        (scheduledReduces + assignedReduces) * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d \n        Math.min(\n            (int)(completedMapPercent * totalMemLimit),\n            (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d \n        (finalReduceMemLimit - netScheduledReduceMem) / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, numPendingReduces);\n      LOG.info(\"Ramping up \" + rampUp);\n      rampUpReduces(rampUp);\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledReduces);\n      LOG.info(\"Ramping down \" + rampDown);\n      rampDownReduces(rampDown);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void scheduleReduces() {\n    \n    if (pendingReduces.size() \u003d\u003d 0) {\n      return;\n    }\n    \n    LOG.info(\"Recalculating schedule...\");\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the \n    //headroom\n    if (scheduledRequests.maps.size() \u003d\u003d 0 \u0026\u0026 pendingReduces.size() \u003e 0) {\n      LOG.info(\"All maps assigned. Ramping up all remaining reduces:\" + pendingReduces.size());\n      for (ContainerRequest req : pendingReduces) {\n        scheduledRequests.addReduce(req);\n      }\n      pendingReduces.clear();\n      return;\n    }\n    \n    \n    int totalMaps \u003d assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();\n    \n    //check for slow start\n    if (!reduceStarted) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        reduceStarted \u003d true;\n      }\n    }\n    \n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d scheduledRequests.maps.size() * mapResourceReqt\n        + assignedRequests.maps.size() * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d scheduledRequests.reduces.size()\n        * reduceResourceReqt + assignedRequests.reduces.size()\n        * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d Math.min((int)(completedMapPercent * totalMemLimit),\n        (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d (finalReduceMemLimit - netScheduledReduceMem)\n        / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, pendingReduces.size());\n      LOG.info(\"Ramping up \" + rampUp);\n      //more reduce to be scheduled\n      for (int i \u003d 0; i \u003c rampUp; i++) {\n        ContainerRequest request \u003d pendingReduces.removeFirst();\n        scheduledRequests.addReduce(request);\n      }\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledRequests.reduces.size());\n      LOG.info(\"Ramping down \" + rampDown);\n      //remove from the scheduled and move back to pending\n      for (int i \u003d 0; i \u003c rampDown; i++) {\n        ContainerRequest request \u003d scheduledRequests.removeReduce();\n        pendingReduces.add(request);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,99 @@\n+  private void scheduleReduces() {\n+    \n+    if (pendingReduces.size() \u003d\u003d 0) {\n+      return;\n+    }\n+    \n+    LOG.info(\"Recalculating schedule...\");\n+    \n+    //if all maps are assigned, then ramp up all reduces irrespective of the \n+    //headroom\n+    if (scheduledRequests.maps.size() \u003d\u003d 0 \u0026\u0026 pendingReduces.size() \u003e 0) {\n+      LOG.info(\"All maps assigned. Ramping up all remaining reduces:\" + pendingReduces.size());\n+      for (ContainerRequest req : pendingReduces) {\n+        scheduledRequests.addReduce(req);\n+      }\n+      pendingReduces.clear();\n+      return;\n+    }\n+    \n+    \n+    int totalMaps \u003d assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();\n+    \n+    //check for slow start\n+    if (!reduceStarted) {//not set yet\n+      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n+                      totalMaps);\n+      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n+        LOG.info(\"Reduce slow start threshold not met. \" +\n+              \"completedMapsForReduceSlowstart \" + completedMapsForReduceSlowstart);\n+        return;\n+      } else {\n+        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n+        reduceStarted \u003d true;\n+      }\n+    }\n+    \n+    float completedMapPercent \u003d 0f;\n+    if (totalMaps !\u003d 0) {//support for 0 maps\n+      completedMapPercent \u003d (float)completedMaps/totalMaps;\n+    } else {\n+      completedMapPercent \u003d 1;\n+    }\n+    \n+    int netScheduledMapMem \u003d scheduledRequests.maps.size() * mapResourceReqt\n+        + assignedRequests.maps.size() * mapResourceReqt;\n+\n+    int netScheduledReduceMem \u003d scheduledRequests.reduces.size()\n+        * reduceResourceReqt + assignedRequests.reduces.size()\n+        * reduceResourceReqt;\n+\n+    int finalMapMemLimit \u003d 0;\n+    int finalReduceMemLimit \u003d 0;\n+    \n+    // ramp up the reduces based on completed map percentage\n+    int totalMemLimit \u003d getMemLimit();\n+    int idealReduceMemLimit \u003d Math.min((int)(completedMapPercent * totalMemLimit),\n+        (int) (maxReduceRampupLimit * totalMemLimit));\n+    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n+\n+    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n+    // to reduce\n+    if (idealMapMemLimit \u003e netScheduledMapMem) {\n+      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n+      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n+      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n+    } else {\n+      finalMapMemLimit \u003d idealMapMemLimit;\n+      finalReduceMemLimit \u003d idealReduceMemLimit;\n+    }\n+    \n+    LOG.info(\"completedMapPercent \" + completedMapPercent +\n+        \" totalMemLimit:\" + totalMemLimit +\n+        \" finalMapMemLimit:\" + finalMapMemLimit +\n+        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n+        \" netScheduledMapMem:\" + netScheduledMapMem +\n+        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n+    \n+    int rampUp \u003d (finalReduceMemLimit - netScheduledReduceMem)\n+        / reduceResourceReqt;\n+    \n+    if (rampUp \u003e 0) {\n+      rampUp \u003d Math.min(rampUp, pendingReduces.size());\n+      LOG.info(\"Ramping up \" + rampUp);\n+      //more reduce to be scheduled\n+      for (int i \u003d 0; i \u003c rampUp; i++) {\n+        ContainerRequest request \u003d pendingReduces.removeFirst();\n+        scheduledRequests.addReduce(request);\n+      }\n+    } else if (rampUp \u003c 0){\n+      int rampDown \u003d -1 * rampUp;\n+      rampDown \u003d Math.min(rampDown, scheduledRequests.reduces.size());\n+      LOG.info(\"Ramping down \" + rampDown);\n+      //remove from the scheduled and move back to pending\n+      for (int i \u003d 0; i \u003c rampDown; i++) {\n+        ContainerRequest request \u003d scheduledRequests.removeReduce();\n+        pendingReduces.add(request);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void scheduleReduces() {\n    \n    if (pendingReduces.size() \u003d\u003d 0) {\n      return;\n    }\n    \n    LOG.info(\"Recalculating schedule...\");\n    \n    //if all maps are assigned, then ramp up all reduces irrespective of the \n    //headroom\n    if (scheduledRequests.maps.size() \u003d\u003d 0 \u0026\u0026 pendingReduces.size() \u003e 0) {\n      LOG.info(\"All maps assigned. Ramping up all remaining reduces:\" + pendingReduces.size());\n      for (ContainerRequest req : pendingReduces) {\n        scheduledRequests.addReduce(req);\n      }\n      pendingReduces.clear();\n      return;\n    }\n    \n    \n    int totalMaps \u003d assignedRequests.maps.size() + completedMaps + scheduledRequests.maps.size();\n    \n    //check for slow start\n    if (!reduceStarted) {//not set yet\n      int completedMapsForReduceSlowstart \u003d (int)Math.ceil(reduceSlowStart * \n                      totalMaps);\n      if(completedMaps \u003c completedMapsForReduceSlowstart) {\n        LOG.info(\"Reduce slow start threshold not met. \" +\n              \"completedMapsForReduceSlowstart \" + completedMapsForReduceSlowstart);\n        return;\n      } else {\n        LOG.info(\"Reduce slow start threshold reached. Scheduling reduces.\");\n        reduceStarted \u003d true;\n      }\n    }\n    \n    float completedMapPercent \u003d 0f;\n    if (totalMaps !\u003d 0) {//support for 0 maps\n      completedMapPercent \u003d (float)completedMaps/totalMaps;\n    } else {\n      completedMapPercent \u003d 1;\n    }\n    \n    int netScheduledMapMem \u003d scheduledRequests.maps.size() * mapResourceReqt\n        + assignedRequests.maps.size() * mapResourceReqt;\n\n    int netScheduledReduceMem \u003d scheduledRequests.reduces.size()\n        * reduceResourceReqt + assignedRequests.reduces.size()\n        * reduceResourceReqt;\n\n    int finalMapMemLimit \u003d 0;\n    int finalReduceMemLimit \u003d 0;\n    \n    // ramp up the reduces based on completed map percentage\n    int totalMemLimit \u003d getMemLimit();\n    int idealReduceMemLimit \u003d Math.min((int)(completedMapPercent * totalMemLimit),\n        (int) (maxReduceRampupLimit * totalMemLimit));\n    int idealMapMemLimit \u003d totalMemLimit - idealReduceMemLimit;\n\n    // check if there aren\u0027t enough maps scheduled, give the free map capacity\n    // to reduce\n    if (idealMapMemLimit \u003e netScheduledMapMem) {\n      int unusedMapMemLimit \u003d idealMapMemLimit - netScheduledMapMem;\n      finalReduceMemLimit \u003d idealReduceMemLimit + unusedMapMemLimit;\n      finalMapMemLimit \u003d totalMemLimit - finalReduceMemLimit;\n    } else {\n      finalMapMemLimit \u003d idealMapMemLimit;\n      finalReduceMemLimit \u003d idealReduceMemLimit;\n    }\n    \n    LOG.info(\"completedMapPercent \" + completedMapPercent +\n        \" totalMemLimit:\" + totalMemLimit +\n        \" finalMapMemLimit:\" + finalMapMemLimit +\n        \" finalReduceMemLimit:\" + finalReduceMemLimit + \n        \" netScheduledMapMem:\" + netScheduledMapMem +\n        \" netScheduledReduceMem:\" + netScheduledReduceMem);\n    \n    int rampUp \u003d (finalReduceMemLimit - netScheduledReduceMem)\n        / reduceResourceReqt;\n    \n    if (rampUp \u003e 0) {\n      rampUp \u003d Math.min(rampUp, pendingReduces.size());\n      LOG.info(\"Ramping up \" + rampUp);\n      //more reduce to be scheduled\n      for (int i \u003d 0; i \u003c rampUp; i++) {\n        ContainerRequest request \u003d pendingReduces.removeFirst();\n        scheduledRequests.addReduce(request);\n      }\n    } else if (rampUp \u003c 0){\n      int rampDown \u003d -1 * rampUp;\n      rampDown \u003d Math.min(rampDown, scheduledRequests.reduces.size());\n      LOG.info(\"Ramping down \" + rampDown);\n      //remove from the scheduled and move back to pending\n      for (int i \u003d 0; i \u003c rampDown; i++) {\n        ContainerRequest request \u003d scheduledRequests.removeReduce();\n        pendingReduces.add(request);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java"
    }
  }
}