{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CommandWithDestination.java",
  "functionName": "recursePath",
  "functionId": "recursePath___src-PathData",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CommandWithDestination.java",
  "functionStartLine": 293,
  "functionEndLine": 321,
  "numCommitsSeen": 29,
  "timeTaken": 1288,
  "changeHistory": [
    "e6bdb33784530f57a41e1b3cd1b0a1f601ca5b88",
    "c3e26735a662e478005c8c75b0909797a22cd640",
    "8f9661da4823bfbb243e430252ec1bb5780ecbfc"
  ],
  "changeHistoryShort": {
    "e6bdb33784530f57a41e1b3cd1b0a1f601ca5b88": "Ybodychange",
    "c3e26735a662e478005c8c75b0909797a22cd640": "Ybodychange",
    "8f9661da4823bfbb243e430252ec1bb5780ecbfc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6bdb33784530f57a41e1b3cd1b0a1f601ca5b88": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10919. Copy command should preserve raw.* namespace extended attributes. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1616840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 10:58 AM",
      "commitName": "e6bdb33784530f57a41e1b3cd1b0a1f601ca5b88",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "25/06/14 10:36 PM",
      "commitNameOld": "c3e26735a662e478005c8c75b0909797a22cd640",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 43.51,
      "commitsBetweenForRepo": 335,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,29 @@\n   protected void recursePath(PathData src) throws IOException {\n     PathData savedDst \u003d dst;\n     try {\n       // modify dst as we descend to append the basename of the\n       // current directory being processed\n       dst \u003d getTargetPath(src);\n+      final boolean preserveRawXattrs \u003d\n+          checkPathsForReservedRaw(src.path, dst.path);\n       if (dst.exists) {\n         if (!dst.stat.isDirectory()) {\n           throw new PathIsNotDirectoryException(dst.toString());\n         }\n       } else {\n         if (!dst.fs.mkdirs(dst.path)) {\n           // too bad we have no clue what failed\n           PathIOException e \u003d new PathIOException(dst.toString());\n           e.setOperation(\"mkdir\");\n           throw e;\n         }    \n         dst.refreshStatus(); // need to update stat to know it exists now\n       }      \n       super.recursePath(src);\n       if (dst.stat.isDirectory()) {\n-        preserveAttributes(src, dst);\n+        preserveAttributes(src, dst, preserveRawXattrs);\n       }\n     } finally {\n       dst \u003d savedDst;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recursePath(PathData src) throws IOException {\n    PathData savedDst \u003d dst;\n    try {\n      // modify dst as we descend to append the basename of the\n      // current directory being processed\n      dst \u003d getTargetPath(src);\n      final boolean preserveRawXattrs \u003d\n          checkPathsForReservedRaw(src.path, dst.path);\n      if (dst.exists) {\n        if (!dst.stat.isDirectory()) {\n          throw new PathIsNotDirectoryException(dst.toString());\n        }\n      } else {\n        if (!dst.fs.mkdirs(dst.path)) {\n          // too bad we have no clue what failed\n          PathIOException e \u003d new PathIOException(dst.toString());\n          e.setOperation(\"mkdir\");\n          throw e;\n        }    \n        dst.refreshStatus(); // need to update stat to know it exists now\n      }      \n      super.recursePath(src);\n      if (dst.stat.isDirectory()) {\n        preserveAttributes(src, dst, preserveRawXattrs);\n      }\n    } finally {\n      dst \u003d savedDst;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CommandWithDestination.java",
      "extendedDetails": {}
    },
    "c3e26735a662e478005c8c75b0909797a22cd640": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9705. FsShell cp -p does not preserve directory attibutes. Contributed by Akira AJISAKA.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605672 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/06/14 10:36 PM",
      "commitName": "c3e26735a662e478005c8c75b0909797a22cd640",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "17/06/14 10:08 AM",
      "commitNameOld": "6e37dd331b52d3081bdda87664934a05834ea753",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 8.52,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,27 @@\n   protected void recursePath(PathData src) throws IOException {\n     PathData savedDst \u003d dst;\n     try {\n       // modify dst as we descend to append the basename of the\n       // current directory being processed\n       dst \u003d getTargetPath(src);\n       if (dst.exists) {\n         if (!dst.stat.isDirectory()) {\n           throw new PathIsNotDirectoryException(dst.toString());\n         }\n       } else {\n         if (!dst.fs.mkdirs(dst.path)) {\n           // too bad we have no clue what failed\n           PathIOException e \u003d new PathIOException(dst.toString());\n           e.setOperation(\"mkdir\");\n           throw e;\n         }    \n         dst.refreshStatus(); // need to update stat to know it exists now\n       }      \n       super.recursePath(src);\n+      if (dst.stat.isDirectory()) {\n+        preserveAttributes(src, dst);\n+      }\n     } finally {\n       dst \u003d savedDst;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recursePath(PathData src) throws IOException {\n    PathData savedDst \u003d dst;\n    try {\n      // modify dst as we descend to append the basename of the\n      // current directory being processed\n      dst \u003d getTargetPath(src);\n      if (dst.exists) {\n        if (!dst.stat.isDirectory()) {\n          throw new PathIsNotDirectoryException(dst.toString());\n        }\n      } else {\n        if (!dst.fs.mkdirs(dst.path)) {\n          // too bad we have no clue what failed\n          PathIOException e \u003d new PathIOException(dst.toString());\n          e.setOperation(\"mkdir\");\n          throw e;\n        }    \n        dst.refreshStatus(); // need to update stat to know it exists now\n      }      \n      super.recursePath(src);\n      if (dst.stat.isDirectory()) {\n        preserveAttributes(src, dst);\n      }\n    } finally {\n      dst \u003d savedDst;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CommandWithDestination.java",
      "extendedDetails": {}
    },
    "8f9661da4823bfbb243e430252ec1bb5780ecbfc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7771. FsShell -copyToLocal, -get, etc. commands throw NPE if the destination directory does not exist.  Contributed by John George and Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195760 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 6:50 PM",
      "commitName": "8f9661da4823bfbb243e430252ec1bb5780ecbfc",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,24 @@\n+  protected void recursePath(PathData src) throws IOException {\n+    PathData savedDst \u003d dst;\n+    try {\n+      // modify dst as we descend to append the basename of the\n+      // current directory being processed\n+      dst \u003d getTargetPath(src);\n+      if (dst.exists) {\n+        if (!dst.stat.isDirectory()) {\n+          throw new PathIsNotDirectoryException(dst.toString());\n+        }\n+      } else {\n+        if (!dst.fs.mkdirs(dst.path)) {\n+          // too bad we have no clue what failed\n+          PathIOException e \u003d new PathIOException(dst.toString());\n+          e.setOperation(\"mkdir\");\n+          throw e;\n+        }    \n+        dst.refreshStatus(); // need to update stat to know it exists now\n+      }      \n+      super.recursePath(src);\n+    } finally {\n+      dst \u003d savedDst;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recursePath(PathData src) throws IOException {\n    PathData savedDst \u003d dst;\n    try {\n      // modify dst as we descend to append the basename of the\n      // current directory being processed\n      dst \u003d getTargetPath(src);\n      if (dst.exists) {\n        if (!dst.stat.isDirectory()) {\n          throw new PathIsNotDirectoryException(dst.toString());\n        }\n      } else {\n        if (!dst.fs.mkdirs(dst.path)) {\n          // too bad we have no clue what failed\n          PathIOException e \u003d new PathIOException(dst.toString());\n          e.setOperation(\"mkdir\");\n          throw e;\n        }    \n        dst.refreshStatus(); // need to update stat to know it exists now\n      }      \n      super.recursePath(src);\n    } finally {\n      dst \u003d savedDst;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CommandWithDestination.java"
    }
  }
}