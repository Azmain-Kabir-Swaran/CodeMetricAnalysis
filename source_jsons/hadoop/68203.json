{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SwiftNativeFileSystemStore.java",
  "functionName": "rename",
  "functionId": "rename___src-Path__dst-Path",
  "sourceFilePath": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
  "functionStartLine": 534,
  "functionEndLine": 713,
  "numCommitsSeen": 11,
  "timeTaken": 1861,
  "changeHistory": [
    "d4d4c37810d92c927df91d78440c3ad73f46e8a0",
    "645a8f2a4d09acb5a21820f52ee78784d9e4cc8a",
    "ed0f4db0dd8769d188e28750e5b78aa0d6f50677",
    "becc23fb65a5c2b632034b8b2c4c08832d47fd96",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874"
  ],
  "changeHistoryShort": {
    "d4d4c37810d92c927df91d78440c3ad73f46e8a0": "Ybodychange",
    "645a8f2a4d09acb5a21820f52ee78784d9e4cc8a": "Ybodychange",
    "ed0f4db0dd8769d188e28750e5b78aa0d6f50677": "Ybodychange",
    "becc23fb65a5c2b632034b8b2c4c08832d47fd96": "Ybodychange",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d4d4c37810d92c927df91d78440c3ad73f46e8a0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14630 Contract Tests to verify create, mkdirs and rename under a file is forbidden\n\nContributed by Steve Loughran.\n\nNot all stores do complete validation here; in particular the S3A\nConnector does not: checking up the entire directory tree to see if a path matches\nis a file significantly slows things down.\n\nThis check does take place in S3A mkdirs(), which walks backwards up the list of\nparent paths until it finds a directory (success) or a file (failure).\nIn practice production applications invariably create destination directories\nbefore writing 1+ file into them -restricting check purely to the mkdirs()\ncall deliver significant speed up while implicitly including the checks.\n\nChange-Id: I2c9df748e92b5655232e7d888d896f1868806eb0\n",
      "commitDate": "09/03/20 7:44 AM",
      "commitName": "d4d4c37810d92c927df91d78440c3ad73f46e8a0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/03/18 3:08 PM",
      "commitNameOld": "29233c3c4a5ef6c7829177fef454c0052d852cc5",
      "commitAuthorOld": "fang zhenyi",
      "daysBetweenCommits": 738.65,
      "commitsBetweenForRepo": 5673,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,180 @@\n   public void rename(Path src, Path dst)\n     throws FileNotFoundException, SwiftOperationFailedException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"mv \" + src + \" \" + dst);\n     }\n     boolean renamingOnToSelf \u003d src.equals(dst);\n \n     SwiftObjectPath srcObject \u003d toObjectPath(src);\n     SwiftObjectPath destObject \u003d toObjectPath(dst);\n \n     if (SwiftUtils.isRootDir(srcObject)) {\n       throw new SwiftOperationFailedException(\"cannot rename root dir\");\n     }\n \n     final SwiftFileStatus srcMetadata;\n     srcMetadata \u003d getObjectMetadata(src);\n     SwiftFileStatus dstMetadata;\n     try {\n       dstMetadata \u003d getObjectMetadata(dst);\n     } catch (FileNotFoundException e) {\n       //destination does not exist.\n       LOG.debug(\"Destination does not exist\");\n       dstMetadata \u003d null;\n     }\n \n     //check to see if the destination parent directory exists\n     Path srcParent \u003d src.getParent();\n     Path dstParent \u003d dst.getParent();\n     //skip the overhead of a HEAD call if the src and dest share the same\n     //parent dir (in which case the dest dir exists), or the destination\n     //directory is root, in which case it must also exist\n     if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n+      SwiftFileStatus fileStatus;\n       try {\n-        getObjectMetadata(dstParent);\n+        fileStatus \u003d getObjectMetadata(dstParent);\n       } catch (FileNotFoundException e) {\n         //destination parent doesn\u0027t exist; bail out\n         LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n         throw e;\n       }\n+      if (!fileStatus.isDir()) {\n+        throw new ParentNotDirectoryException(dstParent.toString());\n+      }\n     }\n \n     boolean destExists \u003d dstMetadata !\u003d null;\n     boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n     //calculate the destination\n     SwiftObjectPath destPath;\n \n     //enum the child entries and everything underneath\n     List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n     boolean srcIsFile \u003d !srcMetadata.isDirectory();\n     if (srcIsFile) {\n \n       //source is a simple file OR a partitioned file\n       // outcomes:\n       // #1 dest exists and is file: fail\n       // #2 dest exists and is dir: destination path becomes under dest dir\n       // #3 dest does not exist: use dest as name\n       if (destExists) {\n \n         if (destIsDir) {\n           //outcome #2 -move to subdir of dest\n           destPath \u003d toObjectPath(new Path(dst, src.getName()));\n         } else {\n           //outcome #1 dest it\u0027s a file: fail if different\n           if (!renamingOnToSelf) {\n             throw new FileAlreadyExistsException(\n                     \"cannot rename a file over one that already exists\");\n           } else {\n             //is mv self self where self is a file. this becomes a no-op\n             LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n             return;\n           }\n         }\n       } else {\n         //outcome #3 -new entry\n         destPath \u003d toObjectPath(dst);\n       }\n       int childCount \u003d childStats.size();\n       //here there is one of:\n       // - a single object \u003d\u003d\u003e standard file\n       // -\u003e\n       if (childCount \u003d\u003d 0) {\n         copyThenDeleteObject(srcObject, destPath);\n       } else {\n         //do the copy\n         SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                               \" copying file and deleting children\");\n \n         copyObject(srcObject, destPath);\n         for (FileStatus stat : childStats) {\n           SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n           deleteObject(stat.getPath());\n         }\n \n         swiftRestClient.delete(srcObject);\n       }\n     } else {\n \n       //here the source exists and is a directory\n       // outcomes (given we know the parent dir exists if we get this far)\n       // #1 destination is a file: fail\n       // #2 destination is a directory: create a new dir under that one\n       // #3 destination doesn\u0027t exist: create a new dir with that name\n       // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n \n \n       if (destExists \u0026\u0026 !destIsDir) {\n         // #1 destination is a file: fail\n         throw new FileAlreadyExistsException(\n                 \"the source is a directory, but not the destination\");\n       }\n       Path targetPath;\n       if (destExists) {\n         // #2 destination is a directory: create a new dir under that one\n         targetPath \u003d new Path(dst, src.getName());\n       } else {\n         // #3 destination doesn\u0027t exist: create a new dir with that name\n         targetPath \u003d dst;\n       }\n       SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n       //final check for any recursive operations\n       if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n         //you can\u0027t rename a directory onto itself\n         throw new SwiftOperationFailedException(\n           \"cannot move a directory under itself\");\n       }\n \n \n       LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n \n       logDirectory(\"Directory to copy \", srcObject, childStats);\n \n       // iterative copy of everything under the directory.\n       // by listing all children this can be done iteratively\n       // rather than recursively -everything in this list is either a file\n       // or a 0-byte-len file pretending to be a directory.\n       String srcURI \u003d src.toUri().toString();\n       int prefixStripCount \u003d srcURI.length() + 1;\n       for (FileStatus fileStatus : childStats) {\n         Path copySourcePath \u003d fileStatus.getPath();\n         String copySourceURI \u003d copySourcePath.toUri().toString();\n \n         String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n \n         Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n         if (LOG.isTraceEnabled()) {\n           //trace to debug some low-level rename path problems; retained\n           //in case they ever come back.\n           LOG.trace(\"srcURI\u003d\" + srcURI\n                   + \"; copySourceURI\u003d\" + copySourceURI\n                   + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                   + \"; copyDestPath\u003d\" + copyDestPath);\n         }\n         SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n \n         try {\n           copyThenDeleteObject(toObjectPath(copySourcePath),\n                   copyDestination);\n         } catch (FileNotFoundException e) {\n           LOG.info(\"Skipping rename of \" + copySourcePath);\n         }\n         //add a throttle delay\n         throttle();\n       }\n       //now rename self. If missing, create the dest directory and warn\n       if (!SwiftUtils.isRootDir(srcObject)) {\n         try {\n           copyThenDeleteObject(srcObject,\n                   targetObjectPath);\n         } catch (FileNotFoundException e) {\n           //create the destination directory\n           LOG.warn(\"Source directory deleted during rename\", e);\n           innerCreateDirectory(destObject);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void rename(Path src, Path dst)\n    throws FileNotFoundException, SwiftOperationFailedException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"mv \" + src + \" \" + dst);\n    }\n    boolean renamingOnToSelf \u003d src.equals(dst);\n\n    SwiftObjectPath srcObject \u003d toObjectPath(src);\n    SwiftObjectPath destObject \u003d toObjectPath(dst);\n\n    if (SwiftUtils.isRootDir(srcObject)) {\n      throw new SwiftOperationFailedException(\"cannot rename root dir\");\n    }\n\n    final SwiftFileStatus srcMetadata;\n    srcMetadata \u003d getObjectMetadata(src);\n    SwiftFileStatus dstMetadata;\n    try {\n      dstMetadata \u003d getObjectMetadata(dst);\n    } catch (FileNotFoundException e) {\n      //destination does not exist.\n      LOG.debug(\"Destination does not exist\");\n      dstMetadata \u003d null;\n    }\n\n    //check to see if the destination parent directory exists\n    Path srcParent \u003d src.getParent();\n    Path dstParent \u003d dst.getParent();\n    //skip the overhead of a HEAD call if the src and dest share the same\n    //parent dir (in which case the dest dir exists), or the destination\n    //directory is root, in which case it must also exist\n    if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n      SwiftFileStatus fileStatus;\n      try {\n        fileStatus \u003d getObjectMetadata(dstParent);\n      } catch (FileNotFoundException e) {\n        //destination parent doesn\u0027t exist; bail out\n        LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n        throw e;\n      }\n      if (!fileStatus.isDir()) {\n        throw new ParentNotDirectoryException(dstParent.toString());\n      }\n    }\n\n    boolean destExists \u003d dstMetadata !\u003d null;\n    boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n    //calculate the destination\n    SwiftObjectPath destPath;\n\n    //enum the child entries and everything underneath\n    List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n    boolean srcIsFile \u003d !srcMetadata.isDirectory();\n    if (srcIsFile) {\n\n      //source is a simple file OR a partitioned file\n      // outcomes:\n      // #1 dest exists and is file: fail\n      // #2 dest exists and is dir: destination path becomes under dest dir\n      // #3 dest does not exist: use dest as name\n      if (destExists) {\n\n        if (destIsDir) {\n          //outcome #2 -move to subdir of dest\n          destPath \u003d toObjectPath(new Path(dst, src.getName()));\n        } else {\n          //outcome #1 dest it\u0027s a file: fail if different\n          if (!renamingOnToSelf) {\n            throw new FileAlreadyExistsException(\n                    \"cannot rename a file over one that already exists\");\n          } else {\n            //is mv self self where self is a file. this becomes a no-op\n            LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n            return;\n          }\n        }\n      } else {\n        //outcome #3 -new entry\n        destPath \u003d toObjectPath(dst);\n      }\n      int childCount \u003d childStats.size();\n      //here there is one of:\n      // - a single object \u003d\u003d\u003e standard file\n      // -\u003e\n      if (childCount \u003d\u003d 0) {\n        copyThenDeleteObject(srcObject, destPath);\n      } else {\n        //do the copy\n        SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                              \" copying file and deleting children\");\n\n        copyObject(srcObject, destPath);\n        for (FileStatus stat : childStats) {\n          SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n          deleteObject(stat.getPath());\n        }\n\n        swiftRestClient.delete(srcObject);\n      }\n    } else {\n\n      //here the source exists and is a directory\n      // outcomes (given we know the parent dir exists if we get this far)\n      // #1 destination is a file: fail\n      // #2 destination is a directory: create a new dir under that one\n      // #3 destination doesn\u0027t exist: create a new dir with that name\n      // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n\n\n      if (destExists \u0026\u0026 !destIsDir) {\n        // #1 destination is a file: fail\n        throw new FileAlreadyExistsException(\n                \"the source is a directory, but not the destination\");\n      }\n      Path targetPath;\n      if (destExists) {\n        // #2 destination is a directory: create a new dir under that one\n        targetPath \u003d new Path(dst, src.getName());\n      } else {\n        // #3 destination doesn\u0027t exist: create a new dir with that name\n        targetPath \u003d dst;\n      }\n      SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n      //final check for any recursive operations\n      if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n        //you can\u0027t rename a directory onto itself\n        throw new SwiftOperationFailedException(\n          \"cannot move a directory under itself\");\n      }\n\n\n      LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n\n      logDirectory(\"Directory to copy \", srcObject, childStats);\n\n      // iterative copy of everything under the directory.\n      // by listing all children this can be done iteratively\n      // rather than recursively -everything in this list is either a file\n      // or a 0-byte-len file pretending to be a directory.\n      String srcURI \u003d src.toUri().toString();\n      int prefixStripCount \u003d srcURI.length() + 1;\n      for (FileStatus fileStatus : childStats) {\n        Path copySourcePath \u003d fileStatus.getPath();\n        String copySourceURI \u003d copySourcePath.toUri().toString();\n\n        String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n\n        Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n        if (LOG.isTraceEnabled()) {\n          //trace to debug some low-level rename path problems; retained\n          //in case they ever come back.\n          LOG.trace(\"srcURI\u003d\" + srcURI\n                  + \"; copySourceURI\u003d\" + copySourceURI\n                  + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                  + \"; copyDestPath\u003d\" + copyDestPath);\n        }\n        SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n\n        try {\n          copyThenDeleteObject(toObjectPath(copySourcePath),\n                  copyDestination);\n        } catch (FileNotFoundException e) {\n          LOG.info(\"Skipping rename of \" + copySourcePath);\n        }\n        //add a throttle delay\n        throttle();\n      }\n      //now rename self. If missing, create the dest directory and warn\n      if (!SwiftUtils.isRootDir(srcObject)) {\n        try {\n          copyThenDeleteObject(srcObject,\n                  targetObjectPath);\n        } catch (FileNotFoundException e) {\n          //create the destination directory\n          LOG.warn(\"Source directory deleted during rename\", e);\n          innerCreateDirectory(destObject);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "645a8f2a4d09acb5a21820f52ee78784d9e4cc8a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14726. Mark FileStatus::isDir as final\n",
      "commitDate": "14/08/17 9:57 PM",
      "commitName": "645a8f2a4d09acb5a21820f52ee78784d9e4cc8a",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "27/04/17 12:57 AM",
      "commitNameOld": "62579b69a0a294ba1ea14cf76c650b640f89f331",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 109.88,
      "commitsBetweenForRepo": 634,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,176 @@\n   public void rename(Path src, Path dst)\n     throws FileNotFoundException, SwiftOperationFailedException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"mv \" + src + \" \" + dst);\n     }\n     boolean renamingOnToSelf \u003d src.equals(dst);\n \n     SwiftObjectPath srcObject \u003d toObjectPath(src);\n     SwiftObjectPath destObject \u003d toObjectPath(dst);\n \n     if (SwiftUtils.isRootDir(srcObject)) {\n       throw new SwiftOperationFailedException(\"cannot rename root dir\");\n     }\n \n     final SwiftFileStatus srcMetadata;\n     srcMetadata \u003d getObjectMetadata(src);\n     SwiftFileStatus dstMetadata;\n     try {\n       dstMetadata \u003d getObjectMetadata(dst);\n     } catch (FileNotFoundException e) {\n       //destination does not exist.\n       LOG.debug(\"Destination does not exist\");\n       dstMetadata \u003d null;\n     }\n \n     //check to see if the destination parent directory exists\n     Path srcParent \u003d src.getParent();\n     Path dstParent \u003d dst.getParent();\n     //skip the overhead of a HEAD call if the src and dest share the same\n     //parent dir (in which case the dest dir exists), or the destination\n     //directory is root, in which case it must also exist\n     if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n       try {\n         getObjectMetadata(dstParent);\n       } catch (FileNotFoundException e) {\n         //destination parent doesn\u0027t exist; bail out\n         LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n         throw e;\n       }\n     }\n \n     boolean destExists \u003d dstMetadata !\u003d null;\n     boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n     //calculate the destination\n     SwiftObjectPath destPath;\n \n     //enum the child entries and everything underneath\n     List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n-    boolean srcIsFile \u003d !srcMetadata.isDir();\n+    boolean srcIsFile \u003d !srcMetadata.isDirectory();\n     if (srcIsFile) {\n \n       //source is a simple file OR a partitioned file\n       // outcomes:\n       // #1 dest exists and is file: fail\n       // #2 dest exists and is dir: destination path becomes under dest dir\n       // #3 dest does not exist: use dest as name\n       if (destExists) {\n \n         if (destIsDir) {\n           //outcome #2 -move to subdir of dest\n           destPath \u003d toObjectPath(new Path(dst, src.getName()));\n         } else {\n           //outcome #1 dest it\u0027s a file: fail if different\n           if (!renamingOnToSelf) {\n             throw new FileAlreadyExistsException(\n                     \"cannot rename a file over one that already exists\");\n           } else {\n             //is mv self self where self is a file. this becomes a no-op\n             LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n             return;\n           }\n         }\n       } else {\n         //outcome #3 -new entry\n         destPath \u003d toObjectPath(dst);\n       }\n       int childCount \u003d childStats.size();\n       //here there is one of:\n       // - a single object \u003d\u003d\u003e standard file\n       // -\u003e\n       if (childCount \u003d\u003d 0) {\n         copyThenDeleteObject(srcObject, destPath);\n       } else {\n         //do the copy\n         SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                               \" copying file and deleting children\");\n \n         copyObject(srcObject, destPath);\n         for (FileStatus stat : childStats) {\n           SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n           deleteObject(stat.getPath());\n         }\n \n         swiftRestClient.delete(srcObject);\n       }\n     } else {\n \n       //here the source exists and is a directory\n       // outcomes (given we know the parent dir exists if we get this far)\n       // #1 destination is a file: fail\n       // #2 destination is a directory: create a new dir under that one\n       // #3 destination doesn\u0027t exist: create a new dir with that name\n       // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n \n \n       if (destExists \u0026\u0026 !destIsDir) {\n         // #1 destination is a file: fail\n         throw new FileAlreadyExistsException(\n                 \"the source is a directory, but not the destination\");\n       }\n       Path targetPath;\n       if (destExists) {\n         // #2 destination is a directory: create a new dir under that one\n         targetPath \u003d new Path(dst, src.getName());\n       } else {\n         // #3 destination doesn\u0027t exist: create a new dir with that name\n         targetPath \u003d dst;\n       }\n       SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n       //final check for any recursive operations\n       if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n         //you can\u0027t rename a directory onto itself\n         throw new SwiftOperationFailedException(\n           \"cannot move a directory under itself\");\n       }\n \n \n       LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n \n       logDirectory(\"Directory to copy \", srcObject, childStats);\n \n       // iterative copy of everything under the directory.\n       // by listing all children this can be done iteratively\n       // rather than recursively -everything in this list is either a file\n       // or a 0-byte-len file pretending to be a directory.\n       String srcURI \u003d src.toUri().toString();\n       int prefixStripCount \u003d srcURI.length() + 1;\n       for (FileStatus fileStatus : childStats) {\n         Path copySourcePath \u003d fileStatus.getPath();\n         String copySourceURI \u003d copySourcePath.toUri().toString();\n \n         String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n \n         Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n         if (LOG.isTraceEnabled()) {\n           //trace to debug some low-level rename path problems; retained\n           //in case they ever come back.\n           LOG.trace(\"srcURI\u003d\" + srcURI\n                   + \"; copySourceURI\u003d\" + copySourceURI\n                   + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                   + \"; copyDestPath\u003d\" + copyDestPath);\n         }\n         SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n \n         try {\n           copyThenDeleteObject(toObjectPath(copySourcePath),\n                   copyDestination);\n         } catch (FileNotFoundException e) {\n           LOG.info(\"Skipping rename of \" + copySourcePath);\n         }\n         //add a throttle delay\n         throttle();\n       }\n       //now rename self. If missing, create the dest directory and warn\n       if (!SwiftUtils.isRootDir(srcObject)) {\n         try {\n           copyThenDeleteObject(srcObject,\n                   targetObjectPath);\n         } catch (FileNotFoundException e) {\n           //create the destination directory\n           LOG.warn(\"Source directory deleted during rename\", e);\n           innerCreateDirectory(destObject);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void rename(Path src, Path dst)\n    throws FileNotFoundException, SwiftOperationFailedException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"mv \" + src + \" \" + dst);\n    }\n    boolean renamingOnToSelf \u003d src.equals(dst);\n\n    SwiftObjectPath srcObject \u003d toObjectPath(src);\n    SwiftObjectPath destObject \u003d toObjectPath(dst);\n\n    if (SwiftUtils.isRootDir(srcObject)) {\n      throw new SwiftOperationFailedException(\"cannot rename root dir\");\n    }\n\n    final SwiftFileStatus srcMetadata;\n    srcMetadata \u003d getObjectMetadata(src);\n    SwiftFileStatus dstMetadata;\n    try {\n      dstMetadata \u003d getObjectMetadata(dst);\n    } catch (FileNotFoundException e) {\n      //destination does not exist.\n      LOG.debug(\"Destination does not exist\");\n      dstMetadata \u003d null;\n    }\n\n    //check to see if the destination parent directory exists\n    Path srcParent \u003d src.getParent();\n    Path dstParent \u003d dst.getParent();\n    //skip the overhead of a HEAD call if the src and dest share the same\n    //parent dir (in which case the dest dir exists), or the destination\n    //directory is root, in which case it must also exist\n    if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n      try {\n        getObjectMetadata(dstParent);\n      } catch (FileNotFoundException e) {\n        //destination parent doesn\u0027t exist; bail out\n        LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n        throw e;\n      }\n    }\n\n    boolean destExists \u003d dstMetadata !\u003d null;\n    boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n    //calculate the destination\n    SwiftObjectPath destPath;\n\n    //enum the child entries and everything underneath\n    List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n    boolean srcIsFile \u003d !srcMetadata.isDirectory();\n    if (srcIsFile) {\n\n      //source is a simple file OR a partitioned file\n      // outcomes:\n      // #1 dest exists and is file: fail\n      // #2 dest exists and is dir: destination path becomes under dest dir\n      // #3 dest does not exist: use dest as name\n      if (destExists) {\n\n        if (destIsDir) {\n          //outcome #2 -move to subdir of dest\n          destPath \u003d toObjectPath(new Path(dst, src.getName()));\n        } else {\n          //outcome #1 dest it\u0027s a file: fail if different\n          if (!renamingOnToSelf) {\n            throw new FileAlreadyExistsException(\n                    \"cannot rename a file over one that already exists\");\n          } else {\n            //is mv self self where self is a file. this becomes a no-op\n            LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n            return;\n          }\n        }\n      } else {\n        //outcome #3 -new entry\n        destPath \u003d toObjectPath(dst);\n      }\n      int childCount \u003d childStats.size();\n      //here there is one of:\n      // - a single object \u003d\u003d\u003e standard file\n      // -\u003e\n      if (childCount \u003d\u003d 0) {\n        copyThenDeleteObject(srcObject, destPath);\n      } else {\n        //do the copy\n        SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                              \" copying file and deleting children\");\n\n        copyObject(srcObject, destPath);\n        for (FileStatus stat : childStats) {\n          SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n          deleteObject(stat.getPath());\n        }\n\n        swiftRestClient.delete(srcObject);\n      }\n    } else {\n\n      //here the source exists and is a directory\n      // outcomes (given we know the parent dir exists if we get this far)\n      // #1 destination is a file: fail\n      // #2 destination is a directory: create a new dir under that one\n      // #3 destination doesn\u0027t exist: create a new dir with that name\n      // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n\n\n      if (destExists \u0026\u0026 !destIsDir) {\n        // #1 destination is a file: fail\n        throw new FileAlreadyExistsException(\n                \"the source is a directory, but not the destination\");\n      }\n      Path targetPath;\n      if (destExists) {\n        // #2 destination is a directory: create a new dir under that one\n        targetPath \u003d new Path(dst, src.getName());\n      } else {\n        // #3 destination doesn\u0027t exist: create a new dir with that name\n        targetPath \u003d dst;\n      }\n      SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n      //final check for any recursive operations\n      if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n        //you can\u0027t rename a directory onto itself\n        throw new SwiftOperationFailedException(\n          \"cannot move a directory under itself\");\n      }\n\n\n      LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n\n      logDirectory(\"Directory to copy \", srcObject, childStats);\n\n      // iterative copy of everything under the directory.\n      // by listing all children this can be done iteratively\n      // rather than recursively -everything in this list is either a file\n      // or a 0-byte-len file pretending to be a directory.\n      String srcURI \u003d src.toUri().toString();\n      int prefixStripCount \u003d srcURI.length() + 1;\n      for (FileStatus fileStatus : childStats) {\n        Path copySourcePath \u003d fileStatus.getPath();\n        String copySourceURI \u003d copySourcePath.toUri().toString();\n\n        String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n\n        Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n        if (LOG.isTraceEnabled()) {\n          //trace to debug some low-level rename path problems; retained\n          //in case they ever come back.\n          LOG.trace(\"srcURI\u003d\" + srcURI\n                  + \"; copySourceURI\u003d\" + copySourceURI\n                  + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                  + \"; copyDestPath\u003d\" + copyDestPath);\n        }\n        SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n\n        try {\n          copyThenDeleteObject(toObjectPath(copySourcePath),\n                  copyDestination);\n        } catch (FileNotFoundException e) {\n          LOG.info(\"Skipping rename of \" + copySourcePath);\n        }\n        //add a throttle delay\n        throttle();\n      }\n      //now rename self. If missing, create the dest directory and warn\n      if (!SwiftUtils.isRootDir(srcObject)) {\n        try {\n          copyThenDeleteObject(srcObject,\n                  targetObjectPath);\n        } catch (FileNotFoundException e) {\n          //create the destination directory\n          LOG.warn(\"Source directory deleted during rename\", e);\n          innerCreateDirectory(destObject);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "ed0f4db0dd8769d188e28750e5b78aa0d6f50677": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11775. Fix Javadoc typos in hadoop-openstack module (Yanjun Wang via aw)\n",
      "commitDate": "08/05/15 5:01 PM",
      "commitName": "ed0f4db0dd8769d188e28750e5b78aa0d6f50677",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "03/03/15 1:06 AM",
      "commitNameOld": "9ae7f9eb7baeb244e1b95aabc93ad8124870b9a9",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 66.62,
      "commitsBetweenForRepo": 656,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,176 @@\n   public void rename(Path src, Path dst)\n     throws FileNotFoundException, SwiftOperationFailedException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"mv \" + src + \" \" + dst);\n     }\n     boolean renamingOnToSelf \u003d src.equals(dst);\n \n     SwiftObjectPath srcObject \u003d toObjectPath(src);\n     SwiftObjectPath destObject \u003d toObjectPath(dst);\n \n     if (SwiftUtils.isRootDir(srcObject)) {\n       throw new SwiftOperationFailedException(\"cannot rename root dir\");\n     }\n \n     final SwiftFileStatus srcMetadata;\n     srcMetadata \u003d getObjectMetadata(src);\n     SwiftFileStatus dstMetadata;\n     try {\n       dstMetadata \u003d getObjectMetadata(dst);\n     } catch (FileNotFoundException e) {\n       //destination does not exist.\n       LOG.debug(\"Destination does not exist\");\n       dstMetadata \u003d null;\n     }\n \n     //check to see if the destination parent directory exists\n     Path srcParent \u003d src.getParent();\n     Path dstParent \u003d dst.getParent();\n     //skip the overhead of a HEAD call if the src and dest share the same\n     //parent dir (in which case the dest dir exists), or the destination\n     //directory is root, in which case it must also exist\n     if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n       try {\n         getObjectMetadata(dstParent);\n       } catch (FileNotFoundException e) {\n         //destination parent doesn\u0027t exist; bail out\n         LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n         throw e;\n       }\n     }\n \n     boolean destExists \u003d dstMetadata !\u003d null;\n     boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n     //calculate the destination\n     SwiftObjectPath destPath;\n \n     //enum the child entries and everything underneath\n     List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n     boolean srcIsFile \u003d !srcMetadata.isDir();\n     if (srcIsFile) {\n \n       //source is a simple file OR a partitioned file\n       // outcomes:\n       // #1 dest exists and is file: fail\n       // #2 dest exists and is dir: destination path becomes under dest dir\n       // #3 dest does not exist: use dest as name\n       if (destExists) {\n \n         if (destIsDir) {\n           //outcome #2 -move to subdir of dest\n           destPath \u003d toObjectPath(new Path(dst, src.getName()));\n         } else {\n-          //outcome #1 dest it\u0027s a file: fail if differeent\n+          //outcome #1 dest it\u0027s a file: fail if different\n           if (!renamingOnToSelf) {\n             throw new FileAlreadyExistsException(\n                     \"cannot rename a file over one that already exists\");\n           } else {\n             //is mv self self where self is a file. this becomes a no-op\n             LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n             return;\n           }\n         }\n       } else {\n         //outcome #3 -new entry\n         destPath \u003d toObjectPath(dst);\n       }\n       int childCount \u003d childStats.size();\n       //here there is one of:\n       // - a single object \u003d\u003d\u003e standard file\n       // -\u003e\n       if (childCount \u003d\u003d 0) {\n         copyThenDeleteObject(srcObject, destPath);\n       } else {\n         //do the copy\n         SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                               \" copying file and deleting children\");\n \n         copyObject(srcObject, destPath);\n         for (FileStatus stat : childStats) {\n           SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n           deleteObject(stat.getPath());\n         }\n \n         swiftRestClient.delete(srcObject);\n       }\n     } else {\n \n       //here the source exists and is a directory\n       // outcomes (given we know the parent dir exists if we get this far)\n       // #1 destination is a file: fail\n       // #2 destination is a directory: create a new dir under that one\n       // #3 destination doesn\u0027t exist: create a new dir with that name\n       // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n \n \n       if (destExists \u0026\u0026 !destIsDir) {\n         // #1 destination is a file: fail\n         throw new FileAlreadyExistsException(\n                 \"the source is a directory, but not the destination\");\n       }\n       Path targetPath;\n       if (destExists) {\n         // #2 destination is a directory: create a new dir under that one\n         targetPath \u003d new Path(dst, src.getName());\n       } else {\n         // #3 destination doesn\u0027t exist: create a new dir with that name\n         targetPath \u003d dst;\n       }\n       SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n       //final check for any recursive operations\n       if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n         //you can\u0027t rename a directory onto itself\n         throw new SwiftOperationFailedException(\n           \"cannot move a directory under itself\");\n       }\n \n \n       LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n \n       logDirectory(\"Directory to copy \", srcObject, childStats);\n \n       // iterative copy of everything under the directory.\n       // by listing all children this can be done iteratively\n       // rather than recursively -everything in this list is either a file\n       // or a 0-byte-len file pretending to be a directory.\n       String srcURI \u003d src.toUri().toString();\n       int prefixStripCount \u003d srcURI.length() + 1;\n       for (FileStatus fileStatus : childStats) {\n         Path copySourcePath \u003d fileStatus.getPath();\n         String copySourceURI \u003d copySourcePath.toUri().toString();\n \n         String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n \n         Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n         if (LOG.isTraceEnabled()) {\n           //trace to debug some low-level rename path problems; retained\n           //in case they ever come back.\n           LOG.trace(\"srcURI\u003d\" + srcURI\n                   + \"; copySourceURI\u003d\" + copySourceURI\n                   + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                   + \"; copyDestPath\u003d\" + copyDestPath);\n         }\n         SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n \n         try {\n           copyThenDeleteObject(toObjectPath(copySourcePath),\n                   copyDestination);\n         } catch (FileNotFoundException e) {\n           LOG.info(\"Skipping rename of \" + copySourcePath);\n         }\n         //add a throttle delay\n         throttle();\n       }\n       //now rename self. If missing, create the dest directory and warn\n       if (!SwiftUtils.isRootDir(srcObject)) {\n         try {\n           copyThenDeleteObject(srcObject,\n                   targetObjectPath);\n         } catch (FileNotFoundException e) {\n           //create the destination directory\n           LOG.warn(\"Source directory deleted during rename\", e);\n           innerCreateDirectory(destObject);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void rename(Path src, Path dst)\n    throws FileNotFoundException, SwiftOperationFailedException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"mv \" + src + \" \" + dst);\n    }\n    boolean renamingOnToSelf \u003d src.equals(dst);\n\n    SwiftObjectPath srcObject \u003d toObjectPath(src);\n    SwiftObjectPath destObject \u003d toObjectPath(dst);\n\n    if (SwiftUtils.isRootDir(srcObject)) {\n      throw new SwiftOperationFailedException(\"cannot rename root dir\");\n    }\n\n    final SwiftFileStatus srcMetadata;\n    srcMetadata \u003d getObjectMetadata(src);\n    SwiftFileStatus dstMetadata;\n    try {\n      dstMetadata \u003d getObjectMetadata(dst);\n    } catch (FileNotFoundException e) {\n      //destination does not exist.\n      LOG.debug(\"Destination does not exist\");\n      dstMetadata \u003d null;\n    }\n\n    //check to see if the destination parent directory exists\n    Path srcParent \u003d src.getParent();\n    Path dstParent \u003d dst.getParent();\n    //skip the overhead of a HEAD call if the src and dest share the same\n    //parent dir (in which case the dest dir exists), or the destination\n    //directory is root, in which case it must also exist\n    if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n      try {\n        getObjectMetadata(dstParent);\n      } catch (FileNotFoundException e) {\n        //destination parent doesn\u0027t exist; bail out\n        LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n        throw e;\n      }\n    }\n\n    boolean destExists \u003d dstMetadata !\u003d null;\n    boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n    //calculate the destination\n    SwiftObjectPath destPath;\n\n    //enum the child entries and everything underneath\n    List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n    boolean srcIsFile \u003d !srcMetadata.isDir();\n    if (srcIsFile) {\n\n      //source is a simple file OR a partitioned file\n      // outcomes:\n      // #1 dest exists and is file: fail\n      // #2 dest exists and is dir: destination path becomes under dest dir\n      // #3 dest does not exist: use dest as name\n      if (destExists) {\n\n        if (destIsDir) {\n          //outcome #2 -move to subdir of dest\n          destPath \u003d toObjectPath(new Path(dst, src.getName()));\n        } else {\n          //outcome #1 dest it\u0027s a file: fail if different\n          if (!renamingOnToSelf) {\n            throw new FileAlreadyExistsException(\n                    \"cannot rename a file over one that already exists\");\n          } else {\n            //is mv self self where self is a file. this becomes a no-op\n            LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n            return;\n          }\n        }\n      } else {\n        //outcome #3 -new entry\n        destPath \u003d toObjectPath(dst);\n      }\n      int childCount \u003d childStats.size();\n      //here there is one of:\n      // - a single object \u003d\u003d\u003e standard file\n      // -\u003e\n      if (childCount \u003d\u003d 0) {\n        copyThenDeleteObject(srcObject, destPath);\n      } else {\n        //do the copy\n        SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                              \" copying file and deleting children\");\n\n        copyObject(srcObject, destPath);\n        for (FileStatus stat : childStats) {\n          SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n          deleteObject(stat.getPath());\n        }\n\n        swiftRestClient.delete(srcObject);\n      }\n    } else {\n\n      //here the source exists and is a directory\n      // outcomes (given we know the parent dir exists if we get this far)\n      // #1 destination is a file: fail\n      // #2 destination is a directory: create a new dir under that one\n      // #3 destination doesn\u0027t exist: create a new dir with that name\n      // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n\n\n      if (destExists \u0026\u0026 !destIsDir) {\n        // #1 destination is a file: fail\n        throw new FileAlreadyExistsException(\n                \"the source is a directory, but not the destination\");\n      }\n      Path targetPath;\n      if (destExists) {\n        // #2 destination is a directory: create a new dir under that one\n        targetPath \u003d new Path(dst, src.getName());\n      } else {\n        // #3 destination doesn\u0027t exist: create a new dir with that name\n        targetPath \u003d dst;\n      }\n      SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n      //final check for any recursive operations\n      if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n        //you can\u0027t rename a directory onto itself\n        throw new SwiftOperationFailedException(\n          \"cannot move a directory under itself\");\n      }\n\n\n      LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n\n      logDirectory(\"Directory to copy \", srcObject, childStats);\n\n      // iterative copy of everything under the directory.\n      // by listing all children this can be done iteratively\n      // rather than recursively -everything in this list is either a file\n      // or a 0-byte-len file pretending to be a directory.\n      String srcURI \u003d src.toUri().toString();\n      int prefixStripCount \u003d srcURI.length() + 1;\n      for (FileStatus fileStatus : childStats) {\n        Path copySourcePath \u003d fileStatus.getPath();\n        String copySourceURI \u003d copySourcePath.toUri().toString();\n\n        String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n\n        Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n        if (LOG.isTraceEnabled()) {\n          //trace to debug some low-level rename path problems; retained\n          //in case they ever come back.\n          LOG.trace(\"srcURI\u003d\" + srcURI\n                  + \"; copySourceURI\u003d\" + copySourceURI\n                  + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                  + \"; copyDestPath\u003d\" + copyDestPath);\n        }\n        SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n\n        try {\n          copyThenDeleteObject(toObjectPath(copySourcePath),\n                  copyDestination);\n        } catch (FileNotFoundException e) {\n          LOG.info(\"Skipping rename of \" + copySourcePath);\n        }\n        //add a throttle delay\n        throttle();\n      }\n      //now rename self. If missing, create the dest directory and warn\n      if (!SwiftUtils.isRootDir(srcObject)) {\n        try {\n          copyThenDeleteObject(srcObject,\n                  targetObjectPath);\n        } catch (FileNotFoundException e) {\n          //create the destination directory\n          LOG.warn(\"Source directory deleted during rename\", e);\n          innerCreateDirectory(destObject);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "becc23fb65a5c2b632034b8b2c4c08832d47fd96": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9361: Strictly define FileSystem APIs - OpenStack portion\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607599 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/07/14 5:10 AM",
      "commitName": "becc23fb65a5c2b632034b8b2c4c08832d47fd96",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "06/06/14 11:00 AM",
      "commitNameOld": "3d077726d090cc811e21bb7f629fc2d8340d7b1d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 26.76,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,176 @@\n   public void rename(Path src, Path dst)\n     throws FileNotFoundException, SwiftOperationFailedException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"mv \" + src + \" \" + dst);\n     }\n     boolean renamingOnToSelf \u003d src.equals(dst);\n \n     SwiftObjectPath srcObject \u003d toObjectPath(src);\n     SwiftObjectPath destObject \u003d toObjectPath(dst);\n \n     if (SwiftUtils.isRootDir(srcObject)) {\n       throw new SwiftOperationFailedException(\"cannot rename root dir\");\n     }\n \n     final SwiftFileStatus srcMetadata;\n     srcMetadata \u003d getObjectMetadata(src);\n     SwiftFileStatus dstMetadata;\n     try {\n       dstMetadata \u003d getObjectMetadata(dst);\n     } catch (FileNotFoundException e) {\n       //destination does not exist.\n       LOG.debug(\"Destination does not exist\");\n       dstMetadata \u003d null;\n     }\n \n     //check to see if the destination parent directory exists\n     Path srcParent \u003d src.getParent();\n     Path dstParent \u003d dst.getParent();\n     //skip the overhead of a HEAD call if the src and dest share the same\n     //parent dir (in which case the dest dir exists), or the destination\n     //directory is root, in which case it must also exist\n     if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n       try {\n         getObjectMetadata(dstParent);\n       } catch (FileNotFoundException e) {\n         //destination parent doesn\u0027t exist; bail out\n         LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n         throw e;\n       }\n     }\n \n     boolean destExists \u003d dstMetadata !\u003d null;\n     boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n     //calculate the destination\n     SwiftObjectPath destPath;\n \n     //enum the child entries and everything underneath\n     List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n     boolean srcIsFile \u003d !srcMetadata.isDir();\n     if (srcIsFile) {\n \n       //source is a simple file OR a partitioned file\n       // outcomes:\n       // #1 dest exists and is file: fail\n       // #2 dest exists and is dir: destination path becomes under dest dir\n       // #3 dest does not exist: use dest as name\n       if (destExists) {\n \n         if (destIsDir) {\n           //outcome #2 -move to subdir of dest\n           destPath \u003d toObjectPath(new Path(dst, src.getName()));\n         } else {\n           //outcome #1 dest it\u0027s a file: fail if differeent\n           if (!renamingOnToSelf) {\n-            throw new SwiftOperationFailedException(\n+            throw new FileAlreadyExistsException(\n                     \"cannot rename a file over one that already exists\");\n           } else {\n             //is mv self self where self is a file. this becomes a no-op\n             LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n             return;\n           }\n         }\n       } else {\n         //outcome #3 -new entry\n         destPath \u003d toObjectPath(dst);\n       }\n       int childCount \u003d childStats.size();\n       //here there is one of:\n       // - a single object \u003d\u003d\u003e standard file\n       // -\u003e\n       if (childCount \u003d\u003d 0) {\n         copyThenDeleteObject(srcObject, destPath);\n       } else {\n         //do the copy\n         SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                               \" copying file and deleting children\");\n \n         copyObject(srcObject, destPath);\n         for (FileStatus stat : childStats) {\n           SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n           deleteObject(stat.getPath());\n         }\n \n         swiftRestClient.delete(srcObject);\n       }\n     } else {\n \n       //here the source exists and is a directory\n       // outcomes (given we know the parent dir exists if we get this far)\n       // #1 destination is a file: fail\n       // #2 destination is a directory: create a new dir under that one\n       // #3 destination doesn\u0027t exist: create a new dir with that name\n       // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n \n \n       if (destExists \u0026\u0026 !destIsDir) {\n         // #1 destination is a file: fail\n-        throw new SwiftOperationFailedException(\n+        throw new FileAlreadyExistsException(\n                 \"the source is a directory, but not the destination\");\n       }\n       Path targetPath;\n       if (destExists) {\n         // #2 destination is a directory: create a new dir under that one\n         targetPath \u003d new Path(dst, src.getName());\n       } else {\n         // #3 destination doesn\u0027t exist: create a new dir with that name\n         targetPath \u003d dst;\n       }\n       SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n       //final check for any recursive operations\n       if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n         //you can\u0027t rename a directory onto itself\n         throw new SwiftOperationFailedException(\n           \"cannot move a directory under itself\");\n       }\n \n \n       LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n \n       logDirectory(\"Directory to copy \", srcObject, childStats);\n \n       // iterative copy of everything under the directory.\n       // by listing all children this can be done iteratively\n       // rather than recursively -everything in this list is either a file\n       // or a 0-byte-len file pretending to be a directory.\n       String srcURI \u003d src.toUri().toString();\n       int prefixStripCount \u003d srcURI.length() + 1;\n       for (FileStatus fileStatus : childStats) {\n         Path copySourcePath \u003d fileStatus.getPath();\n         String copySourceURI \u003d copySourcePath.toUri().toString();\n \n         String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n \n         Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n         if (LOG.isTraceEnabled()) {\n           //trace to debug some low-level rename path problems; retained\n           //in case they ever come back.\n           LOG.trace(\"srcURI\u003d\" + srcURI\n                   + \"; copySourceURI\u003d\" + copySourceURI\n                   + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                   + \"; copyDestPath\u003d\" + copyDestPath);\n         }\n         SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n \n         try {\n           copyThenDeleteObject(toObjectPath(copySourcePath),\n                   copyDestination);\n         } catch (FileNotFoundException e) {\n           LOG.info(\"Skipping rename of \" + copySourcePath);\n         }\n         //add a throttle delay\n         throttle();\n       }\n       //now rename self. If missing, create the dest directory and warn\n       if (!SwiftUtils.isRootDir(srcObject)) {\n         try {\n           copyThenDeleteObject(srcObject,\n                   targetObjectPath);\n         } catch (FileNotFoundException e) {\n           //create the destination directory\n           LOG.warn(\"Source directory deleted during rename\", e);\n           innerCreateDirectory(destObject);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void rename(Path src, Path dst)\n    throws FileNotFoundException, SwiftOperationFailedException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"mv \" + src + \" \" + dst);\n    }\n    boolean renamingOnToSelf \u003d src.equals(dst);\n\n    SwiftObjectPath srcObject \u003d toObjectPath(src);\n    SwiftObjectPath destObject \u003d toObjectPath(dst);\n\n    if (SwiftUtils.isRootDir(srcObject)) {\n      throw new SwiftOperationFailedException(\"cannot rename root dir\");\n    }\n\n    final SwiftFileStatus srcMetadata;\n    srcMetadata \u003d getObjectMetadata(src);\n    SwiftFileStatus dstMetadata;\n    try {\n      dstMetadata \u003d getObjectMetadata(dst);\n    } catch (FileNotFoundException e) {\n      //destination does not exist.\n      LOG.debug(\"Destination does not exist\");\n      dstMetadata \u003d null;\n    }\n\n    //check to see if the destination parent directory exists\n    Path srcParent \u003d src.getParent();\n    Path dstParent \u003d dst.getParent();\n    //skip the overhead of a HEAD call if the src and dest share the same\n    //parent dir (in which case the dest dir exists), or the destination\n    //directory is root, in which case it must also exist\n    if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n      try {\n        getObjectMetadata(dstParent);\n      } catch (FileNotFoundException e) {\n        //destination parent doesn\u0027t exist; bail out\n        LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n        throw e;\n      }\n    }\n\n    boolean destExists \u003d dstMetadata !\u003d null;\n    boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n    //calculate the destination\n    SwiftObjectPath destPath;\n\n    //enum the child entries and everything underneath\n    List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n    boolean srcIsFile \u003d !srcMetadata.isDir();\n    if (srcIsFile) {\n\n      //source is a simple file OR a partitioned file\n      // outcomes:\n      // #1 dest exists and is file: fail\n      // #2 dest exists and is dir: destination path becomes under dest dir\n      // #3 dest does not exist: use dest as name\n      if (destExists) {\n\n        if (destIsDir) {\n          //outcome #2 -move to subdir of dest\n          destPath \u003d toObjectPath(new Path(dst, src.getName()));\n        } else {\n          //outcome #1 dest it\u0027s a file: fail if differeent\n          if (!renamingOnToSelf) {\n            throw new FileAlreadyExistsException(\n                    \"cannot rename a file over one that already exists\");\n          } else {\n            //is mv self self where self is a file. this becomes a no-op\n            LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n            return;\n          }\n        }\n      } else {\n        //outcome #3 -new entry\n        destPath \u003d toObjectPath(dst);\n      }\n      int childCount \u003d childStats.size();\n      //here there is one of:\n      // - a single object \u003d\u003d\u003e standard file\n      // -\u003e\n      if (childCount \u003d\u003d 0) {\n        copyThenDeleteObject(srcObject, destPath);\n      } else {\n        //do the copy\n        SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                              \" copying file and deleting children\");\n\n        copyObject(srcObject, destPath);\n        for (FileStatus stat : childStats) {\n          SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n          deleteObject(stat.getPath());\n        }\n\n        swiftRestClient.delete(srcObject);\n      }\n    } else {\n\n      //here the source exists and is a directory\n      // outcomes (given we know the parent dir exists if we get this far)\n      // #1 destination is a file: fail\n      // #2 destination is a directory: create a new dir under that one\n      // #3 destination doesn\u0027t exist: create a new dir with that name\n      // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n\n\n      if (destExists \u0026\u0026 !destIsDir) {\n        // #1 destination is a file: fail\n        throw new FileAlreadyExistsException(\n                \"the source is a directory, but not the destination\");\n      }\n      Path targetPath;\n      if (destExists) {\n        // #2 destination is a directory: create a new dir under that one\n        targetPath \u003d new Path(dst, src.getName());\n      } else {\n        // #3 destination doesn\u0027t exist: create a new dir with that name\n        targetPath \u003d dst;\n      }\n      SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n      //final check for any recursive operations\n      if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n        //you can\u0027t rename a directory onto itself\n        throw new SwiftOperationFailedException(\n          \"cannot move a directory under itself\");\n      }\n\n\n      LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n\n      logDirectory(\"Directory to copy \", srcObject, childStats);\n\n      // iterative copy of everything under the directory.\n      // by listing all children this can be done iteratively\n      // rather than recursively -everything in this list is either a file\n      // or a 0-byte-len file pretending to be a directory.\n      String srcURI \u003d src.toUri().toString();\n      int prefixStripCount \u003d srcURI.length() + 1;\n      for (FileStatus fileStatus : childStats) {\n        Path copySourcePath \u003d fileStatus.getPath();\n        String copySourceURI \u003d copySourcePath.toUri().toString();\n\n        String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n\n        Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n        if (LOG.isTraceEnabled()) {\n          //trace to debug some low-level rename path problems; retained\n          //in case they ever come back.\n          LOG.trace(\"srcURI\u003d\" + srcURI\n                  + \"; copySourceURI\u003d\" + copySourceURI\n                  + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                  + \"; copyDestPath\u003d\" + copyDestPath);\n        }\n        SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n\n        try {\n          copyThenDeleteObject(toObjectPath(copySourcePath),\n                  copyDestination);\n        } catch (FileNotFoundException e) {\n          LOG.info(\"Skipping rename of \" + copySourcePath);\n        }\n        //add a throttle delay\n        throttle();\n      }\n      //now rename self. If missing, create the dest directory and warn\n      if (!SwiftUtils.isRootDir(srcObject)) {\n        try {\n          copyThenDeleteObject(srcObject,\n                  targetObjectPath);\n        } catch (FileNotFoundException e) {\n          //create the destination directory\n          LOG.warn(\"Source directory deleted during rename\", e);\n          innerCreateDirectory(destObject);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8545. Filesystem Implementation for OpenStack Swift\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526854 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 4:32 AM",
      "commitName": "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,176 @@\n+  public void rename(Path src, Path dst)\n+    throws FileNotFoundException, SwiftOperationFailedException, IOException {\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"mv \" + src + \" \" + dst);\n+    }\n+    boolean renamingOnToSelf \u003d src.equals(dst);\n+\n+    SwiftObjectPath srcObject \u003d toObjectPath(src);\n+    SwiftObjectPath destObject \u003d toObjectPath(dst);\n+\n+    if (SwiftUtils.isRootDir(srcObject)) {\n+      throw new SwiftOperationFailedException(\"cannot rename root dir\");\n+    }\n+\n+    final SwiftFileStatus srcMetadata;\n+    srcMetadata \u003d getObjectMetadata(src);\n+    SwiftFileStatus dstMetadata;\n+    try {\n+      dstMetadata \u003d getObjectMetadata(dst);\n+    } catch (FileNotFoundException e) {\n+      //destination does not exist.\n+      LOG.debug(\"Destination does not exist\");\n+      dstMetadata \u003d null;\n+    }\n+\n+    //check to see if the destination parent directory exists\n+    Path srcParent \u003d src.getParent();\n+    Path dstParent \u003d dst.getParent();\n+    //skip the overhead of a HEAD call if the src and dest share the same\n+    //parent dir (in which case the dest dir exists), or the destination\n+    //directory is root, in which case it must also exist\n+    if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n+      try {\n+        getObjectMetadata(dstParent);\n+      } catch (FileNotFoundException e) {\n+        //destination parent doesn\u0027t exist; bail out\n+        LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n+        throw e;\n+      }\n+    }\n+\n+    boolean destExists \u003d dstMetadata !\u003d null;\n+    boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n+    //calculate the destination\n+    SwiftObjectPath destPath;\n+\n+    //enum the child entries and everything underneath\n+    List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n+    boolean srcIsFile \u003d !srcMetadata.isDir();\n+    if (srcIsFile) {\n+\n+      //source is a simple file OR a partitioned file\n+      // outcomes:\n+      // #1 dest exists and is file: fail\n+      // #2 dest exists and is dir: destination path becomes under dest dir\n+      // #3 dest does not exist: use dest as name\n+      if (destExists) {\n+\n+        if (destIsDir) {\n+          //outcome #2 -move to subdir of dest\n+          destPath \u003d toObjectPath(new Path(dst, src.getName()));\n+        } else {\n+          //outcome #1 dest it\u0027s a file: fail if differeent\n+          if (!renamingOnToSelf) {\n+            throw new SwiftOperationFailedException(\n+                    \"cannot rename a file over one that already exists\");\n+          } else {\n+            //is mv self self where self is a file. this becomes a no-op\n+            LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n+            return;\n+          }\n+        }\n+      } else {\n+        //outcome #3 -new entry\n+        destPath \u003d toObjectPath(dst);\n+      }\n+      int childCount \u003d childStats.size();\n+      //here there is one of:\n+      // - a single object \u003d\u003d\u003e standard file\n+      // -\u003e\n+      if (childCount \u003d\u003d 0) {\n+        copyThenDeleteObject(srcObject, destPath);\n+      } else {\n+        //do the copy\n+        SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n+                              \" copying file and deleting children\");\n+\n+        copyObject(srcObject, destPath);\n+        for (FileStatus stat : childStats) {\n+          SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n+          deleteObject(stat.getPath());\n+        }\n+\n+        swiftRestClient.delete(srcObject);\n+      }\n+    } else {\n+\n+      //here the source exists and is a directory\n+      // outcomes (given we know the parent dir exists if we get this far)\n+      // #1 destination is a file: fail\n+      // #2 destination is a directory: create a new dir under that one\n+      // #3 destination doesn\u0027t exist: create a new dir with that name\n+      // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n+\n+\n+      if (destExists \u0026\u0026 !destIsDir) {\n+        // #1 destination is a file: fail\n+        throw new SwiftOperationFailedException(\n+                \"the source is a directory, but not the destination\");\n+      }\n+      Path targetPath;\n+      if (destExists) {\n+        // #2 destination is a directory: create a new dir under that one\n+        targetPath \u003d new Path(dst, src.getName());\n+      } else {\n+        // #3 destination doesn\u0027t exist: create a new dir with that name\n+        targetPath \u003d dst;\n+      }\n+      SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n+      //final check for any recursive operations\n+      if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n+        //you can\u0027t rename a directory onto itself\n+        throw new SwiftOperationFailedException(\n+          \"cannot move a directory under itself\");\n+      }\n+\n+\n+      LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n+\n+      logDirectory(\"Directory to copy \", srcObject, childStats);\n+\n+      // iterative copy of everything under the directory.\n+      // by listing all children this can be done iteratively\n+      // rather than recursively -everything in this list is either a file\n+      // or a 0-byte-len file pretending to be a directory.\n+      String srcURI \u003d src.toUri().toString();\n+      int prefixStripCount \u003d srcURI.length() + 1;\n+      for (FileStatus fileStatus : childStats) {\n+        Path copySourcePath \u003d fileStatus.getPath();\n+        String copySourceURI \u003d copySourcePath.toUri().toString();\n+\n+        String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n+\n+        Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n+        if (LOG.isTraceEnabled()) {\n+          //trace to debug some low-level rename path problems; retained\n+          //in case they ever come back.\n+          LOG.trace(\"srcURI\u003d\" + srcURI\n+                  + \"; copySourceURI\u003d\" + copySourceURI\n+                  + \"; copyDestSubPath\u003d\" + copyDestSubPath\n+                  + \"; copyDestPath\u003d\" + copyDestPath);\n+        }\n+        SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n+\n+        try {\n+          copyThenDeleteObject(toObjectPath(copySourcePath),\n+                  copyDestination);\n+        } catch (FileNotFoundException e) {\n+          LOG.info(\"Skipping rename of \" + copySourcePath);\n+        }\n+        //add a throttle delay\n+        throttle();\n+      }\n+      //now rename self. If missing, create the dest directory and warn\n+      if (!SwiftUtils.isRootDir(srcObject)) {\n+        try {\n+          copyThenDeleteObject(srcObject,\n+                  targetObjectPath);\n+        } catch (FileNotFoundException e) {\n+          //create the destination directory\n+          LOG.warn(\"Source directory deleted during rename\", e);\n+          innerCreateDirectory(destObject);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void rename(Path src, Path dst)\n    throws FileNotFoundException, SwiftOperationFailedException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"mv \" + src + \" \" + dst);\n    }\n    boolean renamingOnToSelf \u003d src.equals(dst);\n\n    SwiftObjectPath srcObject \u003d toObjectPath(src);\n    SwiftObjectPath destObject \u003d toObjectPath(dst);\n\n    if (SwiftUtils.isRootDir(srcObject)) {\n      throw new SwiftOperationFailedException(\"cannot rename root dir\");\n    }\n\n    final SwiftFileStatus srcMetadata;\n    srcMetadata \u003d getObjectMetadata(src);\n    SwiftFileStatus dstMetadata;\n    try {\n      dstMetadata \u003d getObjectMetadata(dst);\n    } catch (FileNotFoundException e) {\n      //destination does not exist.\n      LOG.debug(\"Destination does not exist\");\n      dstMetadata \u003d null;\n    }\n\n    //check to see if the destination parent directory exists\n    Path srcParent \u003d src.getParent();\n    Path dstParent \u003d dst.getParent();\n    //skip the overhead of a HEAD call if the src and dest share the same\n    //parent dir (in which case the dest dir exists), or the destination\n    //directory is root, in which case it must also exist\n    if (dstParent !\u003d null \u0026\u0026 !dstParent.equals(srcParent)) {\n      try {\n        getObjectMetadata(dstParent);\n      } catch (FileNotFoundException e) {\n        //destination parent doesn\u0027t exist; bail out\n        LOG.debug(\"destination parent directory \" + dstParent + \" doesn\u0027t exist\");\n        throw e;\n      }\n    }\n\n    boolean destExists \u003d dstMetadata !\u003d null;\n    boolean destIsDir \u003d destExists \u0026\u0026 SwiftUtils.isDirectory(dstMetadata);\n    //calculate the destination\n    SwiftObjectPath destPath;\n\n    //enum the child entries and everything underneath\n    List\u003cFileStatus\u003e childStats \u003d listDirectory(srcObject, true, true);\n    boolean srcIsFile \u003d !srcMetadata.isDir();\n    if (srcIsFile) {\n\n      //source is a simple file OR a partitioned file\n      // outcomes:\n      // #1 dest exists and is file: fail\n      // #2 dest exists and is dir: destination path becomes under dest dir\n      // #3 dest does not exist: use dest as name\n      if (destExists) {\n\n        if (destIsDir) {\n          //outcome #2 -move to subdir of dest\n          destPath \u003d toObjectPath(new Path(dst, src.getName()));\n        } else {\n          //outcome #1 dest it\u0027s a file: fail if differeent\n          if (!renamingOnToSelf) {\n            throw new SwiftOperationFailedException(\n                    \"cannot rename a file over one that already exists\");\n          } else {\n            //is mv self self where self is a file. this becomes a no-op\n            LOG.debug(\"Renaming file onto self: no-op \u003d\u003e success\");\n            return;\n          }\n        }\n      } else {\n        //outcome #3 -new entry\n        destPath \u003d toObjectPath(dst);\n      }\n      int childCount \u003d childStats.size();\n      //here there is one of:\n      // - a single object \u003d\u003d\u003e standard file\n      // -\u003e\n      if (childCount \u003d\u003d 0) {\n        copyThenDeleteObject(srcObject, destPath);\n      } else {\n        //do the copy\n        SwiftUtils.debug(LOG, \"Source file appears to be partitioned.\" +\n                              \" copying file and deleting children\");\n\n        copyObject(srcObject, destPath);\n        for (FileStatus stat : childStats) {\n          SwiftUtils.debug(LOG, \"Deleting partitioned file %s \", stat);\n          deleteObject(stat.getPath());\n        }\n\n        swiftRestClient.delete(srcObject);\n      }\n    } else {\n\n      //here the source exists and is a directory\n      // outcomes (given we know the parent dir exists if we get this far)\n      // #1 destination is a file: fail\n      // #2 destination is a directory: create a new dir under that one\n      // #3 destination doesn\u0027t exist: create a new dir with that name\n      // #3 and #4 are only allowed if the dest path is not \u003d\u003d or under src\n\n\n      if (destExists \u0026\u0026 !destIsDir) {\n        // #1 destination is a file: fail\n        throw new SwiftOperationFailedException(\n                \"the source is a directory, but not the destination\");\n      }\n      Path targetPath;\n      if (destExists) {\n        // #2 destination is a directory: create a new dir under that one\n        targetPath \u003d new Path(dst, src.getName());\n      } else {\n        // #3 destination doesn\u0027t exist: create a new dir with that name\n        targetPath \u003d dst;\n      }\n      SwiftObjectPath targetObjectPath \u003d toObjectPath(targetPath);\n      //final check for any recursive operations\n      if (srcObject.isEqualToOrParentOf(targetObjectPath)) {\n        //you can\u0027t rename a directory onto itself\n        throw new SwiftOperationFailedException(\n          \"cannot move a directory under itself\");\n      }\n\n\n      LOG.info(\"mv  \" + srcObject + \" \" + targetPath);\n\n      logDirectory(\"Directory to copy \", srcObject, childStats);\n\n      // iterative copy of everything under the directory.\n      // by listing all children this can be done iteratively\n      // rather than recursively -everything in this list is either a file\n      // or a 0-byte-len file pretending to be a directory.\n      String srcURI \u003d src.toUri().toString();\n      int prefixStripCount \u003d srcURI.length() + 1;\n      for (FileStatus fileStatus : childStats) {\n        Path copySourcePath \u003d fileStatus.getPath();\n        String copySourceURI \u003d copySourcePath.toUri().toString();\n\n        String copyDestSubPath \u003d copySourceURI.substring(prefixStripCount);\n\n        Path copyDestPath \u003d new Path(targetPath, copyDestSubPath);\n        if (LOG.isTraceEnabled()) {\n          //trace to debug some low-level rename path problems; retained\n          //in case they ever come back.\n          LOG.trace(\"srcURI\u003d\" + srcURI\n                  + \"; copySourceURI\u003d\" + copySourceURI\n                  + \"; copyDestSubPath\u003d\" + copyDestSubPath\n                  + \"; copyDestPath\u003d\" + copyDestPath);\n        }\n        SwiftObjectPath copyDestination \u003d toObjectPath(copyDestPath);\n\n        try {\n          copyThenDeleteObject(toObjectPath(copySourcePath),\n                  copyDestination);\n        } catch (FileNotFoundException e) {\n          LOG.info(\"Skipping rename of \" + copySourcePath);\n        }\n        //add a throttle delay\n        throttle();\n      }\n      //now rename self. If missing, create the dest directory and warn\n      if (!SwiftUtils.isRootDir(srcObject)) {\n        try {\n          copyThenDeleteObject(srcObject,\n                  targetObjectPath);\n        } catch (FileNotFoundException e) {\n          //create the destination directory\n          LOG.warn(\"Source directory deleted during rename\", e);\n          innerCreateDirectory(destObject);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java"
    }
  }
}