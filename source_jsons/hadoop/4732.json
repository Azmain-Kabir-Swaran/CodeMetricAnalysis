{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "INodesInPath.java",
  "functionName": "resolve",
  "functionId": "resolve___startingDir-INodeDirectory(modifiers-final)__components-byte[][]__isRaw-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
  "functionStartLine": 138,
  "functionEndLine": 229,
  "numCommitsSeen": 55,
  "timeTaken": 2905,
  "changeHistory": [
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a"
  ],
  "changeHistoryShort": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange,Yparametermetachange)",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,92 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean isRaw,\n-      final boolean resolveLink) throws UnresolvedLinkException {\n+      byte[][] components, final boolean isRaw) {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     int count \u003d 0;\n     int inodeNum \u003d 0;\n     INode[] inodes \u003d new INode[components.length];\n     boolean isSnapshot \u003d false;\n     int snapshotId \u003d CURRENT_STATE_ID;\n \n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n       inodes[inodeNum++] \u003d curNode;\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n             dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n             snapshotId)) {\n           snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n                dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n             int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n-        final String path \u003d constructPath(components, 0, components.length);\n-        final String preceding \u003d constructPath(components, 0, count);\n-        final String remainder \u003d\n-          constructPath(components, count + 1, components.length);\n-        final String link \u003d DFSUtil.bytes2String(components[count]);\n-        final String target \u003d curNode.asSymlink().getSymlinkString();\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UnresolvedPathException \" +\n-            \" path: \" + path + \" preceding: \" + preceding +\n-            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n-            \" remainder: \" + remainder);\n-        }\n-        throw new UnresolvedPathException(path, preceding, remainder, target);\n-      }\n       if (lastComp || !isDir) {\n         break;\n       }\n-      final byte[] childName \u003d components[count + 1];\n-      \n+\n+      final byte[] childName \u003d components[++count];\n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n-        // skip the \".snapshot\" in components\n-        count++;\n         isSnapshot \u003d true;\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n           snapshotId \u003d s.getId();\n         }\n+        // combine .snapshot \u0026 name into 1 component element to ensure\n+        // 1-to-1 correspondence between components and inodes arrays is\n+        // preserved so a path can be reconstructed.\n+        byte[][] componentsCopy \u003d\n+            Arrays.copyOf(components, components.length - 1);\n+        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n+            DFSUtil.byteArray2PathString(components, count, 2));\n+        // shift the remaining components after snapshot name\n+        int start \u003d count + 2;\n+        System.arraycopy(components, start, componentsCopy, count + 1,\n+            components.length - start);\n+        components \u003d componentsCopy;\n+        // reduce the inodes array to compensate for reduction in components\n+        inodes \u003d Arrays.copyOf(inodes, components.length);\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName,\n             isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n-      count++;\n-    }\n-    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n-      // for snapshot path shrink the inode array. however, for path ending with\n-      // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[components.length - 1];\n-      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n-      inodes \u003d newNodes;\n     }\n     return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      byte[][] components, final boolean isRaw) {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n\n      final byte[] childName \u003d components[++count];\n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n        // combine .snapshot \u0026 name into 1 component element to ensure\n        // 1-to-1 correspondence between components and inodes arrays is\n        // preserved so a path can be reconstructed.\n        byte[][] componentsCopy \u003d\n            Arrays.copyOf(components, components.length - 1);\n        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n            DFSUtil.byteArray2PathString(components, count, 2));\n        // shift the remaining components after snapshot name\n        int start \u003d count + 2;\n        System.arraycopy(components, start, componentsCopy, count + 1,\n            components.length - start);\n        components \u003d componentsCopy;\n        // reduce the inodes array to compensate for reduction in components\n        inodes \u003d Arrays.copyOf(inodes, components.length);\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n    }\n    return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {
            "oldValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][](modifiers-final), isRaw-boolean(modifiers-final), resolveLink-boolean(modifiers-final)]",
            "newValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][], isRaw-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,92 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean isRaw,\n-      final boolean resolveLink) throws UnresolvedLinkException {\n+      byte[][] components, final boolean isRaw) {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     int count \u003d 0;\n     int inodeNum \u003d 0;\n     INode[] inodes \u003d new INode[components.length];\n     boolean isSnapshot \u003d false;\n     int snapshotId \u003d CURRENT_STATE_ID;\n \n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n       inodes[inodeNum++] \u003d curNode;\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n             dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n             snapshotId)) {\n           snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n                dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n             int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n-        final String path \u003d constructPath(components, 0, components.length);\n-        final String preceding \u003d constructPath(components, 0, count);\n-        final String remainder \u003d\n-          constructPath(components, count + 1, components.length);\n-        final String link \u003d DFSUtil.bytes2String(components[count]);\n-        final String target \u003d curNode.asSymlink().getSymlinkString();\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UnresolvedPathException \" +\n-            \" path: \" + path + \" preceding: \" + preceding +\n-            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n-            \" remainder: \" + remainder);\n-        }\n-        throw new UnresolvedPathException(path, preceding, remainder, target);\n-      }\n       if (lastComp || !isDir) {\n         break;\n       }\n-      final byte[] childName \u003d components[count + 1];\n-      \n+\n+      final byte[] childName \u003d components[++count];\n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n-        // skip the \".snapshot\" in components\n-        count++;\n         isSnapshot \u003d true;\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n           snapshotId \u003d s.getId();\n         }\n+        // combine .snapshot \u0026 name into 1 component element to ensure\n+        // 1-to-1 correspondence between components and inodes arrays is\n+        // preserved so a path can be reconstructed.\n+        byte[][] componentsCopy \u003d\n+            Arrays.copyOf(components, components.length - 1);\n+        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n+            DFSUtil.byteArray2PathString(components, count, 2));\n+        // shift the remaining components after snapshot name\n+        int start \u003d count + 2;\n+        System.arraycopy(components, start, componentsCopy, count + 1,\n+            components.length - start);\n+        components \u003d componentsCopy;\n+        // reduce the inodes array to compensate for reduction in components\n+        inodes \u003d Arrays.copyOf(inodes, components.length);\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName,\n             isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n-      count++;\n-    }\n-    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n-      // for snapshot path shrink the inode array. however, for path ending with\n-      // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[components.length - 1];\n-      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n-      inodes \u003d newNodes;\n     }\n     return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      byte[][] components, final boolean isRaw) {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n\n      final byte[] childName \u003d components[++count];\n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n        // combine .snapshot \u0026 name into 1 component element to ensure\n        // 1-to-1 correspondence between components and inodes arrays is\n        // preserved so a path can be reconstructed.\n        byte[][] componentsCopy \u003d\n            Arrays.copyOf(components, components.length - 1);\n        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n            DFSUtil.byteArray2PathString(components, count, 2));\n        // shift the remaining components after snapshot name\n        int start \u003d count + 2;\n        System.arraycopy(components, start, componentsCopy, count + 1,\n            components.length - start);\n        components \u003d componentsCopy;\n        // reduce the inodes array to compensate for reduction in components\n        inodes \u003d Arrays.copyOf(inodes, components.length);\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n    }\n    return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {
            "oldValue": "[UnresolvedLinkException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,92 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean isRaw,\n-      final boolean resolveLink) throws UnresolvedLinkException {\n+      byte[][] components, final boolean isRaw) {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     int count \u003d 0;\n     int inodeNum \u003d 0;\n     INode[] inodes \u003d new INode[components.length];\n     boolean isSnapshot \u003d false;\n     int snapshotId \u003d CURRENT_STATE_ID;\n \n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n       inodes[inodeNum++] \u003d curNode;\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n             dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n             snapshotId)) {\n           snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n                dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n             int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n-        final String path \u003d constructPath(components, 0, components.length);\n-        final String preceding \u003d constructPath(components, 0, count);\n-        final String remainder \u003d\n-          constructPath(components, count + 1, components.length);\n-        final String link \u003d DFSUtil.bytes2String(components[count]);\n-        final String target \u003d curNode.asSymlink().getSymlinkString();\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UnresolvedPathException \" +\n-            \" path: \" + path + \" preceding: \" + preceding +\n-            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n-            \" remainder: \" + remainder);\n-        }\n-        throw new UnresolvedPathException(path, preceding, remainder, target);\n-      }\n       if (lastComp || !isDir) {\n         break;\n       }\n-      final byte[] childName \u003d components[count + 1];\n-      \n+\n+      final byte[] childName \u003d components[++count];\n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n-        // skip the \".snapshot\" in components\n-        count++;\n         isSnapshot \u003d true;\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n           snapshotId \u003d s.getId();\n         }\n+        // combine .snapshot \u0026 name into 1 component element to ensure\n+        // 1-to-1 correspondence between components and inodes arrays is\n+        // preserved so a path can be reconstructed.\n+        byte[][] componentsCopy \u003d\n+            Arrays.copyOf(components, components.length - 1);\n+        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n+            DFSUtil.byteArray2PathString(components, count, 2));\n+        // shift the remaining components after snapshot name\n+        int start \u003d count + 2;\n+        System.arraycopy(components, start, componentsCopy, count + 1,\n+            components.length - start);\n+        components \u003d componentsCopy;\n+        // reduce the inodes array to compensate for reduction in components\n+        inodes \u003d Arrays.copyOf(inodes, components.length);\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName,\n             isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n-      count++;\n-    }\n-    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n-      // for snapshot path shrink the inode array. however, for path ending with\n-      // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[components.length - 1];\n-      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n-      inodes \u003d newNodes;\n     }\n     return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      byte[][] components, final boolean isRaw) {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n\n      final byte[] childName \u003d components[++count];\n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n        // combine .snapshot \u0026 name into 1 component element to ensure\n        // 1-to-1 correspondence between components and inodes arrays is\n        // preserved so a path can be reconstructed.\n        byte[][] componentsCopy \u003d\n            Arrays.copyOf(components, components.length - 1);\n        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n            DFSUtil.byteArray2PathString(components, count, 2));\n        // shift the remaining components after snapshot name\n        int start \u003d count + 2;\n        System.arraycopy(components, start, componentsCopy, count + 1,\n            components.length - start);\n        components \u003d componentsCopy;\n        // reduce the inodes array to compensate for reduction in components\n        inodes \u003d Arrays.copyOf(inodes, components.length);\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n    }\n    return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,92 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean isRaw,\n-      final boolean resolveLink) throws UnresolvedLinkException {\n+      byte[][] components, final boolean isRaw) {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     int count \u003d 0;\n     int inodeNum \u003d 0;\n     INode[] inodes \u003d new INode[components.length];\n     boolean isSnapshot \u003d false;\n     int snapshotId \u003d CURRENT_STATE_ID;\n \n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n       inodes[inodeNum++] \u003d curNode;\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n             dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n             snapshotId)) {\n           snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n                dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n             int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n-        final String path \u003d constructPath(components, 0, components.length);\n-        final String preceding \u003d constructPath(components, 0, count);\n-        final String remainder \u003d\n-          constructPath(components, count + 1, components.length);\n-        final String link \u003d DFSUtil.bytes2String(components[count]);\n-        final String target \u003d curNode.asSymlink().getSymlinkString();\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UnresolvedPathException \" +\n-            \" path: \" + path + \" preceding: \" + preceding +\n-            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n-            \" remainder: \" + remainder);\n-        }\n-        throw new UnresolvedPathException(path, preceding, remainder, target);\n-      }\n       if (lastComp || !isDir) {\n         break;\n       }\n-      final byte[] childName \u003d components[count + 1];\n-      \n+\n+      final byte[] childName \u003d components[++count];\n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n-        // skip the \".snapshot\" in components\n-        count++;\n         isSnapshot \u003d true;\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n           snapshotId \u003d s.getId();\n         }\n+        // combine .snapshot \u0026 name into 1 component element to ensure\n+        // 1-to-1 correspondence between components and inodes arrays is\n+        // preserved so a path can be reconstructed.\n+        byte[][] componentsCopy \u003d\n+            Arrays.copyOf(components, components.length - 1);\n+        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n+            DFSUtil.byteArray2PathString(components, count, 2));\n+        // shift the remaining components after snapshot name\n+        int start \u003d count + 2;\n+        System.arraycopy(components, start, componentsCopy, count + 1,\n+            components.length - start);\n+        components \u003d componentsCopy;\n+        // reduce the inodes array to compensate for reduction in components\n+        inodes \u003d Arrays.copyOf(inodes, components.length);\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName,\n             isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n-      count++;\n-    }\n-    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n-      // for snapshot path shrink the inode array. however, for path ending with\n-      // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[components.length - 1];\n-      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n-      inodes \u003d newNodes;\n     }\n     return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      byte[][] components, final boolean isRaw) {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n\n      final byte[] childName \u003d components[++count];\n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n        // combine .snapshot \u0026 name into 1 component element to ensure\n        // 1-to-1 correspondence between components and inodes arrays is\n        // preserved so a path can be reconstructed.\n        byte[][] componentsCopy \u003d\n            Arrays.copyOf(components, components.length - 1);\n        componentsCopy[count] \u003d DFSUtil.string2Bytes(\n            DFSUtil.byteArray2PathString(components, count, 2));\n        // shift the remaining components after snapshot name\n        int start \u003d count + 2;\n        System.arraycopy(components, start, componentsCopy, count + 1,\n            components.length - start);\n        components \u003d componentsCopy;\n        // reduce the inodes array to compensate for reduction in components\n        inodes \u003d Arrays.copyOf(inodes, components.length);\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n    }\n    return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {
            "oldValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][](modifiers-final), isRaw-boolean(modifiers-final), resolveLink-boolean(modifiers-final)]",
            "newValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][], isRaw-boolean(modifiers-final)]"
          }
        }
      ]
    },
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
      "commitDate": "24/08/16 6:46 AM",
      "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthor": "Daryn Sharp",
      "diff": "@@ -0,0 +1,104 @@\n+  static INodesInPath resolve(final INodeDirectory startingDir,\n+      final byte[][] components, final boolean isRaw,\n+      final boolean resolveLink) throws UnresolvedLinkException {\n+    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n+\n+    INode curNode \u003d startingDir;\n+    int count \u003d 0;\n+    int inodeNum \u003d 0;\n+    INode[] inodes \u003d new INode[components.length];\n+    boolean isSnapshot \u003d false;\n+    int snapshotId \u003d CURRENT_STATE_ID;\n+\n+    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n+      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n+      inodes[inodeNum++] \u003d curNode;\n+      final boolean isRef \u003d curNode.isReference();\n+      final boolean isDir \u003d curNode.isDirectory();\n+      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n+      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n+        //if the path is a non-snapshot path, update the latest snapshot.\n+        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n+            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n+            snapshotId)) {\n+          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n+        }\n+      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n+        // If the curNode is a reference node, need to check its dstSnapshot:\n+        // 1. if the existing snapshot is no later than the dstSnapshot (which\n+        // is the latest snapshot in dst before the rename), the changes \n+        // should be recorded in previous snapshots (belonging to src).\n+        // 2. however, if the ref node is already the last component, we still \n+        // need to know the latest snapshot among the ref node\u0027s ancestors, \n+        // in case of processing a deletion operation. Thus we do not overwrite\n+        // the latest snapshot if lastComp is true. In case of the operation is\n+        // a modification operation, we do a similar check in corresponding \n+        // recordModification method.\n+        if (!isSnapshot) {\n+          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n+          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n+              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n+               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n+            int lastSnapshot \u003d CURRENT_STATE_ID;\n+            DirectoryWithSnapshotFeature sf;\n+            if (curNode.isDirectory() \u0026\u0026 \n+                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n+              lastSnapshot \u003d sf.getLastSnapshotId();\n+            }\n+            snapshotId \u003d lastSnapshot;\n+          }\n+        }\n+      }\n+      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n+        final String path \u003d constructPath(components, 0, components.length);\n+        final String preceding \u003d constructPath(components, 0, count);\n+        final String remainder \u003d\n+          constructPath(components, count + 1, components.length);\n+        final String link \u003d DFSUtil.bytes2String(components[count]);\n+        final String target \u003d curNode.asSymlink().getSymlinkString();\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"UnresolvedPathException \" +\n+            \" path: \" + path + \" preceding: \" + preceding +\n+            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n+            \" remainder: \" + remainder);\n+        }\n+        throw new UnresolvedPathException(path, preceding, remainder, target);\n+      }\n+      if (lastComp || !isDir) {\n+        break;\n+      }\n+      final byte[] childName \u003d components[count + 1];\n+      \n+      // check if the next byte[] in components is for \".snapshot\"\n+      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n+        // skip the \".snapshot\" in components\n+        count++;\n+        isSnapshot \u003d true;\n+        // check if \".snapshot\" is the last element of components\n+        if (count \u003d\u003d components.length - 1) {\n+          break;\n+        }\n+        // Resolve snapshot root\n+        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n+        if (s \u003d\u003d null) {\n+          curNode \u003d null; // snapshot not found\n+        } else {\n+          curNode \u003d s.getRoot();\n+          snapshotId \u003d s.getId();\n+        }\n+      } else {\n+        // normal case, and also for resolving file/dir under snapshot root\n+        curNode \u003d dir.getChild(childName,\n+            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n+      }\n+      count++;\n+    }\n+    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n+      // for snapshot path shrink the inode array. however, for path ending with\n+      // .snapshot, still keep last the null inode in the array\n+      INode[] newNodes \u003d new INode[components.length - 1];\n+      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n+      inodes \u003d newNodes;\n+    }\n+    return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final boolean isRaw,\n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n      count++;\n    }\n    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n      // for snapshot path shrink the inode array. however, for path ending with\n      // .snapshot, still keep last the null inode in the array\n      INode[] newNodes \u003d new INode[components.length - 1];\n      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n      inodes \u003d newNodes;\n    }\n    return new INodesInPath(inodes, components, isRaw, isSnapshot, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java"
    }
  }
}