{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InnerNodeImpl.java",
  "functionName": "getLeaf",
  "functionId": "getLeaf___leafIndex-int__excludedNode-Node",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/InnerNodeImpl.java",
  "functionStartLine": 245,
  "functionEndLine": 291,
  "numCommitsSeen": 41,
  "timeTaken": 3212,
  "changeHistory": [
    "dd4a7633ece11c528a58146f92522b55e7be4dc6",
    "003ae00693d079799c4dcf02705379bcf34b8c79",
    "47a69ec7a5417cb56b75d07184dd6888ff068302",
    "4d0cab2729e2bdb1742b62dba69bd30ab69c868e",
    "415ce38b82fd173790fdbf3760a7846a41a0579d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "dd4a7633ece11c528a58146f92522b55e7be4dc6": "Ybodychange",
    "003ae00693d079799c4dcf02705379bcf34b8c79": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "47a69ec7a5417cb56b75d07184dd6888ff068302": "Ybodychange",
    "4d0cab2729e2bdb1742b62dba69bd30ab69c868e": "Ybodychange",
    "415ce38b82fd173790fdbf3760a7846a41a0579d": "Ymodifierchange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dd4a7633ece11c528a58146f92522b55e7be4dc6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16156. [Clean-up] Remove NULL check before instanceof and fix checkstyle in InnerNodeImpl. Contributed by Shweta Yakkali.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "17/06/19 11:47 PM",
      "commitName": "dd4a7633ece11c528a58146f92522b55e7be4dc6",
      "commitAuthor": "Shweta Yakkali",
      "commitDateOld": "13/03/17 5:30 PM",
      "commitNameOld": "9832ae0ed8853d29072c9ea7031cd2373e6b16f9",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 826.26,
      "commitsBetweenForRepo": 6481,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,47 @@\n   public Node getLeaf(int leafIndex, Node excludedNode) {\n     int count\u003d0;\n     // check if the excluded node a leaf\n-    boolean isLeaf \u003d\n-      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n+    boolean isLeaf \u003d !(excludedNode instanceof InnerNode);\n     // calculate the total number of excluded leaf nodes\n     int numOfExcludedLeaves \u003d\n-      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n+        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n     if (isLeafParent()) { // children are leaves\n       if (isLeaf) { // excluded node is a leaf node\n         if (excludedNode !\u003d null \u0026\u0026\n             childrenMap.containsKey(excludedNode.getName())) {\n           int excludedIndex \u003d children.indexOf(excludedNode);\n           if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n             // excluded node is one of the children so adjust the leaf index\n             leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n           }\n         }\n       }\n       // range check\n       if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n         return null;\n       }\n       return children.get(leafIndex);\n     } else {\n       for(int i\u003d0; i\u003cchildren.size(); i++) {\n         InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n         if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n           // not the excludedNode\n           int numOfLeaves \u003d child.getNumOfLeaves();\n           if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n             numOfLeaves -\u003d numOfExcludedLeaves;\n           }\n           if (count+numOfLeaves \u003e leafIndex) {\n             // the leaf is in the child subtree\n             return child.getLeaf(leafIndex-count, excludedNode);\n           } else {\n             // go to the next child\n             count \u003d count+numOfLeaves;\n           }\n         } else { // it is the excluededNode\n           // skip it and set the excludedNode to be null\n           excludedNode \u003d null;\n         }\n       }\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Node getLeaf(int leafIndex, Node excludedNode) {\n    int count\u003d0;\n    // check if the excluded node a leaf\n    boolean isLeaf \u003d !(excludedNode instanceof InnerNode);\n    // calculate the total number of excluded leaf nodes\n    int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n    if (isLeafParent()) { // children are leaves\n      if (isLeaf) { // excluded node is a leaf node\n        if (excludedNode !\u003d null \u0026\u0026\n            childrenMap.containsKey(excludedNode.getName())) {\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n      }\n      // range check\n      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n        return null;\n      }\n      return children.get(leafIndex);\n    } else {\n      for(int i\u003d0; i\u003cchildren.size(); i++) {\n        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n          // not the excludedNode\n          int numOfLeaves \u003d child.getNumOfLeaves();\n          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n            numOfLeaves -\u003d numOfExcludedLeaves;\n          }\n          if (count+numOfLeaves \u003e leafIndex) {\n            // the leaf is in the child subtree\n            return child.getLeaf(leafIndex-count, excludedNode);\n          } else {\n            // go to the next child\n            count \u003d count+numOfLeaves;\n          }\n        } else { // it is the excluededNode\n          // skip it and set the excludedNode to be null\n          excludedNode \u003d null;\n        }\n      }\n      return null;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/InnerNodeImpl.java",
      "extendedDetails": {}
    },
    "003ae00693d079799c4dcf02705379bcf34b8c79": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-11430. Separate class InnerNode from class NetworkTopology and make it extendable. Contributed by Tsz Wo Nicholas Sze\n",
      "commitDate": "21/02/17 3:32 PM",
      "commitName": "003ae00693d079799c4dcf02705379bcf34b8c79",
      "commitAuthor": "Mingliang Liu",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-11430. Separate class InnerNode from class NetworkTopology and make it extendable. Contributed by Tsz Wo Nicholas Sze\n",
          "commitDate": "21/02/17 3:32 PM",
          "commitName": "003ae00693d079799c4dcf02705379bcf34b8c79",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "21/02/17 2:54 PM",
          "commitNameOld": "8ef7ebbc7112e1868c9b12ff1df4a40fe7afa8af",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,48 @@\n-    Node getLeaf(int leafIndex, Node excludedNode) {\n-      int count\u003d0;\n-      // check if the excluded node a leaf\n-      boolean isLeaf \u003d\n-        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n-      // calculate the total number of excluded leaf nodes\n-      int numOfExcludedLeaves \u003d\n-        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n-      if (isLeafParent()) { // children are leaves\n-        if (isLeaf) { // excluded node is a leaf node\n-          if (excludedNode !\u003d null \u0026\u0026\n-              childrenMap.containsKey(excludedNode.getName())) {\n-            int excludedIndex \u003d children.indexOf(excludedNode);\n-            if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n-              // excluded node is one of the children so adjust the leaf index\n-              leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n-            }\n+  public Node getLeaf(int leafIndex, Node excludedNode) {\n+    int count\u003d0;\n+    // check if the excluded node a leaf\n+    boolean isLeaf \u003d\n+      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n+    // calculate the total number of excluded leaf nodes\n+    int numOfExcludedLeaves \u003d\n+      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n+    if (isLeafParent()) { // children are leaves\n+      if (isLeaf) { // excluded node is a leaf node\n+        if (excludedNode !\u003d null \u0026\u0026\n+            childrenMap.containsKey(excludedNode.getName())) {\n+          int excludedIndex \u003d children.indexOf(excludedNode);\n+          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n+            // excluded node is one of the children so adjust the leaf index\n+            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n           }\n         }\n-        // range check\n-        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n-          return null;\n-        }\n-        return children.get(leafIndex);\n-      } else {\n-        for(int i\u003d0; i\u003cchildren.size(); i++) {\n-          InnerNode child \u003d (InnerNode)children.get(i);\n-          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n-            // not the excludedNode\n-            int numOfLeaves \u003d child.getNumOfLeaves();\n-            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n-              numOfLeaves -\u003d numOfExcludedLeaves;\n-            }\n-            if (count+numOfLeaves \u003e leafIndex) {\n-              // the leaf is in the child subtree\n-              return child.getLeaf(leafIndex-count, excludedNode);\n-            } else {\n-              // go to the next child\n-              count \u003d count+numOfLeaves;\n-            }\n-          } else { // it is the excluededNode\n-            // skip it and set the excludedNode to be null\n-            excludedNode \u003d null;\n-          }\n-        }\n+      }\n+      // range check\n+      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n         return null;\n       }\n-    }\n\\ No newline at end of file\n+      return children.get(leafIndex);\n+    } else {\n+      for(int i\u003d0; i\u003cchildren.size(); i++) {\n+        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n+        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n+          // not the excludedNode\n+          int numOfLeaves \u003d child.getNumOfLeaves();\n+          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n+            numOfLeaves -\u003d numOfExcludedLeaves;\n+          }\n+          if (count+numOfLeaves \u003e leafIndex) {\n+            // the leaf is in the child subtree\n+            return child.getLeaf(leafIndex-count, excludedNode);\n+          } else {\n+            // go to the next child\n+            count \u003d count+numOfLeaves;\n+          }\n+        } else { // it is the excluededNode\n+          // skip it and set the excludedNode to be null\n+          excludedNode \u003d null;\n+        }\n+      }\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public Node getLeaf(int leafIndex, Node excludedNode) {\n    int count\u003d0;\n    // check if the excluded node a leaf\n    boolean isLeaf \u003d\n      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n    // calculate the total number of excluded leaf nodes\n    int numOfExcludedLeaves \u003d\n      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n    if (isLeafParent()) { // children are leaves\n      if (isLeaf) { // excluded node is a leaf node\n        if (excludedNode !\u003d null \u0026\u0026\n            childrenMap.containsKey(excludedNode.getName())) {\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n      }\n      // range check\n      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n        return null;\n      }\n      return children.get(leafIndex);\n    } else {\n      for(int i\u003d0; i\u003cchildren.size(); i++) {\n        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n          // not the excludedNode\n          int numOfLeaves \u003d child.getNumOfLeaves();\n          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n            numOfLeaves -\u003d numOfExcludedLeaves;\n          }\n          if (count+numOfLeaves \u003e leafIndex) {\n            // the leaf is in the child subtree\n            return child.getLeaf(leafIndex-count, excludedNode);\n          } else {\n            // go to the next child\n            count \u003d count+numOfLeaves;\n          }\n        } else { // it is the excluededNode\n          // skip it and set the excludedNode to be null\n          excludedNode \u003d null;\n        }\n      }\n      return null;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/InnerNodeImpl.java",
          "extendedDetails": {
            "oldPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
            "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/InnerNodeImpl.java",
            "oldMethodName": "getLeaf",
            "newMethodName": "getLeaf"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-11430. Separate class InnerNode from class NetworkTopology and make it extendable. Contributed by Tsz Wo Nicholas Sze\n",
          "commitDate": "21/02/17 3:32 PM",
          "commitName": "003ae00693d079799c4dcf02705379bcf34b8c79",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "21/02/17 2:54 PM",
          "commitNameOld": "8ef7ebbc7112e1868c9b12ff1df4a40fe7afa8af",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,48 @@\n-    Node getLeaf(int leafIndex, Node excludedNode) {\n-      int count\u003d0;\n-      // check if the excluded node a leaf\n-      boolean isLeaf \u003d\n-        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n-      // calculate the total number of excluded leaf nodes\n-      int numOfExcludedLeaves \u003d\n-        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n-      if (isLeafParent()) { // children are leaves\n-        if (isLeaf) { // excluded node is a leaf node\n-          if (excludedNode !\u003d null \u0026\u0026\n-              childrenMap.containsKey(excludedNode.getName())) {\n-            int excludedIndex \u003d children.indexOf(excludedNode);\n-            if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n-              // excluded node is one of the children so adjust the leaf index\n-              leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n-            }\n+  public Node getLeaf(int leafIndex, Node excludedNode) {\n+    int count\u003d0;\n+    // check if the excluded node a leaf\n+    boolean isLeaf \u003d\n+      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n+    // calculate the total number of excluded leaf nodes\n+    int numOfExcludedLeaves \u003d\n+      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n+    if (isLeafParent()) { // children are leaves\n+      if (isLeaf) { // excluded node is a leaf node\n+        if (excludedNode !\u003d null \u0026\u0026\n+            childrenMap.containsKey(excludedNode.getName())) {\n+          int excludedIndex \u003d children.indexOf(excludedNode);\n+          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n+            // excluded node is one of the children so adjust the leaf index\n+            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n           }\n         }\n-        // range check\n-        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n-          return null;\n-        }\n-        return children.get(leafIndex);\n-      } else {\n-        for(int i\u003d0; i\u003cchildren.size(); i++) {\n-          InnerNode child \u003d (InnerNode)children.get(i);\n-          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n-            // not the excludedNode\n-            int numOfLeaves \u003d child.getNumOfLeaves();\n-            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n-              numOfLeaves -\u003d numOfExcludedLeaves;\n-            }\n-            if (count+numOfLeaves \u003e leafIndex) {\n-              // the leaf is in the child subtree\n-              return child.getLeaf(leafIndex-count, excludedNode);\n-            } else {\n-              // go to the next child\n-              count \u003d count+numOfLeaves;\n-            }\n-          } else { // it is the excluededNode\n-            // skip it and set the excludedNode to be null\n-            excludedNode \u003d null;\n-          }\n-        }\n+      }\n+      // range check\n+      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n         return null;\n       }\n-    }\n\\ No newline at end of file\n+      return children.get(leafIndex);\n+    } else {\n+      for(int i\u003d0; i\u003cchildren.size(); i++) {\n+        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n+        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n+          // not the excludedNode\n+          int numOfLeaves \u003d child.getNumOfLeaves();\n+          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n+            numOfLeaves -\u003d numOfExcludedLeaves;\n+          }\n+          if (count+numOfLeaves \u003e leafIndex) {\n+            // the leaf is in the child subtree\n+            return child.getLeaf(leafIndex-count, excludedNode);\n+          } else {\n+            // go to the next child\n+            count \u003d count+numOfLeaves;\n+          }\n+        } else { // it is the excluededNode\n+          // skip it and set the excludedNode to be null\n+          excludedNode \u003d null;\n+        }\n+      }\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public Node getLeaf(int leafIndex, Node excludedNode) {\n    int count\u003d0;\n    // check if the excluded node a leaf\n    boolean isLeaf \u003d\n      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n    // calculate the total number of excluded leaf nodes\n    int numOfExcludedLeaves \u003d\n      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n    if (isLeafParent()) { // children are leaves\n      if (isLeaf) { // excluded node is a leaf node\n        if (excludedNode !\u003d null \u0026\u0026\n            childrenMap.containsKey(excludedNode.getName())) {\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n      }\n      // range check\n      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n        return null;\n      }\n      return children.get(leafIndex);\n    } else {\n      for(int i\u003d0; i\u003cchildren.size(); i++) {\n        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n          // not the excludedNode\n          int numOfLeaves \u003d child.getNumOfLeaves();\n          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n            numOfLeaves -\u003d numOfExcludedLeaves;\n          }\n          if (count+numOfLeaves \u003e leafIndex) {\n            // the leaf is in the child subtree\n            return child.getLeaf(leafIndex-count, excludedNode);\n          } else {\n            // go to the next child\n            count \u003d count+numOfLeaves;\n          }\n        } else { // it is the excluededNode\n          // skip it and set the excludedNode to be null\n          excludedNode \u003d null;\n        }\n      }\n      return null;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/InnerNodeImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11430. Separate class InnerNode from class NetworkTopology and make it extendable. Contributed by Tsz Wo Nicholas Sze\n",
          "commitDate": "21/02/17 3:32 PM",
          "commitName": "003ae00693d079799c4dcf02705379bcf34b8c79",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "21/02/17 2:54 PM",
          "commitNameOld": "8ef7ebbc7112e1868c9b12ff1df4a40fe7afa8af",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,48 @@\n-    Node getLeaf(int leafIndex, Node excludedNode) {\n-      int count\u003d0;\n-      // check if the excluded node a leaf\n-      boolean isLeaf \u003d\n-        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n-      // calculate the total number of excluded leaf nodes\n-      int numOfExcludedLeaves \u003d\n-        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n-      if (isLeafParent()) { // children are leaves\n-        if (isLeaf) { // excluded node is a leaf node\n-          if (excludedNode !\u003d null \u0026\u0026\n-              childrenMap.containsKey(excludedNode.getName())) {\n-            int excludedIndex \u003d children.indexOf(excludedNode);\n-            if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n-              // excluded node is one of the children so adjust the leaf index\n-              leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n-            }\n+  public Node getLeaf(int leafIndex, Node excludedNode) {\n+    int count\u003d0;\n+    // check if the excluded node a leaf\n+    boolean isLeaf \u003d\n+      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n+    // calculate the total number of excluded leaf nodes\n+    int numOfExcludedLeaves \u003d\n+      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n+    if (isLeafParent()) { // children are leaves\n+      if (isLeaf) { // excluded node is a leaf node\n+        if (excludedNode !\u003d null \u0026\u0026\n+            childrenMap.containsKey(excludedNode.getName())) {\n+          int excludedIndex \u003d children.indexOf(excludedNode);\n+          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n+            // excluded node is one of the children so adjust the leaf index\n+            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n           }\n         }\n-        // range check\n-        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n-          return null;\n-        }\n-        return children.get(leafIndex);\n-      } else {\n-        for(int i\u003d0; i\u003cchildren.size(); i++) {\n-          InnerNode child \u003d (InnerNode)children.get(i);\n-          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n-            // not the excludedNode\n-            int numOfLeaves \u003d child.getNumOfLeaves();\n-            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n-              numOfLeaves -\u003d numOfExcludedLeaves;\n-            }\n-            if (count+numOfLeaves \u003e leafIndex) {\n-              // the leaf is in the child subtree\n-              return child.getLeaf(leafIndex-count, excludedNode);\n-            } else {\n-              // go to the next child\n-              count \u003d count+numOfLeaves;\n-            }\n-          } else { // it is the excluededNode\n-            // skip it and set the excludedNode to be null\n-            excludedNode \u003d null;\n-          }\n-        }\n+      }\n+      // range check\n+      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n         return null;\n       }\n-    }\n\\ No newline at end of file\n+      return children.get(leafIndex);\n+    } else {\n+      for(int i\u003d0; i\u003cchildren.size(); i++) {\n+        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n+        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n+          // not the excludedNode\n+          int numOfLeaves \u003d child.getNumOfLeaves();\n+          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n+            numOfLeaves -\u003d numOfExcludedLeaves;\n+          }\n+          if (count+numOfLeaves \u003e leafIndex) {\n+            // the leaf is in the child subtree\n+            return child.getLeaf(leafIndex-count, excludedNode);\n+          } else {\n+            // go to the next child\n+            count \u003d count+numOfLeaves;\n+          }\n+        } else { // it is the excluededNode\n+          // skip it and set the excludedNode to be null\n+          excludedNode \u003d null;\n+        }\n+      }\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public Node getLeaf(int leafIndex, Node excludedNode) {\n    int count\u003d0;\n    // check if the excluded node a leaf\n    boolean isLeaf \u003d\n      excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n    // calculate the total number of excluded leaf nodes\n    int numOfExcludedLeaves \u003d\n      isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n    if (isLeafParent()) { // children are leaves\n      if (isLeaf) { // excluded node is a leaf node\n        if (excludedNode !\u003d null \u0026\u0026\n            childrenMap.containsKey(excludedNode.getName())) {\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n      }\n      // range check\n      if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n        return null;\n      }\n      return children.get(leafIndex);\n    } else {\n      for(int i\u003d0; i\u003cchildren.size(); i++) {\n        InnerNodeImpl child \u003d (InnerNodeImpl)children.get(i);\n        if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n          // not the excludedNode\n          int numOfLeaves \u003d child.getNumOfLeaves();\n          if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n            numOfLeaves -\u003d numOfExcludedLeaves;\n          }\n          if (count+numOfLeaves \u003e leafIndex) {\n            // the leaf is in the child subtree\n            return child.getLeaf(leafIndex-count, excludedNode);\n          } else {\n            // go to the next child\n            count \u003d count+numOfLeaves;\n          }\n        } else { // it is the excluededNode\n          // skip it and set the excludedNode to be null\n          excludedNode \u003d null;\n        }\n      }\n      return null;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/InnerNodeImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "47a69ec7a5417cb56b75d07184dd6888ff068302": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12185. NetworkTopology is not efficient adding/getting/removing nodes. Contributed by Inigo Goiri\n",
      "commitDate": "06/07/15 3:03 PM",
      "commitName": "47a69ec7a5417cb56b75d07184dd6888ff068302",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "02/07/15 9:39 PM",
      "commitNameOld": "e59f6fad6a8849cfab6acbf012f338d9cc7dd63c",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 3.72,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,48 @@\n     Node getLeaf(int leafIndex, Node excludedNode) {\n       int count\u003d0;\n       // check if the excluded node a leaf\n       boolean isLeaf \u003d\n         excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n       // calculate the total number of excluded leaf nodes\n       int numOfExcludedLeaves \u003d\n         isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n       if (isLeafParent()) { // children are leaves\n         if (isLeaf) { // excluded node is a leaf node\n-          int excludedIndex \u003d children.indexOf(excludedNode);\n-          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n-            // excluded node is one of the children so adjust the leaf index\n-            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n+          if (excludedNode !\u003d null \u0026\u0026\n+              childrenMap.containsKey(excludedNode.getName())) {\n+            int excludedIndex \u003d children.indexOf(excludedNode);\n+            if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n+              // excluded node is one of the children so adjust the leaf index\n+              leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n+            }\n           }\n         }\n         // range check\n         if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n           return null;\n         }\n         return children.get(leafIndex);\n       } else {\n         for(int i\u003d0; i\u003cchildren.size(); i++) {\n           InnerNode child \u003d (InnerNode)children.get(i);\n           if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n             // not the excludedNode\n             int numOfLeaves \u003d child.getNumOfLeaves();\n             if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n               numOfLeaves -\u003d numOfExcludedLeaves;\n             }\n             if (count+numOfLeaves \u003e leafIndex) {\n               // the leaf is in the child subtree\n               return child.getLeaf(leafIndex-count, excludedNode);\n             } else {\n               // go to the next child\n               count \u003d count+numOfLeaves;\n             }\n           } else { // it is the excluededNode\n             // skip it and set the excludedNode to be null\n             excludedNode \u003d null;\n           }\n         }\n         return null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isLeafParent()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          if (excludedNode !\u003d null \u0026\u0026\n              childrenMap.containsKey(excludedNode.getName())) {\n            int excludedIndex \u003d children.indexOf(excludedNode);\n            if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n              // excluded node is one of the children so adjust the leaf index\n              leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n            }\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "4d0cab2729e2bdb1742b62dba69bd30ab69c868e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3601. Add BlockPlacementPolicyWithNodeGroup to support block placement with 4-layer network topology.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1357442 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/07/12 6:31 PM",
      "commitName": "4d0cab2729e2bdb1742b62dba69bd30ab69c868e",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "07/06/12 7:29 PM",
      "commitNameOld": "415ce38b82fd173790fdbf3760a7846a41a0579d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 26.96,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n     Node getLeaf(int leafIndex, Node excludedNode) {\n       int count\u003d0;\n       // check if the excluded node a leaf\n       boolean isLeaf \u003d\n         excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n       // calculate the total number of excluded leaf nodes\n       int numOfExcludedLeaves \u003d\n         isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n-      if (isRack()) { // children are leaves\n+      if (isLeafParent()) { // children are leaves\n         if (isLeaf) { // excluded node is a leaf node\n           int excludedIndex \u003d children.indexOf(excludedNode);\n           if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n             // excluded node is one of the children so adjust the leaf index\n             leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n           }\n         }\n         // range check\n         if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n           return null;\n         }\n         return children.get(leafIndex);\n       } else {\n         for(int i\u003d0; i\u003cchildren.size(); i++) {\n           InnerNode child \u003d (InnerNode)children.get(i);\n           if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n             // not the excludedNode\n             int numOfLeaves \u003d child.getNumOfLeaves();\n             if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n               numOfLeaves -\u003d numOfExcludedLeaves;\n             }\n             if (count+numOfLeaves \u003e leafIndex) {\n               // the leaf is in the child subtree\n               return child.getLeaf(leafIndex-count, excludedNode);\n             } else {\n               // go to the next child\n               count \u003d count+numOfLeaves;\n             }\n           } else { // it is the excluededNode\n             // skip it and set the excludedNode to be null\n             excludedNode \u003d null;\n           }\n         }\n         return null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isLeafParent()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "415ce38b82fd173790fdbf3760a7846a41a0579d": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-8469. Make NetworkTopology class pluggable.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1347867 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/06/12 7:29 PM",
      "commitName": "415ce38b82fd173790fdbf3760a7846a41a0579d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "12/04/12 9:37 AM",
      "commitNameOld": "f01ede227f0594388afb855234b0c4fbd250be26",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 56.41,
      "commitsBetweenForRepo": 329,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n-    private Node getLeaf(int leafIndex, Node excludedNode) {\n+    Node getLeaf(int leafIndex, Node excludedNode) {\n       int count\u003d0;\n       // check if the excluded node a leaf\n       boolean isLeaf \u003d\n         excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n       // calculate the total number of excluded leaf nodes\n       int numOfExcludedLeaves \u003d\n         isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n       if (isRack()) { // children are leaves\n         if (isLeaf) { // excluded node is a leaf node\n           int excludedIndex \u003d children.indexOf(excludedNode);\n           if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n             // excluded node is one of the children so adjust the leaf index\n             leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n           }\n         }\n         // range check\n         if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n           return null;\n         }\n         return children.get(leafIndex);\n       } else {\n         for(int i\u003d0; i\u003cchildren.size(); i++) {\n           InnerNode child \u003d (InnerNode)children.get(i);\n           if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n             // not the excludedNode\n             int numOfLeaves \u003d child.getNumOfLeaves();\n             if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n               numOfLeaves -\u003d numOfExcludedLeaves;\n             }\n             if (count+numOfLeaves \u003e leafIndex) {\n               // the leaf is in the child subtree\n               return child.getLeaf(leafIndex-count, excludedNode);\n             } else {\n               // go to the next child\n               count \u003d count+numOfLeaves;\n             }\n           } else { // it is the excluededNode\n             // skip it and set the excludedNode to be null\n             excludedNode \u003d null;\n           }\n         }\n         return null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isRack()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[]"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isRack()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isRack()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/net/NetworkTopology.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isRack()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/net/NetworkTopology.java",
        "newPath": "common/src/java/org/apache/hadoop/net/NetworkTopology.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,45 @@\n+    private Node getLeaf(int leafIndex, Node excludedNode) {\n+      int count\u003d0;\n+      // check if the excluded node a leaf\n+      boolean isLeaf \u003d\n+        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n+      // calculate the total number of excluded leaf nodes\n+      int numOfExcludedLeaves \u003d\n+        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n+      if (isRack()) { // children are leaves\n+        if (isLeaf) { // excluded node is a leaf node\n+          int excludedIndex \u003d children.indexOf(excludedNode);\n+          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n+            // excluded node is one of the children so adjust the leaf index\n+            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n+          }\n+        }\n+        // range check\n+        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n+          return null;\n+        }\n+        return children.get(leafIndex);\n+      } else {\n+        for(int i\u003d0; i\u003cchildren.size(); i++) {\n+          InnerNode child \u003d (InnerNode)children.get(i);\n+          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n+            // not the excludedNode\n+            int numOfLeaves \u003d child.getNumOfLeaves();\n+            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n+              numOfLeaves -\u003d numOfExcludedLeaves;\n+            }\n+            if (count+numOfLeaves \u003e leafIndex) {\n+              // the leaf is in the child subtree\n+              return child.getLeaf(leafIndex-count, excludedNode);\n+            } else {\n+              // go to the next child\n+              count \u003d count+numOfLeaves;\n+            }\n+          } else { // it is the excluededNode\n+            // skip it and set the excludedNode to be null\n+            excludedNode \u003d null;\n+          }\n+        }\n+        return null;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private Node getLeaf(int leafIndex, Node excludedNode) {\n      int count\u003d0;\n      // check if the excluded node a leaf\n      boolean isLeaf \u003d\n        excludedNode \u003d\u003d null || !(excludedNode instanceof InnerNode);\n      // calculate the total number of excluded leaf nodes\n      int numOfExcludedLeaves \u003d\n        isLeaf ? 1 : ((InnerNode)excludedNode).getNumOfLeaves();\n      if (isRack()) { // children are leaves\n        if (isLeaf) { // excluded node is a leaf node\n          int excludedIndex \u003d children.indexOf(excludedNode);\n          if (excludedIndex !\u003d -1 \u0026\u0026 leafIndex \u003e\u003d 0) {\n            // excluded node is one of the children so adjust the leaf index\n            leafIndex \u003d leafIndex\u003e\u003dexcludedIndex ? leafIndex+1 : leafIndex;\n          }\n        }\n        // range check\n        if (leafIndex\u003c0 || leafIndex\u003e\u003dthis.getNumOfChildren()) {\n          return null;\n        }\n        return children.get(leafIndex);\n      } else {\n        for(int i\u003d0; i\u003cchildren.size(); i++) {\n          InnerNode child \u003d (InnerNode)children.get(i);\n          if (excludedNode \u003d\u003d null || excludedNode !\u003d child) {\n            // not the excludedNode\n            int numOfLeaves \u003d child.getNumOfLeaves();\n            if (excludedNode !\u003d null \u0026\u0026 child.isAncestor(excludedNode)) {\n              numOfLeaves -\u003d numOfExcludedLeaves;\n            }\n            if (count+numOfLeaves \u003e leafIndex) {\n              // the leaf is in the child subtree\n              return child.getLeaf(leafIndex-count, excludedNode);\n            } else {\n              // go to the next child\n              count \u003d count+numOfLeaves;\n            }\n          } else { // it is the excluededNode\n            // skip it and set the excludedNode to be null\n            excludedNode \u003d null;\n          }\n        }\n        return null;\n      }\n    }",
      "path": "src/java/org/apache/hadoop/net/NetworkTopology.java"
    }
  }
}