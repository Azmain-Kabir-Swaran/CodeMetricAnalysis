{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JobMonitor.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-tools/hadoop-gridmix/src/main/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
  "functionStartLine": 143,
  "functionEndLine": 248,
  "numCommitsSeen": 8,
  "timeTaken": 4764,
  "changeHistory": [
    "070916130a538968f8e01a1e895f3092d50983ae",
    "dcf84707ab50662add112bd6b01c0bfd63374853",
    "8a2073cc61699f5692fcf638f4bae4d1c544870a",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "070916130a538968f8e01a1e895f3092d50983ae": "Ybodychange",
    "dcf84707ab50662add112bd6b01c0bfd63374853": "Yfilerename",
    "8a2073cc61699f5692fcf638f4bae4d1c544870a": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "070916130a538968f8e01a1e895f3092d50983ae": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5098. Fix findbugs warnings in gridmix. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1464209 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/13 2:22 PM",
      "commitName": "070916130a538968f8e01a1e895f3092d50983ae",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "17/05/12 8:06 AM",
      "commitNameOld": "dcf84707ab50662add112bd6b01c0bfd63374853",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 321.26,
      "commitsBetweenForRepo": 1635,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,106 @@\n     public void run() {\n       boolean graceful;\n       boolean shutdown;\n       while (true) {\n         try {\n-          synchronized (runningJobs) {\n-            synchronized (mJobs) {\n-              graceful \u003d JobMonitor.this.graceful;\n-              shutdown \u003d JobMonitor.this.shutdown;\n-              runningJobs.drainTo(mJobs);\n-            }\n+          synchronized (mJobs) {\n+            graceful \u003d JobMonitor.this.graceful;\n+            shutdown \u003d JobMonitor.this.shutdown;\n+            runningJobs.drainTo(mJobs);\n           }\n \n           // shutdown conditions; either shutdown requested and all jobs\n           // have completed or abort requested and there are recently\n           // submitted jobs not in the monitored set\n           if (shutdown) {\n             if (!graceful) {\n-              synchronized (runningJobs) {\n-                while (!runningJobs.isEmpty()) {\n-                  synchronized (mJobs) {\n-                    runningJobs.drainTo(mJobs);\n-                  }\n+              while (!runningJobs.isEmpty()) {\n+                synchronized (mJobs) {\n+                  runningJobs.drainTo(mJobs);\n                 }\n               }\n               break;\n             }\n             \n             synchronized (mJobs) {\n               if (graceful \u0026\u0026 mJobs.isEmpty()) {\n                 break;\n               }\n             }\n           }\n           JobStats jobStats \u003d null;\n           synchronized (mJobs) {\n             jobStats \u003d mJobs.poll();\n           }\n           while (jobStats !\u003d null) {\n             Job job \u003d jobStats.getJob();\n             \n             try {\n               // get the job status\n               long start \u003d System.currentTimeMillis();\n               JobStatus status \u003d job.getStatus(); // cache the job status\n               long end \u003d System.currentTimeMillis();\n               \n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Status polling for job \" + job.getJobID() + \" took \"\n                           + (end-start) + \"ms.\");\n               }\n               \n               // update the job progress\n               jobStats.updateJobStatus(status);\n               \n               // if the job is complete, let others know\n               if (status.isJobComplete()) {\n                 if (status.getState() \u003d\u003d JobStatus.State.SUCCEEDED) {\n                   onSuccess(job);\n                 } else {\n                   onFailure(job);\n                 }\n                 synchronized (statistics) {\n                   statistics.add(jobStats);\n                 }\n               } else {\n                 // add the running job back and break\n                 synchronized (mJobs) {\n                   if (!mJobs.offer(jobStats)) {\n                     LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                          ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                              // happen\n                   }\n                 }\n                 break;\n               }\n             } catch (IOException e) {\n               if (e.getCause() instanceof ClosedByInterruptException) {\n                 // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                 // is blocking and may throw a wrapped Exception if this thread\n                 // is interrupted. Since the lower level cleared the flag,\n                 // reset it here\n                 Thread.currentThread().interrupt();\n               } else {\n                 LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                      ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                 synchronized (statistics) {\n                   statistics.add(jobStats);\n                 }\n               }\n             }\n             \n             // get the next job\n             synchronized (mJobs) {\n               jobStats \u003d mJobs.poll();\n             }\n           }\n           \n           // sleep for a while before checking again\n           try {\n             TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n           } catch (InterruptedException e) {\n             shutdown \u003d true;\n             continue;\n           }\n         } catch (Throwable e) {\n           LOG.warn(\"Unexpected exception: \", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      boolean graceful;\n      boolean shutdown;\n      while (true) {\n        try {\n          synchronized (mJobs) {\n            graceful \u003d JobMonitor.this.graceful;\n            shutdown \u003d JobMonitor.this.shutdown;\n            runningJobs.drainTo(mJobs);\n          }\n\n          // shutdown conditions; either shutdown requested and all jobs\n          // have completed or abort requested and there are recently\n          // submitted jobs not in the monitored set\n          if (shutdown) {\n            if (!graceful) {\n              while (!runningJobs.isEmpty()) {\n                synchronized (mJobs) {\n                  runningJobs.drainTo(mJobs);\n                }\n              }\n              break;\n            }\n            \n            synchronized (mJobs) {\n              if (graceful \u0026\u0026 mJobs.isEmpty()) {\n                break;\n              }\n            }\n          }\n          JobStats jobStats \u003d null;\n          synchronized (mJobs) {\n            jobStats \u003d mJobs.poll();\n          }\n          while (jobStats !\u003d null) {\n            Job job \u003d jobStats.getJob();\n            \n            try {\n              // get the job status\n              long start \u003d System.currentTimeMillis();\n              JobStatus status \u003d job.getStatus(); // cache the job status\n              long end \u003d System.currentTimeMillis();\n              \n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Status polling for job \" + job.getJobID() + \" took \"\n                          + (end-start) + \"ms.\");\n              }\n              \n              // update the job progress\n              jobStats.updateJobStatus(status);\n              \n              // if the job is complete, let others know\n              if (status.isJobComplete()) {\n                if (status.getState() \u003d\u003d JobStatus.State.SUCCEEDED) {\n                  onSuccess(job);\n                } else {\n                  onFailure(job);\n                }\n                synchronized (statistics) {\n                  statistics.add(jobStats);\n                }\n              } else {\n                // add the running job back and break\n                synchronized (mJobs) {\n                  if (!mJobs.offer(jobStats)) {\n                    LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                         ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                             // happen\n                  }\n                }\n                break;\n              }\n            } catch (IOException e) {\n              if (e.getCause() instanceof ClosedByInterruptException) {\n                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                // is blocking and may throw a wrapped Exception if this thread\n                // is interrupted. Since the lower level cleared the flag,\n                // reset it here\n                Thread.currentThread().interrupt();\n              } else {\n                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                synchronized (statistics) {\n                  statistics.add(jobStats);\n                }\n              }\n            }\n            \n            // get the next job\n            synchronized (mJobs) {\n              jobStats \u003d mJobs.poll();\n            }\n          }\n          \n          // sleep for a while before checking again\n          try {\n            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n          } catch (InterruptedException e) {\n            shutdown \u003d true;\n            continue;\n          }\n        } catch (Throwable e) {\n          LOG.warn(\"Unexpected exception: \", e);\n        }\n      }\n    }",
      "path": "hadoop-tools/hadoop-gridmix/src/main/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
      "extendedDetails": {}
    },
    "dcf84707ab50662add112bd6b01c0bfd63374853": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-3543. Mavenize Gridmix. (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1339629 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/12 8:06 AM",
      "commitName": "dcf84707ab50662add112bd6b01c0bfd63374853",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "17/05/12 7:20 AM",
      "commitNameOld": "e1f09365ca0bee093f849fcf2e546dd6e2c0a965",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      boolean graceful;\n      boolean shutdown;\n      while (true) {\n        try {\n          synchronized (runningJobs) {\n            synchronized (mJobs) {\n              graceful \u003d JobMonitor.this.graceful;\n              shutdown \u003d JobMonitor.this.shutdown;\n              runningJobs.drainTo(mJobs);\n            }\n          }\n\n          // shutdown conditions; either shutdown requested and all jobs\n          // have completed or abort requested and there are recently\n          // submitted jobs not in the monitored set\n          if (shutdown) {\n            if (!graceful) {\n              synchronized (runningJobs) {\n                while (!runningJobs.isEmpty()) {\n                  synchronized (mJobs) {\n                    runningJobs.drainTo(mJobs);\n                  }\n                }\n              }\n              break;\n            }\n            \n            synchronized (mJobs) {\n              if (graceful \u0026\u0026 mJobs.isEmpty()) {\n                break;\n              }\n            }\n          }\n          JobStats jobStats \u003d null;\n          synchronized (mJobs) {\n            jobStats \u003d mJobs.poll();\n          }\n          while (jobStats !\u003d null) {\n            Job job \u003d jobStats.getJob();\n            \n            try {\n              // get the job status\n              long start \u003d System.currentTimeMillis();\n              JobStatus status \u003d job.getStatus(); // cache the job status\n              long end \u003d System.currentTimeMillis();\n              \n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Status polling for job \" + job.getJobID() + \" took \"\n                          + (end-start) + \"ms.\");\n              }\n              \n              // update the job progress\n              jobStats.updateJobStatus(status);\n              \n              // if the job is complete, let others know\n              if (status.isJobComplete()) {\n                if (status.getState() \u003d\u003d JobStatus.State.SUCCEEDED) {\n                  onSuccess(job);\n                } else {\n                  onFailure(job);\n                }\n                synchronized (statistics) {\n                  statistics.add(jobStats);\n                }\n              } else {\n                // add the running job back and break\n                synchronized (mJobs) {\n                  if (!mJobs.offer(jobStats)) {\n                    LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                         ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                             // happen\n                  }\n                }\n                break;\n              }\n            } catch (IOException e) {\n              if (e.getCause() instanceof ClosedByInterruptException) {\n                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                // is blocking and may throw a wrapped Exception if this thread\n                // is interrupted. Since the lower level cleared the flag,\n                // reset it here\n                Thread.currentThread().interrupt();\n              } else {\n                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                synchronized (statistics) {\n                  statistics.add(jobStats);\n                }\n              }\n            }\n            \n            // get the next job\n            synchronized (mJobs) {\n              jobStats \u003d mJobs.poll();\n            }\n          }\n          \n          // sleep for a while before checking again\n          try {\n            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n          } catch (InterruptedException e) {\n            shutdown \u003d true;\n            continue;\n          }\n        } catch (Throwable e) {\n          LOG.warn(\"Unexpected exception: \", e);\n        }\n      }\n    }",
      "path": "hadoop-tools/hadoop-gridmix/src/main/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
        "newPath": "hadoop-tools/hadoop-gridmix/src/main/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java"
      }
    },
    "8a2073cc61699f5692fcf638f4bae4d1c544870a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3787. [Gridmix] Optimize job monitoring and STRESS mode for faster job submission. (amarrk)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1292736 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/02/12 2:41 AM",
      "commitName": "8a2073cc61699f5692fcf638f4bae4d1c544870a",
      "commitAuthor": "Amar Kamat",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 182.44,
      "commitsBetweenForRepo": 1146,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,110 @@\n     public void run() {\n       boolean graceful;\n       boolean shutdown;\n       while (true) {\n         try {\n-          synchronized (mJobs) {\n-            graceful \u003d JobMonitor.this.graceful;\n-            shutdown \u003d JobMonitor.this.shutdown;\n-            runningJobs.drainTo(mJobs);\n+          synchronized (runningJobs) {\n+            synchronized (mJobs) {\n+              graceful \u003d JobMonitor.this.graceful;\n+              shutdown \u003d JobMonitor.this.shutdown;\n+              runningJobs.drainTo(mJobs);\n+            }\n           }\n \n           // shutdown conditions; either shutdown requested and all jobs\n           // have completed or abort requested and there are recently\n           // submitted jobs not in the monitored set\n           if (shutdown) {\n             if (!graceful) {\n-              while (!runningJobs.isEmpty()) {\n-                synchronized (mJobs) {\n-                  runningJobs.drainTo(mJobs);\n+              synchronized (runningJobs) {\n+                while (!runningJobs.isEmpty()) {\n+                  synchronized (mJobs) {\n+                    runningJobs.drainTo(mJobs);\n+                  }\n                 }\n               }\n               break;\n-            } else if (mJobs.isEmpty()) {\n-              break;\n+            }\n+            \n+            synchronized (mJobs) {\n+              if (graceful \u0026\u0026 mJobs.isEmpty()) {\n+                break;\n+              }\n             }\n           }\n-          while (!mJobs.isEmpty()) {\n-            Job job;\n-            synchronized (mJobs) {\n-              job \u003d mJobs.poll();\n-            }\n+          JobStats jobStats \u003d null;\n+          synchronized (mJobs) {\n+            jobStats \u003d mJobs.poll();\n+          }\n+          while (jobStats !\u003d null) {\n+            Job job \u003d jobStats.getJob();\n+            \n             try {\n-              if (job.isComplete()) {\n-                process(job);\n-                statistics.add(job);\n-                continue;\n+              // get the job status\n+              long start \u003d System.currentTimeMillis();\n+              JobStatus status \u003d job.getStatus(); // cache the job status\n+              long end \u003d System.currentTimeMillis();\n+              \n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Status polling for job \" + job.getJobID() + \" took \"\n+                          + (end-start) + \"ms.\");\n+              }\n+              \n+              // update the job progress\n+              jobStats.updateJobStatus(status);\n+              \n+              // if the job is complete, let others know\n+              if (status.isJobComplete()) {\n+                if (status.getState() \u003d\u003d JobStatus.State.SUCCEEDED) {\n+                  onSuccess(job);\n+                } else {\n+                  onFailure(job);\n+                }\n+                synchronized (statistics) {\n+                  statistics.add(jobStats);\n+                }\n+              } else {\n+                // add the running job back and break\n+                synchronized (mJobs) {\n+                  if (!mJobs.offer(jobStats)) {\n+                    LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n+                         ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n+                                                             // happen\n+                  }\n+                }\n+                break;\n               }\n             } catch (IOException e) {\n               if (e.getCause() instanceof ClosedByInterruptException) {\n                 // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                 // is blocking and may throw a wrapped Exception if this thread\n                 // is interrupted. Since the lower level cleared the flag,\n                 // reset it here\n                 Thread.currentThread().interrupt();\n               } else {\n                 LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                      ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n-                continue;\n+                synchronized (statistics) {\n+                  statistics.add(jobStats);\n+                }\n               }\n             }\n+            \n+            // get the next job\n             synchronized (mJobs) {\n-              if (!mJobs.offer(job)) {\n-                LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n-                     ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n-                                                         // happen\n-              }\n+              jobStats \u003d mJobs.poll();\n             }\n-            break;\n           }\n+          \n+          // sleep for a while before checking again\n           try {\n             TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n           } catch (InterruptedException e) {\n             shutdown \u003d true;\n             continue;\n           }\n         } catch (Throwable e) {\n           LOG.warn(\"Unexpected exception: \", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      boolean graceful;\n      boolean shutdown;\n      while (true) {\n        try {\n          synchronized (runningJobs) {\n            synchronized (mJobs) {\n              graceful \u003d JobMonitor.this.graceful;\n              shutdown \u003d JobMonitor.this.shutdown;\n              runningJobs.drainTo(mJobs);\n            }\n          }\n\n          // shutdown conditions; either shutdown requested and all jobs\n          // have completed or abort requested and there are recently\n          // submitted jobs not in the monitored set\n          if (shutdown) {\n            if (!graceful) {\n              synchronized (runningJobs) {\n                while (!runningJobs.isEmpty()) {\n                  synchronized (mJobs) {\n                    runningJobs.drainTo(mJobs);\n                  }\n                }\n              }\n              break;\n            }\n            \n            synchronized (mJobs) {\n              if (graceful \u0026\u0026 mJobs.isEmpty()) {\n                break;\n              }\n            }\n          }\n          JobStats jobStats \u003d null;\n          synchronized (mJobs) {\n            jobStats \u003d mJobs.poll();\n          }\n          while (jobStats !\u003d null) {\n            Job job \u003d jobStats.getJob();\n            \n            try {\n              // get the job status\n              long start \u003d System.currentTimeMillis();\n              JobStatus status \u003d job.getStatus(); // cache the job status\n              long end \u003d System.currentTimeMillis();\n              \n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Status polling for job \" + job.getJobID() + \" took \"\n                          + (end-start) + \"ms.\");\n              }\n              \n              // update the job progress\n              jobStats.updateJobStatus(status);\n              \n              // if the job is complete, let others know\n              if (status.isJobComplete()) {\n                if (status.getState() \u003d\u003d JobStatus.State.SUCCEEDED) {\n                  onSuccess(job);\n                } else {\n                  onFailure(job);\n                }\n                synchronized (statistics) {\n                  statistics.add(jobStats);\n                }\n              } else {\n                // add the running job back and break\n                synchronized (mJobs) {\n                  if (!mJobs.offer(jobStats)) {\n                    LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                         ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                             // happen\n                  }\n                }\n                break;\n              }\n            } catch (IOException e) {\n              if (e.getCause() instanceof ClosedByInterruptException) {\n                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                // is blocking and may throw a wrapped Exception if this thread\n                // is interrupted. Since the lower level cleared the flag,\n                // reset it here\n                Thread.currentThread().interrupt();\n              } else {\n                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                synchronized (statistics) {\n                  statistics.add(jobStats);\n                }\n              }\n            }\n            \n            // get the next job\n            synchronized (mJobs) {\n              jobStats \u003d mJobs.poll();\n            }\n          }\n          \n          // sleep for a while before checking again\n          try {\n            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n          } catch (InterruptedException e) {\n            shutdown \u003d true;\n            continue;\n          }\n        } catch (Throwable e) {\n          LOG.warn(\"Unexpected exception: \", e);\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      boolean graceful;\n      boolean shutdown;\n      while (true) {\n        try {\n          synchronized (mJobs) {\n            graceful \u003d JobMonitor.this.graceful;\n            shutdown \u003d JobMonitor.this.shutdown;\n            runningJobs.drainTo(mJobs);\n          }\n\n          // shutdown conditions; either shutdown requested and all jobs\n          // have completed or abort requested and there are recently\n          // submitted jobs not in the monitored set\n          if (shutdown) {\n            if (!graceful) {\n              while (!runningJobs.isEmpty()) {\n                synchronized (mJobs) {\n                  runningJobs.drainTo(mJobs);\n                }\n              }\n              break;\n            } else if (mJobs.isEmpty()) {\n              break;\n            }\n          }\n          while (!mJobs.isEmpty()) {\n            Job job;\n            synchronized (mJobs) {\n              job \u003d mJobs.poll();\n            }\n            try {\n              if (job.isComplete()) {\n                process(job);\n                statistics.add(job);\n                continue;\n              }\n            } catch (IOException e) {\n              if (e.getCause() instanceof ClosedByInterruptException) {\n                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                // is blocking and may throw a wrapped Exception if this thread\n                // is interrupted. Since the lower level cleared the flag,\n                // reset it here\n                Thread.currentThread().interrupt();\n              } else {\n                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                continue;\n              }\n            }\n            synchronized (mJobs) {\n              if (!mJobs.offer(job)) {\n                LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                         // happen\n              }\n            }\n            break;\n          }\n          try {\n            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n          } catch (InterruptedException e) {\n            shutdown \u003d true;\n            continue;\n          }\n        } catch (Throwable e) {\n          LOG.warn(\"Unexpected exception: \", e);\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
        "newPath": "hadoop-mapreduce-project/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      boolean graceful;\n      boolean shutdown;\n      while (true) {\n        try {\n          synchronized (mJobs) {\n            graceful \u003d JobMonitor.this.graceful;\n            shutdown \u003d JobMonitor.this.shutdown;\n            runningJobs.drainTo(mJobs);\n          }\n\n          // shutdown conditions; either shutdown requested and all jobs\n          // have completed or abort requested and there are recently\n          // submitted jobs not in the monitored set\n          if (shutdown) {\n            if (!graceful) {\n              while (!runningJobs.isEmpty()) {\n                synchronized (mJobs) {\n                  runningJobs.drainTo(mJobs);\n                }\n              }\n              break;\n            } else if (mJobs.isEmpty()) {\n              break;\n            }\n          }\n          while (!mJobs.isEmpty()) {\n            Job job;\n            synchronized (mJobs) {\n              job \u003d mJobs.poll();\n            }\n            try {\n              if (job.isComplete()) {\n                process(job);\n                statistics.add(job);\n                continue;\n              }\n            } catch (IOException e) {\n              if (e.getCause() instanceof ClosedByInterruptException) {\n                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                // is blocking and may throw a wrapped Exception if this thread\n                // is interrupted. Since the lower level cleared the flag,\n                // reset it here\n                Thread.currentThread().interrupt();\n              } else {\n                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                continue;\n              }\n            }\n            synchronized (mJobs) {\n              if (!mJobs.offer(job)) {\n                LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                         // happen\n              }\n            }\n            break;\n          }\n          try {\n            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n          } catch (InterruptedException e) {\n            shutdown \u003d true;\n            continue;\n          }\n        } catch (Throwable e) {\n          LOG.warn(\"Unexpected exception: \", e);\n        }\n      }\n    }",
      "path": "hadoop-mapreduce/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java",
        "newPath": "hadoop-mapreduce/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,70 @@\n+    public void run() {\n+      boolean graceful;\n+      boolean shutdown;\n+      while (true) {\n+        try {\n+          synchronized (mJobs) {\n+            graceful \u003d JobMonitor.this.graceful;\n+            shutdown \u003d JobMonitor.this.shutdown;\n+            runningJobs.drainTo(mJobs);\n+          }\n+\n+          // shutdown conditions; either shutdown requested and all jobs\n+          // have completed or abort requested and there are recently\n+          // submitted jobs not in the monitored set\n+          if (shutdown) {\n+            if (!graceful) {\n+              while (!runningJobs.isEmpty()) {\n+                synchronized (mJobs) {\n+                  runningJobs.drainTo(mJobs);\n+                }\n+              }\n+              break;\n+            } else if (mJobs.isEmpty()) {\n+              break;\n+            }\n+          }\n+          while (!mJobs.isEmpty()) {\n+            Job job;\n+            synchronized (mJobs) {\n+              job \u003d mJobs.poll();\n+            }\n+            try {\n+              if (job.isComplete()) {\n+                process(job);\n+                statistics.add(job);\n+                continue;\n+              }\n+            } catch (IOException e) {\n+              if (e.getCause() instanceof ClosedByInterruptException) {\n+                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n+                // is blocking and may throw a wrapped Exception if this thread\n+                // is interrupted. Since the lower level cleared the flag,\n+                // reset it here\n+                Thread.currentThread().interrupt();\n+              } else {\n+                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n+                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n+                continue;\n+              }\n+            }\n+            synchronized (mJobs) {\n+              if (!mJobs.offer(job)) {\n+                LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n+                     ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n+                                                         // happen\n+              }\n+            }\n+            break;\n+          }\n+          try {\n+            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n+          } catch (InterruptedException e) {\n+            shutdown \u003d true;\n+            continue;\n+          }\n+        } catch (Throwable e) {\n+          LOG.warn(\"Unexpected exception: \", e);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      boolean graceful;\n      boolean shutdown;\n      while (true) {\n        try {\n          synchronized (mJobs) {\n            graceful \u003d JobMonitor.this.graceful;\n            shutdown \u003d JobMonitor.this.shutdown;\n            runningJobs.drainTo(mJobs);\n          }\n\n          // shutdown conditions; either shutdown requested and all jobs\n          // have completed or abort requested and there are recently\n          // submitted jobs not in the monitored set\n          if (shutdown) {\n            if (!graceful) {\n              while (!runningJobs.isEmpty()) {\n                synchronized (mJobs) {\n                  runningJobs.drainTo(mJobs);\n                }\n              }\n              break;\n            } else if (mJobs.isEmpty()) {\n              break;\n            }\n          }\n          while (!mJobs.isEmpty()) {\n            Job job;\n            synchronized (mJobs) {\n              job \u003d mJobs.poll();\n            }\n            try {\n              if (job.isComplete()) {\n                process(job);\n                statistics.add(job);\n                continue;\n              }\n            } catch (IOException e) {\n              if (e.getCause() instanceof ClosedByInterruptException) {\n                // Job doesn\u0027t throw InterruptedException, but RPC socket layer\n                // is blocking and may throw a wrapped Exception if this thread\n                // is interrupted. Since the lower level cleared the flag,\n                // reset it here\n                Thread.currentThread().interrupt();\n              } else {\n                LOG.warn(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName()), e);\n                continue;\n              }\n            }\n            synchronized (mJobs) {\n              if (!mJobs.offer(job)) {\n                LOG.error(\"Lost job \" + (null \u003d\u003d job.getJobName()\n                     ? \"\u003cunknown\u003e\" : job.getJobName())); // should never\n                                                         // happen\n              }\n            }\n            break;\n          }\n          try {\n            TimeUnit.MILLISECONDS.sleep(pollDelayMillis);\n          } catch (InterruptedException e) {\n            shutdown \u003d true;\n            continue;\n          }\n        } catch (Throwable e) {\n          LOG.warn(\"Unexpected exception: \", e);\n        }\n      }\n    }",
      "path": "mapreduce/src/contrib/gridmix/src/java/org/apache/hadoop/mapred/gridmix/JobMonitor.java"
    }
  }
}