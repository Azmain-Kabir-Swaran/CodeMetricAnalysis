{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReconfigurableBase.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
  "functionStartLine": 114,
  "functionEndLine": 160,
  "numCommitsSeen": 12,
  "timeTaken": 2983,
  "changeHistory": [
    "10311c30b02d984a11f2cedfd06eb2a766ad1576",
    "f66ad1fab958a28ef40c684366c23695237a8e60",
    "4b689e7a758a55cec2ca8398727feefc8ac21bfd",
    "1de1641f17f890059e85e57304ce33c7070a08de",
    "d112d183242f447d4b742139f3a4ea531a997f45",
    "f636f9d9439742d7ebaaf21f7e22652403572c61",
    "b3d5d269a73a1826ebf6f637a0dbd69f6261dbcb",
    "1861b32eb551a07d748afc6205ea9573f9503eda"
  ],
  "changeHistoryShort": {
    "10311c30b02d984a11f2cedfd06eb2a766ad1576": "Ybodychange",
    "f66ad1fab958a28ef40c684366c23695237a8e60": "Ybodychange",
    "4b689e7a758a55cec2ca8398727feefc8ac21bfd": "Ybodychange",
    "1de1641f17f890059e85e57304ce33c7070a08de": "Ybodychange",
    "d112d183242f447d4b742139f3a4ea531a997f45": "Ybodychange",
    "f636f9d9439742d7ebaaf21f7e22652403572c61": "Ybodychange",
    "b3d5d269a73a1826ebf6f637a0dbd69f6261dbcb": "Ybodychange",
    "1861b32eb551a07d748afc6205ea9573f9503eda": "Yintroduced"
  },
  "changeHistoryDetails": {
    "10311c30b02d984a11f2cedfd06eb2a766ad1576": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14807. should prevent the possibility of NPE about ReconfigurableBase.java. Contributed by hu xiaodong.\n",
      "commitDate": "17/06/19 7:55 PM",
      "commitName": "10311c30b02d984a11f2cedfd06eb2a766ad1576",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "02/01/18 5:22 PM",
      "commitNameOld": "d82874851ea98caeb0ef5c23b7bc5d6fc14145ba",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 531.06,
      "commitsBetweenForRepo": 4491,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,47 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n       final Configuration oldConf \u003d parent.getConf();\n       final Configuration newConf \u003d parent.getNewConf();\n       final Collection\u003cPropertyChange\u003e changes \u003d\n           parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n       ConfigRedactor oldRedactor \u003d new ConfigRedactor(oldConf);\n       ConfigRedactor newRedactor \u003d new ConfigRedactor(newConf);\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n         String oldValRedacted \u003d oldRedactor.redact(change.prop, change.oldVal);\n         String newValRedacted \u003d newRedactor.redact(change.prop, change.newVal);\n         if (!parent.isPropertyReconfigurable(change.prop)) {\n           LOG.info(String.format(\n               \"Property %s is not configurable: old value: %s, new value: %s\",\n               change.prop,\n               oldValRedacted,\n               newValRedacted));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n             + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : oldValRedacted)\n             + \"\\\" to \\\"\"\n             + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : newValRedacted)\n             + \"\\\".\");\n         try {\n           String effectiveValue \u003d\n               parent.reconfigurePropertyImpl(change.prop, change.newVal);\n           if (change.newVal !\u003d null) {\n             oldConf.set(change.prop, effectiveValue);\n           } else {\n             oldConf.unset(change.prop);\n           }\n         } catch (ReconfigurationException e) {\n-          errorMessage \u003d e.getCause().getMessage();\n+          Throwable cause \u003d e.getCause();\n+          errorMessage \u003d cause \u003d\u003d null ? e.getMessage() : cause.getMessage();\n         }\n         results.put(change, Optional.ofNullable(errorMessage));\n       }\n \n       synchronized (parent.reconfigLock) {\n         parent.endTime \u003d Time.now();\n         parent.status \u003d Collections.unmodifiableMap(results);\n         parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      final Configuration oldConf \u003d parent.getConf();\n      final Configuration newConf \u003d parent.getNewConf();\n      final Collection\u003cPropertyChange\u003e changes \u003d\n          parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      ConfigRedactor oldRedactor \u003d new ConfigRedactor(oldConf);\n      ConfigRedactor newRedactor \u003d new ConfigRedactor(newConf);\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        String oldValRedacted \u003d oldRedactor.redact(change.prop, change.oldVal);\n        String newValRedacted \u003d newRedactor.redact(change.prop, change.newVal);\n        if (!parent.isPropertyReconfigurable(change.prop)) {\n          LOG.info(String.format(\n              \"Property %s is not configurable: old value: %s, new value: %s\",\n              change.prop,\n              oldValRedacted,\n              newValRedacted));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : oldValRedacted)\n            + \"\\\" to \\\"\"\n            + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : newValRedacted)\n            + \"\\\".\");\n        try {\n          String effectiveValue \u003d\n              parent.reconfigurePropertyImpl(change.prop, change.newVal);\n          if (change.newVal !\u003d null) {\n            oldConf.set(change.prop, effectiveValue);\n          } else {\n            oldConf.unset(change.prop);\n          }\n        } catch (ReconfigurationException e) {\n          Throwable cause \u003d e.getCause();\n          errorMessage \u003d cause \u003d\u003d null ? e.getMessage() : cause.getMessage();\n        }\n        results.put(change, Optional.ofNullable(errorMessage));\n      }\n\n      synchronized (parent.reconfigLock) {\n        parent.endTime \u003d Time.now();\n        parent.status \u003d Collections.unmodifiableMap(results);\n        parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "f66ad1fab958a28ef40c684366c23695237a8e60": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14957. ReconfigurationTaskStatus is exposing guava Optional in its public api. Contributed by Haibo Chen, Xiao Chen.\n",
      "commitDate": "25/10/17 2:11 PM",
      "commitName": "f66ad1fab958a28ef40c684366c23695237a8e60",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 99.69,
      "commitsBetweenForRepo": 835,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n       final Configuration oldConf \u003d parent.getConf();\n       final Configuration newConf \u003d parent.getNewConf();\n       final Collection\u003cPropertyChange\u003e changes \u003d\n           parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n       ConfigRedactor oldRedactor \u003d new ConfigRedactor(oldConf);\n       ConfigRedactor newRedactor \u003d new ConfigRedactor(newConf);\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n         String oldValRedacted \u003d oldRedactor.redact(change.prop, change.oldVal);\n         String newValRedacted \u003d newRedactor.redact(change.prop, change.newVal);\n         if (!parent.isPropertyReconfigurable(change.prop)) {\n           LOG.info(String.format(\n               \"Property %s is not configurable: old value: %s, new value: %s\",\n               change.prop,\n               oldValRedacted,\n               newValRedacted));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n             + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : oldValRedacted)\n             + \"\\\" to \\\"\"\n             + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : newValRedacted)\n             + \"\\\".\");\n         try {\n           String effectiveValue \u003d\n               parent.reconfigurePropertyImpl(change.prop, change.newVal);\n           if (change.newVal !\u003d null) {\n             oldConf.set(change.prop, effectiveValue);\n           } else {\n             oldConf.unset(change.prop);\n           }\n         } catch (ReconfigurationException e) {\n           errorMessage \u003d e.getCause().getMessage();\n         }\n-        results.put(change, Optional.fromNullable(errorMessage));\n+        results.put(change, Optional.ofNullable(errorMessage));\n       }\n \n       synchronized (parent.reconfigLock) {\n         parent.endTime \u003d Time.now();\n         parent.status \u003d Collections.unmodifiableMap(results);\n         parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      final Configuration oldConf \u003d parent.getConf();\n      final Configuration newConf \u003d parent.getNewConf();\n      final Collection\u003cPropertyChange\u003e changes \u003d\n          parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      ConfigRedactor oldRedactor \u003d new ConfigRedactor(oldConf);\n      ConfigRedactor newRedactor \u003d new ConfigRedactor(newConf);\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        String oldValRedacted \u003d oldRedactor.redact(change.prop, change.oldVal);\n        String newValRedacted \u003d newRedactor.redact(change.prop, change.newVal);\n        if (!parent.isPropertyReconfigurable(change.prop)) {\n          LOG.info(String.format(\n              \"Property %s is not configurable: old value: %s, new value: %s\",\n              change.prop,\n              oldValRedacted,\n              newValRedacted));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : oldValRedacted)\n            + \"\\\" to \\\"\"\n            + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : newValRedacted)\n            + \"\\\".\");\n        try {\n          String effectiveValue \u003d\n              parent.reconfigurePropertyImpl(change.prop, change.newVal);\n          if (change.newVal !\u003d null) {\n            oldConf.set(change.prop, effectiveValue);\n          } else {\n            oldConf.unset(change.prop);\n          }\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.getCause().getMessage();\n        }\n        results.put(change, Optional.ofNullable(errorMessage));\n      }\n\n      synchronized (parent.reconfigLock) {\n        parent.endTime \u003d Time.now();\n        parent.status \u003d Collections.unmodifiableMap(results);\n        parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "4b689e7a758a55cec2ca8398727feefc8ac21bfd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13494. ReconfigurableBase can log sensitive information. Contributed by Sean Mackrory.\n",
      "commitDate": "16/08/16 3:01 PM",
      "commitName": "4b689e7a758a55cec2ca8398727feefc8ac21bfd",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "12/02/16 12:41 PM",
      "commitNameOld": "1de1641f17f890059e85e57304ce33c7070a08de",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 186.06,
      "commitsBetweenForRepo": 1325,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,46 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n       final Configuration oldConf \u003d parent.getConf();\n       final Configuration newConf \u003d parent.getNewConf();\n       final Collection\u003cPropertyChange\u003e changes \u003d\n           parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n+      ConfigRedactor oldRedactor \u003d new ConfigRedactor(oldConf);\n+      ConfigRedactor newRedactor \u003d new ConfigRedactor(newConf);\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n+        String oldValRedacted \u003d oldRedactor.redact(change.prop, change.oldVal);\n+        String newValRedacted \u003d newRedactor.redact(change.prop, change.newVal);\n         if (!parent.isPropertyReconfigurable(change.prop)) {\n           LOG.info(String.format(\n               \"Property %s is not configurable: old value: %s, new value: %s\",\n-              change.prop, change.oldVal, change.newVal));\n+              change.prop,\n+              oldValRedacted,\n+              newValRedacted));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n-            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n-            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n+            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : oldValRedacted)\n+            + \"\\\" to \\\"\"\n+            + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : newValRedacted)\n             + \"\\\".\");\n         try {\n           String effectiveValue \u003d\n               parent.reconfigurePropertyImpl(change.prop, change.newVal);\n           if (change.newVal !\u003d null) {\n             oldConf.set(change.prop, effectiveValue);\n           } else {\n             oldConf.unset(change.prop);\n           }\n         } catch (ReconfigurationException e) {\n           errorMessage \u003d e.getCause().getMessage();\n         }\n         results.put(change, Optional.fromNullable(errorMessage));\n       }\n \n       synchronized (parent.reconfigLock) {\n         parent.endTime \u003d Time.now();\n         parent.status \u003d Collections.unmodifiableMap(results);\n         parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      final Configuration oldConf \u003d parent.getConf();\n      final Configuration newConf \u003d parent.getNewConf();\n      final Collection\u003cPropertyChange\u003e changes \u003d\n          parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      ConfigRedactor oldRedactor \u003d new ConfigRedactor(oldConf);\n      ConfigRedactor newRedactor \u003d new ConfigRedactor(newConf);\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        String oldValRedacted \u003d oldRedactor.redact(change.prop, change.oldVal);\n        String newValRedacted \u003d newRedactor.redact(change.prop, change.newVal);\n        if (!parent.isPropertyReconfigurable(change.prop)) {\n          LOG.info(String.format(\n              \"Property %s is not configurable: old value: %s, new value: %s\",\n              change.prop,\n              oldValRedacted,\n              newValRedacted));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : oldValRedacted)\n            + \"\\\" to \\\"\"\n            + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : newValRedacted)\n            + \"\\\".\");\n        try {\n          String effectiveValue \u003d\n              parent.reconfigurePropertyImpl(change.prop, change.newVal);\n          if (change.newVal !\u003d null) {\n            oldConf.set(change.prop, effectiveValue);\n          } else {\n            oldConf.unset(change.prop);\n          }\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.getCause().getMessage();\n        }\n        results.put(change, Optional.fromNullable(errorMessage));\n      }\n\n      synchronized (parent.reconfigLock) {\n        parent.endTime \u003d Time.now();\n        parent.status \u003d Collections.unmodifiableMap(results);\n        parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "1de1641f17f890059e85e57304ce33c7070a08de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9801. ReconfigurableBase should update the cached configuration. (Arpit Agarwal)\n",
      "commitDate": "12/02/16 12:41 PM",
      "commitName": "1de1641f17f890059e85e57304ce33c7070a08de",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "19/06/15 7:14 PM",
      "commitNameOld": "d112d183242f447d4b742139f3a4ea531a997f45",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 237.77,
      "commitsBetweenForRepo": 1609,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,39 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n-      Configuration oldConf \u003d this.parent.getConf();\n-      Configuration newConf \u003d this.parent.getNewConf();\n-      Collection\u003cPropertyChange\u003e changes \u003d\n-          this.parent.getChangedProperties(newConf, oldConf);\n+      final Configuration oldConf \u003d parent.getConf();\n+      final Configuration newConf \u003d parent.getNewConf();\n+      final Collection\u003cPropertyChange\u003e changes \u003d\n+          parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n-        if (!this.parent.isPropertyReconfigurable(change.prop)) {\n+        if (!parent.isPropertyReconfigurable(change.prop)) {\n           LOG.info(String.format(\n               \"Property %s is not configurable: old value: %s, new value: %s\",\n               change.prop, change.oldVal, change.newVal));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n             + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n             + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n             + \"\\\".\");\n         try {\n-          this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n+          String effectiveValue \u003d\n+              parent.reconfigurePropertyImpl(change.prop, change.newVal);\n+          if (change.newVal !\u003d null) {\n+            oldConf.set(change.prop, effectiveValue);\n+          } else {\n+            oldConf.unset(change.prop);\n+          }\n         } catch (ReconfigurationException e) {\n           errorMessage \u003d e.getCause().getMessage();\n         }\n         results.put(change, Optional.fromNullable(errorMessage));\n       }\n \n-      synchronized (this.parent.reconfigLock) {\n-        this.parent.endTime \u003d Time.now();\n-        this.parent.status \u003d Collections.unmodifiableMap(results);\n-        this.parent.reconfigThread \u003d null;\n+      synchronized (parent.reconfigLock) {\n+        parent.endTime \u003d Time.now();\n+        parent.status \u003d Collections.unmodifiableMap(results);\n+        parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      final Configuration oldConf \u003d parent.getConf();\n      final Configuration newConf \u003d parent.getNewConf();\n      final Collection\u003cPropertyChange\u003e changes \u003d\n          parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        if (!parent.isPropertyReconfigurable(change.prop)) {\n          LOG.info(String.format(\n              \"Property %s is not configurable: old value: %s, new value: %s\",\n              change.prop, change.oldVal, change.newVal));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n            + \"\\\".\");\n        try {\n          String effectiveValue \u003d\n              parent.reconfigurePropertyImpl(change.prop, change.newVal);\n          if (change.newVal !\u003d null) {\n            oldConf.set(change.prop, effectiveValue);\n          } else {\n            oldConf.unset(change.prop);\n          }\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.getCause().getMessage();\n        }\n        results.put(change, Optional.fromNullable(errorMessage));\n      }\n\n      synchronized (parent.reconfigLock) {\n        parent.endTime \u003d Time.now();\n        parent.status \u003d Collections.unmodifiableMap(results);\n        parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "d112d183242f447d4b742139f3a4ea531a997f45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8582. Support getting a list of reconfigurable config properties and do not generate spurious reconfig warnings (Lei (Eddy) Xu via Colin P.  McCabe)\n",
      "commitDate": "19/06/15 7:14 PM",
      "commitName": "d112d183242f447d4b742139f3a4ea531a997f45",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "24/11/14 10:55 AM",
      "commitNameOld": "f636f9d9439742d7ebaaf21f7e22652403572c61",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 207.3,
      "commitsBetweenForRepo": 1705,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,33 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n       Configuration oldConf \u003d this.parent.getConf();\n-      Configuration newConf \u003d new Configuration();\n+      Configuration newConf \u003d this.parent.getNewConf();\n       Collection\u003cPropertyChange\u003e changes \u003d\n           this.parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n         if (!this.parent.isPropertyReconfigurable(change.prop)) {\n-          errorMessage \u003d \"Property \" + change.prop +\n-              \" is not reconfigurable\";\n-          LOG.info(errorMessage);\n-          results.put(change, Optional.of(errorMessage));\n+          LOG.info(String.format(\n+              \"Property %s is not configurable: old value: %s, new value: %s\",\n+              change.prop, change.oldVal, change.newVal));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n             + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n             + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n             + \"\\\".\");\n         try {\n           this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n         } catch (ReconfigurationException e) {\n           errorMessage \u003d e.getCause().getMessage();\n         }\n         results.put(change, Optional.fromNullable(errorMessage));\n       }\n \n       synchronized (this.parent.reconfigLock) {\n         this.parent.endTime \u003d Time.now();\n         this.parent.status \u003d Collections.unmodifiableMap(results);\n         this.parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      Configuration oldConf \u003d this.parent.getConf();\n      Configuration newConf \u003d this.parent.getNewConf();\n      Collection\u003cPropertyChange\u003e changes \u003d\n          this.parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        if (!this.parent.isPropertyReconfigurable(change.prop)) {\n          LOG.info(String.format(\n              \"Property %s is not configurable: old value: %s, new value: %s\",\n              change.prop, change.oldVal, change.newVal));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n            + \"\\\".\");\n        try {\n          this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.getCause().getMessage();\n        }\n        results.put(change, Optional.fromNullable(errorMessage));\n      }\n\n      synchronized (this.parent.reconfigLock) {\n        this.parent.endTime \u003d Time.now();\n        this.parent.status \u003d Collections.unmodifiableMap(results);\n        this.parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "f636f9d9439742d7ebaaf21f7e22652403572c61": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7419. Improve error messages for DataNode hot swap drive feature (Lei Xu via Colin P. Mccabe)\n",
      "commitDate": "24/11/14 10:55 AM",
      "commitName": "f636f9d9439742d7ebaaf21f7e22652403572c61",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "29/09/14 11:29 AM",
      "commitNameOld": "b3d5d269a73a1826ebf6f637a0dbd69f6261dbcb",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 56.02,
      "commitsBetweenForRepo": 509,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n       Configuration oldConf \u003d this.parent.getConf();\n       Configuration newConf \u003d new Configuration();\n       Collection\u003cPropertyChange\u003e changes \u003d\n           this.parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n         if (!this.parent.isPropertyReconfigurable(change.prop)) {\n           errorMessage \u003d \"Property \" + change.prop +\n               \" is not reconfigurable\";\n           LOG.info(errorMessage);\n           results.put(change, Optional.of(errorMessage));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n             + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n             + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n             + \"\\\".\");\n         try {\n           this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n         } catch (ReconfigurationException e) {\n-          errorMessage \u003d e.toString();\n+          errorMessage \u003d e.getCause().getMessage();\n         }\n         results.put(change, Optional.fromNullable(errorMessage));\n       }\n \n       synchronized (this.parent.reconfigLock) {\n         this.parent.endTime \u003d Time.now();\n         this.parent.status \u003d Collections.unmodifiableMap(results);\n         this.parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      Configuration oldConf \u003d this.parent.getConf();\n      Configuration newConf \u003d new Configuration();\n      Collection\u003cPropertyChange\u003e changes \u003d\n          this.parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        if (!this.parent.isPropertyReconfigurable(change.prop)) {\n          errorMessage \u003d \"Property \" + change.prop +\n              \" is not reconfigurable\";\n          LOG.info(errorMessage);\n          results.put(change, Optional.of(errorMessage));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n            + \"\\\".\");\n        try {\n          this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.getCause().getMessage();\n        }\n        results.put(change, Optional.fromNullable(errorMessage));\n      }\n\n      synchronized (this.parent.reconfigLock) {\n        this.parent.endTime \u003d Time.now();\n        this.parent.status \u003d Collections.unmodifiableMap(results);\n        this.parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "b3d5d269a73a1826ebf6f637a0dbd69f6261dbcb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7157. Using Time.now() for recording start/end time of reconfiguration tasks (Lei Xu via Colin Patrick McCabe)\n",
      "commitDate": "29/09/14 11:29 AM",
      "commitName": "b3d5d269a73a1826ebf6f637a0dbd69f6261dbcb",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "25/09/14 1:11 PM",
      "commitNameOld": "1861b32eb551a07d748afc6205ea9573f9503eda",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 3.93,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     public void run() {\n       LOG.info(\"Starting reconfiguration task.\");\n       Configuration oldConf \u003d this.parent.getConf();\n       Configuration newConf \u003d new Configuration();\n       Collection\u003cPropertyChange\u003e changes \u003d\n           this.parent.getChangedProperties(newConf, oldConf);\n       Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n       for (PropertyChange change : changes) {\n         String errorMessage \u003d null;\n         if (!this.parent.isPropertyReconfigurable(change.prop)) {\n           errorMessage \u003d \"Property \" + change.prop +\n               \" is not reconfigurable\";\n           LOG.info(errorMessage);\n           results.put(change, Optional.of(errorMessage));\n           continue;\n         }\n         LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n             + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n             + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n             + \"\\\".\");\n         try {\n           this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n         } catch (ReconfigurationException e) {\n           errorMessage \u003d e.toString();\n         }\n         results.put(change, Optional.fromNullable(errorMessage));\n       }\n \n       synchronized (this.parent.reconfigLock) {\n-        this.parent.endTime \u003d Time.monotonicNow();\n+        this.parent.endTime \u003d Time.now();\n         this.parent.status \u003d Collections.unmodifiableMap(results);\n         this.parent.reconfigThread \u003d null;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      Configuration oldConf \u003d this.parent.getConf();\n      Configuration newConf \u003d new Configuration();\n      Collection\u003cPropertyChange\u003e changes \u003d\n          this.parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        if (!this.parent.isPropertyReconfigurable(change.prop)) {\n          errorMessage \u003d \"Property \" + change.prop +\n              \" is not reconfigurable\";\n          LOG.info(errorMessage);\n          results.put(change, Optional.of(errorMessage));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n            + \"\\\".\");\n        try {\n          this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.toString();\n        }\n        results.put(change, Optional.fromNullable(errorMessage));\n      }\n\n      synchronized (this.parent.reconfigLock) {\n        this.parent.endTime \u003d Time.now();\n        this.parent.status \u003d Collections.unmodifiableMap(results);\n        this.parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java",
      "extendedDetails": {}
    },
    "1861b32eb551a07d748afc6205ea9573f9503eda": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6808. Add command line option to ask DataNode reload configuration. (Lei Xu via Colin McCabe)\n",
      "commitDate": "25/09/14 1:11 PM",
      "commitName": "1861b32eb551a07d748afc6205ea9573f9503eda",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,34 @@\n+    public void run() {\n+      LOG.info(\"Starting reconfiguration task.\");\n+      Configuration oldConf \u003d this.parent.getConf();\n+      Configuration newConf \u003d new Configuration();\n+      Collection\u003cPropertyChange\u003e changes \u003d\n+          this.parent.getChangedProperties(newConf, oldConf);\n+      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n+      for (PropertyChange change : changes) {\n+        String errorMessage \u003d null;\n+        if (!this.parent.isPropertyReconfigurable(change.prop)) {\n+          errorMessage \u003d \"Property \" + change.prop +\n+              \" is not reconfigurable\";\n+          LOG.info(errorMessage);\n+          results.put(change, Optional.of(errorMessage));\n+          continue;\n+        }\n+        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n+            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n+            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n+            + \"\\\".\");\n+        try {\n+          this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n+        } catch (ReconfigurationException e) {\n+          errorMessage \u003d e.toString();\n+        }\n+        results.put(change, Optional.fromNullable(errorMessage));\n+      }\n+\n+      synchronized (this.parent.reconfigLock) {\n+        this.parent.endTime \u003d Time.monotonicNow();\n+        this.parent.status \u003d Collections.unmodifiableMap(results);\n+        this.parent.reconfigThread \u003d null;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Starting reconfiguration task.\");\n      Configuration oldConf \u003d this.parent.getConf();\n      Configuration newConf \u003d new Configuration();\n      Collection\u003cPropertyChange\u003e changes \u003d\n          this.parent.getChangedProperties(newConf, oldConf);\n      Map\u003cPropertyChange, Optional\u003cString\u003e\u003e results \u003d Maps.newHashMap();\n      for (PropertyChange change : changes) {\n        String errorMessage \u003d null;\n        if (!this.parent.isPropertyReconfigurable(change.prop)) {\n          errorMessage \u003d \"Property \" + change.prop +\n              \" is not reconfigurable\";\n          LOG.info(errorMessage);\n          results.put(change, Optional.of(errorMessage));\n          continue;\n        }\n        LOG.info(\"Change property: \" + change.prop + \" from \\\"\"\n            + ((change.oldVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.oldVal)\n            + \"\\\" to \\\"\" + ((change.newVal \u003d\u003d null) ? \"\u003cdefault\u003e\" : change.newVal)\n            + \"\\\".\");\n        try {\n          this.parent.reconfigurePropertyImpl(change.prop, change.newVal);\n        } catch (ReconfigurationException e) {\n          errorMessage \u003d e.toString();\n        }\n        results.put(change, Optional.fromNullable(errorMessage));\n      }\n\n      synchronized (this.parent.reconfigLock) {\n        this.parent.endTime \u003d Time.monotonicNow();\n        this.parent.status \u003d Collections.unmodifiableMap(results);\n        this.parent.reconfigThread \u003d null;\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/ReconfigurableBase.java"
    }
  }
}