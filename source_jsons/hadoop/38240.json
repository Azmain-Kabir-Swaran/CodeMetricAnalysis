{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueuePriorityContainerCandidateSelector.java",
  "functionName": "initializePriorityDigraph",
  "functionId": "initializePriorityDigraph",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
  "functionStartLine": 120,
  "functionEndLine": 157,
  "numCommitsSeen": 12,
  "timeTaken": 3879,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
    "128d773a2315fa6baaa3a52b13c53c77e741b69c",
    "ce832059db077fa95922198b066a737ed4f609fe"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": "Yrename",
    "128d773a2315fa6baaa3a52b13c53c77e741b69c": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,38 @@\n   private void initializePriorityDigraph() {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Initializing priority preemption directed graph:\");\n-    }\n+    LOG.debug(\"Initializing priority preemption directed graph:\");\n     // Make sure we iterate all leaf queue combinations\n     for (String q1 : preemptionContext.getLeafQueueNames()) {\n       for (String q2 : preemptionContext.getLeafQueueNames()) {\n         // Make sure we only calculate each combination once instead of all\n         // permutations\n         if (q1.compareTo(q2) \u003c 0) {\n           TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n               RMNodeLabelsManager.NO_LABEL);\n           TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n               RMNodeLabelsManager.NO_LABEL);\n \n           List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n           List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n \n           // Get direct ancestor below LCA (Lowest common ancestor)\n           int i \u003d path1.size() - 1;\n           int j \u003d path2.size() - 1;\n           while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n             i--;\n             j--;\n           }\n \n           // compare priority of path1[i] and path2[j]\n           int p1 \u003d path1.get(i).relativePriority;\n           int p2 \u003d path2.get(j).relativePriority;\n           if (p1 \u003c p2) {\n             priorityDigraph.put(q2, q1, true);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n-            }\n+            LOG.debug(\"- Added priority ordering edge: {} \u003e\u003e {}\", q2, q1);\n           } else if (p2 \u003c p1) {\n             priorityDigraph.put(q1, q2, true);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n-            }\n+            LOG.debug(\"- Added priority ordering edge: {} \u003e\u003e {}\", q1, q2);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initializePriorityDigraph() {\n    LOG.debug(\"Initializing priority preemption directed graph:\");\n    // Make sure we iterate all leaf queue combinations\n    for (String q1 : preemptionContext.getLeafQueueNames()) {\n      for (String q2 : preemptionContext.getLeafQueueNames()) {\n        // Make sure we only calculate each combination once instead of all\n        // permutations\n        if (q1.compareTo(q2) \u003c 0) {\n          TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n              RMNodeLabelsManager.NO_LABEL);\n          TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n              RMNodeLabelsManager.NO_LABEL);\n\n          List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n          List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n\n          // Get direct ancestor below LCA (Lowest common ancestor)\n          int i \u003d path1.size() - 1;\n          int j \u003d path2.size() - 1;\n          while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n            i--;\n            j--;\n          }\n\n          // compare priority of path1[i] and path2[j]\n          int p1 \u003d path1.get(i).relativePriority;\n          int p2 \u003d path2.get(j).relativePriority;\n          if (p1 \u003c p2) {\n            priorityDigraph.put(q2, q1, true);\n            LOG.debug(\"- Added priority ordering edge: {} \u003e\u003e {}\", q2, q1);\n          } else if (p2 \u003c p1) {\n            priorityDigraph.put(q1, q2, true);\n            LOG.debug(\"- Added priority ordering edge: {} \u003e\u003e {}\", q1, q2);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {}
    },
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": {
      "type": "Yrename",
      "commitMessage": "HADOOP-15254. Correct the wrong word spelling \u0027intialize\u0027. Contributed by fang zhenyi.\n",
      "commitDate": "24/02/18 2:41 PM",
      "commitName": "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "12/01/18 2:11 AM",
      "commitNameOld": "128d773a2315fa6baaa3a52b13c53c77e741b69c",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 43.52,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n-  private void intializePriorityDigraph() {\n+  private void initializePriorityDigraph() {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Initializing priority preemption directed graph:\");\n     }\n     // Make sure we iterate all leaf queue combinations\n     for (String q1 : preemptionContext.getLeafQueueNames()) {\n       for (String q2 : preemptionContext.getLeafQueueNames()) {\n         // Make sure we only calculate each combination once instead of all\n         // permutations\n         if (q1.compareTo(q2) \u003c 0) {\n           TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n               RMNodeLabelsManager.NO_LABEL);\n           TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n               RMNodeLabelsManager.NO_LABEL);\n \n           List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n           List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n \n           // Get direct ancestor below LCA (Lowest common ancestor)\n           int i \u003d path1.size() - 1;\n           int j \u003d path2.size() - 1;\n           while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n             i--;\n             j--;\n           }\n \n           // compare priority of path1[i] and path2[j]\n           int p1 \u003d path1.get(i).relativePriority;\n           int p2 \u003d path2.get(j).relativePriority;\n           if (p1 \u003c p2) {\n             priorityDigraph.put(q2, q1, true);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n             }\n           } else if (p2 \u003c p1) {\n             priorityDigraph.put(q1, q2, true);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initializePriorityDigraph() {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Initializing priority preemption directed graph:\");\n    }\n    // Make sure we iterate all leaf queue combinations\n    for (String q1 : preemptionContext.getLeafQueueNames()) {\n      for (String q2 : preemptionContext.getLeafQueueNames()) {\n        // Make sure we only calculate each combination once instead of all\n        // permutations\n        if (q1.compareTo(q2) \u003c 0) {\n          TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n              RMNodeLabelsManager.NO_LABEL);\n          TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n              RMNodeLabelsManager.NO_LABEL);\n\n          List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n          List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n\n          // Get direct ancestor below LCA (Lowest common ancestor)\n          int i \u003d path1.size() - 1;\n          int j \u003d path2.size() - 1;\n          while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n            i--;\n            j--;\n          }\n\n          // compare priority of path1[i] and path2[j]\n          int p1 \u003d path1.get(i).relativePriority;\n          int p2 \u003d path2.get(j).relativePriority;\n          if (p1 \u003c p2) {\n            priorityDigraph.put(q2, q1, true);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n            }\n          } else if (p2 \u003c p1) {\n            priorityDigraph.put(q1, q2, true);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {
        "oldValue": "intializePriorityDigraph",
        "newValue": "initializePriorityDigraph"
      }
    },
    "128d773a2315fa6baaa3a52b13c53c77e741b69c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7727. Incorrect log levels in few logs with QueuePriorityContainerCandidateSelector. Contributed by Prabhu Joseph.\n",
      "commitDate": "12/01/18 2:11 AM",
      "commitName": "128d773a2315fa6baaa3a52b13c53c77e741b69c",
      "commitAuthor": "Sunil G",
      "commitDateOld": "17/09/17 9:20 PM",
      "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 116.24,
      "commitsBetweenForRepo": 817,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n   private void intializePriorityDigraph() {\n-    LOG.info(\"Initializing priority preemption directed graph:\");\n-\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Initializing priority preemption directed graph:\");\n+    }\n     // Make sure we iterate all leaf queue combinations\n     for (String q1 : preemptionContext.getLeafQueueNames()) {\n       for (String q2 : preemptionContext.getLeafQueueNames()) {\n         // Make sure we only calculate each combination once instead of all\n         // permutations\n         if (q1.compareTo(q2) \u003c 0) {\n           TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n               RMNodeLabelsManager.NO_LABEL);\n           TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n               RMNodeLabelsManager.NO_LABEL);\n \n           List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n           List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n \n           // Get direct ancestor below LCA (Lowest common ancestor)\n           int i \u003d path1.size() - 1;\n           int j \u003d path2.size() - 1;\n           while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n             i--;\n             j--;\n           }\n \n           // compare priority of path1[i] and path2[j]\n           int p1 \u003d path1.get(i).relativePriority;\n           int p2 \u003d path2.get(j).relativePriority;\n           if (p1 \u003c p2) {\n             priorityDigraph.put(q2, q1, true);\n             if (LOG.isDebugEnabled()) {\n-              LOG.info(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n+              LOG.debug(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n             }\n           } else if (p2 \u003c p1) {\n             priorityDigraph.put(q1, q2, true);\n             if (LOG.isDebugEnabled()) {\n-              LOG.info(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n+              LOG.debug(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void intializePriorityDigraph() {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Initializing priority preemption directed graph:\");\n    }\n    // Make sure we iterate all leaf queue combinations\n    for (String q1 : preemptionContext.getLeafQueueNames()) {\n      for (String q2 : preemptionContext.getLeafQueueNames()) {\n        // Make sure we only calculate each combination once instead of all\n        // permutations\n        if (q1.compareTo(q2) \u003c 0) {\n          TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n              RMNodeLabelsManager.NO_LABEL);\n          TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n              RMNodeLabelsManager.NO_LABEL);\n\n          List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n          List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n\n          // Get direct ancestor below LCA (Lowest common ancestor)\n          int i \u003d path1.size() - 1;\n          int j \u003d path2.size() - 1;\n          while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n            i--;\n            j--;\n          }\n\n          // compare priority of path1[i] and path2[j]\n          int p1 \u003d path1.get(i).relativePriority;\n          int p2 \u003d path2.get(j).relativePriority;\n          if (p1 \u003c p2) {\n            priorityDigraph.put(q2, q1, true);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n            }\n          } else if (p2 \u003c p1) {\n            priorityDigraph.put(q1, q2, true);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,43 @@\n+  private void intializePriorityDigraph() {\n+    LOG.info(\"Initializing priority preemption directed graph:\");\n+\n+    // Make sure we iterate all leaf queue combinations\n+    for (String q1 : preemptionContext.getLeafQueueNames()) {\n+      for (String q2 : preemptionContext.getLeafQueueNames()) {\n+        // Make sure we only calculate each combination once instead of all\n+        // permutations\n+        if (q1.compareTo(q2) \u003c 0) {\n+          TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n+              RMNodeLabelsManager.NO_LABEL);\n+          TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n+              RMNodeLabelsManager.NO_LABEL);\n+\n+          List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n+          List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n+\n+          // Get direct ancestor below LCA (Lowest common ancestor)\n+          int i \u003d path1.size() - 1;\n+          int j \u003d path2.size() - 1;\n+          while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n+            i--;\n+            j--;\n+          }\n+\n+          // compare priority of path1[i] and path2[j]\n+          int p1 \u003d path1.get(i).relativePriority;\n+          int p2 \u003d path2.get(j).relativePriority;\n+          if (p1 \u003c p2) {\n+            priorityDigraph.put(q2, q1, true);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.info(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n+            }\n+          } else if (p2 \u003c p1) {\n+            priorityDigraph.put(q1, q2, true);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.info(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void intializePriorityDigraph() {\n    LOG.info(\"Initializing priority preemption directed graph:\");\n\n    // Make sure we iterate all leaf queue combinations\n    for (String q1 : preemptionContext.getLeafQueueNames()) {\n      for (String q2 : preemptionContext.getLeafQueueNames()) {\n        // Make sure we only calculate each combination once instead of all\n        // permutations\n        if (q1.compareTo(q2) \u003c 0) {\n          TempQueuePerPartition tq1 \u003d preemptionContext.getQueueByPartition(q1,\n              RMNodeLabelsManager.NO_LABEL);\n          TempQueuePerPartition tq2 \u003d preemptionContext.getQueueByPartition(q2,\n              RMNodeLabelsManager.NO_LABEL);\n\n          List\u003cTempQueuePerPartition\u003e path1 \u003d getPathToRoot(tq1);\n          List\u003cTempQueuePerPartition\u003e path2 \u003d getPathToRoot(tq2);\n\n          // Get direct ancestor below LCA (Lowest common ancestor)\n          int i \u003d path1.size() - 1;\n          int j \u003d path2.size() - 1;\n          while (path1.get(i).queueName.equals(path2.get(j).queueName)) {\n            i--;\n            j--;\n          }\n\n          // compare priority of path1[i] and path2[j]\n          int p1 \u003d path1.get(i).relativePriority;\n          int p2 \u003d path2.get(j).relativePriority;\n          if (p1 \u003c p2) {\n            priorityDigraph.put(q2, q1, true);\n            if (LOG.isDebugEnabled()) {\n              LOG.info(\"- Added priority ordering edge: \" + q2 + \" \u003e\u003e \" + q1);\n            }\n          } else if (p2 \u003c p1) {\n            priorityDigraph.put(q1, q2, true);\n            if (LOG.isDebugEnabled()) {\n              LOG.info(\"- Added priority ordering edge: \" + q1 + \" \u003e\u003e \" + q2);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/QueuePriorityContainerCandidateSelector.java"
    }
  }
}