{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "processRpcOutOfBandRequest",
  "functionId": "processRpcOutOfBandRequest___header-RpcRequestHeaderProto__buffer-RpcWritable.Buffer",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 2738,
  "functionEndLine": 2766,
  "numCommitsSeen": 420,
  "timeTaken": 8708,
  "changeHistory": [
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
    "580a8334963709e728ed677c815fb7fef9bca70e",
    "63a1273f2a8e0b668ff70330262adedee63112d9",
    "f5312aedb9fa3dc895d61844b5c3202b02554f80",
    "65be21267587f04a2c33af65b951211cc9085b15",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
    "eb2a60338715e517ba8e4d32ecfe28691a882188",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
    "589c68ae09effd6c4f26505d61636f779c22e99f",
    "186df142cc19c2969c1f8b56df0d8f75e3db66b1",
    "65200998c01b17e017d1814e8b1f4d82ac334a23",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2",
    "940389afce6a1b9b9e1519aed528cbc444786756",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "580a8334963709e728ed677c815fb7fef9bca70e": "Ymultichange(Yparameterchange,Ybodychange)",
    "63a1273f2a8e0b668ff70330262adedee63112d9": "Ybodychange",
    "f5312aedb9fa3dc895d61844b5c3202b02554f80": "Ybodychange",
    "65be21267587f04a2c33af65b951211cc9085b15": "Ybodychange",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": "Ymultichange(Yrename,Yparameterchange,Yexceptionschange,Ybodychange)",
    "eb2a60338715e517ba8e4d32ecfe28691a882188": "Ybodychange",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": "Ybodychange",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": "Ybodychange",
    "589c68ae09effd6c4f26505d61636f779c22e99f": "Ybodychange",
    "186df142cc19c2969c1f8b56df0d8f75e3db66b1": "Ybodychange",
    "65200998c01b17e017d1814e8b1f4d82ac334a23": "Ybodychange",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2": "Ybodychange",
    "940389afce6a1b9b9e1519aed528cbc444786756": "Ymultichange(Yparameterchange,Ybodychange)",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
      "commitDate": "09/02/17 8:47 AM",
      "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n-        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n+        RpcWritable.Buffer buffer) throws RpcServerException,\n             IOException, InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n-          throw new WrappedRpcServerException(\n+          throw new FatalRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n         processConnectionContext(buffer);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n-          throw new WrappedRpcServerException(\n+          throw new FatalRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"SASL protocol not requested by client\");\n         }\n         saslReadAndProcess(buffer);\n       } else if (callId \u003d\u003d PING_CALL_ID) {\n         LOG.debug(\"Received ping message\");\n       } else {\n-        throw new WrappedRpcServerException(\n+        throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n            IOException, InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new FatalRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(buffer);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new FatalRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        saslReadAndProcess(buffer);\n      } else if (callId \u003d\u003d PING_CALL_ID) {\n        LOG.debug(\"Received ping message\");\n      } else {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[WrappedRpcServerException, IOException, InterruptedException]",
            "newValue": "[RpcServerException, IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n-        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n+        RpcWritable.Buffer buffer) throws RpcServerException,\n             IOException, InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n-          throw new WrappedRpcServerException(\n+          throw new FatalRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n         processConnectionContext(buffer);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n-          throw new WrappedRpcServerException(\n+          throw new FatalRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"SASL protocol not requested by client\");\n         }\n         saslReadAndProcess(buffer);\n       } else if (callId \u003d\u003d PING_CALL_ID) {\n         LOG.debug(\"Received ping message\");\n       } else {\n-        throw new WrappedRpcServerException(\n+        throw new FatalRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws RpcServerException,\n            IOException, InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new FatalRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(buffer);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new FatalRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        saslReadAndProcess(buffer);\n      } else if (callId \u003d\u003d PING_CALL_ID) {\n        LOG.debug(\"Received ping message\");\n      } else {\n        throw new FatalRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "580a8334963709e728ed677c815fb7fef9bca70e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "03/08/16 11:22 AM",
      "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "03/08/16 11:22 AM",
          "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/08/16 7:31 AM",
          "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n-        DataInputStream dis) throws WrappedRpcServerException, IOException,\n-        InterruptedException {\n+        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n+            IOException, InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n-        processConnectionContext(dis);\n+        processConnectionContext(buffer);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"SASL protocol not requested by client\");\n         }\n-        saslReadAndProcess(dis);\n+        saslReadAndProcess(buffer);\n       } else if (callId \u003d\u003d PING_CALL_ID) {\n         LOG.debug(\"Received ping message\");\n       } else {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n            IOException, InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(buffer);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        saslReadAndProcess(buffer);\n      } else if (callId \u003d\u003d PING_CALL_ID) {\n        LOG.debug(\"Received ping message\");\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[header-RpcRequestHeaderProto, dis-DataInputStream]",
            "newValue": "[header-RpcRequestHeaderProto, buffer-RpcWritable.Buffer]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "03/08/16 11:22 AM",
          "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/08/16 7:31 AM",
          "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n-        DataInputStream dis) throws WrappedRpcServerException, IOException,\n-        InterruptedException {\n+        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n+            IOException, InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n-        processConnectionContext(dis);\n+        processConnectionContext(buffer);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"SASL protocol not requested by client\");\n         }\n-        saslReadAndProcess(dis);\n+        saslReadAndProcess(buffer);\n       } else if (callId \u003d\u003d PING_CALL_ID) {\n         LOG.debug(\"Received ping message\");\n       } else {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        RpcWritable.Buffer buffer) throws WrappedRpcServerException,\n            IOException, InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(buffer);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        saslReadAndProcess(buffer);\n      } else if (callId \u003d\u003d PING_CALL_ID) {\n        LOG.debug(\"Received ping message\");\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "63a1273f2a8e0b668ff70330262adedee63112d9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9832. Add RPC header to client ping (daryn)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510793 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/08/13 4:01 PM",
      "commitName": "63a1273f2a8e0b668ff70330262adedee63112d9",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "05/08/13 3:02 PM",
      "commitNameOld": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,29 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException, IOException,\n         InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n         processConnectionContext(dis);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"SASL protocol not requested by client\");\n         }\n         saslReadAndProcess(dis);\n+      } else if (callId \u003d\u003d PING_CALL_ID) {\n+        LOG.debug(\"Received ping message\");\n       } else {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        saslReadAndProcess(dis);\n      } else if (callId \u003d\u003d PING_CALL_ID) {\n        LOG.debug(\"Received ping message\");\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "f5312aedb9fa3dc895d61844b5c3202b02554f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9816. RPC Sasl QOP is broken (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510772 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/08/13 3:02 PM",
      "commitName": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "29/07/13 7:44 AM",
      "commitNameOld": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 7.3,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,27 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException, IOException,\n         InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n         processConnectionContext(dis);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"SASL protocol not requested by client\");\n         }\n-        RpcSaslProto response \u003d saslReadAndProcess(dis);\n-        // send back response if any, may throw IOException\n-        if (response !\u003d null) {\n-          doSaslReply(response);\n-        }\n+        saslReadAndProcess(dis);\n       } else {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        saslReadAndProcess(dis);\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "24/07/13 12:48 AM",
      "commitNameOld": "a0a986dda77ea03dac9cfc7e0631bae611034ef4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.29,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,31 @@\n     private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n         DataInputStream dis) throws WrappedRpcServerException, IOException,\n         InterruptedException {\n       final int callId \u003d header.getCallId();\n       if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n         // SASL must be established prior to connection context\n         if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n           throw new WrappedRpcServerException(\n               RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n               \"Connection header sent during SASL negotiation\");\n         }\n         // read and authorize the user\n         processConnectionContext(dis);\n       } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n         // if client was switched to simple, ignore first SASL message\n         if (authProtocol !\u003d AuthProtocol.SASL) {\n-          if (!skipInitialSaslHandshake) {\n-            throw new WrappedRpcServerException(\n-                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n-                \"SASL protocol not requested by client\");\n-          }\n-          skipInitialSaslHandshake \u003d false;\n-          return;\n+          throw new WrappedRpcServerException(\n+              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+              \"SASL protocol not requested by client\");\n         }\n         RpcSaslProto response \u003d saslReadAndProcess(dis);\n         // send back response if any, may throw IOException\n         if (response !\u003d null) {\n           doSaslReply(response);\n         }\n       } else {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             \"Unknown out of band call #\" + callId);\n       }\n     }    \n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"SASL protocol not requested by client\");\n        }\n        RpcSaslProto response \u003d saslReadAndProcess(dis);\n        // send back response if any, may throw IOException\n        if (response !\u003d null) {\n          doSaslReply(response);\n        }\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 10:59 AM",
      "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,35 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n+    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException, IOException,\n+        InterruptedException {\n+      final int callId \u003d header.getCallId();\n+      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n+        // SASL must be established prior to connection context\n+        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n+          throw new WrappedRpcServerException(\n+              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+              \"Connection header sent during SASL negotiation\");\n+        }\n+        // read and authorize the user\n+        processConnectionContext(dis);\n+      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n+        // if client was switched to simple, ignore first SASL message\n+        if (authProtocol !\u003d AuthProtocol.SASL) {\n+          if (!skipInitialSaslHandshake) {\n+            throw new WrappedRpcServerException(\n+                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+                \"SASL protocol not requested by client\");\n+          }\n+          skipInitialSaslHandshake \u003d false;\n+          return;\n+        }\n+        RpcSaslProto response \u003d saslReadAndProcess(dis);\n+        // send back response if any, may throw IOException\n+        if (response !\u003d null) {\n+          doSaslReply(response);\n+        }\n+      } else {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            \"Unknown out of band call #\" + callId);\n       }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n-          getRpcRequestWrapper(header.getRpcKind());\n-      if (rpcRequestClass \u003d\u003d null) {\n-        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n-            \" from client \" + getHostAddress());\n-        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n-            header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n-      }\n-      Writable rpcRequest;\n-      try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n-        rpcRequest.readFields(dis);\n-      } catch (Throwable t) { // includes runtime exception from newInstance\n-        LOG.warn(\"Unable to read call parameters for client \" +\n-                 getHostAddress() + \"on connection protocol \" +\n-            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n-      }\n-        \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n-          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n-              .toByteArray());\n-      callQueue.put(call);              // queue the call; maybe blocked here\n-      incRpcCount();  // Increment the rpc count\n-    }\n\\ No newline at end of file\n+    }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          if (!skipInitialSaslHandshake) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                \"SASL protocol not requested by client\");\n          }\n          skipInitialSaslHandshake \u003d false;\n          return;\n        }\n        RpcSaslProto response \u003d saslReadAndProcess(dis);\n        // send back response if any, may throw IOException\n        if (response !\u003d null) {\n          doSaslReply(response);\n        }\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "processRpcRequest",
            "newValue": "processRpcOutOfBandRequest"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,35 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n+    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException, IOException,\n+        InterruptedException {\n+      final int callId \u003d header.getCallId();\n+      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n+        // SASL must be established prior to connection context\n+        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n+          throw new WrappedRpcServerException(\n+              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+              \"Connection header sent during SASL negotiation\");\n+        }\n+        // read and authorize the user\n+        processConnectionContext(dis);\n+      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n+        // if client was switched to simple, ignore first SASL message\n+        if (authProtocol !\u003d AuthProtocol.SASL) {\n+          if (!skipInitialSaslHandshake) {\n+            throw new WrappedRpcServerException(\n+                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+                \"SASL protocol not requested by client\");\n+          }\n+          skipInitialSaslHandshake \u003d false;\n+          return;\n+        }\n+        RpcSaslProto response \u003d saslReadAndProcess(dis);\n+        // send back response if any, may throw IOException\n+        if (response !\u003d null) {\n+          doSaslReply(response);\n+        }\n+      } else {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            \"Unknown out of band call #\" + callId);\n       }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n-          getRpcRequestWrapper(header.getRpcKind());\n-      if (rpcRequestClass \u003d\u003d null) {\n-        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n-            \" from client \" + getHostAddress());\n-        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n-            header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n-      }\n-      Writable rpcRequest;\n-      try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n-        rpcRequest.readFields(dis);\n-      } catch (Throwable t) { // includes runtime exception from newInstance\n-        LOG.warn(\"Unable to read call parameters for client \" +\n-                 getHostAddress() + \"on connection protocol \" +\n-            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n-      }\n-        \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n-          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n-              .toByteArray());\n-      callQueue.put(call);              // queue the call; maybe blocked here\n-      incRpcCount();  // Increment the rpc count\n-    }\n\\ No newline at end of file\n+    }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          if (!skipInitialSaslHandshake) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                \"SASL protocol not requested by client\");\n          }\n          skipInitialSaslHandshake \u003d false;\n          return;\n        }\n        RpcSaslProto response \u003d saslReadAndProcess(dis);\n        // send back response if any, may throw IOException\n        if (response !\u003d null) {\n          doSaslReply(response);\n        }\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[buf-byte[]]",
            "newValue": "[header-RpcRequestHeaderProto, dis-DataInputStream]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,35 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n+    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException, IOException,\n+        InterruptedException {\n+      final int callId \u003d header.getCallId();\n+      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n+        // SASL must be established prior to connection context\n+        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n+          throw new WrappedRpcServerException(\n+              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+              \"Connection header sent during SASL negotiation\");\n+        }\n+        // read and authorize the user\n+        processConnectionContext(dis);\n+      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n+        // if client was switched to simple, ignore first SASL message\n+        if (authProtocol !\u003d AuthProtocol.SASL) {\n+          if (!skipInitialSaslHandshake) {\n+            throw new WrappedRpcServerException(\n+                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+                \"SASL protocol not requested by client\");\n+          }\n+          skipInitialSaslHandshake \u003d false;\n+          return;\n+        }\n+        RpcSaslProto response \u003d saslReadAndProcess(dis);\n+        // send back response if any, may throw IOException\n+        if (response !\u003d null) {\n+          doSaslReply(response);\n+        }\n+      } else {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            \"Unknown out of band call #\" + callId);\n       }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n-          getRpcRequestWrapper(header.getRpcKind());\n-      if (rpcRequestClass \u003d\u003d null) {\n-        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n-            \" from client \" + getHostAddress());\n-        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n-            header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n-      }\n-      Writable rpcRequest;\n-      try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n-        rpcRequest.readFields(dis);\n-      } catch (Throwable t) { // includes runtime exception from newInstance\n-        LOG.warn(\"Unable to read call parameters for client \" +\n-                 getHostAddress() + \"on connection protocol \" +\n-            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n-      }\n-        \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n-          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n-              .toByteArray());\n-      callQueue.put(call);              // queue the call; maybe blocked here\n-      incRpcCount();  // Increment the rpc count\n-    }\n\\ No newline at end of file\n+    }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          if (!skipInitialSaslHandshake) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                \"SASL protocol not requested by client\");\n          }\n          skipInitialSaslHandshake \u003d false;\n          return;\n        }\n        RpcSaslProto response \u003d saslReadAndProcess(dis);\n        // send back response if any, may throw IOException\n        if (response !\u003d null) {\n          doSaslReply(response);\n        }\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[RpcServerException, IOException, InterruptedException]",
            "newValue": "[WrappedRpcServerException, IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,35 @@\n-    private void processRpcRequest(byte[] buf) \n-        throws  RpcServerException, IOException, InterruptedException {\n-      DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n-        \n-      if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + header.getCallId());\n-      if (!header.hasRpcOp()) {\n-        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n+    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n+        DataInputStream dis) throws WrappedRpcServerException, IOException,\n+        InterruptedException {\n+      final int callId \u003d header.getCallId();\n+      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n+        // SASL must be established prior to connection context\n+        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n+          throw new WrappedRpcServerException(\n+              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+              \"Connection header sent during SASL negotiation\");\n+        }\n+        // read and authorize the user\n+        processConnectionContext(dis);\n+      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n+        // if client was switched to simple, ignore first SASL message\n+        if (authProtocol !\u003d AuthProtocol.SASL) {\n+          if (!skipInitialSaslHandshake) {\n+            throw new WrappedRpcServerException(\n+                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+                \"SASL protocol not requested by client\");\n+          }\n+          skipInitialSaslHandshake \u003d false;\n+          return;\n+        }\n+        RpcSaslProto response \u003d saslReadAndProcess(dis);\n+        // send back response if any, may throw IOException\n+        if (response !\u003d null) {\n+          doSaslReply(response);\n+        }\n+      } else {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            \"Unknown out of band call #\" + callId);\n       }\n-      if (header.getRpcOp() !\u003d \n-          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        String err \u003d \"IPC Server does not implement rpc header operation\" + \n-                header.getRpcOp();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      // If we know the rpc kind, get its class so that we can deserialize\n-      // (Note it would make more sense to have the handler deserialize but \n-      // we continue with this original design.\n-      if (!header.hasRpcKind()) {\n-        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);\n-      }\n-      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n-          getRpcRequestWrapper(header.getRpcKind());\n-      if (rpcRequestClass \u003d\u003d null) {\n-        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n-            \" from client \" + getHostAddress());\n-        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n-            header.getRpcKind();\n-        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n-            RpcServerException.class.getName(), err);\n-        throw new RpcServerException(err);   \n-      }\n-      Writable rpcRequest;\n-      try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n-        rpcRequest.readFields(dis);\n-      } catch (Throwable t) { // includes runtime exception from newInstance\n-        LOG.warn(\"Unable to read call parameters for client \" +\n-                 getHostAddress() + \"on connection protocol \" +\n-            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, \n-            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n-            null, t.getClass().getName(),\n-            err);\n-        responder.doRespond(readParamsFailedCall);\n-        throw new RpcServerException(err, t);\n-      }\n-        \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n-          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n-              .toByteArray());\n-      callQueue.put(call);              // queue the call; maybe blocked here\n-      incRpcCount();  // Increment the rpc count\n-    }\n\\ No newline at end of file\n+    }    \n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcOutOfBandRequest(RpcRequestHeaderProto header,\n        DataInputStream dis) throws WrappedRpcServerException, IOException,\n        InterruptedException {\n      final int callId \u003d header.getCallId();\n      if (callId \u003d\u003d CONNECTION_CONTEXT_CALL_ID) {\n        // SASL must be established prior to connection context\n        if (authProtocol \u003d\u003d AuthProtocol.SASL \u0026\u0026 !saslContextEstablished) {\n          throw new WrappedRpcServerException(\n              RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n              \"Connection header sent during SASL negotiation\");\n        }\n        // read and authorize the user\n        processConnectionContext(dis);\n      } else if (callId \u003d\u003d AuthProtocol.SASL.callId) {\n        // if client was switched to simple, ignore first SASL message\n        if (authProtocol !\u003d AuthProtocol.SASL) {\n          if (!skipInitialSaslHandshake) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                \"SASL protocol not requested by client\");\n          }\n          skipInitialSaslHandshake \u003d false;\n          return;\n        }\n        RpcSaslProto response \u003d saslReadAndProcess(dis);\n        // send back response if any, may throw IOException\n        if (response !\u003d null) {\n          doSaslReply(response);\n        }\n      } else {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            \"Unknown out of band call #\" + callId);\n      }\n    }    ",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "eb2a60338715e517ba8e4d32ecfe28691a882188": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9688. Add globally unique Client ID to RPC requests. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500843 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/07/13 10:08 AM",
      "commitName": "eb2a60338715e517ba8e4d32ecfe28691a882188",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "01/07/13 4:17 PM",
      "commitNameOld": "805e9b5b6d835d1b7a50af18967afb8eebdf8606",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n     private void processRpcRequest(byte[] buf) \n         throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n         String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n         String err \u003d \"IPC Server does not implement rpc header operation\" + \n                 header.getRpcOp();\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n         String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final String err \u003d \"Unknown rpc kind in rpc header\"  + \n             header.getRpcKind();\n         respondBadRpcHeader(new Call(header.getCallId(), null, this),\n             RpcServerException.class.getName(), err);\n         throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n         String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n         setupResponse(responseBuffer, readParamsFailedCall, \n             RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n             null, t.getClass().getName(),\n             err);\n         responder.doRespond(readParamsFailedCall);\n         throw new RpcServerException(err, t);\n       }\n         \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n-          ProtoUtil.convert(header.getRpcKind()));\n+      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n+          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n+              .toByteArray());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this,\n          ProtoUtil.convert(header.getRpcKind()), header.getClientId()\n              .toByteArray());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": {
      "type": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/13 10:51 AM",
      "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
      "commitAuthor": "Sanjay Radia",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/05/13 10:51 AM",
          "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "27/03/13 11:51 AM",
          "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 37.96,
          "commitsBetweenForRepo": 210,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-    private void processData(byte[] buf) throws  IOException, InterruptedException {\n+    private void processRpcRequest(byte[] buf) \n+        throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getRpcOp());\n+        String err \u003d \"IPC Server does not implement rpc header operation\" + \n+                header.getRpcOp();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getRpcKind());\n-        responder.doRespond(readParamsFailedCall);\n-        return;   \n+        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n+            header.getRpcKind();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n-      } catch (Throwable t) {\n+      } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            t.getClass().getName(),\n-            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        setupResponse(responseBuffer, readParamsFailedCall, \n+            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n+            null, t.getClass().getName(),\n+            err);\n         responder.doRespond(readParamsFailedCall);\n-        return;\n+        throw new RpcServerException(err, t);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "processData",
            "newValue": "processRpcRequest"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/05/13 10:51 AM",
          "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "27/03/13 11:51 AM",
          "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 37.96,
          "commitsBetweenForRepo": 210,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-    private void processData(byte[] buf) throws  IOException, InterruptedException {\n+    private void processRpcRequest(byte[] buf) \n+        throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getRpcOp());\n+        String err \u003d \"IPC Server does not implement rpc header operation\" + \n+                header.getRpcOp();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getRpcKind());\n-        responder.doRespond(readParamsFailedCall);\n-        return;   \n+        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n+            header.getRpcKind();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n-      } catch (Throwable t) {\n+      } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            t.getClass().getName(),\n-            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        setupResponse(responseBuffer, readParamsFailedCall, \n+            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n+            null, t.getClass().getName(),\n+            err);\n         responder.doRespond(readParamsFailedCall);\n-        return;\n+        throw new RpcServerException(err, t);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[IOException, InterruptedException]",
            "newValue": "[RpcServerException, IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/05/13 10:51 AM",
          "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "27/03/13 11:51 AM",
          "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 37.96,
          "commitsBetweenForRepo": 210,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,68 @@\n-    private void processData(byte[] buf) throws  IOException, InterruptedException {\n+    private void processRpcRequest(byte[] buf) \n+        throws  RpcServerException, IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       if (header.getRpcOp() !\u003d \n           RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n-        throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getRpcOp());\n+        String err \u003d \"IPC Server does not implement rpc header operation\" + \n+                header.getRpcOp();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n+        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n-        final Call readParamsFailedCall \u003d \n-            new Call(header.getCallId(), null, this);\n-        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n-\n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getRpcKind());\n-        responder.doRespond(readParamsFailedCall);\n-        return;   \n+        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n+            header.getRpcKind();\n+        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n+            RpcServerException.class.getName(), err);\n+        throw new RpcServerException(err);   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n-      } catch (Throwable t) {\n+      } catch (Throwable t) { // includes runtime exception from newInstance\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n-            t.getClass().getName(),\n-            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        setupResponse(responseBuffer, readParamsFailedCall, \n+            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n+            null, t.getClass().getName(),\n+            err);\n         responder.doRespond(readParamsFailedCall);\n-        return;\n+        throw new RpcServerException(err, t);\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processRpcRequest(byte[] buf) \n        throws  RpcServerException, IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        String err \u003d \" IPC Server: No rpc op in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        String err \u003d \"IPC Server does not implement rpc header operation\" + \n                header.getRpcOp();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        String err \u003d \" IPC Server: No rpc kind in rpcRequestHeader\";\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final String err \u003d \"Unknown rpc kind in rpc header\"  + \n            header.getRpcKind();\n        respondBadRpcHeader(new Call(header.getCallId(), null, this),\n            RpcServerException.class.getName(), err);\n        throw new RpcServerException(err);   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) { // includes runtime exception from newInstance\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n        String err \u003d \"IPC server unable to read call parameters: \"+ t.getMessage();\n\n        setupResponse(responseBuffer, readParamsFailedCall, \n            RpcStatusProto.FATAL, RpcErrorCodeProto.FATAL_DESERIALIZING_REQUEST,\n            null, t.getClass().getName(),\n            err);\n        responder.doRespond(readParamsFailedCall);\n        throw new RpcServerException(err, t);\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9140 Cleanup rpc PB protos (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423189 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/12 2:16 PM",
      "commitName": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "05/12/12 6:53 PM",
      "commitNameOld": "3337588975fa24c0044408c6caf91abea4dca4d4",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 11.81,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n+      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n-        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n+        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n       }\n-      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n+      if (header.getRpcOp() !\u003d \n+          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getRpcOp());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n-        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n+        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             IOException.class.getName(),\n             \"Unknown rpc kind \"  + header.getRpcKind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcRequestHeaderProto header \u003d RpcRequestHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        throw new IOException(\" IPC Server: No rpc op in rpcRequestHeader\");\n      }\n      if (header.getRpcOp() !\u003d \n          RpcRequestHeaderProto.OperationProto.RPC_FINAL_PACKET) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getRpcOp());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        throw new IOException(\" IPC Server: No rpc kind in rpcRequestHeader\");\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getRpcKind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8366 Use ProtoBuf for RpcResponseHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1337283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/05/12 9:56 AM",
      "commitName": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "02/05/12 11:35 PM",
      "commitNameOld": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 8.43,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (!header.hasRpcOp()) {\n         throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n       }\n       if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getRpcOp());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       if (!header.hasRpcKind()) {\n         throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n       }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             IOException.class.getName(),\n             \"Unknown rpc kind \"  + header.getRpcKind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n             this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n-        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n           ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n      }\n      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getRpcOp());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getRpcKind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, RpcStatusProto.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "589c68ae09effd6c4f26505d61636f779c22e99f": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8285 Use ProtoBuf for RpcPayLoadHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1329319 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/12 9:34 AM",
      "commitName": "589c68ae09effd6c4f26505d61636f779c22e99f",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "17/04/12 8:04 AM",
      "commitNameOld": "e8eed2f62d30e0bf2f915ee3ad6b9c9f6d2d97cb",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,59 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n-      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n-      header.readFields(dis);           // Read the RpcPayload header\n+      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n-      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n+      if (!header.hasRpcOp()) {\n+        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n+      }\n+      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n-              header.getOperation());\n+              header.getRpcOp());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n+      if (!header.hasRpcKind()) {\n+        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n+      }\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n-          getRpcRequestWrapper(header.getkind());\n+          getRpcRequestWrapper(header.getRpcKind());\n       if (rpcRequestClass \u003d\u003d null) {\n-        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n+        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             IOException.class.getName(),\n-            \"Unknown rpc kind \"  + header.getkind());\n+            \"Unknown rpc kind \"  + header.getRpcKind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress() + \"on connection protocol \" +\n-            this.protocolName + \" for rpcKind \" + header.getkind(),  t);\n+            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n-      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n+      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n+          ProtoUtil.convert(header.getRpcKind()));\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeaderProto header \u003d RpcPayloadHeaderProto.parseDelimitedFrom(dis);\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (!header.hasRpcOp()) {\n        throw new IOException(\" IPC Server: No rpc op in rpcPayloadHeader\");\n      }\n      if (header.getRpcOp() !\u003d RpcPayloadOperationProto.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getRpcOp());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      if (!header.hasRpcKind()) {\n        throw new IOException(\" IPC Server: No rpc kind in rpcPayloadHeader\");\n      }\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getRpcKind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getRpcKind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getRpcKind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getRpcKind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, \n          ProtoUtil.convert(header.getRpcKind()));\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "186df142cc19c2969c1f8b56df0d8f75e3db66b1": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7913 Fix bug in ProtoBufRpcEngine  (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213619 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 1:18 AM",
      "commitName": "186df142cc19c2969c1f8b56df0d8f75e3db66b1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "04/12/11 12:44 PM",
      "commitNameOld": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 8.52,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcPayloadHeader header \u003d new RpcPayloadHeader();\n       header.readFields(dis);           // Read the RpcPayload header\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getOperation());\n       }\n       // If we know the rpc kind, get its class so that we can deserialize\n       // (Note it would make more sense to have the handler deserialize but \n       // we continue with this original design.\n       Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n           getRpcRequestWrapper(header.getkind());\n       if (rpcRequestClass \u003d\u003d null) {\n         LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n             \" from client \" + getHostAddress());\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             IOException.class.getName(),\n             \"Unknown rpc kind \"  + header.getkind());\n         responder.doRespond(readParamsFailedCall);\n         return;   \n       }\n       Writable rpcRequest;\n       try { //Read the rpc request\n         rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n-                 getHostAddress(), t);\n+                 getHostAddress() + \"on connection protocol \" +\n+            this.protocolName + \" for rpcKind \" + header.getkind(),  t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n      header.readFields(dis);           // Read the RpcPayload header\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getOperation());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getkind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getkind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress() + \"on connection protocol \" +\n            this.protocolName + \" for rpcKind \" + header.getkind(),  t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "65200998c01b17e017d1814e8b1f4d82ac334a23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7862  Move the support for multiple protocols to lower layer so that Writable, PB and Avro can all use it (includes HDFS and MR changes to match) (Sanjay) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210208 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/11 12:44 PM",
      "commitName": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "27/11/11 12:27 PM",
      "commitNameOld": "229a3a23127e33f596d485dec580e31c48ba9057",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,52 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       RpcPayloadHeader header \u003d new RpcPayloadHeader();\n       header.readFields(dis);           // Read the RpcPayload header\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + header.getCallId());\n       if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n         throw new IOException(\"IPC Server does not implement operation\" + \n               header.getOperation());\n       }\n+      // If we know the rpc kind, get its class so that we can deserialize\n+      // (Note it would make more sense to have the handler deserialize but \n+      // we continue with this original design.\n+      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n+          getRpcRequestWrapper(header.getkind());\n+      if (rpcRequestClass \u003d\u003d null) {\n+        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n+            \" from client \" + getHostAddress());\n+        final Call readParamsFailedCall \u003d \n+            new Call(header.getCallId(), null, this);\n+        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n+\n+        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+            IOException.class.getName(),\n+            \"Unknown rpc kind \"  + header.getkind());\n+        responder.doRespond(readParamsFailedCall);\n+        return;   \n+      }\n       Writable rpcRequest;\n       try { //Read the rpc request\n-        rpcRequest \u003d ReflectionUtils.newInstance(paramClass, conf);\n+        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n         rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress(), t);\n         final Call readParamsFailedCall \u003d \n             new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n       Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n      header.readFields(dis);           // Read the RpcPayload header\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getOperation());\n      }\n      // If we know the rpc kind, get its class so that we can deserialize\n      // (Note it would make more sense to have the handler deserialize but \n      // we continue with this original design.\n      Class\u003c? extends Writable\u003e rpcRequestClass \u003d \n          getRpcRequestWrapper(header.getkind());\n      if (rpcRequestClass \u003d\u003d null) {\n        LOG.warn(\"Unknown rpc kind \"  + header.getkind() + \n            \" from client \" + getHostAddress());\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            IOException.class.getName(),\n            \"Unknown rpc kind \"  + header.getkind());\n        responder.doRespond(readParamsFailedCall);\n        return;   \n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(rpcRequestClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": {
      "type": "Ybodychange",
      "commitMessage": "\t\tHADOOP-7776 Make the Ipc-Header in a RPC-Payload an explicit header (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1197885 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/11/11 10:06 PM",
      "commitName": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 10.96,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,34 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n-      int id \u003d dis.readInt();                    // try to read an id\n+      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n+      header.readFields(dis);           // Read the RpcPayload header\n         \n       if (LOG.isDebugEnabled())\n-        LOG.debug(\" got #\" + id);\n-      Writable param;\n-      try {\n-        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n-        param.readFields(dis);\n+        LOG.debug(\" got #\" + header.getCallId());\n+      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n+        throw new IOException(\"IPC Server does not implement operation\" + \n+              header.getOperation());\n+      }\n+      Writable rpcRequest;\n+      try { //Read the rpc request\n+        rpcRequest \u003d ReflectionUtils.newInstance(paramClass, conf);\n+        rpcRequest.readFields(dis);\n       } catch (Throwable t) {\n         LOG.warn(\"Unable to read call parameters for client \" +\n                  getHostAddress(), t);\n-        final Call readParamsFailedCall \u003d new Call(id, null, this);\n+        final Call readParamsFailedCall \u003d \n+            new Call(header.getCallId(), null, this);\n         ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n         setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n             t.getClass().getName(),\n             \"IPC server unable to read call parameters: \" + t.getMessage());\n         responder.doRespond(readParamsFailedCall);\n         return;\n       }\n         \n-      Call call \u003d new Call(id, param, this);\n+      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      RpcPayloadHeader header \u003d new RpcPayloadHeader();\n      header.readFields(dis);           // Read the RpcPayload header\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + header.getCallId());\n      if (header.getOperation() !\u003d RpcPayloadOperation.RPC_FINAL_PAYLOAD) {\n        throw new IOException(\"IPC Server does not implement operation\" + \n              header.getOperation());\n      }\n      Writable rpcRequest;\n      try { //Read the rpc request\n        rpcRequest \u003d ReflectionUtils.newInstance(paramClass, conf);\n        rpcRequest.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d \n            new Call(header.getCallId(), null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(header.getCallId(), rpcRequest, this, header.getkind());\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7121. Exceptions while serializing IPC call responses are not handled well. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1129982 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/11 7:00 PM",
      "commitName": "e05a6d1dce1b83bc2abe4eb2efc1afd51c8facd2",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "26/05/11 12:48 AM",
      "commitNameOld": "2f6c03ad54725e59e3d18866cfaaea734bb37c82",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,28 @@\n     private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n         new DataInputStream(new ByteArrayInputStream(buf));\n       int id \u003d dis.readInt();                    // try to read an id\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + id);\n+      Writable param;\n+      try {\n+        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n+        param.readFields(dis);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Unable to read call parameters for client \" +\n+                 getHostAddress(), t);\n+        final Call readParamsFailedCall \u003d new Call(id, null, this);\n+        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n \n-      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n-      param.readFields(dis);        \n+        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n+            t.getClass().getName(),\n+            \"IPC server unable to read call parameters: \" + t.getMessage());\n+        responder.doRespond(readParamsFailedCall);\n+        return;\n+      }\n         \n       Call call \u003d new Call(id, param, this);\n       callQueue.put(call);              // queue the call; maybe blocked here\n       incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n      Writable param;\n      try {\n        param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n        param.readFields(dis);\n      } catch (Throwable t) {\n        LOG.warn(\"Unable to read call parameters for client \" +\n                 getHostAddress(), t);\n        final Call readParamsFailedCall \u003d new Call(id, null, this);\n        ByteArrayOutputStream responseBuffer \u003d new ByteArrayOutputStream();\n\n        setupResponse(responseBuffer, readParamsFailedCall, Status.FATAL, null,\n            t.getClass().getName(),\n            \"IPC server unable to read call parameters: \" + t.getMessage());\n        responder.doRespond(readParamsFailedCall);\n        return;\n      }\n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "940389afce6a1b9b9e1519aed528cbc444786756": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/10 5:30 PM",
      "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthor": "Devaraj Das",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/02/10 5:30 PM",
          "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "27/01/10 12:08 AM",
          "commitNameOld": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
          "commitAuthorOld": "Owen O\u0027Malley",
          "daysBetweenCommits": 6.72,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,15 @@\n-    private void processData() throws  IOException, InterruptedException {\n+    private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(data.array()));\n+        new DataInputStream(new ByteArrayInputStream(buf));\n       int id \u003d dis.readInt();                    // try to read an id\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + id);\n \n       Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n       param.readFields(dis);        \n         \n       Call call \u003d new Call(id, param, this);\n       callQueue.put(call);              // queue the call; maybe blocked here\n+      incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n\n      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n      param.readFields(dis);        \n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "src/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[buf-byte[]]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/02/10 5:30 PM",
          "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "27/01/10 12:08 AM",
          "commitNameOld": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
          "commitAuthorOld": "Owen O\u0027Malley",
          "daysBetweenCommits": 6.72,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,15 @@\n-    private void processData() throws  IOException, InterruptedException {\n+    private void processData(byte[] buf) throws  IOException, InterruptedException {\n       DataInputStream dis \u003d\n-        new DataInputStream(new ByteArrayInputStream(data.array()));\n+        new DataInputStream(new ByteArrayInputStream(buf));\n       int id \u003d dis.readInt();                    // try to read an id\n         \n       if (LOG.isDebugEnabled())\n         LOG.debug(\" got #\" + id);\n \n       Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n       param.readFields(dis);        \n         \n       Call call \u003d new Call(id, param, this);\n       callQueue.put(call);              // queue the call; maybe blocked here\n+      incRpcCount();  // Increment the rpc count\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processData(byte[] buf) throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(buf));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n\n      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);//read param\n      param.readFields(dis);        \n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n      incRpcCount();  // Increment the rpc count\n    }",
          "path": "src/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,14 @@\n+    private void processData() throws  IOException, InterruptedException {\n+      DataInputStream dis \u003d\n+        new DataInputStream(new ByteArrayInputStream(data.array()));\n+      int id \u003d dis.readInt();                    // try to read an id\n+        \n+      if (LOG.isDebugEnabled())\n+        LOG.debug(\" got #\" + id);\n+\n+      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);           // read param\n+      param.readFields(dis);        \n+        \n+      Call call \u003d new Call(id, param, this);\n+      callQueue.put(call);              // queue the call; maybe blocked here\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void processData() throws  IOException, InterruptedException {\n      DataInputStream dis \u003d\n        new DataInputStream(new ByteArrayInputStream(data.array()));\n      int id \u003d dis.readInt();                    // try to read an id\n        \n      if (LOG.isDebugEnabled())\n        LOG.debug(\" got #\" + id);\n\n      Writable param \u003d ReflectionUtils.newInstance(paramClass, conf);           // read param\n      param.readFields(dis);        \n        \n      Call call \u003d new Call(id, param, this);\n      callQueue.put(call);              // queue the call; maybe blocked here\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}