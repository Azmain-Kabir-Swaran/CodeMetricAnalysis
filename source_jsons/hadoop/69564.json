{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AzureADAuthenticator.java",
  "functionName": "parseTokenFromStream",
  "functionId": "parseTokenFromStream___httpResponseStream-InputStream__isMsi-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/oauth2/AzureADAuthenticator.java",
  "functionStartLine": 416,
  "functionEndLine": 475,
  "numCommitsSeen": 15,
  "timeTaken": 2662,
  "changeHistory": [
    "0b931f36ec83dc72729a9e84a0d313f471061c64",
    "9149b9703e3ab09abdc087db129e82ad3f4cefa1"
  ],
  "changeHistoryShort": {
    "0b931f36ec83dc72729a9e84a0d313f471061c64": "Ymultichange(Yparameterchange,Ybodychange)",
    "9149b9703e3ab09abdc087db129e82ad3f4cefa1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0b931f36ec83dc72729a9e84a0d313f471061c64": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Hadoop 16890. Change in expiry calculation for MSI token provider.\n\n\r\nContributed by Bilahari T H",
      "commitDate": "11/03/20 1:39 PM",
      "commitName": "0b931f36ec83dc72729a9e84a0d313f471061c64",
      "commitAuthor": "bilaharith",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Hadoop 16890. Change in expiry calculation for MSI token provider.\n\n\r\nContributed by Bilahari T H",
          "commitDate": "11/03/20 1:39 PM",
          "commitName": "0b931f36ec83dc72729a9e84a0d313f471061c64",
          "commitAuthor": "bilaharith",
          "commitDateOld": "07/10/19 5:07 AM",
          "commitNameOld": "1a77a15fe44df9ec837be5c558279d8fd4d25e97",
          "commitAuthorOld": "bilaharith",
          "daysBetweenCommits": 156.36,
          "commitsBetweenForRepo": 555,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,60 @@\n-  private static AzureADToken parseTokenFromStream(InputStream httpResponseStream) throws IOException {\n+  private static AzureADToken parseTokenFromStream(\n+      InputStream httpResponseStream, boolean isMsi) throws IOException {\n     AzureADToken token \u003d new AzureADToken();\n     try {\n-      int expiryPeriod \u003d 0;\n+      int expiryPeriodInSecs \u003d 0;\n+      long expiresOnInSecs \u003d -1;\n \n       JsonFactory jf \u003d new JsonFactory();\n       JsonParser jp \u003d jf.createJsonParser(httpResponseStream);\n       String fieldName, fieldValue;\n       jp.nextToken();\n       while (jp.hasCurrentToken()) {\n         if (jp.getCurrentToken() \u003d\u003d JsonToken.FIELD_NAME) {\n           fieldName \u003d jp.getCurrentName();\n           jp.nextToken();  // field value\n           fieldValue \u003d jp.getText();\n \n           if (fieldName.equals(\"access_token\")) {\n             token.setAccessToken(fieldValue);\n           }\n+\n           if (fieldName.equals(\"expires_in\")) {\n-            expiryPeriod \u003d Integer.parseInt(fieldValue);\n+            expiryPeriodInSecs \u003d Integer.parseInt(fieldValue);\n           }\n+\n+          if (fieldName.equals(\"expires_on\")) {\n+            expiresOnInSecs \u003d Long.parseLong(fieldValue);\n+          }\n+\n         }\n         jp.nextToken();\n       }\n       jp.close();\n-      long expiry \u003d System.currentTimeMillis();\n-      expiry \u003d expiry + expiryPeriod * 1000L; // convert expiryPeriod to milliseconds and add\n-      token.setExpiry(new Date(expiry));\n-      LOG.debug(\"AADToken: fetched token with expiry \" + token.getExpiry().toString());\n+      if (expiresOnInSecs \u003e 0) {\n+        LOG.debug(\"Expiry based on expires_on: {}\", expiresOnInSecs);\n+        token.setExpiry(new Date(expiresOnInSecs * 1000));\n+      } else {\n+        if (isMsi) {\n+          // Currently there is a known issue that MSI does not update expires_in\n+          // for refresh and will have the value from first AAD token fetch request.\n+          // Due to this known limitation, expires_in is not supported for MSI token fetch flow.\n+          throw new UnsupportedOperationException(\"MSI Responded with invalid expires_on\");\n+        }\n+\n+        LOG.debug(\"Expiry based on expires_in: {}\", expiryPeriodInSecs);\n+        long expiry \u003d System.currentTimeMillis();\n+        expiry \u003d expiry + expiryPeriodInSecs * 1000L; // convert expiryPeriod to milliseconds and add\n+        token.setExpiry(new Date(expiry));\n+      }\n+\n+      LOG.debug(\"AADToken: fetched token with expiry {}, expiresOn passed: {}\",\n+          token.getExpiry().toString(), expiresOnInSecs);\n     } catch (Exception ex) {\n       LOG.debug(\"AADToken: got exception when parsing json token \" + ex.toString());\n       throw ex;\n     } finally {\n       httpResponseStream.close();\n     }\n     return token;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static AzureADToken parseTokenFromStream(\n      InputStream httpResponseStream, boolean isMsi) throws IOException {\n    AzureADToken token \u003d new AzureADToken();\n    try {\n      int expiryPeriodInSecs \u003d 0;\n      long expiresOnInSecs \u003d -1;\n\n      JsonFactory jf \u003d new JsonFactory();\n      JsonParser jp \u003d jf.createJsonParser(httpResponseStream);\n      String fieldName, fieldValue;\n      jp.nextToken();\n      while (jp.hasCurrentToken()) {\n        if (jp.getCurrentToken() \u003d\u003d JsonToken.FIELD_NAME) {\n          fieldName \u003d jp.getCurrentName();\n          jp.nextToken();  // field value\n          fieldValue \u003d jp.getText();\n\n          if (fieldName.equals(\"access_token\")) {\n            token.setAccessToken(fieldValue);\n          }\n\n          if (fieldName.equals(\"expires_in\")) {\n            expiryPeriodInSecs \u003d Integer.parseInt(fieldValue);\n          }\n\n          if (fieldName.equals(\"expires_on\")) {\n            expiresOnInSecs \u003d Long.parseLong(fieldValue);\n          }\n\n        }\n        jp.nextToken();\n      }\n      jp.close();\n      if (expiresOnInSecs \u003e 0) {\n        LOG.debug(\"Expiry based on expires_on: {}\", expiresOnInSecs);\n        token.setExpiry(new Date(expiresOnInSecs * 1000));\n      } else {\n        if (isMsi) {\n          // Currently there is a known issue that MSI does not update expires_in\n          // for refresh and will have the value from first AAD token fetch request.\n          // Due to this known limitation, expires_in is not supported for MSI token fetch flow.\n          throw new UnsupportedOperationException(\"MSI Responded with invalid expires_on\");\n        }\n\n        LOG.debug(\"Expiry based on expires_in: {}\", expiryPeriodInSecs);\n        long expiry \u003d System.currentTimeMillis();\n        expiry \u003d expiry + expiryPeriodInSecs * 1000L; // convert expiryPeriod to milliseconds and add\n        token.setExpiry(new Date(expiry));\n      }\n\n      LOG.debug(\"AADToken: fetched token with expiry {}, expiresOn passed: {}\",\n          token.getExpiry().toString(), expiresOnInSecs);\n    } catch (Exception ex) {\n      LOG.debug(\"AADToken: got exception when parsing json token \" + ex.toString());\n      throw ex;\n    } finally {\n      httpResponseStream.close();\n    }\n    return token;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/oauth2/AzureADAuthenticator.java",
          "extendedDetails": {
            "oldValue": "[httpResponseStream-InputStream]",
            "newValue": "[httpResponseStream-InputStream, isMsi-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Hadoop 16890. Change in expiry calculation for MSI token provider.\n\n\r\nContributed by Bilahari T H",
          "commitDate": "11/03/20 1:39 PM",
          "commitName": "0b931f36ec83dc72729a9e84a0d313f471061c64",
          "commitAuthor": "bilaharith",
          "commitDateOld": "07/10/19 5:07 AM",
          "commitNameOld": "1a77a15fe44df9ec837be5c558279d8fd4d25e97",
          "commitAuthorOld": "bilaharith",
          "daysBetweenCommits": 156.36,
          "commitsBetweenForRepo": 555,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,60 @@\n-  private static AzureADToken parseTokenFromStream(InputStream httpResponseStream) throws IOException {\n+  private static AzureADToken parseTokenFromStream(\n+      InputStream httpResponseStream, boolean isMsi) throws IOException {\n     AzureADToken token \u003d new AzureADToken();\n     try {\n-      int expiryPeriod \u003d 0;\n+      int expiryPeriodInSecs \u003d 0;\n+      long expiresOnInSecs \u003d -1;\n \n       JsonFactory jf \u003d new JsonFactory();\n       JsonParser jp \u003d jf.createJsonParser(httpResponseStream);\n       String fieldName, fieldValue;\n       jp.nextToken();\n       while (jp.hasCurrentToken()) {\n         if (jp.getCurrentToken() \u003d\u003d JsonToken.FIELD_NAME) {\n           fieldName \u003d jp.getCurrentName();\n           jp.nextToken();  // field value\n           fieldValue \u003d jp.getText();\n \n           if (fieldName.equals(\"access_token\")) {\n             token.setAccessToken(fieldValue);\n           }\n+\n           if (fieldName.equals(\"expires_in\")) {\n-            expiryPeriod \u003d Integer.parseInt(fieldValue);\n+            expiryPeriodInSecs \u003d Integer.parseInt(fieldValue);\n           }\n+\n+          if (fieldName.equals(\"expires_on\")) {\n+            expiresOnInSecs \u003d Long.parseLong(fieldValue);\n+          }\n+\n         }\n         jp.nextToken();\n       }\n       jp.close();\n-      long expiry \u003d System.currentTimeMillis();\n-      expiry \u003d expiry + expiryPeriod * 1000L; // convert expiryPeriod to milliseconds and add\n-      token.setExpiry(new Date(expiry));\n-      LOG.debug(\"AADToken: fetched token with expiry \" + token.getExpiry().toString());\n+      if (expiresOnInSecs \u003e 0) {\n+        LOG.debug(\"Expiry based on expires_on: {}\", expiresOnInSecs);\n+        token.setExpiry(new Date(expiresOnInSecs * 1000));\n+      } else {\n+        if (isMsi) {\n+          // Currently there is a known issue that MSI does not update expires_in\n+          // for refresh and will have the value from first AAD token fetch request.\n+          // Due to this known limitation, expires_in is not supported for MSI token fetch flow.\n+          throw new UnsupportedOperationException(\"MSI Responded with invalid expires_on\");\n+        }\n+\n+        LOG.debug(\"Expiry based on expires_in: {}\", expiryPeriodInSecs);\n+        long expiry \u003d System.currentTimeMillis();\n+        expiry \u003d expiry + expiryPeriodInSecs * 1000L; // convert expiryPeriod to milliseconds and add\n+        token.setExpiry(new Date(expiry));\n+      }\n+\n+      LOG.debug(\"AADToken: fetched token with expiry {}, expiresOn passed: {}\",\n+          token.getExpiry().toString(), expiresOnInSecs);\n     } catch (Exception ex) {\n       LOG.debug(\"AADToken: got exception when parsing json token \" + ex.toString());\n       throw ex;\n     } finally {\n       httpResponseStream.close();\n     }\n     return token;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static AzureADToken parseTokenFromStream(\n      InputStream httpResponseStream, boolean isMsi) throws IOException {\n    AzureADToken token \u003d new AzureADToken();\n    try {\n      int expiryPeriodInSecs \u003d 0;\n      long expiresOnInSecs \u003d -1;\n\n      JsonFactory jf \u003d new JsonFactory();\n      JsonParser jp \u003d jf.createJsonParser(httpResponseStream);\n      String fieldName, fieldValue;\n      jp.nextToken();\n      while (jp.hasCurrentToken()) {\n        if (jp.getCurrentToken() \u003d\u003d JsonToken.FIELD_NAME) {\n          fieldName \u003d jp.getCurrentName();\n          jp.nextToken();  // field value\n          fieldValue \u003d jp.getText();\n\n          if (fieldName.equals(\"access_token\")) {\n            token.setAccessToken(fieldValue);\n          }\n\n          if (fieldName.equals(\"expires_in\")) {\n            expiryPeriodInSecs \u003d Integer.parseInt(fieldValue);\n          }\n\n          if (fieldName.equals(\"expires_on\")) {\n            expiresOnInSecs \u003d Long.parseLong(fieldValue);\n          }\n\n        }\n        jp.nextToken();\n      }\n      jp.close();\n      if (expiresOnInSecs \u003e 0) {\n        LOG.debug(\"Expiry based on expires_on: {}\", expiresOnInSecs);\n        token.setExpiry(new Date(expiresOnInSecs * 1000));\n      } else {\n        if (isMsi) {\n          // Currently there is a known issue that MSI does not update expires_in\n          // for refresh and will have the value from first AAD token fetch request.\n          // Due to this known limitation, expires_in is not supported for MSI token fetch flow.\n          throw new UnsupportedOperationException(\"MSI Responded with invalid expires_on\");\n        }\n\n        LOG.debug(\"Expiry based on expires_in: {}\", expiryPeriodInSecs);\n        long expiry \u003d System.currentTimeMillis();\n        expiry \u003d expiry + expiryPeriodInSecs * 1000L; // convert expiryPeriod to milliseconds and add\n        token.setExpiry(new Date(expiry));\n      }\n\n      LOG.debug(\"AADToken: fetched token with expiry {}, expiresOn passed: {}\",\n          token.getExpiry().toString(), expiresOnInSecs);\n    } catch (Exception ex) {\n      LOG.debug(\"AADToken: got exception when parsing json token \" + ex.toString());\n      throw ex;\n    } finally {\n      httpResponseStream.close();\n    }\n    return token;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/oauth2/AzureADAuthenticator.java",
          "extendedDetails": {}
        }
      ]
    },
    "9149b9703e3ab09abdc087db129e82ad3f4cefa1": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15660. ABFS: Add support for OAuth\nContributed by Da Zhou, Rajeev Bansal, and Junhua Gu.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "9149b9703e3ab09abdc087db129e82ad3f4cefa1",
      "commitAuthor": "Thomas Marquardt",
      "diff": "@@ -0,0 +1,37 @@\n+  private static AzureADToken parseTokenFromStream(InputStream httpResponseStream) throws IOException {\n+    AzureADToken token \u003d new AzureADToken();\n+    try {\n+      int expiryPeriod \u003d 0;\n+\n+      JsonFactory jf \u003d new JsonFactory();\n+      JsonParser jp \u003d jf.createJsonParser(httpResponseStream);\n+      String fieldName, fieldValue;\n+      jp.nextToken();\n+      while (jp.hasCurrentToken()) {\n+        if (jp.getCurrentToken() \u003d\u003d JsonToken.FIELD_NAME) {\n+          fieldName \u003d jp.getCurrentName();\n+          jp.nextToken();  // field value\n+          fieldValue \u003d jp.getText();\n+\n+          if (fieldName.equals(\"access_token\")) {\n+            token.setAccessToken(fieldValue);\n+          }\n+          if (fieldName.equals(\"expires_in\")) {\n+            expiryPeriod \u003d Integer.parseInt(fieldValue);\n+          }\n+        }\n+        jp.nextToken();\n+      }\n+      jp.close();\n+      long expiry \u003d System.currentTimeMillis();\n+      expiry \u003d expiry + expiryPeriod * 1000L; // convert expiryPeriod to milliseconds and add\n+      token.setExpiry(new Date(expiry));\n+      LOG.debug(\"AADToken: fetched token with expiry \" + token.getExpiry().toString());\n+    } catch (Exception ex) {\n+      LOG.debug(\"AADToken: got exception when parsing json token \" + ex.toString());\n+      throw ex;\n+    } finally {\n+      httpResponseStream.close();\n+    }\n+    return token;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static AzureADToken parseTokenFromStream(InputStream httpResponseStream) throws IOException {\n    AzureADToken token \u003d new AzureADToken();\n    try {\n      int expiryPeriod \u003d 0;\n\n      JsonFactory jf \u003d new JsonFactory();\n      JsonParser jp \u003d jf.createJsonParser(httpResponseStream);\n      String fieldName, fieldValue;\n      jp.nextToken();\n      while (jp.hasCurrentToken()) {\n        if (jp.getCurrentToken() \u003d\u003d JsonToken.FIELD_NAME) {\n          fieldName \u003d jp.getCurrentName();\n          jp.nextToken();  // field value\n          fieldValue \u003d jp.getText();\n\n          if (fieldName.equals(\"access_token\")) {\n            token.setAccessToken(fieldValue);\n          }\n          if (fieldName.equals(\"expires_in\")) {\n            expiryPeriod \u003d Integer.parseInt(fieldValue);\n          }\n        }\n        jp.nextToken();\n      }\n      jp.close();\n      long expiry \u003d System.currentTimeMillis();\n      expiry \u003d expiry + expiryPeriod * 1000L; // convert expiryPeriod to milliseconds and add\n      token.setExpiry(new Date(expiry));\n      LOG.debug(\"AADToken: fetched token with expiry \" + token.getExpiry().toString());\n    } catch (Exception ex) {\n      LOG.debug(\"AADToken: got exception when parsing json token \" + ex.toString());\n      throw ex;\n    } finally {\n      httpResponseStream.close();\n    }\n    return token;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/oauth2/AzureADAuthenticator.java"
    }
  }
}