{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProcfsBasedProcessTree.java",
  "functionName": "constructProcessSMAPInfo",
  "functionId": "constructProcessSMAPInfo___pInfo-ProcessTreeSmapMemInfo__procfsDir-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
  "functionStartLine": 762,
  "functionEndLine": 811,
  "numCommitsSeen": 30,
  "timeTaken": 3804,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
    "626b5103d44692adf3882af61bdafa40114c44f7",
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4",
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
    "36ed8c74eaa13c0cbff94f852bb5c1dd94d864ed",
    "06579878dfca0b634aaecfe63bb90c46113b3037"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509": "Ybodychange",
    "626b5103d44692adf3882af61bdafa40114c44f7": "Ybodychange",
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4": "Ybodychange",
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1": "Ybodychange",
    "36ed8c74eaa13c0cbff94f852bb5c1dd94d864ed": "Ybodychange",
    "06579878dfca0b634aaecfe63bb90c46113b3037": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "03/03/19 11:59 PM",
      "commitNameOld": "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 11.64,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,50 @@\n   private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n       String procfsDir) {\n     BufferedReader in \u003d null;\n     InputStreamReader fReader \u003d null;\n     try {\n       File pidDir \u003d new File(procfsDir, pInfo.getPid());\n       File file \u003d new File(pidDir, SMAPS);\n       if (!file.exists()) {\n         return;\n       }\n       fReader \u003d new InputStreamReader(\n           new FileInputStream(file), Charset.forName(\"UTF-8\"));\n       in \u003d new BufferedReader(fReader);\n       ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n       List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n       for (String line : lines) {\n         line \u003d line.trim();\n         try {\n           Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n           if (address.find()) {\n             memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n             memoryMappingInfo.setPermission(address.group(4));\n             pInfo.getMemoryInfoList().add(memoryMappingInfo);\n             continue;\n           }\n           Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n           if (memInfo.find()) {\n             String key \u003d memInfo.group(1).trim();\n             String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n-            }\n+            LOG.debug(\"MemInfo : {} : Value  : {}\", key, value);\n \n             if (memoryMappingInfo !\u003d null) {\n               memoryMappingInfo.setMemInfo(key, value);\n             }\n           }\n         } catch (Throwable t) {\n           LOG\n             .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n         }\n       }\n     } catch (FileNotFoundException f) {\n       LOG.error(f.toString());\n     } catch (IOException e) {\n       LOG.error(e.toString());\n     } catch (Throwable t) {\n       LOG.error(t.toString());\n     } finally {\n       IOUtils.closeQuietly(in);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    InputStreamReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new InputStreamReader(\n          new FileInputStream(file), Charset.forName(\"UTF-8\"));\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            LOG.debug(\"MemInfo : {} : Value  : {}\", key, value);\n\n            if (memoryMappingInfo !\u003d null) {\n              memoryMappingInfo.setMemInfo(key, value);\n            }\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f.toString());\n    } catch (IOException e) {\n      LOG.error(e.toString());\n    } catch (Throwable t) {\n      LOG.error(t.toString());\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7477. Moving logging APIs over to slf4j in hadoop-yarn-common. Contributed by Prabhu Joseph.\n",
      "commitDate": "03/03/19 11:59 PM",
      "commitName": "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/02/19 11:45 AM",
      "commitNameOld": "95372657fc25c02399b01793833021ccf88dada2",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.51,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n       String procfsDir) {\n     BufferedReader in \u003d null;\n     InputStreamReader fReader \u003d null;\n     try {\n       File pidDir \u003d new File(procfsDir, pInfo.getPid());\n       File file \u003d new File(pidDir, SMAPS);\n       if (!file.exists()) {\n         return;\n       }\n       fReader \u003d new InputStreamReader(\n           new FileInputStream(file), Charset.forName(\"UTF-8\"));\n       in \u003d new BufferedReader(fReader);\n       ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n       List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n       for (String line : lines) {\n         line \u003d line.trim();\n         try {\n           Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n           if (address.find()) {\n             memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n             memoryMappingInfo.setPermission(address.group(4));\n             pInfo.getMemoryInfoList().add(memoryMappingInfo);\n             continue;\n           }\n           Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n           if (memInfo.find()) {\n             String key \u003d memInfo.group(1).trim();\n             String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n             }\n \n             if (memoryMappingInfo !\u003d null) {\n               memoryMappingInfo.setMemInfo(key, value);\n             }\n           }\n         } catch (Throwable t) {\n           LOG\n             .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n         }\n       }\n     } catch (FileNotFoundException f) {\n-      LOG.error(f);\n+      LOG.error(f.toString());\n     } catch (IOException e) {\n-      LOG.error(e);\n+      LOG.error(e.toString());\n     } catch (Throwable t) {\n-      LOG.error(t);\n+      LOG.error(t.toString());\n     } finally {\n       IOUtils.closeQuietly(in);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    InputStreamReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new InputStreamReader(\n          new FileInputStream(file), Charset.forName(\"UTF-8\"));\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n            }\n\n            if (memoryMappingInfo !\u003d null) {\n              memoryMappingInfo.setMemInfo(key, value);\n            }\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f.toString());\n    } catch (IOException e) {\n      LOG.error(e.toString());\n    } catch (Throwable t) {\n      LOG.error(t.toString());\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "626b5103d44692adf3882af61bdafa40114c44f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7688. Miscellaneous Improvements To ProcfsBasedProcessTree. Contributed by BELUGA BEHR.\n",
      "commitDate": "02/01/18 5:39 PM",
      "commitName": "626b5103d44692adf3882af61bdafa40114c44f7",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "01/05/17 4:01 AM",
      "commitNameOld": "4b5bd73ac53f7de4899b5b70078249ad20216048",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 246.61,
      "commitsBetweenForRepo": 1710,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n       String procfsDir) {\n     BufferedReader in \u003d null;\n     InputStreamReader fReader \u003d null;\n     try {\n       File pidDir \u003d new File(procfsDir, pInfo.getPid());\n       File file \u003d new File(pidDir, SMAPS);\n       if (!file.exists()) {\n         return;\n       }\n       fReader \u003d new InputStreamReader(\n           new FileInputStream(file), Charset.forName(\"UTF-8\"));\n       in \u003d new BufferedReader(fReader);\n       ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n       List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n       for (String line : lines) {\n         line \u003d line.trim();\n         try {\n           Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n           if (address.find()) {\n             memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n             memoryMappingInfo.setPermission(address.group(4));\n             pInfo.getMemoryInfoList().add(memoryMappingInfo);\n             continue;\n           }\n           Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n           if (memInfo.find()) {\n             String key \u003d memInfo.group(1).trim();\n             String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n             }\n \n             if (memoryMappingInfo !\u003d null) {\n               memoryMappingInfo.setMemInfo(key, value);\n             }\n           }\n         } catch (Throwable t) {\n           LOG\n             .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n         }\n       }\n     } catch (FileNotFoundException f) {\n-      LOG.error(f.getMessage());\n+      LOG.error(f);\n     } catch (IOException e) {\n-      LOG.error(e.getMessage());\n+      LOG.error(e);\n     } catch (Throwable t) {\n-      LOG.error(t.getMessage());\n+      LOG.error(t);\n     } finally {\n       IOUtils.closeQuietly(in);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    InputStreamReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new InputStreamReader(\n          new FileInputStream(file), Charset.forName(\"UTF-8\"));\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n            }\n\n            if (memoryMappingInfo !\u003d null) {\n              memoryMappingInfo.setMemInfo(key, value);\n            }\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f);\n    } catch (IOException e) {\n      LOG.error(e);\n    } catch (Throwable t) {\n      LOG.error(t);\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5257. Fix unreleased resources and null dereferences (yufeigu via rkanter)\n",
      "commitDate": "27/12/16 2:14 PM",
      "commitName": "9262797e86453fc04b7ca3710b73b21fcdf9e6b4",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "11/10/16 8:12 AM",
      "commitNameOld": "ecb51b857ac7faceff981b2b6f22ea1af0d42ab1",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 77.29,
      "commitsBetweenForRepo": 558,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,52 @@\n   private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n       String procfsDir) {\n     BufferedReader in \u003d null;\n     InputStreamReader fReader \u003d null;\n     try {\n       File pidDir \u003d new File(procfsDir, pInfo.getPid());\n       File file \u003d new File(pidDir, SMAPS);\n       if (!file.exists()) {\n         return;\n       }\n       fReader \u003d new InputStreamReader(\n           new FileInputStream(file), Charset.forName(\"UTF-8\"));\n       in \u003d new BufferedReader(fReader);\n       ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n       List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n       for (String line : lines) {\n         line \u003d line.trim();\n         try {\n           Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n           if (address.find()) {\n             memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n             memoryMappingInfo.setPermission(address.group(4));\n             pInfo.getMemoryInfoList().add(memoryMappingInfo);\n             continue;\n           }\n           Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n           if (memInfo.find()) {\n             String key \u003d memInfo.group(1).trim();\n             String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n             }\n-            memoryMappingInfo.setMemInfo(key, value);\n+\n+            if (memoryMappingInfo !\u003d null) {\n+              memoryMappingInfo.setMemInfo(key, value);\n+            }\n           }\n         } catch (Throwable t) {\n           LOG\n             .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n         }\n       }\n     } catch (FileNotFoundException f) {\n       LOG.error(f.getMessage());\n     } catch (IOException e) {\n       LOG.error(e.getMessage());\n     } catch (Throwable t) {\n       LOG.error(t.getMessage());\n     } finally {\n       IOUtils.closeQuietly(in);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    InputStreamReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new InputStreamReader(\n          new FileInputStream(file), Charset.forName(\"UTF-8\"));\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n            }\n\n            if (memoryMappingInfo !\u003d null) {\n              memoryMappingInfo.setMemInfo(key, value);\n            }\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f.getMessage());\n    } catch (IOException e) {\n      LOG.error(e.getMessage());\n    } catch (Throwable t) {\n      LOG.error(t.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2939. Fix new findbugs warnings in hadoop-yarn-common. (Li Lu via junping_du)\n",
      "commitDate": "22/12/14 3:06 AM",
      "commitName": "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
      "commitAuthor": "Junping Du",
      "commitDateOld": "17/04/14 11:05 AM",
      "commitNameOld": "36ed8c74eaa13c0cbff94f852bb5c1dd94d864ed",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 248.71,
      "commitsBetweenForRepo": 2030,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,49 @@\n   private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n       String procfsDir) {\n     BufferedReader in \u003d null;\n-    FileReader fReader \u003d null;\n+    InputStreamReader fReader \u003d null;\n     try {\n       File pidDir \u003d new File(procfsDir, pInfo.getPid());\n       File file \u003d new File(pidDir, SMAPS);\n       if (!file.exists()) {\n         return;\n       }\n-      fReader \u003d new FileReader(file);\n+      fReader \u003d new InputStreamReader(\n+          new FileInputStream(file), Charset.forName(\"UTF-8\"));\n       in \u003d new BufferedReader(fReader);\n       ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n       List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n       for (String line : lines) {\n         line \u003d line.trim();\n         try {\n           Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n           if (address.find()) {\n             memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n             memoryMappingInfo.setPermission(address.group(4));\n             pInfo.getMemoryInfoList().add(memoryMappingInfo);\n             continue;\n           }\n           Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n           if (memInfo.find()) {\n             String key \u003d memInfo.group(1).trim();\n             String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n             }\n             memoryMappingInfo.setMemInfo(key, value);\n           }\n         } catch (Throwable t) {\n           LOG\n             .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n         }\n       }\n     } catch (FileNotFoundException f) {\n       LOG.error(f.getMessage());\n     } catch (IOException e) {\n       LOG.error(e.getMessage());\n     } catch (Throwable t) {\n       LOG.error(t.getMessage());\n     } finally {\n       IOUtils.closeQuietly(in);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    InputStreamReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new InputStreamReader(\n          new FileInputStream(file), Charset.forName(\"UTF-8\"));\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n            }\n            memoryMappingInfo.setMemInfo(key, value);\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f.getMessage());\n    } catch (IOException e) {\n      LOG.error(e.getMessage());\n    } catch (Throwable t) {\n      LOG.error(t.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "36ed8c74eaa13c0cbff94f852bb5c1dd94d864ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1870. FileInputStream is not closed in ProcfsBasedProcessTree#constructProcessSMAPInfo. (Fengdong Yu via junping_du)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1588324 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/04/14 11:05 AM",
      "commitName": "36ed8c74eaa13c0cbff94f852bb5c1dd94d864ed",
      "commitAuthor": "Junping Du",
      "commitDateOld": "21/03/14 5:01 PM",
      "commitNameOld": "06579878dfca0b634aaecfe63bb90c46113b3037",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 26.75,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n       String procfsDir) {\n     BufferedReader in \u003d null;\n     FileReader fReader \u003d null;\n     try {\n       File pidDir \u003d new File(procfsDir, pInfo.getPid());\n       File file \u003d new File(pidDir, SMAPS);\n       if (!file.exists()) {\n         return;\n       }\n       fReader \u003d new FileReader(file);\n       in \u003d new BufferedReader(fReader);\n       ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n-      List\u003cString\u003e lines \u003d IOUtils.readLines(new FileInputStream(file));\n+      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n       for (String line : lines) {\n         line \u003d line.trim();\n         try {\n           Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n           if (address.find()) {\n             memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n             memoryMappingInfo.setPermission(address.group(4));\n             pInfo.getMemoryInfoList().add(memoryMappingInfo);\n             continue;\n           }\n           Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n           if (memInfo.find()) {\n             String key \u003d memInfo.group(1).trim();\n             String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n             }\n             memoryMappingInfo.setMemInfo(key, value);\n           }\n         } catch (Throwable t) {\n           LOG\n             .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n         }\n       }\n     } catch (FileNotFoundException f) {\n       LOG.error(f.getMessage());\n     } catch (IOException e) {\n       LOG.error(e.getMessage());\n     } catch (Throwable t) {\n       LOG.error(t.getMessage());\n     } finally {\n       IOUtils.closeQuietly(in);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    FileReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new FileReader(file);\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(in);\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n            }\n            memoryMappingInfo.setMemInfo(key, value);\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f.getMessage());\n    } catch (IOException e) {\n      LOG.error(e.getMessage());\n    } catch (Throwable t) {\n      LOG.error(t.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "06579878dfca0b634aaecfe63bb90c46113b3037": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1775. Enhanced ProcfsBasedProcessTree to optionally add the ability to use smaps for obtaining used memory information. Contributed by Rajesh Balamohan.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/14 5:01 PM",
      "commitName": "06579878dfca0b634aaecfe63bb90c46113b3037",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,48 @@\n+  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n+      String procfsDir) {\n+    BufferedReader in \u003d null;\n+    FileReader fReader \u003d null;\n+    try {\n+      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n+      File file \u003d new File(pidDir, SMAPS);\n+      if (!file.exists()) {\n+        return;\n+      }\n+      fReader \u003d new FileReader(file);\n+      in \u003d new BufferedReader(fReader);\n+      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n+      List\u003cString\u003e lines \u003d IOUtils.readLines(new FileInputStream(file));\n+      for (String line : lines) {\n+        line \u003d line.trim();\n+        try {\n+          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n+          if (address.find()) {\n+            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n+            memoryMappingInfo.setPermission(address.group(4));\n+            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n+            continue;\n+          }\n+          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n+          if (memInfo.find()) {\n+            String key \u003d memInfo.group(1).trim();\n+            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n+            }\n+            memoryMappingInfo.setMemInfo(key, value);\n+          }\n+        } catch (Throwable t) {\n+          LOG\n+            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n+        }\n+      }\n+    } catch (FileNotFoundException f) {\n+      LOG.error(f.getMessage());\n+    } catch (IOException e) {\n+      LOG.error(e.getMessage());\n+    } catch (Throwable t) {\n+      LOG.error(t.getMessage());\n+    } finally {\n+      IOUtils.closeQuietly(in);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void constructProcessSMAPInfo(ProcessTreeSmapMemInfo pInfo,\n      String procfsDir) {\n    BufferedReader in \u003d null;\n    FileReader fReader \u003d null;\n    try {\n      File pidDir \u003d new File(procfsDir, pInfo.getPid());\n      File file \u003d new File(pidDir, SMAPS);\n      if (!file.exists()) {\n        return;\n      }\n      fReader \u003d new FileReader(file);\n      in \u003d new BufferedReader(fReader);\n      ProcessSmapMemoryInfo memoryMappingInfo \u003d null;\n      List\u003cString\u003e lines \u003d IOUtils.readLines(new FileInputStream(file));\n      for (String line : lines) {\n        line \u003d line.trim();\n        try {\n          Matcher address \u003d ADDRESS_PATTERN.matcher(line);\n          if (address.find()) {\n            memoryMappingInfo \u003d new ProcessSmapMemoryInfo(line);\n            memoryMappingInfo.setPermission(address.group(4));\n            pInfo.getMemoryInfoList().add(memoryMappingInfo);\n            continue;\n          }\n          Matcher memInfo \u003d MEM_INFO_PATTERN.matcher(line);\n          if (memInfo.find()) {\n            String key \u003d memInfo.group(1).trim();\n            String value \u003d memInfo.group(2).replace(KB, \"\").trim();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MemInfo : \" + key + \" : Value  : \" + value);\n            }\n            memoryMappingInfo.setMemInfo(key, value);\n          }\n        } catch (Throwable t) {\n          LOG\n            .warn(\"Error parsing smaps line : \" + line + \"; \" + t.getMessage());\n        }\n      }\n    } catch (FileNotFoundException f) {\n      LOG.error(f.getMessage());\n    } catch (IOException e) {\n      LOG.error(e.getMessage());\n    } catch (Throwable t) {\n      LOG.error(t.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java"
    }
  }
}