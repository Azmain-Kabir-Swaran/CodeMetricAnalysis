{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RmSingleLineParser.java",
  "functionName": "parseLine",
  "functionId": "parseLine___logLine-String(modifiers-final)__jobMetas-Map__String,JobMetaData__(modifiers-final)__skylineRecords-Map__RecurrenceId,List__ResourceSkyline____(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-resourceestimator/src/main/java/org/apache/hadoop/resourceestimator/translator/impl/RmSingleLineParser.java",
  "functionStartLine": 79,
  "functionEndLine": 202,
  "numCommitsSeen": 1,
  "timeTaken": 404,
  "changeHistory": [
    "625039ef20e6011ab360131d70582a6e4bf2ec1d"
  ],
  "changeHistoryShort": {
    "625039ef20e6011ab360131d70582a6e4bf2ec1d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "625039ef20e6011ab360131d70582a6e4bf2ec1d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14840. Tool to estimate resource requirements of an application pipeline based on prior executions. (Rui Li via Subru).\n",
      "commitDate": "25/10/17 3:51 PM",
      "commitName": "625039ef20e6011ab360131d70582a6e4bf2ec1d",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,124 @@\n+  @Override public final void parseLine(final String logLine,\n+      final Map\u003cString, JobMetaData\u003e jobMetas,\n+      final Map\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e skylineRecords)\n+      throws DataFieldNotFoundException, ParseException {\n+    final String[] splits \u003d logLine.split(\",\", 5); // Limit the max number of 5\n+    // splits\n+    if (splits.length \u003c 5) {\n+      return;\n+    }\n+    final Matcher jobEventMatcher \u003d FILTER_PATTERN.matcher(splits[4]); // search\n+    // only\n+    // the\n+    // tail\n+    if (!jobEventMatcher.find()) { // this line of log does not contain targeted\n+      // events\n+      return;\n+    }\n+\n+    // now we have the match, let\u0027s do some parsing\n+    final long date \u003d PARSERUTIL.stringToUnixTimestamp(splits[1]);\n+    final String tail \u003d splits[4].split(\"\\\\s+\", 4)[3]; // use the tail of the\n+    // tail only\n+    switch (jobEventMatcher.group(1)) {\n+    case \"Submit Application Request\": {\n+      /** Submit job. */\n+      final Matcher appIdMatch \u003d SUBMISSION_PATTERN.matcher(tail);\n+      if (appIdMatch.find()) {\n+        final String appId \u003d appIdMatch.group(1);\n+        jobMetas.put(appId, new JobMetaData(date));\n+      } else {\n+        throw new DataFieldNotFoundException(tail);\n+      }\n+      break;\n+    }\n+    case \"AM Allocated Container\": {\n+      /** Allocate container. */\n+      final Matcher containerEventMatcher \u003d\n+          CONTAINER_EVENT_PATTERN.matcher(tail);\n+      if (containerEventMatcher.find()) {\n+        final String appId \u003d containerEventMatcher.group(1);\n+        final String containerId \u003d containerEventMatcher.group(2);\n+        final JobMetaData appMeta \u003d jobMetas.get(appId);\n+        if (appMeta !\u003d null) {\n+          appMeta.setContainerStart(containerId, date);\n+        }\n+      } else {\n+        throw new DataFieldNotFoundException(tail);\n+      }\n+      break;\n+    }\n+    case \", Resource:\": {\n+      final Matcher containerSpecMatcher \u003d CONTAINER_SPEC_PATTERN.matcher(tail);\n+      if (containerSpecMatcher.find()) {\n+        final String appId \u003d \"application_\" + containerSpecMatcher.group(2);\n+        final JobMetaData appMeta \u003d jobMetas.get(appId);\n+        if (appMeta !\u003d null) {\n+          final long memAlloc \u003d Long.parseLong(containerSpecMatcher.group(3));\n+          final int cpuAlloc \u003d Integer.parseInt(containerSpecMatcher.group(4));\n+          final Resource containerAlloc \u003d\n+              Resource.newInstance(memAlloc, cpuAlloc);\n+          appMeta.getResourceSkyline().setContainerSpec(containerAlloc);\n+        }\n+      } else {\n+        throw new DataFieldNotFoundException(tail);\n+      }\n+      break;\n+    }\n+    case \"AM Released Container\": {\n+      final Matcher containerEventMatcher \u003d\n+          CONTAINER_EVENT_PATTERN.matcher(tail);\n+      if (containerEventMatcher.find()) {\n+        final String appId \u003d containerEventMatcher.group(1);\n+        final JobMetaData appMeta \u003d jobMetas.get(appId);\n+        if (appMeta !\u003d null) {\n+          final String containerId \u003d containerEventMatcher.group(2);\n+          appMeta.setContainerEnd(containerId, date);\n+        }\n+      } else {\n+        throw new DataFieldNotFoundException(tail);\n+      }\n+      break;\n+    }\n+    case \"finalState\u003dFAILED\": {\n+      /** In case of appAttempt failed: discard previous records. */\n+      final Matcher failMatcher \u003d FAIL_PATTERN.matcher(tail);\n+      if (failMatcher.find()) {\n+        final String appId \u003d \"application_\" + failMatcher.group(1);\n+        if (jobMetas.containsKey(appId)) {\n+          jobMetas.put(appId, new JobMetaData(date));\n+        }\n+      } else {\n+        throw new DataFieldNotFoundException(tail);\n+      }\n+      break;\n+    }\n+    case \"ApplicationSummary\": {\n+      /** Finish a job. */\n+      final Matcher finishMatcher \u003d FINISH_PATTERN.matcher(tail);\n+      if (finishMatcher.find()) {\n+        final String appId \u003d finishMatcher.group(1);\n+        final String pipelineId \u003d finishMatcher.group(2);\n+        final String runId \u003d finishMatcher.group(3);\n+        final RecurrenceId recurrenceId \u003d new RecurrenceId(pipelineId, runId);\n+        final JobMetaData appMeta \u003d jobMetas.remove(appId);\n+        if (appMeta !\u003d null) {\n+          appMeta.setRecurrenceId(recurrenceId).setJobFinishTime(date)\n+              .getResourceSkyline().setJobInputDataSize(0); // TODO: need to\n+          // read job input\n+          // data size from\n+          // logs\n+          appMeta.createSkyline();\n+          final ResourceSkyline resourceSkyline \u003d appMeta.getResourceSkyline();\n+          resourceSkyline.setJobId(appId);\n+          aggregateSkyline(resourceSkyline, recurrenceId, skylineRecords);\n+        }\n+      } else {\n+        throw new DataFieldNotFoundException(tail);\n+      }\n+      break;\n+    }\n+    default:\n+      break;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  @Override public final void parseLine(final String logLine,\n      final Map\u003cString, JobMetaData\u003e jobMetas,\n      final Map\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e skylineRecords)\n      throws DataFieldNotFoundException, ParseException {\n    final String[] splits \u003d logLine.split(\",\", 5); // Limit the max number of 5\n    // splits\n    if (splits.length \u003c 5) {\n      return;\n    }\n    final Matcher jobEventMatcher \u003d FILTER_PATTERN.matcher(splits[4]); // search\n    // only\n    // the\n    // tail\n    if (!jobEventMatcher.find()) { // this line of log does not contain targeted\n      // events\n      return;\n    }\n\n    // now we have the match, let\u0027s do some parsing\n    final long date \u003d PARSERUTIL.stringToUnixTimestamp(splits[1]);\n    final String tail \u003d splits[4].split(\"\\\\s+\", 4)[3]; // use the tail of the\n    // tail only\n    switch (jobEventMatcher.group(1)) {\n    case \"Submit Application Request\": {\n      /** Submit job. */\n      final Matcher appIdMatch \u003d SUBMISSION_PATTERN.matcher(tail);\n      if (appIdMatch.find()) {\n        final String appId \u003d appIdMatch.group(1);\n        jobMetas.put(appId, new JobMetaData(date));\n      } else {\n        throw new DataFieldNotFoundException(tail);\n      }\n      break;\n    }\n    case \"AM Allocated Container\": {\n      /** Allocate container. */\n      final Matcher containerEventMatcher \u003d\n          CONTAINER_EVENT_PATTERN.matcher(tail);\n      if (containerEventMatcher.find()) {\n        final String appId \u003d containerEventMatcher.group(1);\n        final String containerId \u003d containerEventMatcher.group(2);\n        final JobMetaData appMeta \u003d jobMetas.get(appId);\n        if (appMeta !\u003d null) {\n          appMeta.setContainerStart(containerId, date);\n        }\n      } else {\n        throw new DataFieldNotFoundException(tail);\n      }\n      break;\n    }\n    case \", Resource:\": {\n      final Matcher containerSpecMatcher \u003d CONTAINER_SPEC_PATTERN.matcher(tail);\n      if (containerSpecMatcher.find()) {\n        final String appId \u003d \"application_\" + containerSpecMatcher.group(2);\n        final JobMetaData appMeta \u003d jobMetas.get(appId);\n        if (appMeta !\u003d null) {\n          final long memAlloc \u003d Long.parseLong(containerSpecMatcher.group(3));\n          final int cpuAlloc \u003d Integer.parseInt(containerSpecMatcher.group(4));\n          final Resource containerAlloc \u003d\n              Resource.newInstance(memAlloc, cpuAlloc);\n          appMeta.getResourceSkyline().setContainerSpec(containerAlloc);\n        }\n      } else {\n        throw new DataFieldNotFoundException(tail);\n      }\n      break;\n    }\n    case \"AM Released Container\": {\n      final Matcher containerEventMatcher \u003d\n          CONTAINER_EVENT_PATTERN.matcher(tail);\n      if (containerEventMatcher.find()) {\n        final String appId \u003d containerEventMatcher.group(1);\n        final JobMetaData appMeta \u003d jobMetas.get(appId);\n        if (appMeta !\u003d null) {\n          final String containerId \u003d containerEventMatcher.group(2);\n          appMeta.setContainerEnd(containerId, date);\n        }\n      } else {\n        throw new DataFieldNotFoundException(tail);\n      }\n      break;\n    }\n    case \"finalState\u003dFAILED\": {\n      /** In case of appAttempt failed: discard previous records. */\n      final Matcher failMatcher \u003d FAIL_PATTERN.matcher(tail);\n      if (failMatcher.find()) {\n        final String appId \u003d \"application_\" + failMatcher.group(1);\n        if (jobMetas.containsKey(appId)) {\n          jobMetas.put(appId, new JobMetaData(date));\n        }\n      } else {\n        throw new DataFieldNotFoundException(tail);\n      }\n      break;\n    }\n    case \"ApplicationSummary\": {\n      /** Finish a job. */\n      final Matcher finishMatcher \u003d FINISH_PATTERN.matcher(tail);\n      if (finishMatcher.find()) {\n        final String appId \u003d finishMatcher.group(1);\n        final String pipelineId \u003d finishMatcher.group(2);\n        final String runId \u003d finishMatcher.group(3);\n        final RecurrenceId recurrenceId \u003d new RecurrenceId(pipelineId, runId);\n        final JobMetaData appMeta \u003d jobMetas.remove(appId);\n        if (appMeta !\u003d null) {\n          appMeta.setRecurrenceId(recurrenceId).setJobFinishTime(date)\n              .getResourceSkyline().setJobInputDataSize(0); // TODO: need to\n          // read job input\n          // data size from\n          // logs\n          appMeta.createSkyline();\n          final ResourceSkyline resourceSkyline \u003d appMeta.getResourceSkyline();\n          resourceSkyline.setJobId(appId);\n          aggregateSkyline(resourceSkyline, recurrenceId, skylineRecords);\n        }\n      } else {\n        throw new DataFieldNotFoundException(tail);\n      }\n      break;\n    }\n    default:\n      break;\n    }\n  }",
      "path": "hadoop-tools/hadoop-resourceestimator/src/main/java/org/apache/hadoop/resourceestimator/translator/impl/RmSingleLineParser.java"
    }
  }
}