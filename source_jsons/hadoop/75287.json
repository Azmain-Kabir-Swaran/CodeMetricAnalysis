{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKFailoverController.java",
  "functionName": "verifyChangedServiceState",
  "functionId": "verifyChangedServiceState___changedState-HAServiceState",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
  "functionStartLine": 863,
  "functionEndLine": 901,
  "numCommitsSeen": 35,
  "timeTaken": 1497,
  "changeHistory": [
    "a6ab37192a90e5ee868376b42be226e00cce31d8",
    "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d"
  ],
  "changeHistoryShort": {
    "a6ab37192a90e5ee868376b42be226e00cce31d8": "Ybodychange",
    "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a6ab37192a90e5ee868376b42be226e00cce31d8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14130. [SBN read] Make ZKFC ObserverNode aware. Contributed by xiangheng and Konstantin Shvachko.",
      "commitDate": "25/02/19 2:35 PM",
      "commitName": "a6ab37192a90e5ee868376b42be226e00cce31d8",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "28/06/18 9:39 AM",
      "commitNameOld": "384764cdeac6490bc47fa0eb7b936baa4c0d3230",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 242.25,
      "commitsBetweenForRepo": 1890,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,39 @@\n   void verifyChangedServiceState(HAServiceState changedState) {\n     synchronized (elector) {\n       synchronized (this) {\n         if (serviceState \u003d\u003d HAServiceState.INITIALIZING) {\n           if (quitElectionOnBadState) {\n             LOG.debug(\"rechecking for electability from bad state\");\n             recheckElectability();\n           }\n           return;\n         }\n+        if (changedState \u003d\u003d HAServiceState.OBSERVER) {\n+          elector.quitElection(true);\n+          serviceState \u003d HAServiceState.OBSERVER;\n+          return;\n+        }\n         if (changedState \u003d\u003d serviceState) {\n           serviceStateMismatchCount \u003d 0;\n           return;\n         }\n         if (serviceStateMismatchCount \u003d\u003d 0) {\n           // recheck one more time. As this might be due to parallel transition.\n           serviceStateMismatchCount++;\n           return;\n         }\n         // quit the election as the expected state and reported state\n         // mismatches.\n         LOG.error(\"Local service \" + localTarget\n             + \" has changed the serviceState to \" + changedState\n             + \". Expected was \" + serviceState\n             + \". Quitting election marking fencing necessary.\");\n         delayJoiningUntilNanotime \u003d System.nanoTime()\n             + TimeUnit.MILLISECONDS.toNanos(1000);\n         elector.quitElection(true);\n         quitElectionOnBadState \u003d true;\n         serviceStateMismatchCount \u003d 0;\n         serviceState \u003d HAServiceState.INITIALIZING;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void verifyChangedServiceState(HAServiceState changedState) {\n    synchronized (elector) {\n      synchronized (this) {\n        if (serviceState \u003d\u003d HAServiceState.INITIALIZING) {\n          if (quitElectionOnBadState) {\n            LOG.debug(\"rechecking for electability from bad state\");\n            recheckElectability();\n          }\n          return;\n        }\n        if (changedState \u003d\u003d HAServiceState.OBSERVER) {\n          elector.quitElection(true);\n          serviceState \u003d HAServiceState.OBSERVER;\n          return;\n        }\n        if (changedState \u003d\u003d serviceState) {\n          serviceStateMismatchCount \u003d 0;\n          return;\n        }\n        if (serviceStateMismatchCount \u003d\u003d 0) {\n          // recheck one more time. As this might be due to parallel transition.\n          serviceStateMismatchCount++;\n          return;\n        }\n        // quit the election as the expected state and reported state\n        // mismatches.\n        LOG.error(\"Local service \" + localTarget\n            + \" has changed the serviceState to \" + changedState\n            + \". Expected was \" + serviceState\n            + \". Quitting election marking fencing necessary.\");\n        delayJoiningUntilNanotime \u003d System.nanoTime()\n            + TimeUnit.MILLISECONDS.toNanos(1000);\n        elector.quitElection(true);\n        quitElectionOnBadState \u003d true;\n        serviceStateMismatchCount \u003d 0;\n        serviceState \u003d HAServiceState.INITIALIZING;\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
      "extendedDetails": {}
    },
    "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10251. Both NameNodes could be in STANDBY State if SNN network is unstable. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1589494 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/14 11:55 AM",
      "commitName": "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,34 @@\n+  void verifyChangedServiceState(HAServiceState changedState) {\n+    synchronized (elector) {\n+      synchronized (this) {\n+        if (serviceState \u003d\u003d HAServiceState.INITIALIZING) {\n+          if (quitElectionOnBadState) {\n+            LOG.debug(\"rechecking for electability from bad state\");\n+            recheckElectability();\n+          }\n+          return;\n+        }\n+        if (changedState \u003d\u003d serviceState) {\n+          serviceStateMismatchCount \u003d 0;\n+          return;\n+        }\n+        if (serviceStateMismatchCount \u003d\u003d 0) {\n+          // recheck one more time. As this might be due to parallel transition.\n+          serviceStateMismatchCount++;\n+          return;\n+        }\n+        // quit the election as the expected state and reported state\n+        // mismatches.\n+        LOG.error(\"Local service \" + localTarget\n+            + \" has changed the serviceState to \" + changedState\n+            + \". Expected was \" + serviceState\n+            + \". Quitting election marking fencing necessary.\");\n+        delayJoiningUntilNanotime \u003d System.nanoTime()\n+            + TimeUnit.MILLISECONDS.toNanos(1000);\n+        elector.quitElection(true);\n+        quitElectionOnBadState \u003d true;\n+        serviceStateMismatchCount \u003d 0;\n+        serviceState \u003d HAServiceState.INITIALIZING;\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void verifyChangedServiceState(HAServiceState changedState) {\n    synchronized (elector) {\n      synchronized (this) {\n        if (serviceState \u003d\u003d HAServiceState.INITIALIZING) {\n          if (quitElectionOnBadState) {\n            LOG.debug(\"rechecking for electability from bad state\");\n            recheckElectability();\n          }\n          return;\n        }\n        if (changedState \u003d\u003d serviceState) {\n          serviceStateMismatchCount \u003d 0;\n          return;\n        }\n        if (serviceStateMismatchCount \u003d\u003d 0) {\n          // recheck one more time. As this might be due to parallel transition.\n          serviceStateMismatchCount++;\n          return;\n        }\n        // quit the election as the expected state and reported state\n        // mismatches.\n        LOG.error(\"Local service \" + localTarget\n            + \" has changed the serviceState to \" + changedState\n            + \". Expected was \" + serviceState\n            + \". Quitting election marking fencing necessary.\");\n        delayJoiningUntilNanotime \u003d System.nanoTime()\n            + TimeUnit.MILLISECONDS.toNanos(1000);\n        elector.quitElection(true);\n        quitElectionOnBadState \u003d true;\n        serviceStateMismatchCount \u003d 0;\n        serviceState \u003d HAServiceState.INITIALIZING;\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java"
    }
  }
}